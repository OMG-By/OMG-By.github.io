<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OMG_By</title>
  
  <subtitle>沉心、静气、学习、总结、进步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-28T05:23:59.781Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OMG_By</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL特性介绍之ICP</title>
    <link href="http://yoursite.com/2020/05/28/new/MySQL/MySQL%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D%E4%B9%8BICP/"/>
    <id>http://yoursite.com/2020/05/28/new/MySQL/MySQL特性介绍之ICP/</id>
    <published>2020-05-28T05:22:48.000Z</published>
    <updated>2020-05-28T05:23:59.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ICP是什么"><a href="#ICP是什么" class="headerlink" title="ICP是什么"></a>ICP是什么</h2><p>Index Condition Pushdown，也称为索引条件下推，体现在执行计划中会出现<code>Using index condition</code>。<br>ICP优化适用于MySQL利用索引从表里检索数据的场景。<br>使用命令<code>set optimizer_switch=&#39;index_condition_pushdown=on&#39;</code>开启</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>索引访问方式是range/ref/eq_ref/ref_or_null，并且需要访问表的完整行记录</li><li>InnoDB和MYISAM表，包括分区的表(5.7)</li><li>对于InnoDB表，ICP只适用于二级索引。ICP的目标是减少访问表的完整行的读取量从而减少IO操作。</li><li>不支持建立在虚拟列上的二级索引</li><li>引用子查询、存储函数的条件没法下推</li><li>Triggered conditions 也没法下推</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="不使用ICP"><a href="#不使用ICP" class="headerlink" title="不使用ICP"></a>不使用ICP</h3><ol><li>用二级索引查找数据的主键</li><li>用主键回表读取完整的行记录</li><li>引擎层利用where语句的条件对行记录进行过滤<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf83cpvaofj30gw09bq3i.jpg" alt=""></li></ol><h3 id="使用ICP"><a href="#使用ICP" class="headerlink" title="使用ICP"></a>使用ICP</h3><ol><li>用二级索引查找数据的主键</li><li>如果where条件中的字段在复合索引中，引擎层对where条件里的字段进行过滤后，返回主键</li><li>利用主键回表读取完整的行记录</li><li>引擎层用where语句的剩余条件对行记录进行过滤<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf83ct0w3xj30ge09b74t.jpg" alt=""></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>ICP的优化在引擎层就能够过滤掉大量的数据，这样无疑能够减少了对base table和mysql server的访问次数，提升了性能。</p><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html</a><br><a href="https://yq.aliyun.com/articles/259696" target="_blank" rel="noopener">https://yq.aliyun.com/articles/259696</a><br><a href="https://zhuanlan.zhihu.com/p/73035620" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73035620</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ICP是什么&quot;&gt;&lt;a href=&quot;#ICP是什么&quot; class=&quot;headerlink&quot; title=&quot;ICP是什么&quot;&gt;&lt;/a&gt;ICP是什么&lt;/h2&gt;&lt;p&gt;Index Condition Pushdown，也称为索引条件下推，体现在执行计划中会出现&lt;code&gt;Us
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL特性" scheme="http://yoursite.com/tags/MySQL%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL特性介绍之MRR</title>
    <link href="http://yoursite.com/2020/05/27/new/MySQL/MySQL%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D%E4%B9%8BMRR/"/>
    <id>http://yoursite.com/2020/05/27/new/MySQL/MySQL特性介绍之MRR/</id>
    <published>2020-05-27T04:59:51.000Z</published>
    <updated>2020-05-28T05:25:12.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是MRR"><a href="#什么是MRR" class="headerlink" title="什么是MRR"></a>什么是MRR</h2><p>Multi-Range Read Optimization，是优化器将随机IO转换成顺序IO以降低查询过程中IO开销的一种手段。<br>它的好处有：</p><ul><li>使数据访问由随机变为顺序</li><li>减少缓冲池中页被替换的次数</li><li>批量处理查询操作</li></ul><p>可以通过<code>set optimizer_switch=&#39;mrr=on&#39;;</code>命令进行开启。</p><h3 id="不使用MRR"><a href="#不使用MRR" class="headerlink" title="不使用MRR"></a>不使用MRR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set optimizer_switch=&apos;mrr=off&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  explain select * from test.t1 where (a between 1 and 10) and (c between 9 and 10) ;</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+------------------------------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key  | key_len | ref  | rows | Extra                              |</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | range | mrrx,xx       | xx   | 5       | NULL |    2 | Using index condition; Using where |</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在不使用MRR时，优化器需要根据二级索引返回的记录来进行回表，这个过程一般会有较多的随机IO操作。</p><h3 id="使用MRR"><a href="#使用MRR" class="headerlink" title="使用MRR"></a>使用MRR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set optimizer_switch=&apos;mrr=on&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  explain select * from test.t1 where (a between 1 and 10) and (c between 9 and 10) ;</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+-----------------------------------------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key  | key_len | ref  | rows | Extra                                         |</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+-----------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | range | mrrx,xx       | xx   | 5       | NULL |    2 | Using index condition; Using where; Using MRR |</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+-----------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在使用了MRR时，SQL语句的执行过程为：</p><ol><li>优化器将二级索引查询到的记录放到一块缓冲区中(read_rnd_buffer_size)</li><li>如果二级索引扫描到文件末尾或者缓冲区已满，则使用快排对缓冲区中的内容按照主键进行排序</li><li>用户线程调用MRR接口获取cluster index，然后根据cluster index获取行数据</li><li>当缓冲区中的cluster index取完数据，则继续调用过程2、3，直到扫描结束</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MRR特性就是在查询过程中，先将满足条件的id查询出来并进行排序后，再进行批量查询操作。从而实现随机IO到顺序IO的转换，提升性能。</p><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.6/en/mrr-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/mrr-optimization.html</a><br><a href="https://zhuanlan.zhihu.com/p/110154066" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110154066</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是MRR&quot;&gt;&lt;a href=&quot;#什么是MRR&quot; class=&quot;headerlink&quot; title=&quot;什么是MRR&quot;&gt;&lt;/a&gt;什么是MRR&lt;/h2&gt;&lt;p&gt;Multi-Range Read Optimization，是优化器将随机IO转换成顺序IO以降低查询过程中
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL特性" scheme="http://yoursite.com/tags/MySQL%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Redis扩展命令实现</title>
    <link href="http://yoursite.com/2020/05/17/new/Redis/Redis%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/05/17/new/Redis/Redis扩展命令实现/</id>
    <published>2020-05-17T05:41:47.000Z</published>
    <updated>2020-05-17T06:06:30.394Z</updated>
    
    <content type="html"><![CDATA[<p>上周，参加公司后端部门开发的分享。<br>在期间，该开发吐槽Redis好几个使用不便利的地方。</p><ol><li><font color="red">Redis没有批量设置过期时间的命令</font></li><li><font color="red">incr 不存在的key的时候，并不会设置过期时间。导致持久化key的存在</font></li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gevcwyswasj30uk0l20wd.jpg" alt=""></p><a id="more"></a><p>作为客户端，解决办法只有使用lua脚本来进行实现：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gevcuiy2fbj30zk09g0v0.jpg" alt=""></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>虽然说使用lua脚本也能够解决这样的问题，但是对用户体验不太友好，同时也增加了编码的复杂度。<br>而且这样的功能实现起来并不算复杂，为什么不可以在Redis服务端去实现这样的功能呢？</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>说干咱就干。<br>利用周末的时间，简单的实现了其中的一个槽点功能:mexpire<br>可能会存在考虑欠缺的地方，但基本功能还是实现了的。</p><h3 id="expire-c"><a href="#expire-c" class="headerlink" title="expire.c"></a>expire.c</h3><p><code>expire.c</code>主要是对过期管理的文件。<br>一开始只想实现mexpire功能，结果发现还有<code>expireta</code>、<code>pexpire</code>、<code>pexpirate</code>命令跟<code>expire</code>命令相近，并且底层实现都是同一个函数。<br>于是就一起实现了。</p><p>逻辑其实很简单，就是遍历传过来的参数。</p><ul><li>如果key存在，就设置过期时间。并计数。</li><li>如果key不存在，就跳过。</li><li>返回成功设置过期时间个数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">void mexpireGenericCommand(client *c, long long basetime, int unit)&#123;</span><br><span class="line"></span><br><span class="line">    if ((c-&gt;argc % 2) == 0)&#123;</span><br><span class="line">        addReplyErrorFormat(c, &quot;wrong number of arguments for %s&quot;, c-&gt;cmd-&gt;name);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int j;</span><br><span class="line">    robj *key, *param;</span><br><span class="line">    long long when;</span><br><span class="line">    int nums = 0;</span><br><span class="line">    for (j = 1; j &lt; c-&gt;argc; j+=2)&#123;</span><br><span class="line">        key = c-&gt;argv[j];</span><br><span class="line">        param = c-&gt;argv[j+1];</span><br><span class="line">        if ((getLongLongFromObject(param, &amp;when) != C_OK) || lookupKeyWrite(c-&gt;db,key) == NULL)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (unit == UNIT_SECONDS) when *= 1000;</span><br><span class="line">        when += basetime;</span><br><span class="line"></span><br><span class="line">        nums++;</span><br><span class="line">        if (when &lt;= mstime() &amp;&amp; !server.loading &amp;&amp; !server.masterhost) &#123;</span><br><span class="line">            int deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c-&gt;db,key) :</span><br><span class="line">                          dbSyncDelete(c-&gt;db,key);</span><br><span class="line">            serverAssertWithInfo(c,key,deleted);</span><br><span class="line">            server.dirty++;</span><br><span class="line"></span><br><span class="line">            signalModifiedKey(c-&gt;db,key);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,key,c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            setExpire(c,c-&gt;db,key,when);</span><br><span class="line">            signalModifiedKey(c-&gt;db,key);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;expire&quot;,key,c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c, nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mexpireCommand(client *c)&#123;</span><br><span class="line">    mexpireGenericCommand(c, mstime(), UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mexpireatCommand(client *c) &#123;</span><br><span class="line">    mexpireGenericCommand(c,0,UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mpexpireCommand(client *c) &#123;</span><br><span class="line">    mexpireGenericCommand(c,mstime(),UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mpexpireatCommand(client *c) &#123;</span><br><span class="line">    mexpireGenericCommand(c,0,UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="server-h"><a href="#server-h" class="headerlink" title="server.h"></a>server.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void mexpireCommand(client *c);</span><br><span class="line">void mexpireatCommand(client *c);</span><br><span class="line">void mpexpireCommand(client *c);</span><br><span class="line">void mpexpireatCommand(client *c);</span><br></pre></td></tr></table></figure><h3 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;mexpire&quot;,mexpireCommand,-3, &quot;write @keyspace&quot;,0,NULL,1,-1,2,0,0,0&#125;,</span><br><span class="line">&#123;&quot;mexpireat&quot;,mexpireatCommand,-3,&quot;write @keyspace&quot;, 0,NULL,1,-1,2,0,0,0&#125;,</span><br><span class="line">&#123;&quot;mpexpire&quot;,mpexpireCommand,-3, &quot;write @keyspace&quot;, 0,NULL,1,-1,2,0,0,0&#125;,</span><br><span class="line">&#123;&quot;mpexpireat&quot;,mpexpireatCommand,-3, &quot;write @keyspace&quot;, 0,NULL,1,-1,2,0,0,0&#125;,</span><br></pre></td></tr></table></figure><p>这里有必要说明一下上面配置的解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct redisCommand &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    int arity;</span><br><span class="line">    char *sflags;   /* Flags as string representation, one char per flag. */</span><br><span class="line">    uint64_t flags; /* The actual flags, obtained from the &apos;sflags&apos; field. */</span><br><span class="line">    /* Use a function to determine keys arguments in a command line.</span><br><span class="line">     * Used for Redis Cluster redirect. */</span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    /* What keys should be loaded in background when calling this command? */</span><br><span class="line">    int firstkey; /* The first argument that&apos;s a key (0 = no keys) */</span><br><span class="line">    int lastkey;  /* The last argument that&apos;s a key */</span><br><span class="line">    int keystep;  /* The step between first and last key */</span><br><span class="line">    long long microseconds, calls;</span><br><span class="line">    int id;     /* Command ID. This is a progressive ID starting from 0 that</span><br><span class="line">                   is assigned at runtime, and is used in order to check</span><br><span class="line">                   ACLs. A connection is able to execute a given command if</span><br><span class="line">                   the user associated to the connection has this command</span><br><span class="line">                   bit set in the bitmap of allowed commands. */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>name：命令名称</li><li>function：指向函数</li><li>arity：参数限制</li><li>sflags：命令属性</li><li>flags：命令属性掩码，一般为0</li><li>get_keys_proc：在复杂参数下，指定那个才是真正的key。一般为NULL</li><li>first_key_index：第一个参数所在位置</li><li>last_key_index：最后一个参数所在位置</li><li>key_step：命令步长</li><li>microseconds：命令的度量项，由Redis来设置，并且总是初始化为0。</li><li>calls：命令的度量项，由Redis来设置，并且总是初始化为0。</li><li>id：命令的权限，由Redis来设置，并且总是初始化为0。</li></ul><p>只需要修改以上几个文件然后启动就可以了。是不是很简单？<br>PS：前一篇文章中解决哨兵BUG<a href="https://omg-by.github.io/2020/05/17/new/redis_BUG%E8%AE%B0%E5%BD%95%E4%B8%80%E5%88%99/" target="_blank" rel="noopener">《Redis哨兵client-reconfig-script脚本bug记录一则》</a>时，调试就需要重新进行make &amp;&amp; make install操作才行。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>命令使用，跟正常使用其他命令并没有什么太大区别。主要会跟<code>mset</code>命令使用比较相似。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gevdm6iviij30la0e8gsd.jpg" alt=""></p><h2 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h2><p>本来还想去github提提issue的，结果发现早就有人跟作者提过这些问题了。我还是too yong to simple呀。<br>但是本着学习的心态，还是提了个issue，问问作者为什么不去实现这些简单又好用的命令。<a href="https://github.com/antirez/redis/issues/7263" target="_blank" rel="noopener">https://github.com/antirez/redis/issues/7263</a><br>后面有时间还是会继续实现其他命令的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周，参加公司后端部门开发的分享。&lt;br&gt;在期间，该开发吐槽Redis好几个使用不便利的地方。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;Redis没有批量设置过期时间的命令&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;incr 不存在的key的时候，并不会设置过期时间。导致持久化key的存在&lt;/font&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gevcwyswasj30uk0l20wd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL闪回工具调研</title>
    <link href="http://yoursite.com/2020/05/17/new/MySQL/MySQL%E9%97%AA%E5%9B%9E%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2020/05/17/new/MySQL/MySQL闪回工具/</id>
    <published>2020-05-16T16:41:47.000Z</published>
    <updated>2020-05-28T05:24:36.246Z</updated>
    
    <content type="html"><![CDATA[<p>刚入职2个月左右的时候，就遇到了业务误操作，将对测试环境的delete操作，到线上执行了。。。(至于业务为什么有delete权限的账号，俺也不知道)<br>由于公司所有实例都部署在阿里云上，所以只能依赖于阿里云的备份恢复系统来进行数据恢复。但是非常慢，当时是大概花了20分钟才完全恢复（-_-||）。<br>于是乎~工作量又被增加了。领导让我调研数据闪回工具。。。</p><p>在工具调研测试过程中，发现了这几个工具存在部分BUG问题，所以给记录一下。避免再次踩坑。</p><h2 id="MyFlash"><a href="#MyFlash" class="headerlink" title="MyFlash"></a>MyFlash</h2><p>MyFlash是由美团点评公司技术工程部开发维护的一个回滚DML操作的工具。该工具通过解析v4版本的binlog，完成回滚操作。相对已有的回滚工具，其增加了更多的过滤选项，让回滚更加容易。</p><font color="red">通过解析binlog来生成回滚binlog文件。</font><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>多种过滤条件，能够按照需求实现精准过滤</li><li>支持离线解析。不会对运行实例造成影响</li></ul><p>缺点：</p><ul><li>binlog格式必须为row，并且binlog_row_image=full。</li><li>只支持5.6和5.7</li><li>只支持DML，不支持DDL</li><li>MyFlash不能解析阿里云RDS的binlog</li></ul><a id="more"></a> <h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 下载源代码</span><br><span class="line">git clone https://github.com/Meituan-Dianping/MyFlash.git</span><br><span class="line"> </span><br><span class="line"># 编译</span><br><span class="line">cd MyFlash</span><br><span class="line">sh build.sh</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node001 binary]# ./flashback --help</span><br><span class="line">Usage:</span><br><span class="line">flashback [OPTION...]</span><br><span class="line"> </span><br><span class="line">Help Options:</span><br><span class="line">-h, --help Show help options</span><br><span class="line"> </span><br><span class="line">Application Options:</span><br><span class="line">--databaseNames databaseName to apply. if multiple, seperate by comma(,) 库名，多个库之间用“，”分割</span><br><span class="line">--tableNames tableName to apply. if multiple, seperate by comma(,) 表名，多个表之间用“，”分割</span><br><span class="line">--start-position start position 开始的位点。如不指定，从文件的开始处回滚。</span><br><span class="line">--stop-position stop position 结束的位点。如不指定，回滚到文件结尾。</span><br><span class="line">--start-datetime start time (format %Y-%m-%d %H:%M:%S) 开始的时间点。如不指定，则不限定时间</span><br><span class="line">--stop-datetime stop time (format %Y-%m-%d %H:%M:%S) 结束的时间点。如不指定，则不限定时间</span><br><span class="line">--sqlTypes sql type to filter . support INSERT, UPDATE ,DELETE. if multiple, seperate by comma(,) 需要回滚的SQL类型，只支持INSERT, UPDATE,DELETE。多个类型之间以“，”分割</span><br><span class="line">--maxSplitSize max file size after split, the uint is M 生成文件分割大小。以M为单位</span><br><span class="line">--binlogFileNames binlog files to process. if multiple, seperate by comma(,) binlog文件名，支持多个文件</span><br><span class="line">--outBinlogFileNameBase output binlog file name base 输出文件名前缀。文件名后缀为：.flashback</span><br><span class="line">--logLevel log level, available option is debug,warning,error</span><br><span class="line">--include-gtids gtids to process 生成的语句包含gtid</span><br><span class="line">--exclude-gtids gtids to skip 跳过gtid</span><br></pre></td></tr></table></figure><h2 id="binlog2sql"><a href="#binlog2sql" class="headerlink" title="binlog2sql"></a>binlog2sql</h2><font color="red">通过模拟从库解析数据来生成回滚SQL。</font><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>直接生成回滚语句，可读性较好。可根据需求进行选择性回滚</li><li>python实现，安装、使用、可扩展性较好</li><li>可指定位点、时间、语句类型</li><li>支持阿里云、自建实例</li></ul><p>缺点：</p><ul><li>需要连接数据库读取binlog，会对线上环境造成一定负载</li><li>依赖binlog。如果binlog被清理则无法生成回滚语句</li><li>不支持离线解析</li><li>解析速度较慢</li></ul><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; git clone https://github.com/danfengcao/binlog2sql.git &amp;&amp; cd binlog2sql</span><br><span class="line">shell&gt; pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">用户授权</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">mysql连接配置</span><br><span class="line">-h host; -P port; -u user; -p password</span><br><span class="line"> </span><br><span class="line">解析模式</span><br><span class="line">--stop-never 持续解析binlog。可选。默认False，同步至执行命令时最新的binlog位置。</span><br><span class="line">-K, --no-primary-key 对INSERT语句去除主键。可选。默认False</span><br><span class="line">-B, --flashback 生成回滚SQL，可解析大文件，不受内存限制。可选。默认False。与stop-never或no-primary-key不能同时添加。</span><br><span class="line">--back-interval -B模式下，每打印一千行回滚SQL，加一句SLEEP多少秒，如不想加SLEEP，请设为0。可选。默认1.0。</span><br><span class="line"> </span><br><span class="line">解析范围控制</span><br><span class="line">--start-file 起始解析文件，只需文件名，无需全路径 。必须。</span><br><span class="line">--start-position/--start-pos 起始解析位置。可选。默认为start-file的起始位置。</span><br><span class="line">--stop-file/--end-file 终止解析文件。可选。默认为start-file同一个文件。若解析模式为stop-never，此选项失效。</span><br><span class="line">--stop-position/--end-pos 终止解析位置。可选。默认为stop-file的最末位置；若解析模式为stop-never，此选项失效。</span><br><span class="line">--start-datetime 起始解析时间，格式&apos;%Y-%m-%d %H:%M:%S&apos;。可选。默认不过滤。</span><br><span class="line">--stop-datetime 终止解析时间，格式&apos;%Y-%m-%d %H:%M:%S&apos;。可选。默认不过滤。</span><br><span class="line"> </span><br><span class="line">对象过滤</span><br><span class="line">-d, --databases 只解析目标db的sql，多个库用空格隔开，如-d db1 db2。可选。默认为空。</span><br><span class="line">-t, --tables 只解析目标table的sql，多张表用空格隔开，如-t tbl1 tbl2。可选。默认为空。</span><br><span class="line">--only-dml 只解析dml，忽略ddl。可选。默认False。</span><br><span class="line">--sql-type 只解析指定类型，支持INSERT, UPDATE, DELETE。多个类型用空格隔开，如--sql-type INSERT DELETE。可选。默认为增删改都解析。用了此参数但没填任何类型，则三者都不解析。</span><br></pre></td></tr></table></figure><h3 id="发现的问题"><a href="#发现的问题" class="headerlink" title="发现的问题"></a>发现的问题</h3><h4 id="datetime类型恢复错误"><a href="#datetime类型恢复错误" class="headerlink" title="datetime类型恢复错误"></a>datetime类型恢复错误</h4><p>问题描述：</p><ul><li>存在字段：<code>o_update_time</code> datetime NOT NULL COMMENT</li><li>存在值：o_update_time: 0000-00-00 00:00:00</li><li>问题一：删除后，binlog2sql生成的insert语句，会将该字段值给设置为NULL。导致插入报错失败。</li><li>问题二：阿里云恢复后，数据不一致。</li></ul><p>删除前数据：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geurdsmu57j312a0oytct.jpg" alt=""></p><p>binlog2sql生成语句：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geurdyxbu0j31u007uaeg.jpg" alt=""></p><h4 id="varbinary类型字段恢复错误"><a href="#varbinary类型字段恢复错误" class="headerlink" title="varbinary类型字段恢复错误"></a>varbinary类型字段恢复错误</h4><p>现数据库中存在经过加密函数加密后的字段。并存在几条数据。然后删除其中一条语句来测试工具生成回滚语句。<br><code>pwd</code> varbinary(255) NOT NULL COMMENT ‘密码’,<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geurfbnj9fj30jr06c74x.jpg" alt=""></p><p>使用binlog2sql生成回滚语句时出错<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geurfewn49j30ps03b0tc.jpg" alt=""></p><h4 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h4><p>在数据类型为decimal、double、float等精度类型时，恢复时会由于精度问题导致恢复数据不一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table huzb_deci\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: huzb_deci</span><br><span class="line">Create Table: CREATE TABLE `huzb_deci` (</span><br><span class="line">  `id` int(11) NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  `dec` decimal(5,2) DEFAULT NULL,</span><br><span class="line">  `flo` float DEFAULT NULL,</span><br><span class="line">  `dou` double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>插入几条数据后，使用binlog2sql进行恢复。可以发现存在以下问题：</p><ol><li>double类型在插入时，由于精度问题，插入数据与原数据已经不一致。</li><li>float类型数据在使用binlog2sql生成恢复语句时，转换成了double类型，小数点后多了几位精度。</li><li>生成的回滚语句执行后，恢复的double类型数据不一致。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into huzb_deci values(1,1.1111111111111111111111111111111,2.22222222,3.333333333333333333333);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; show warnings;</span><br><span class="line">+-------+------+------------------------------------------+</span><br><span class="line">| Level | Code | Message                                  |</span><br><span class="line">+-------+------+------------------------------------------+</span><br><span class="line">| Note  | 1265 | Data truncated for column &apos;dec&apos; at row 1 |</span><br><span class="line">+-------+------+------------------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from huzb_deci;</span><br><span class="line">+----+------+---------+--------------------+</span><br><span class="line">| id | dec  | flo     | dou                |</span><br><span class="line">+----+------+---------+--------------------+</span><br><span class="line">|  1 | 1.11 | 2.22222 | 3.3333333333333335 |</span><br><span class="line">+----+------+---------+--------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 利用binlog2sql生成恢复语句并执行。</span><br><span class="line">mysql&gt; INSERT INTO `huzb`.`huzb_deci`(`id`, `dec`, `flo`, `dou`) VALUES (1, 1.11, 2.22222232818604, 3.33333333333333); #start 260805 end 260989 time 2019-10-30 19:58:48</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from huzb_deci;</span><br><span class="line">+----+------+---------+------------------+</span><br><span class="line">| id | dec  | flo     | dou              |</span><br><span class="line">+----+------+---------+------------------+</span><br><span class="line">|  1 | 1.11 | 2.22222 | 3.33333333333333 |</span><br><span class="line">+----+------+---------+------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><h4 id="日期错误问题修复"><a href="#日期错误问题修复" class="headerlink" title="日期错误问题修复"></a>日期错误问题修复</h4><ol><li>按照<a href="https://github.com/noplay/python-mysql-replication/pull/228修改对应的python-mysql-replication包文件(需要修改：binlogstream.py和row_event.py两个文件)" target="_blank" rel="noopener">https://github.com/noplay/python-mysql-replication/pull/228修改对应的python-mysql-replication包文件(需要修改：binlogstream.py和row_event.py两个文件)</a></li><li>binlog2sql中修改。增加date_tostr参数</li><li>不能直接使用python-mysql-replication的最新依赖包。只能通过修改文件，可能会引起未知问题</li><li>如果无NULL值字段，可尝试使用文本替换方式来修改插入语句。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binlog2sql.py 修改：</span><br><span class="line">stream = BinLogStreamReader(connection_settings=self.conn_setting, server_id=self.server_id,</span><br><span class="line">                            log_file=self.start_file, log_pos=self.start_pos, only_schemas=self.only_schemas,</span><br><span class="line">                            only_tables=self.only_tables, resume_stream=True, blocking=True, date_tostr=True)</span><br></pre></td></tr></table></figure></li></ol><h4 id="二进制流数据导入导出错误问题修复"><a href="#二进制流数据导入导出错误问题修复" class="headerlink" title="二进制流数据导入导出错误问题修复"></a>二进制流数据导入导出错误问题修复</h4><p>根据mysqldump导出二进制数据时的方式，所以有以下修复思路：</p><ol><li>在生成sql文本时，将二进制流转换成十六进制。</li><li>在导入数据时，利用原生的unhex将十六进制转换成二进制。<br>修改binlog2sql_util.py以下位置:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># TODO 改动一：二进制流解析为十六进制</span><br><span class="line">def fix_object(value):</span><br><span class="line">    &quot;&quot;&quot;Fixes python objects so that they can be properly inserted into SQL queries&quot;&quot;&quot;</span><br><span class="line">    if isinstance(value, set):</span><br><span class="line">        value = &apos;,&apos;.join(value)</span><br><span class="line">    if PY3PLUS and isinstance(value, bytes):</span><br><span class="line">        # return value.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;)</span><br><span class="line">        # 将二进制数据转换成十六进制数据，并使用特殊符号包含起来。用于后面转换</span><br><span class="line">        return &quot;----&quot; + bytes.hex(value) + &quot;____&quot;</span><br><span class="line">    elif not PY3PLUS and isinstance(value, unicode):</span><br><span class="line">        return value.encode(&apos;utf-8&apos;)</span><br><span class="line">    else:</span><br><span class="line">        return value</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># TODO 改动二：修改生成sql中的unhex串</span><br><span class="line">unhex_inex = str.find(sql, &quot;&apos;----&quot;)</span><br><span class="line">if unhex_inex != -1:</span><br><span class="line">    sql = str.replace(sql, &quot;&apos;----&quot;, &quot;unhex(&apos;&quot;)</span><br><span class="line">    sql = str.replace(sql, &quot;____&apos;&quot;, &quot;&apos;)&quot;)</span><br><span class="line">sql += &apos; #start %s end %s time %s&apos; % (e_start_pos, binlog_event.packet.log_pos, time)</span><br></pre></td></tr></table></figure></li></ol><p>题外话：<br>小公司还是各种体系、规范不够完善，要是在上一家公司，早就被业务吊起来diss不知道多少遍了。<br>数据备份恢复是作为DBA最重要的技能点之一，但是由于云化的出现，导致很多人都只会点点点，太过于依赖平台的操作，而忽略了DBA的本质工作。这也是我接下来的工作重点：MySQL、Redis自动化备份恢复系统的建设工作（已完成）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚入职2个月左右的时候，就遇到了业务误操作，将对测试环境的delete操作，到线上执行了。。。(至于业务为什么有delete权限的账号，俺也不知道)&lt;br&gt;由于公司所有实例都部署在阿里云上，所以只能依赖于阿里云的备份恢复系统来进行数据恢复。但是非常慢，当时是大概花了20分钟才完全恢复（-_-||）。&lt;br&gt;于是乎~工作量又被增加了。领导让我调研数据闪回工具。。。&lt;/p&gt;
&lt;p&gt;在工具调研测试过程中，发现了这几个工具存在部分BUG问题，所以给记录一下。避免再次踩坑。&lt;/p&gt;
&lt;h2 id=&quot;MyFlash&quot;&gt;&lt;a href=&quot;#MyFlash&quot; class=&quot;headerlink&quot; title=&quot;MyFlash&quot;&gt;&lt;/a&gt;MyFlash&lt;/h2&gt;&lt;p&gt;MyFlash是由美团点评公司技术工程部开发维护的一个回滚DML操作的工具。该工具通过解析v4版本的binlog，完成回滚操作。相对已有的回滚工具，其增加了更多的过滤选项，让回滚更加容易。&lt;/p&gt;
&lt;font color=&quot;red&quot;&gt;通过解析binlog来生成回滚binlog文件。&lt;/font&gt;

&lt;h3 id=&quot;优缺点&quot;&gt;&lt;a href=&quot;#优缺点&quot; class=&quot;headerlink&quot; title=&quot;优缺点&quot;&gt;&lt;/a&gt;优缺点&lt;/h3&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多种过滤条件，能够按照需求实现精准过滤&lt;/li&gt;
&lt;li&gt;支持离线解析。不会对运行实例造成影响&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;binlog格式必须为row，并且binlog_row_image=full。&lt;/li&gt;
&lt;li&gt;只支持5.6和5.7&lt;/li&gt;
&lt;li&gt;只支持DML，不支持DDL&lt;/li&gt;
&lt;li&gt;MyFlash不能解析阿里云RDS的binlog&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL工具" scheme="http://yoursite.com/tags/MySQL%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Redis哨兵client-reconfig-script脚本bug记录一则</title>
    <link href="http://yoursite.com/2020/05/17/new/Redis/redis_BUG%E8%AE%B0%E5%BD%95%E4%B8%80%E5%88%99/"/>
    <id>http://yoursite.com/2020/05/17/new/Redis/redis_BUG记录一则/</id>
    <published>2020-05-16T16:00:47.000Z</published>
    <updated>2020-05-16T16:06:27.092Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵子一直在做自建机房Redis主从的环境搭建。了解到哨兵高可用切换后的会调用<code>client-reconfig-script</code>参数配置的脚本。<br>但是遇到了一个从2.8版本一直存在至今的BUG。我已经提了一个PR给官方，并被meger了。<a href="https://github.com/antirez/redis/pull/7113" target="_blank" rel="noopener">https://github.com/antirez/redis/pull/7113</a><br>特此记录一下。</p><h2 id="BUG场景"><a href="#BUG场景" class="headerlink" title="BUG场景"></a>BUG场景</h2><p>手动将主实例kill掉，模拟宕机情况。在某些情况下，<font color="red">哨兵已经触发了高可用切换</font>行为（主从状态、日志均有）。但是并<font color="red">没有调用</font>配置的脚本（非必现，但是落到同一台机器调用时并不会调用）<br>重启该机器上的哨兵节点又恢复正常。（重启大法好）</p><a id="more"></a><h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>根据网上搜索到的脚本也自己编写了一个。大概逻辑就是</p><ol><li>新主IP等于本机IP触发域名切换、元数据修改等操作，并exit 0;</li><li>非本机IP不做任何操作，并exit 1;</li></ol><p>按道理来说，这个脚本处理逻辑跟网上99%给出的脚本一致，应该问题不大。<br>的确，在前几次或者短时间内触发多次触发高可用切换，脚本都能够正常执行。<br>但是遇到以下几种情况下不会触发。</p><ol><li>触发2次高可用切换后，本人划水半小时，再来触发，此时脚本不执行。</li><li>连续触发10次左右，都正常。总时长在5分钟左右后，脚本不执行。</li></ol><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><h3 id="脚本问题？"><a href="#脚本问题？" class="headerlink" title="脚本问题？"></a>脚本问题？</h3><p>首先，由于是第一次接触哨兵调用脚本。所以怀疑是自己写的脚本逻辑不正确。于是在编写脚本中每一个操作前都输出日志，甚至在第一行输出东西；结果仍没有调用！<br>而且轮到其他机器上的哨兵调用脚本时，可能能够调用成功。<br>所以排除脚本问题。</p><h3 id="脚本权限问题？"><a href="#脚本权限问题？" class="headerlink" title="脚本权限问题？"></a>脚本权限问题？</h3><p>通过google在Stack Overflow上，以及在Redis交流群中咨询。了解到可能存在脚本权限问题可能会调用失败。<br>于是关注该脚本在每次被调用后的状态，发现并没有什么变化。并且机器为新机器，只有本人在操作。所以认为权限问题不大可能。</p><h3 id="发现共性"><a href="#发现共性" class="headerlink" title="发现共性"></a>发现共性</h3><p>在进行多次高可用切换测试后，所有的哨兵切换在执行完高可用切换后，都不再去调用脚本。<br>这个时候，对所有的哨兵节点状态进行查看。发现有一个共性。<code>sentinel_running_scripts</code>值都为16。<br>该参数表示正在执行的脚本。<br>进一步验证，发现：</p><ol><li>该值小于16时，会正常调用。</li><li>该值会进行周期性的增加。</li><li>只触发一次高可用时，该值变成9后不再增加。</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><font color="red">没有什么问题是阅读源码解决不了的</font><p>通过分析哨兵节点进行高可用切换段代码。发现在调用<code>client-reconfig-script</code>脚本时，会根据其返回值做不同处理。</p><ul><li>0：表示脚本执行成功。不重试</li><li>1：表示脚本执行失败。进行重试，最多10次</li><li>大于1：表示脚本执行失败。不进行重试。</li></ul><p>bug出现点：</p><ul><li>当running_scripts &gt;= SENTINEL_SCRIPT_MAX_RUNNING(16)时就不会再进入到调用脚本的逻辑里。</li><li>当调用脚本时，running_scripts++</li><li>脚本重试也会触发running_scripts++</li><li>只有当脚本达到最大重试次数(10次)，或者脚本返回非1值时，才触发一次running_scripts–</li></ul><p>可以看到，在非新主机器脚本执行时，脚本总会exit 1。所以会重试10次。running_scripts+10-1=9。<br>当遇到两次这样的情况，running_scripts就等于16了。调用脚本逻辑将不再被执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">/* Run pending scripts if we are not already at max number of running</span><br><span class="line"> * scripts. */</span><br><span class="line">void sentinelRunPendingScripts(void) &#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    mstime_t now = mstime();</span><br><span class="line"></span><br><span class="line">    /* Find jobs that are not running and run them, from the top to the</span><br><span class="line">     * tail of the queue, so we run older jobs first. */</span><br><span class="line">    // li是script_queue的一个前向迭代器</span><br><span class="line">    listRewind(sentinel.scripts_queue,&amp;li);</span><br><span class="line">    // 开始遍历running_scripts队列</span><br><span class="line">    while (sentinel.running_scripts &lt; SENTINEL_SCRIPT_MAX_RUNNING &amp;&amp;</span><br><span class="line">           (ln = listNext(&amp;li)) != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        sentinelScriptJob *sj = ln-&gt;value;</span><br><span class="line">        pid_t pid;</span><br><span class="line"></span><br><span class="line">        /* Skip if already running. */</span><br><span class="line">        // 跳过正在执行的job</span><br><span class="line">        if (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) continue;</span><br><span class="line"></span><br><span class="line">        /* Skip if it&apos;s a retry, but not enough time has elapsed. */</span><br><span class="line">        // 还没到执行时间，暂时跳过</span><br><span class="line">        if (sj-&gt;start_time &amp;&amp; sj-&gt;start_time &gt; now) continue;</span><br><span class="line"></span><br><span class="line">        sj-&gt;flags |= SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">        sj-&gt;start_time = mstime();</span><br><span class="line">        sj-&gt;retry_num++;</span><br><span class="line">        // fork一个子进程</span><br><span class="line">        pid = fork();</span><br><span class="line"></span><br><span class="line">        // fork子进程失败</span><br><span class="line">        if (pid == -1) &#123;</span><br><span class="line">            /* Parent (fork error).</span><br><span class="line">             * We report fork errors as signal 99, in order to unify the</span><br><span class="line">             * reporting with other kind of errors. */</span><br><span class="line">            sentinelEvent(LL_WARNING,&quot;-script-error&quot;,NULL,</span><br><span class="line">                          &quot;%s %d %d&quot;, sj-&gt;argv[0], 99, 0);</span><br><span class="line">            sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">            sj-&gt;pid = 0;</span><br><span class="line">        &#125; else if (pid == 0) &#123;</span><br><span class="line">            /* Child */</span><br><span class="line">            execve(sj-&gt;argv[0],sj-&gt;argv,environ);</span><br><span class="line">            /* If we are here an error occurred. */</span><br><span class="line">            _exit(2); /* Don&apos;t retry execution. */</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sentinel.running_scripts++;</span><br><span class="line">            sj-&gt;pid = pid;</span><br><span class="line">            sentinelEvent(LL_DEBUG,&quot;+script-child&quot;,NULL,&quot;%ld&quot;,(long)pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Check for scripts that terminated, and remove them from the queue if the</span><br><span class="line"> * script terminated successfully. If instead the script was terminated by</span><br><span class="line"> * a signal, or returned exit code &quot;1&quot;, it is scheduled to run again if</span><br><span class="line"> * the max number of retries did not already elapsed. */</span><br><span class="line">void sentinelCollectTerminatedScripts(void) &#123;</span><br><span class="line">    int statloc;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    while ((pid = wait3(&amp;statloc,WNOHANG,NULL)) &gt; 0) &#123;</span><br><span class="line">        int exitcode = WEXITSTATUS(statloc);</span><br><span class="line">        int bysignal = 0;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        sentinelScriptJob *sj;</span><br><span class="line"></span><br><span class="line">        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</span><br><span class="line">        sentinelEvent(LL_DEBUG,&quot;-script-child&quot;,NULL,&quot;%ld %d %d&quot;,</span><br><span class="line">            (long)pid, exitcode, bysignal);</span><br><span class="line"></span><br><span class="line">        ln = sentinelGetScriptListNodeByPid(pid);</span><br><span class="line">        if (ln == NULL) &#123;</span><br><span class="line">            serverLog(LL_WARNING,&quot;wait3() returned a pid (%ld) we can&apos;t find in our scripts execution queue!&quot;, (long)pid);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        sj = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">        /* If the script was terminated by a signal or returns an</span><br><span class="line">         * exit code of &quot;1&quot; (that means: please retry), we reschedule it</span><br><span class="line">         * if the max number of retries is not already reached. */</span><br><span class="line">        // 如果脚本中断或者退出值为1。则重新进入队列，并增加执行时间</span><br><span class="line">        if ((bysignal || exitcode == 1) &amp;&amp;</span><br><span class="line">            sj-&gt;retry_num != SENTINEL_SCRIPT_MAX_RETRY)</span><br><span class="line">        &#123;</span><br><span class="line">            sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">            sj-&gt;pid = 0;</span><br><span class="line">            sj-&gt;start_time = mstime() +</span><br><span class="line">                             sentinelScriptRetryDelay(sj-&gt;retry_num);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* Otherwise let&apos;s remove the script, but log the event if the</span><br><span class="line">             * execution did not terminated in the best of the ways. */</span><br><span class="line">            // 如果是中断或者不成功，则是因为到达了执行次数上线，打印出错误日志</span><br><span class="line">            if (bysignal || exitcode != 0) &#123;</span><br><span class="line">                sentinelEvent(LL_WARNING,&quot;-script-error&quot;,NULL,</span><br><span class="line">                              &quot;%s %d %d&quot;, sj-&gt;argv[0], bysignal, exitcode);</span><br><span class="line">            &#125;</span><br><span class="line">            // 这个地方只会在成功或者重试了10才执行到。</span><br><span class="line">            listDelNode(sentinel.scripts_queue,ln);</span><br><span class="line">            sentinelReleaseScriptJob(sj);</span><br><span class="line">            sentinel.running_scripts--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="临时解决方案"><a href="#临时解决方案" class="headerlink" title="临时解决方案"></a>临时解决方案</h3><p>脚本不exit 1。exit 2表示失败，即不进行哨兵重试调用脚本行为。</p><h3 id="源码修复"><a href="#源码修复" class="headerlink" title="源码修复"></a>源码修复</h3><p>将上面源码中的<code>sentinel.running_scripts--;</code>提到else之外。即使exit 1也需要减一。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵子一直在做自建机房Redis主从的环境搭建。了解到哨兵高可用切换后的会调用&lt;code&gt;client-reconfig-script&lt;/code&gt;参数配置的脚本。&lt;br&gt;但是遇到了一个从2.8版本一直存在至今的BUG。我已经提了一个PR给官方，并被meger了。&lt;a href=&quot;https://github.com/antirez/redis/pull/7113&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/antirez/redis/pull/7113&lt;/a&gt;&lt;br&gt;特此记录一下。&lt;/p&gt;
&lt;h2 id=&quot;BUG场景&quot;&gt;&lt;a href=&quot;#BUG场景&quot; class=&quot;headerlink&quot; title=&quot;BUG场景&quot;&gt;&lt;/a&gt;BUG场景&lt;/h2&gt;&lt;p&gt;手动将主实例kill掉，模拟宕机情况。在某些情况下，&lt;font color=&quot;red&quot;&gt;哨兵已经触发了高可用切换&lt;/font&gt;行为（主从状态、日志均有）。但是并&lt;font color=&quot;red&quot;&gt;没有调用&lt;/font&gt;配置的脚本（非必现，但是落到同一台机器调用时并不会调用）&lt;br&gt;重启该机器上的哨兵节点又恢复正常。（重启大法好）&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis指标说明</title>
    <link href="http://yoursite.com/2020/04/26/new/Redis/Redis_INFO/"/>
    <id>http://yoursite.com/2020/04/26/new/Redis/Redis_INFO/</id>
    <published>2020-04-26T02:30:47.000Z</published>
    <updated>2020-04-26T06:03:22.046Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于Redis最新unstable版本下，执行info命令后，返回的各项指标进行解释。并对其中需要特别注意的指标进行指出说明。<br>并会对阿里云info进行简单对比。区分阿里云对info进行了哪些方面的改造。</p><a id="more"></a><h2 id="info可选命令值"><a href="#info可选命令值" class="headerlink" title="info可选命令值"></a>info可选命令值</h2><p>info这个命令的判断实现是在<code>server.c-&gt;genRedisInfoString(char *section)</code>函数中。根据不同的section返回不同的info信息。<br>section可选值有以下这些：</p><ul><li>空 or all or default：大部分简要的信息</li><li>clients：客户端相关信息</li><li>memory：内存使用相关信息</li><li>persistence：RDB 和 AOF 的相关信息</li><li>stats：一般统计信息</li><li>replication：主/从复制信息</li><li>cpu：CPU 计算量统计信息</li><li>cluster：Redis 集群信息</li><li>keyspace：数据库相关的统计信息</li><li>commandstats：Redis 命令统计信息</li></ul><h2 id="info信息介绍"><a href="#info信息介绍" class="headerlink" title="info信息介绍"></a>info信息介绍</h2><h3 id="unstable信息"><a href="#unstable信息" class="headerlink" title="unstable信息"></a>unstable信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"># Server</span><br><span class="line">redis_version:999.999.999           // redi服务器版本</span><br><span class="line">redis_git_sha1:d044e33c             // Git SHA1</span><br><span class="line">redis_git_dirty:1                   // Git dirty flag</span><br><span class="line">redis_build_id:f0892bae2ab3d928     // redis build 版本</span><br><span class="line">redis_mode:standalone               // redis运行模式</span><br><span class="line">os:Darwin 19.4.0 x86_64             // 运行redis服务的操作系统</span><br><span class="line">arch_bits:64                        // 服务器架构，32位or64位</span><br><span class="line">multiplexing_api:kqueue             // redis所使用的事件处理机制</span><br><span class="line">atomicvar_api:atomic-builtin        // 原子处理API</span><br><span class="line">gcc_version:4.2.1                   // 编译Reedis时使用的GCC版本</span><br><span class="line">process_id:87804                    // Redis服务进程PID</span><br><span class="line">run_id:c7373afe697afdd775ab4220091574652e10354b   // Redis服务器的随机标识符</span><br><span class="line">tcp_port:6379                       // TCP/IP端口</span><br><span class="line">uptime_in_seconds:37                // 服务器启动至今的时间，单位秒</span><br><span class="line">uptime_in_days:0                    // 服务器启动至今的时间，单位天</span><br><span class="line">hz:10                               // redis内部调用频率，每秒运行多少次serverCron</span><br><span class="line">configured_hz:10                    // 配置文件设置的频率数</span><br><span class="line">lru_clock:10750326                  // 自增时钟，用于管理LRU管理，每执行一次serverCron更新一次</span><br><span class="line">executable:/Users/hzb/redis_github/redis_debug/cmake-build-debug/src/redis-server // 执行文件</span><br><span class="line">config_file:                        // 配置文件路径</span><br><span class="line"></span><br><span class="line"># Clients</span><br><span class="line">connected_clients:2                 // 连接的客户端数</span><br><span class="line">client_recent_max_input_buffer:2    // 当前客户端连接中，最大的输入缓冲区大小</span><br><span class="line">client_recent_max_output_buffer:0   // 当前客户端连接中，最大的输出缓冲区大小</span><br><span class="line">blocked_clients:0                   // 正在等待你阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端数</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">used_memory:1082368                 // 当前内存使用量，byte为单位</span><br><span class="line">used_memory_human:1.03M             // 以可读方式显示当前内存使用量</span><br><span class="line">used_memory_rss:5779456             // 从操作系统层面，返回redis已分配的内存总量，这个值与ps、top等命令输出的一样</span><br><span class="line">used_memory_rss_human:5.51M         // 可读方式显示已分配总量</span><br><span class="line">used_memory_peak:1082368            // redis内存使用峰值</span><br><span class="line">used_memory_peak_human:1.03M        // 已可读方式显示内存使用峰值</span><br><span class="line">used_memory_peak_perc:100.15%       // (used_memory/ used_memory_peak) *100%</span><br><span class="line">used_memory_overhead:1066024        // Redis为了维护数据集内部机制所需的内存开销，包括客户端输出缓冲区、查询缓冲区、AOF重写缓冲区、backlog等</span><br><span class="line">used_memory_startup:998672          // Redis服务器启动时消耗的内存</span><br><span class="line">used_memory_dataset:16344           // 数据真实使用的内存量。（used_memory—used_memory_overhead）</span><br><span class="line">used_memory_dataset_perc:19.53%     // 数据占用内存占使用内存比。（100%*(used_memory_dataset/(used_memory—used_memory_startup))）</span><br><span class="line">allocator_allocated:1035760         // </span><br><span class="line">allocator_active:5741568</span><br><span class="line">allocator_resident:5741568</span><br><span class="line">total_system_memory:17179869184     // 总系统内存</span><br><span class="line">total_system_memory_human:16.00G</span><br><span class="line">used_memory_lua:37888               // Lua引擎使用内存</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">used_memory_scripts:0                 </span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">maxmemory:0                         // 设置的最大内存使用量。默认为0，表示不限制</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction         // 淘汰策略</span><br><span class="line">allocator_frag_ratio:5.54           // 碎片率</span><br><span class="line">allocator_frag_bytes:4705808        // 碎片大小</span><br><span class="line">allocator_rss_ratio:1.00            // 常驻内存比例</span><br><span class="line">allocator_rss_bytes:0               // 常驻内存大小</span><br><span class="line">rss_overhead_ratio:1.01             // 常驻内存开销比例</span><br><span class="line">rss_overhead_bytes:37888            // 常驻内存开销大小</span><br><span class="line">mem_fragmentation_ratio:5.58        // 碎片率（used_memory_rss/ used_memory） 正常在（1-1.6）之间</span><br><span class="line">mem_fragmentation_bytes:4743696     // 内存碎片大小</span><br><span class="line">mem_not_counted_for_evict:0         // 被驱逐的内存</span><br><span class="line">mem_replication_backlog:0           // Redis复制积压缓冲区内存</span><br><span class="line">mem_clients_slaves:0                // Redis节点客户端消耗内存</span><br><span class="line">mem_clients_normal:66632            // Rediis常规客户端消耗内存</span><br><span class="line">mem_aof_buffer:0                    // AOF使用内存</span><br><span class="line">mem_allocator:libc                  // 内存分配器</span><br><span class="line">active_defrag_running:0             // 碎片整理是否处于活动状态</span><br><span class="line">lazyfree_pending_objects:0          // 0-不存在延迟释放的挂起对象</span><br><span class="line"></span><br><span class="line"># Persistence</span><br><span class="line">loading:0                           // 服务器是否正在载入持久化文件</span><br><span class="line">rdb_changes_since_last_save:0       // 离最近一次成功生成rdb文件，写入命令的个数，即有多少个写入命令没有持久化</span><br><span class="line">rdb_bgsave_in_progress:0            // 服务器是否正在创建rdb文件</span><br><span class="line">rdb_last_save_time:1587808593       // 离最近一次成功创建rdb文件的时间戳。当前时间戳 - rdb_last_save_time=多少秒未成功生成rdb文件</span><br><span class="line">rdb_last_bgsave_status:ok           // 最近一次rdb持久化是否成功</span><br><span class="line">rdb_last_bgsave_time_sec:-1         // 最近一次成功生成rdb文件耗时秒数</span><br><span class="line">rdb_current_bgsave_time_sec:-1      // 如果服务器正在创建rdb文件，那么这个域记录的就是当前的创建操作已经耗费的秒数</span><br><span class="line">rdb_last_cow_size:0                 // RDB过程中父进程与子进程相比执行了多少修改(包括读缓冲区，写缓冲区，数据修改等)。</span><br><span class="line">aof_enabled:0                       // 是否开启了aof</span><br><span class="line">aof_rewrite_in_progress:0           // 标识aof的rewrite操作是否在进行中</span><br><span class="line">aof_rewrite_scheduled:0             // 正在等待执行rewrite任务个数</span><br><span class="line">aof_last_rewrite_time_sec:-1        // 最近一次aof rewrite耗费的时长</span><br><span class="line">aof_current_rewrite_time_sec:-1     // 如果rewrite操作正在进行，则记录所使用的时间，单位秒</span><br><span class="line">aof_last_bgrewrite_status:ok        // 上次bgrewriteaof操作的状态</span><br><span class="line">aof_last_write_status:ok            // 上次aof写入状态</span><br><span class="line">aof_last_cow_size:0                 // AOF过程中父进程与子进程相比执行了多少修改(包括读缓冲区，写缓冲区，数据修改等)。</span><br><span class="line"></span><br><span class="line"># Stats</span><br><span class="line">total_connections_received:2        // 新创建连接的个数</span><br><span class="line">total_commands_processed:3          // redis处理命令总数</span><br><span class="line">instantaneous_ops_per_sec:0         // redis当前的QPS</span><br><span class="line">total_net_input_bytes:62            // redis网络入口流量字节数</span><br><span class="line">total_net_output_bytes:39355        // redis网络出口流量字节数</span><br><span class="line">instantaneous_input_kbps:0.00       // redis网络入口kps</span><br><span class="line">instantaneous_output_kbps:0.00      // redis网络出口kps</span><br><span class="line">rejected_connections:0              // 拒绝的连接个数</span><br><span class="line">sync_full:0                         // 主从完全同步成功次数</span><br><span class="line">sync_partial_ok:0                   // 主从部分同步成功次数</span><br><span class="line">sync_partial_err:0                  // 主从部分同步失败次数</span><br><span class="line">expired_keys:0                      // 运行以来过期的key的数量</span><br><span class="line">expired_stale_perc:0.00             // 过期的比率</span><br><span class="line">expired_time_cap_reached_count:0    // 过期计数</span><br><span class="line">evicted_keys:0                      // 运行以来剔除(超过了maxmemory后)的key的数量</span><br><span class="line">keyspace_hits:0                     // 命中次数</span><br><span class="line">keyspace_misses:0                   // 没命中次数</span><br><span class="line">pubsub_channels:0                   // 当前使用中的频道数量</span><br><span class="line">pubsub_patterns:0                   // 当前使用的模式的数量</span><br><span class="line">latest_fork_usec:0                  // 最近一次fork操作阻塞redis进程的耗时数，单位微秒</span><br><span class="line">migrate_cached_sockets:0            // 是否已经缓存了到该地址的连接</span><br><span class="line">slave_expires_tracked_keys:0        // 从实例到期key数量</span><br><span class="line">active_defrag_hits:0                // 主动碎片整理命中次数</span><br><span class="line">active_defrag_misses:0              // 主动碎片整理未命中次数</span><br><span class="line">active_defrag_key_hits:0            // 主动碎片整理key命中次数</span><br><span class="line">active_defrag_key_misses:0          // 主动碎片整理key未命中次数</span><br><span class="line"></span><br><span class="line"># Replication</span><br><span class="line">role:master                         // 实例角色</span><br><span class="line">connected_slaves:0                  // 连接的slave实例个数</span><br><span class="line">master_replid:59e5c4b387f62e131a284ca4a144152cbc38dd2b    // 主实例启动随机字符串</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000   // 主实例启动随机字符串2</span><br><span class="line">master_repl_offset:0                // 主从同步偏移量</span><br><span class="line">second_repl_offset:-1               // 主从同步偏移量2,此值如果和上面的offset相同说明主从一致没延迟</span><br><span class="line">repl_backlog_active:0               // 复制积压缓冲区是否开启</span><br><span class="line">repl_backlog_size:1048576           // 复制积压缓冲大小</span><br><span class="line">repl_backlog_first_byte_offset:0    // 复制缓冲区里偏移量的大小</span><br><span class="line">repl_backlog_histlen:0              // 此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小</span><br><span class="line"></span><br><span class="line"># CPU</span><br><span class="line">used_cpu_sys:0.023950               // 所有redis主进程在核心态所占用的CPU时求和累计起来</span><br><span class="line">used_cpu_user:0.021295              // 所有redis主进程在用户态所占用的CPU时求和累计起来</span><br><span class="line">used_cpu_sys_children:0.000000      // 后台进程在核心态所占用的CPU时求和累计起来</span><br><span class="line">used_cpu_user_children:0.000000     // 后台进程在用户态所占用的CPU时求和累计起来</span><br><span class="line"></span><br><span class="line"># Cluster</span><br><span class="line">cluster_enabled:0                   // 是否开启了集群模式</span><br><span class="line"></span><br><span class="line"># Keyspace</span><br><span class="line">db0:keys=14,expires=0,avg_ttl=0     // key的数量,以及带有生存期的key的数,平均存活时间</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; info commandstats</span><br><span class="line"># Commandstats</span><br><span class="line">cmdstat_get:calls=1,usec=16,usec_per_call=16.00       // 命令：调用次数，消耗的时间（微秒），消耗时间平均值（微秒）</span><br><span class="line">cmdstat_info:calls=1,usec=45,usec_per_call=45.00</span><br><span class="line">cmdstat_command:calls=1,usec=1454,usec_per_call=1454.00</span><br></pre></td></tr></table></figure><h3 id="阿里云信息"><a href="#阿里云信息" class="headerlink" title="阿里云信息"></a>阿里云信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">r-2ze48c70febc6e34.redis.rds.aliyuncs.com:6379&gt; info</span><br><span class="line"># Server</span><br><span class="line">redis_version:4.0.11</span><br><span class="line">redis_git_sha1:0b2746f2</span><br><span class="line">redis_git_dirty:1</span><br><span class="line">redis_build_id:5cfe6fcdd30f0fbc</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux  </span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">atomicvar_api:atomic-builtin</span><br><span class="line">gcc_version:0.0.0</span><br><span class="line">process_id:48004</span><br><span class="line">run_id:d61d98f1f9489bbc0f790d5a7cee510c62aa6614</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:648333</span><br><span class="line">uptime_in_days:7</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:10767429</span><br><span class="line">executable:</span><br><span class="line">config_file:</span><br><span class="line"></span><br><span class="line"># Clients</span><br><span class="line">connected_clients:18</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:14</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">used_memory:249353384</span><br><span class="line">used_memory_human:237.80M</span><br><span class="line">used_memory_rss:283426816</span><br><span class="line">used_memory_rss_human:270.30M</span><br><span class="line">used_memory_peak:279685640</span><br><span class="line">used_memory_peak_human:266.73M</span><br><span class="line">used_memory_peak_perc:89.15%</span><br><span class="line">used_memory_overhead:145987838</span><br><span class="line">used_memory_startup:7985288</span><br><span class="line">used_memory_dataset:103365546</span><br><span class="line">used_memory_dataset_perc:42.82%</span><br><span class="line">used_memory_lua:44032</span><br><span class="line">used_memory_lua_human:43.00K</span><br><span class="line">used_memory_scripts:488</span><br><span class="line">used_memory_scripts_human:488B</span><br><span class="line">number_of_cached_scripts:1</span><br><span class="line">maxmemory:1073741824</span><br><span class="line">maxmemory_human:1.00G</span><br><span class="line">maxmemory_policy:volatile-lru</span><br><span class="line">mem_fragmentation_ratio:1.14</span><br><span class="line">mem_allocator:jemalloc-5.1.0</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br><span class="line">oom_err_count:0</span><br><span class="line"></span><br><span class="line"># Stats</span><br><span class="line">total_connections_received:858268</span><br><span class="line">total_commands_processed:336711164</span><br><span class="line">instantaneous_ops_per_sec:774</span><br><span class="line">total_net_input_bytes:17239795209</span><br><span class="line">total_net_output_bytes:49608006979</span><br><span class="line">instantaneous_input_kbps:33.74</span><br><span class="line">instantaneous_output_kbps:201.54</span><br><span class="line">rejected_connections:0</span><br><span class="line">rejected_connections_status:0</span><br><span class="line">sync_full:4</span><br><span class="line">sync_partial_ok:1</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:9241799</span><br><span class="line">expired_stale_perc:11.51</span><br><span class="line">expired_time_cap_reached_count:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">evicted_keys_per_sec:0</span><br><span class="line">keyspace_hits:106766672</span><br><span class="line">keyspace_misses:205934497</span><br><span class="line">hits_per_sec:405.50</span><br><span class="line">misses_per_sec:338.25</span><br><span class="line">hit_rate_percentage:54.52</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:11205</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line">slave_expires_tracked_keys:0</span><br><span class="line">active_defrag_hits:0</span><br><span class="line">active_defrag_misses:0</span><br><span class="line">active_defrag_key_hits:0</span><br><span class="line">active_defrag_key_misses:0</span><br><span class="line">traffic_control_input:0</span><br><span class="line">traffic_control_input_status:0</span><br><span class="line">traffic_control_output:0</span><br><span class="line">traffic_control_output_status:0</span><br><span class="line">total_bigkeys:0</span><br><span class="line">bigkeys_status:0</span><br><span class="line">stat_avg_rt:2</span><br><span class="line">stat_max_rt:428</span><br><span class="line">pacluster_migrate_sum_rt:0</span><br><span class="line">pacluster_migrate_max_rt:0</span><br><span class="line">pacluster_migrate_qps:0</span><br><span class="line">pacluster_import_sum_rt:0</span><br><span class="line">pacluster_import_max_rt:0</span><br><span class="line">pacluster_import_qps:0</span><br><span class="line">pacluster_migrate_start_time:0</span><br><span class="line">pacluster_importing_start_time:0</span><br><span class="line"></span><br><span class="line"># CPU</span><br><span class="line">used_cpu_sys:4143.00</span><br><span class="line">used_cpu_user:3553.77</span><br><span class="line">used_cpu_sys_children:2.71</span><br><span class="line">used_cpu_user_children:26.16</span><br><span class="line"></span><br><span class="line"># Cluster</span><br><span class="line">cluster_enabled:0</span><br><span class="line">databases:256</span><br><span class="line">nodecount:1</span><br><span class="line"></span><br><span class="line"># paCluster</span><br><span class="line">pacluster_enabled:0</span><br><span class="line"></span><br><span class="line"># Keyspace</span><br><span class="line">db0:keys=1790098,expires=319664,avg_ttl=9670198</span><br></pre></td></tr></table></figure><h3 id="阿里云改造"><a href="#阿里云改造" class="headerlink" title="阿里云改造"></a>阿里云改造</h3><p>通过对比，可以看到阿里云对info中的部分信息进行改造。<br>主要有：</p><ol><li>隐藏了Persistence持久话信息。这对我们排查问题时，无法确认是否因为持久化造成。</li><li>隐藏了Replication主从复制信息。</li><li><p>Stats状态中的统计信息增加了以下统计信息。主要包含（bigkeys统计、rt信息、集群相关的一些信息）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">total_bigkeys:0</span><br><span class="line">bigkeys_status:0</span><br><span class="line">stat_avg_rt:2</span><br><span class="line">stat_max_rt:428</span><br><span class="line">pacluster_migrate_sum_rt:0</span><br><span class="line">pacluster_migrate_max_rt:0</span><br><span class="line">pacluster_migrate_qps:0</span><br><span class="line">pacluster_import_sum_rt:0</span><br><span class="line">pacluster_import_max_rt:0</span><br><span class="line">pacluster_import_qps:0</span><br><span class="line">pacluster_migrate_start_time:0</span><br><span class="line">pacluster_importing_start_time:0</span><br></pre></td></tr></table></figure></li><li><p>新增了paCluster</p></li><li>Cluster中的信息进行改造</li><li>版本区别，Redis新版本中。将client_longest_output_list、client_biggest_input_buf修改成了client_recent_max_input_buffer、client_recent_max_output_buffer</li><li>info commandstats增加了其他指标</li></ol><h2 id="需要监控的参数"><a href="#需要监控的参数" class="headerlink" title="需要监控的参数"></a>需要监控的参数</h2><ul><li>connected_clients: 当前连接客户端数</li><li>client_longest_output_list：客户端中最长的输出缓冲区大小</li><li>client_biggest_input_buf：最大的输入缓冲区大小</li><li>used_memory：当前使用内存量</li><li>used_memory_peak：内存使用峰值</li><li>used_memory_overhead：维护消耗内存</li><li>maxmemory：允许使用最大内存</li><li>mem_fragmentation_ratio：内存碎片率</li><li>mem_replication_backlog：复制积压缓冲区大小</li><li>mem_clients_slaves：节点消耗内存量</li><li>mem_clients_normal：常规客户端消耗内存量</li><li>rdb_last_save_time：最近一次rdb持久化时间</li><li>rdb_last_bgsave_status：最近一次rdb持久化状态</li><li>rdb_last_bgsave_time_sec：最近一次rdb持久化消耗时间</li><li>rdb_last_cow_size：rdb持久化时cow消耗内存</li><li>total_connections_received：新创建连接数（取差值）</li><li>instantaneous_ops_per_sec：OPS</li><li>instantaneous_input_kbps：输入带宽</li><li>instantaneous_output_kbps：输出带宽</li><li>expired_keys：已过期的key（取差值）</li><li>evicted_keys：剔除的key（取差值）</li><li>keyspace_hits：命中数（取比例）</li><li>keyspace_misses：未命中数。（取比例）</li><li>connected_slaves：当前连接slave个数</li><li>master_repl_offset-second_repl_offset：主从延迟</li><li>Keyspace：各DBkey信息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文基于Redis最新unstable版本下，执行info命令后，返回的各项指标进行解释。并对其中需要特别注意的指标进行指出说明。&lt;br&gt;并会对阿里云info进行简单对比。区分阿里云对info进行了哪些方面的改造。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《向上管理的艺术》小结</title>
    <link href="http://yoursite.com/2020/04/19/new/other/%E3%80%8A%E7%BA%BF%E4%B8%8A%E7%AE%A1%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2020/04/19/new/other/《线上管理的艺术》小结/</id>
    <published>2020-04-19T12:53:03.000Z</published>
    <updated>2020-04-19T13:13:34.629Z</updated>
    
    <content type="html"><![CDATA[<p>20%的向上管理，决定了80%的工作效率和工作成果。</p><p>在之前的一篇博客<a href="https://omg-by.github.io/2020/01/05/new/other/%E5%90%AC%E3%80%8A%E5%B7%A5%E4%BD%9C%E4%B8%89%E5%B9%B4%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E3%80%8B%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">听《工作三年我学到了什么》总结</a>提到的音频中，讨论者推荐了《向上管理的艺术》这本书。于是便买了（我才不会告诉你是凑单），利用了一周的睡前时间把它给读完，在读的过程中，回想自己这一年半的工作经历，的确是在无意间触犯到了好几条禁忌行为。。。感谢领导的包容和支持。<br>利用周末空余时间将这本书做个简单的总结，尽量从自身层面优化。不仅是与领导沟通，在生活中也处处需要注意。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdz9w4eciyj31dv0u07g4.jpg" alt=""></p><p>一个人的汇报反馈机制，往往能影响到上司对你的态度和看法。上司也有自己的事要做，并不会时时刻刻的盯着你；<br>领导负责下发任务，如果没有反馈，那么他将无法掌控任务的进度，甚至最终因没有反馈而导致任务失败，则会大大降低领导对你的看法。<br>领导的经验摆在那，有很多在我们看来比较困难的事，也许领导几句话、一个想法、一个电话就能轻松的解决。<font color="red">领导在一定意义上，也是我们的资源</font>。</p><p>领导也是一个人，也会有各种各样的性格和情绪。<font color="red">如何在合适时机、选择合适方式才式获取到到正反馈信息？</font>这不仅仅跟领导反馈，在生活中，这也是一门需要时时需要注意的地方。<br>毕竟是有求于人，往往就是那么一个不经意的小点，导致了事情的失败，影响的只会是自己，徒增非常多的人力物力。</p><p><font color="red">多站在别人的角度上思考</font>，别人是怎么看待这件事，需要我做什么，希望我怎么做。才能以更好的姿势、更快的效率去做好一件事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;20%的向上管理，决定了80%的工作效率和工作成果。&lt;/p&gt;
&lt;p&gt;在之前的一篇博客&lt;a href=&quot;https://omg-by.github.io/2020/01/05/new/other/%E5%90%AC%E3%80%8A%E5%B7%A5%E4%BD%9C%E4%
      
    
    </summary>
    
      <category term="生活杂记" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis RDB文件存储格式</title>
    <link href="http://yoursite.com/2020/01/14/new/Redis/Redis-RDB%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/01/14/new/Redis/Redis-RDB文件存储格式/</id>
    <published>2020-01-14T12:13:30.000Z</published>
    <updated>2020-01-14T13:42:26.518Z</updated>
    
    <content type="html"><![CDATA[<p>Redis存在两种数据文件：RDB和AOF。<br>AOF文件的结构比较简单，就不做说明。主要是简介RDB数据文件的结构</p><p>*.rdb文件是表示Redis瞬间快照的一个二进制文件。根据这个快照文件，可以将Redis恢复到Redis当时的状态。<br>rdb文件针对读写进行了优化操作。尽可能的会使用LZF压缩算法来减少文件的大小。</p><p>在命令行下我们可以通过<code>od -x rdb.rdb | less</code>和<code>od -c rdb.rdb | less</code>命令查看16进制和字符模式下的rdb文件。<br>注意：使用<code>od -x</code>命令查出来的16进制是逆序的。</p><h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gan46keebgj30r806z3z8.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">----------------------------# RDB文件是二进制的，所以并不存在回车换行来分隔一行一行.</span><br><span class="line">52 45 44 49 53              # 以字符串 &quot;REDIS&quot; 开头</span><br><span class="line">30 30 30 36                 # RDB 的版本号，大端存储，比如左边这个表示版本号为0006</span><br><span class="line">----------------------------</span><br><span class="line">FE 00                       # FE = FE表示数据库编号，Redis支持多个库，以数字编号，这里00表示第0个数据库</span><br><span class="line">----------------------------# Key-Value 对存储开始了</span><br><span class="line">FD $length-encoding         # FD 表示过期时间，过期时间是用 length encoding 编码存储的，后面会讲到</span><br><span class="line">$value-type                 # 1 个字节用于表示value的类型，比如set,hash,list,zset等</span><br><span class="line">$string-encoded-key         # Key 值，通过string encoding 编码，同样后面会讲到</span><br><span class="line">$encoded-value              # Value值，根据不同的Value类型采用不同的编码方式</span><br><span class="line">----------------------------</span><br><span class="line">FC $length-encoding         # FC 表示毫秒级的过期时间，后面的具体时间用length encoding编码存储</span><br><span class="line">$value-type                 # 同上，也是一个字节的value类型</span><br><span class="line">$string-encoded-key         # 同样是以 string encoding 编码的 Key值</span><br><span class="line">$encoded-value              # 同样是以对应的数据类型编码的 Value 值</span><br><span class="line">----------------------------</span><br><span class="line">$value-type                 # 下面是没有过期时间设置的 Key-Value对，为防止冲突，数据类型不会以 FD, FC, FE, FF 开头</span><br><span class="line">$string-encoded-key</span><br><span class="line">$encoded-value</span><br><span class="line">----------------------------</span><br><span class="line">FE $length-encoding         # 下一个库开始，库的编号用 length encoding 编码</span><br><span class="line">----------------------------</span><br><span class="line">...                         # 继续存储这个数据库的 Key-Value 对</span><br><span class="line">FF                          ## FF：RDB文件结束的标志</span><br><span class="line">8 byte checksum             ## 8位校验码                  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">od -x rdb.rdb | head -n 10</span><br><span class="line">0000000 4552 4944 3053 3030 fe36 fc1e ae47 2160</span><br><span class="line">0000020 016e 0000 2800 6c65 7361 6974 5f63 3036</span><br><span class="line">0000040 3930 3562 6432 3139 3962 3233 3134 3138</span><br><span class="line">0000060 6338 3031 3338 6166 6233 3163 6264 5d4e</span><br><span class="line">0000100 8b1f 0008 0000 0000 ff00 9bcc 535b 595a</span><br><span class="line">0000120 c79b 66fb e7ae a42b 1db8 7585 7bde dea7</span><br><span class="line">0000140 a779 eb62 7264 3500 e931 2a1c 2165 116c</span><br><span class="line">0000160 6082 1838 27b5 1855 8b4d fb67 d18d 6344</span><br><span class="line">0000200 3a62 6231 51b7 6dd3 6247 bb50 9aac b9ab</span><br><span class="line">0000220 8f9c d610 7366 af95 b530 cd01 d906 8104</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">od -c rdb.rdb | head -n 10</span><br><span class="line">0000000   R   E   D   I   S   0   0   0   6 376 036 374   G 256   `   !</span><br><span class="line">0000020   n 001  \0  \0  \0   (   e   l   a   s   t   i   c   _   6   0</span><br><span class="line">0000040   0   9   b   5   2   d   9   1   b   9   3   2   4   1   8   1</span><br><span class="line">0000060   8   c   1   0   8   3   f   a   3   b   c   1   d   b   N   ]</span><br><span class="line">0000100 037 213  \b  \0  \0  \0  \0  \0  \0 377 314 233   [   S   Z   Y</span><br><span class="line">0000120 233 307 373   f 256 347   + 244 270 035 205   u 336   &#123; 247 336</span><br><span class="line">0000140   y 247   b 353   d   r  \0   5   1 351 034   *   e   !   l 021</span><br><span class="line">0000160 202   `   8 030 265   &apos;   U 030   M 213   g 373 215 321   D   c</span><br><span class="line">0000200   b   :   1   b 267   Q 323   m   G   b   P 273 254 232 253 271</span><br><span class="line">0000220 234 217 020 326   f   s 225 257   0 265 001 315 006 331 004 201</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>rdb文件固定以魔术字符串”REDIS”开头，表示这个rdb文件时Redis数据文件。<br><code>52 45 44 49 53 # &quot;REDIS&quot;</code></p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>接下来固定4个字节保存rdb格式的的版本号。<br><code>30 30 30 36 # Version = 6</code></p><h3 id="数据库编号"><a href="#数据库编号" class="headerlink" title="数据库编号"></a>数据库编号</h3><p>一个字节<code>0xfe</code>表示开始选择数据库；在这个字节之后，一个可变长度字段表示数据库编号。具体部分参考<b>长度编码</b>部分<br><code>1e</code>表示十进制的30，代表是30数据库</p><h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><p>在选择数据库后，就是具体的一些键值对记录。每个键值对包含4个部分</p><table><thead><tr><th>名称</th><th>大小</th><th>说明</th></tr></thead><tbody><tr><td>RDB_OPCODE_EXPIRETIME_MS</td><td>1byte</td><td>0xfc/0xfd(252/253)，说明是带过期时间的键值对</td></tr><tr><td>ms</td><td>8bytes</td><td>时间戳</td></tr><tr><td>TYPE</td><td>1byte</td><td>键值对类型</td></tr><tr><td>key</td><td>—-</td><td>键</td></tr><tr><td>value</td><td>—-</td><td>值</td></tr></tbody></table><h4 id="过期标记和过期时间戳"><a href="#过期标记和过期时间戳" class="headerlink" title="过期标记和过期时间戳"></a>过期标记和过期时间戳</h4><p>一个字节。<code>0xFD</code>表示过期时间戳以秒为单位，<code>0xFC</code>表示过期时间戳以毫秒为单位。<br>如果设置了过期时间，那么接下来的8个字节就表示具体的过期时间。<br>在导入RDB文件的时候，会将已经过期的key进行丢弃。</p><p>如果没有设置过期时间，则没有这两个字段。</p><h4 id="key类型"><a href="#key类型" class="headerlink" title="key类型"></a>key类型</h4><p>一个字节，表示保存键值对value的具体编码。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gan531wxo8j30ly0dqt9u.jpg" alt=""></p><ul><li>0表示是一个简单字符串</li><li>当值为9-13时，该值被包装到字符串中，读取字符串后，会对其进行进一步解析。</li><li>当值为1-4时，该值是一个字符串序列，此字符串序列用于构造列表、集合、集合或哈希表等复杂数据类型。</li></ul><h4 id="键值对-1"><a href="#键值对-1" class="headerlink" title="键值对"></a>键值对</h4><p>key固定为字符串编码保存。<br>value取决于编码，不同的编码有不同的保存格式。<br>后面会有详细介绍。</p><h2 id="长度编码"><a href="#长度编码" class="headerlink" title="长度编码"></a>长度编码</h2><p>长度编码用于存储下一个对象的长度，长度编码是一种可变长字节编码，目的在于使用更少的字节来表示内容。<br>从数据流中取出一个字节，前面两个bit可能存在以下几种情况：</p><ul><li>00：接下来6位表示长度</li><li>01：取出下一个字节，组合的14位表示长度</li><li>10：剩余6位舍弃，取出4个字节表示长度</li><li>11：表示下一个对象以特殊格式编码。其余6位表示格式。</li></ul><p>63的数字只需要一个字节进行存储<br>64 – 16383 的数字只需要两个字节进行存储<br>16383 - 2^32 -1 的数字只需要用5个字节（1个字节的标识加4个字节的值）进行存储</p><h2 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h2><p>Redis字符串是二进制安全的，这意味着可以在其中存储任何内容。它没有任何特殊的字符串结尾标记。最好将Redis字符串视为字节数组。</p><p>在RDB文件中有三种类型的字符串：</p><ol><li>简单字符串</li><li>8、16、32位的整数</li><li>一个经过LZF压缩的支付串</li></ol><h3 id="简单字符串"><a href="#简单字符串" class="headerlink" title="简单字符串"></a>简单字符串</h3><p>简单字符串编码非常简单，就是 字符串长度+具体的字符串<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ganb8w8bbzj31is03g74g.jpg" alt=""></p><h3 id="整数字符串"><a href="#整数字符串" class="headerlink" title="整数字符串"></a>整数字符串</h3><p>在长度编码为<code>11</code>的时候，读取后续的6位。如果后续的6位为：</p><ul><li>0表示跟随的是8位整数</li><li>1表示跟随的是16位整数</li><li>2表示跟随的是32位整数</li></ul><h3 id="压缩字符串"><a href="#压缩字符串" class="headerlink" title="压缩字符串"></a>压缩字符串</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ganbdubpn0j31i603mwey.jpg" alt=""><br>在长度编码为<code>11</code>的时候，读取后续的6位。如果后续的6位为<code>3</code>表示后面跟随着的是压缩字符串。具体步骤为下：</p><ol><li>使用长度编码方式从c_len中读取出压缩的长度</li><li>使用长度编码方式从o_len中读取出压缩前的长度</li><li>读取出压缩后的字符串</li><li>使用LZF算法解压缩</li></ol><h3 id="List编码和Set编码"><a href="#List编码和Set编码" class="headerlink" title="List编码和Set编码"></a>List编码和Set编码</h3><p>一个Redis list表示为一序列字符串</p><ol><li>首先，从流中读取list的大小，按照长度编码的方式读取出<code>size</code>大小值。</li><li>按照字符串编码方式从流中读取出size个字符串</li><li>使用这些字符串重新构建list</li></ol><h3 id="Hash编码"><a href="#Hash编码" class="headerlink" title="Hash编码"></a>Hash编码</h3><ol><li>从流中按照长度编码的方式读取出hash表的大小size</li><li>从流中按照字符串编码方式读取出2*size个字符串对象</li><li>键值对交替出现</li></ol><h3 id="Ziplist编码"><a href="#Ziplist编码" class="headerlink" title="Ziplist编码"></a>Ziplist编码</h3><p>一个Ziplist编码本质上是一个list类型的字符串，借助于标记(flag)和偏移量(offset)来达到双向遍历。<br>为解析一个ziplist，首先从流中按照字符串编码读取一个字符串，这个字符串就是ziplist的封装。<br>结构如下：</p><ol><li>zlbytes ：这是一个 4 字节无符号整数，表示 ziplist 的总字节数。这 4 字节是 little endian 格式－－最先出现的是最低有效位组</li><li>zltail：这是一个 4 字节无符号整数，little endian 格式。它表示到 ziplist 的尾条目（tail entry）的偏移。</li><li>zllen：这是一个 2 字节无符号整数，little endian 格式。它表示 ziplist 的条目的数量</li><li>entry：一个条目表示 ziplist 的元素。细节在下面</li><li>zlend：总是等于 255。它表示 ziplist 的结束</li></ol><p>ziplist的每个entry都是以下这样的格式： <code>&lt;length-prev-entry&gt;&lt;special-flag&gt;&lt;raw-bytes-of-entry&gt;</code><br>具体参考Redis中ziplist的实现方式。</p><h2 id="CRC校验和"><a href="#CRC校验和" class="headerlink" title="CRC校验和"></a>CRC校验和</h2><p>从Redis5开始启动参数控制是否将8字节的校验和添加到文件末尾，可以通过修改参数关闭该功能。<br>当禁用校验和的时候，此字段为0</p><blockquote><p><a href="https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_File_Format.textile" target="_blank" rel="noopener">https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_File_Format.textile</a><br><a href="https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_Version_History.textile" target="_blank" rel="noopener">https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_Version_History.textile</a><br><a href="https://github.com/wen866595/open-doc/blob/master/redis-doc/Redis-RDB-Dump-File-Format-cn.md" target="_blank" rel="noopener">https://github.com/wen866595/open-doc/blob/master/redis-doc/Redis-RDB-Dump-File-Format-cn.md</a><br><a href="https://blog.csdn.net/guiqulaxi920/article/details/51177307" target="_blank" rel="noopener">https://blog.csdn.net/guiqulaxi920/article/details/51177307</a><br><a href="http://ascii.911cha.com/" target="_blank" rel="noopener">http://ascii.911cha.com/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis存在两种数据文件：RDB和AOF。&lt;br&gt;AOF文件的结构比较简单，就不做说明。主要是简介RDB数据文件的结构&lt;/p&gt;
&lt;p&gt;*.rdb文件是表示Redis瞬间快照的一个二进制文件。根据这个快照文件，可以将Redis恢复到Redis当时的状态。&lt;br&gt;rdb文件针对读写进行了优化操作。尽可能的会使用LZF压缩算法来减少文件的大小。&lt;/p&gt;
&lt;p&gt;在命令行下我们可以通过&lt;code&gt;od -x rdb.rdb | less&lt;/code&gt;和&lt;code&gt;od -c rdb.rdb | less&lt;/code&gt;命令查看16进制和字符模式下的rdb文件。&lt;br&gt;注意：使用&lt;code&gt;od -x&lt;/code&gt;命令查出来的16进制是逆序的。&lt;/p&gt;
&lt;h2 id=&quot;RDB文件结构&quot;&gt;&lt;a href=&quot;#RDB文件结构&quot; class=&quot;headerlink&quot; title=&quot;RDB文件结构&quot;&gt;&lt;/a&gt;RDB文件结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gan46keebgj30r806z3z8.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;----------------------------# RDB文件是二进制的，所以并不存在回车换行来分隔一行一行.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52 45 44 49 53              # 以字符串 &amp;quot;REDIS&amp;quot; 开头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30 30 30 36                 # RDB 的版本号，大端存储，比如左边这个表示版本号为0006&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FE 00                       # FE = FE表示数据库编号，Redis支持多个库，以数字编号，这里00表示第0个数据库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------# Key-Value 对存储开始了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FD $length-encoding         # FD 表示过期时间，过期时间是用 length encoding 编码存储的，后面会讲到&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$value-type                 # 1 个字节用于表示value的类型，比如set,hash,list,zset等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$string-encoded-key         # Key 值，通过string encoding 编码，同样后面会讲到&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$encoded-value              # Value值，根据不同的Value类型采用不同的编码方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FC $length-encoding         # FC 表示毫秒级的过期时间，后面的具体时间用length encoding编码存储&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$value-type                 # 同上，也是一个字节的value类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$string-encoded-key         # 同样是以 string encoding 编码的 Key值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$encoded-value              # 同样是以对应的数据类型编码的 Value 值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$value-type                 # 下面是没有过期时间设置的 Key-Value对，为防止冲突，数据类型不会以 FD, FC, FE, FF 开头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$string-encoded-key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$encoded-value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FE $length-encoding         # 下一个库开始，库的编号用 length encoding 编码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...                         # 继续存储这个数据库的 Key-Value 对&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FF                          ## FF：RDB文件结束的标志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8 byte checksum             ## 8位校验码                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;od -x rdb.rdb | head -n 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000000 4552 4944 3053 3030 fe36 fc1e ae47 2160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000020 016e 0000 2800 6c65 7361 6974 5f63 3036&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000040 3930 3562 6432 3139 3962 3233 3134 3138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000060 6338 3031 3338 6166 6233 3163 6264 5d4e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000100 8b1f 0008 0000 0000 ff00 9bcc 535b 595a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000120 c79b 66fb e7ae a42b 1db8 7585 7bde dea7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000140 a779 eb62 7264 3500 e931 2a1c 2165 116c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000160 6082 1838 27b5 1855 8b4d fb67 d18d 6344&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000200 3a62 6231 51b7 6dd3 6247 bb50 9aac b9ab&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000220 8f9c d610 7366 af95 b530 cd01 d906 8104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;od -c rdb.rdb | head -n 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000000   R   E   D   I   S   0   0   0   6 376 036 374   G 256   `   !&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000020   n 001  \0  \0  \0   (   e   l   a   s   t   i   c   _   6   0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000040   0   9   b   5   2   d   9   1   b   9   3   2   4   1   8   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000060   8   c   1   0   8   3   f   a   3   b   c   1   d   b   N   ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000100 037 213  \b  \0  \0  \0  \0  \0  \0 377 314 233   [   S   Z   Y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000120 233 307 373   f 256 347   + 244 270 035 205   u 336   &amp;#123; 247 336&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000140   y 247   b 353   d   r  \0   5   1 351 034   *   e   !   l 021&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000160 202   `   8 030 265   &amp;apos;   U 030   M 213   g 373 215 321   D   c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000200   b   :   1   b 267   Q 323   m   G   b   P 273 254 232 253 271&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000220 234 217 020 326   f   s 225 257   0 265 001 315 006 331 004 201&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>pika学习之同步篇</title>
    <link href="http://yoursite.com/2020/01/05/new/pika/pika%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/01/05/new/pika/pika复制模块/</id>
    <published>2020-01-05T14:08:29.000Z</published>
    <updated>2020-01-05T14:11:12.720Z</updated>
    
    <content type="html"><![CDATA[<ul><li>pika支持m-s的复制方式，跟redis主从复制命令一样，通过slave执行slaveof命令来触发。</li><li>slave的trysync线程向master发起trysync，同时将同步位点信息发送给master</li><li>master处理trysync命令，发起对slave的同步过程，从同步点开始顺序发送binlog或进行全同步</li></ul><h1 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h1><p>pika在需要进行全量同步的时候，会将数据文件进行dump后通过rsync的deamon模式发送给slave。</p><h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><ol><li>slave在trysnc前启动rsync进程启动rsync服务</li><li>master发现需要全同步时，判断是否有备份文件可用，如果没有先dump一份</li><li>master通过rsync向slave发送dump出的文件</li><li>slave用收到的文件替换自己的db</li><li>slave用最新的偏移量再次发起trysnc</li><li>完成同步 </li></ol><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0g8e1iij30oq09q0th.jpg" alt=""></p><center>slave同步流程</center><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0gae0huj30me08qt99.jpg" alt=""></p><center>master同步流程</center><a id="more"></a><p>slave连接状态：</p><ul><li>No Connect：不尝试成为任何其他节点的slave</li><li>Connect：Slaveof后尝试成为某个节点的slave，发送trysnc命令和同步点</li><li>Connecting：收到master回复可以slaveof，尝试跟master建立心跳</li><li>Connected: 心跳建立成功</li><li>WaitSync：不断检测是否DBSync完成，完成后更新DB并发起新的slaveof<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0h9q8ulj30hn0dr0tm.jpg" alt=""></li></ul><h1 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h1><p>Pika的主从同步是通过Binlog来完成的，在一主多从的结构中，master节点也可以给多个slave复用一个Binlog，不同的slave拥有不同的偏移量。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><ol><li>当WorkerThread接收到客户端的命令，按照执行顺序，添加到Binlog里</li><li>BinglogSenderThread判断它所负责的从节点在主节点的Binlog里是否有需要同步的命令，若有则发送给从节点</li><li>BinglogReceiverModule模块则做以下三件事情：接收主节点的BinlogSenderThread发送过来的同步命令；把接收到的命令应用到本地的数据上；把接收到的命令添加到本地Binlog里 至此，一条命令从主节点到从节点的同步过程完成<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0spmbugj30i20en75l.jpg" alt=""></li></ol><ul><li>WorkerThread：接受和处理用户的命令</li><li>BinlogSenderThread：负责顺序地向对应的从节点发送在需要同步的命令</li><li>BinlogReceiverModule: 负责接受主节点发送过来的同步命令</li><li>Binglog：用于顺序的记录需要同步的命令</li></ul><p>上图中的<code>BinLogReceiverModule</code>是为了更好的说明方便而抽象出来的一个对象，从图中可以看出<code>BinLogReceiverModule</code>是由一个<code>BinlogReceiverThread</code>和多个<code>BinlogBGWorker</code>组成。</p><ul><li>BinlogReceiverThread: 负责接受由主节点传送过来的命令，并分发给各个BinlogBGWorker，若当前的节点是只读状态（不能接受客户端的同步命令），则在这个阶段写Binlog</li><li>BinlogBGWorker：负责执行同步命令；若该节点不是只读状态（还能接受客户端的同步命令），则在这个阶段写Binlog（在命令执行之前写）</li></ul><p>BinlogReceiverThread接收到一个同步命令后，它会给这个命令赋予一个唯一的序列号（这个序列号是递增的），并把它分发给一个BinlogBGWorker；而各个BinlogBGWorker则会根据各个命令的所对应的序列号的顺序来执行各个命令，这样也就保证了命令执行的顺序和主节点执行的顺序一致了 之所以这么设计主要原因是：</p><ol><li>配备多个BinlogBGWorker是可以提高主从同步的效率，减少主从同步的滞后延迟</li><li>BinlogBGWorker在执行执行之前写Binlog可以提高命令执行的并行度</li><li>在当前节点是非只读状态，让BinglogReceiverThread来写Binlog，是为了让Binglog里保存的命令顺序和命令的执行顺序保持一致</li></ol><h2 id="Binlog结构"><a href="#Binlog结构" class="headerlink" title="Binlog结构"></a>Binlog结构</h2><p>由于主从偏移量一样，所以一旦发生网络或节点故障需要重连主从时，slave只需要将当前的偏移量发送给master，master找到后从该偏移量开始同步后续命令。<br>理论上命令不做处理一条一条追加到Binlog文件中，这也就意味着如果文件写错一个字节就会导致整个文件不可用，所以pika采用了类似leveldb log的格式来进行存储。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0rxhp2rj30i20att9m.jpg" alt=""></p><h3 id="leveldb-log"><a href="#leveldb-log" class="headerlink" title="leveldb log"></a>leveldb log</h3><p>在leveldb中，所有的写操作都必须先成功的append到操作日志中，然后再更新内存memtable</p><ol><li>可以将随机的写IO变成append，极大的提高写磁盘速度</li><li>防止在节点down机导致内存数据丢失，造成数据丢失<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">The log file contents are a sequence of 32KB blocks.  The only</span><br><span class="line">exception is that the tail of the file may contain a partial block.</span><br><span class="line"></span><br><span class="line">Each block consists of a sequence of records:</span><br><span class="line">   block := record* trailer?</span><br><span class="line">   record :=</span><br><span class="line">    checksum: uint32    // crc32c of type and data[] ; little-endian</span><br><span class="line">    length: uint16      // little-endian</span><br><span class="line">    type: uint8     // One of FULL, FIRST, MIDDLE, LAST</span><br><span class="line">    data: uint8[length]</span><br><span class="line"></span><br><span class="line">A record never starts within the last six bytes of a block (since it</span><br><span class="line">won&apos;t fit).  Any leftover bytes here form the trailer, which must</span><br><span class="line">consist entirely of zero bytes and must be skipped by readers.</span><br></pre></td></tr></table></figure></li></ol><p>日志文件由连续的大小为32KB的block组成，block又由连续的record组成，record的格式为 | CRC(4 byte) | Length(2 byte) | type(1 byte) | data |</p><blockquote><p><a href="https://www.jianshu.com/p/223f0c73ddc2" target="_blank" rel="noopener">LevelDB 功能与架构</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;pika支持m-s的复制方式，跟redis主从复制命令一样，通过slave执行slaveof命令来触发。&lt;/li&gt;
&lt;li&gt;slave的trysync线程向master发起trysync，同时将同步位点信息发送给master&lt;/li&gt;
&lt;li&gt;master处理trysync命令，发起对slave的同步过程，从同步点开始顺序发送binlog或进行全同步&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;全量同步&quot;&gt;&lt;a href=&quot;#全量同步&quot; class=&quot;headerlink&quot; title=&quot;全量同步&quot;&gt;&lt;/a&gt;全量同步&lt;/h1&gt;&lt;p&gt;pika在需要进行全量同步的时候，会将数据文件进行dump后通过rsync的deamon模式发送给slave。&lt;/p&gt;
&lt;h2 id=&quot;实现逻辑&quot;&gt;&lt;a href=&quot;#实现逻辑&quot; class=&quot;headerlink&quot; title=&quot;实现逻辑&quot;&gt;&lt;/a&gt;实现逻辑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;slave在trysnc前启动rsync进程启动rsync服务&lt;/li&gt;
&lt;li&gt;master发现需要全同步时，判断是否有备份文件可用，如果没有先dump一份&lt;/li&gt;
&lt;li&gt;master通过rsync向slave发送dump出的文件&lt;/li&gt;
&lt;li&gt;slave用收到的文件替换自己的db&lt;/li&gt;
&lt;li&gt;slave用最新的偏移量再次发起trysnc&lt;/li&gt;
&lt;li&gt;完成同步 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gam0g8e1iij30oq09q0th.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;slave同步流程&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gam0gae0huj30me08qt99.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;master同步流程&lt;/center&gt;
    
    </summary>
    
      <category term="Pika" scheme="http://yoursite.com/categories/Pika/"/>
    
    
      <category term="Pika" scheme="http://yoursite.com/tags/Pika/"/>
    
  </entry>
  
  <entry>
    <title>何为IO多路复用</title>
    <link href="http://yoursite.com/2020/01/05/new/Redis/%E4%BD%95%E4%B8%BAIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://yoursite.com/2020/01/05/new/Redis/何为IO多路复用/</id>
    <published>2020-01-05T08:29:22.000Z</published>
    <updated>2020-01-05T08:32:32.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络编程概念"><a href="#网络编程概念" class="headerlink" title="网络编程概念"></a>网络编程概念</h2><p>在网络当中，数据的传输是基于HTTP/TCP协议簇来实现的。TCP协议仅仅是把这些数据看做是一串二进制流来进行处理。<br>所以：<b>客户端和服务器是通过在建立的连接上发送字节流来进行通信</b></p><p>一个连接由它两端的套接字地址唯一确定，结构为<code>(客户端地址:客户端端口号，服务端地址:服务端端口号)</code>。有了通信双方的连接地址信息后，就可以进行数据传输了。</p><p>在Unix系统中，实现了一套套接字接口来描述和规范双方通信的整个过程。<br>创建-&gt;连接-&gt;绑定-&gt;监听-&gt;响应<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1galrpl667mj30hs0dzwfp.jpg" alt=""></p><blockquote><ul><li>socket()：创建一个套接字描述符</li><li>connect()：客户端通过调用connect函数来建立和服务器的连接</li><li>bind()：告诉内核将socket()创建的套接字与某个服务端地址与端口连接起来，后续会对这个地址和端口进行监听</li><li>listen()：告诉内核，将这个套接字当成服务器这种被动实体来看待(服务器是等待客户端连接的被动实体，而内核认为socket()创建的套接字默认是主动实体，所以才需要listen()函数，告诉内核进行主动到被动实体的转换)</li><li>accept()：等待客户端的连接请求并返回一个新的已连接描述符</li></ul></blockquote><a id="more"></a><h2 id="最简单的单进程服务器"><a href="#最简单的单进程服务器" class="headerlink" title="最简单的单进程服务器"></a>最简单的单进程服务器</h2><p>由于Unix的历史遗留问题，原始的套接字接口对地址和端口等数据封装并不简洁。<br>在最初的服务器中，一个服务器进程只能同时处理一个客户端连接与相关的读写操作。<br>在读写的过程中，整个进程被该客户端独占，当前服务器进程只能处理该客户端连接的读写操作，无法对其他客户端连接请求进行处理。</p><h2 id="IO并发提升"><a href="#IO并发提升" class="headerlink" title="IO并发提升"></a>IO并发提升</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>如果去优化单进程？<br>一个进程不行，那就搞多个进程来同时处理不就得了。</p><p>由于一个客户端的connect对应着一个服务端的accept，那么每次客户端过来时，都使用fork()来进行accept的系统调用。</p><p>缺点：</p><ul><li>进程创建的数量随连接请求的增加而增加。</li><li>fork等系统调用会使得进程的上下文进行切换，效率很低。</li><li>进程与进程之间的地址空间私有。使得进程之间的数据共享比较困难。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>线程是运行在进程上下文的逻辑流。一个进程可以包含多个线程，多个线程运行在单一的进程上下文中，因此共享这个进程的地址空间的所有内容，解决了进程与进程之间通信难的问题。同时，由于一个线程的上下文要比一个进程的上下文小得多，所以线程的上下文切换，要比进程的上下文切换效率高得多。线程是轻量级的进程，解决了进程上下文切换效率低的问题。</p><h3 id="基于单进程的IO多路复用"><a href="#基于单进程的IO多路复用" class="headerlink" title="基于单进程的IO多路复用"></a>基于单进程的IO多路复用</h3><p>前面谈到的都是通过增加进程和线程的数量来同时处理多个套接字。而IO多路复用只需要一个进程就能够处理多个套接字。</p><p>其本质是：<b>一个服务端进程可以同时处理多个套接字描述符</b></p><p>在之前的讲述中，一个服务端进程，只能同时处理一个连接。如果想同时处理多个客户端连接，需要多进程或者多线程的帮助，免不了上下文切换的开销。IO多路复用技术就解决了上下文切换的问题。IO多路复用技术的发展可以分为select-&gt;poll-&gt;epoll三个阶段。</p><p>IO多路复用的核心就是添加了一个<b>套接字集合管理员</b>，它可以同时监听多个套接字。由于客户端连接以及读写事件到来的随机性，我们需要这个管理员在单进程内部对多个套接字的事件进行合理的调度。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select()函数会在某个或某些套接字的状态从不可读变为可读、或不可写变为可写的时候通知服务器主进程。所以select()本身的调用是阻塞的。但是具体哪一个套接字或哪些套接字变为可读或可写我们是不知道的，所以我们需要遍历所有select()返回的套接字来判断哪些套接字可以进行处理了。</p><p>但是，select()函数本身的调用阻塞的。因为select()需要一直等到有状态变化的套接字之后（比如监听套接字或者连接套接字的状态由不可读变为可读），才能解除select()本身的阻塞，继续对读写就绪的套接字进行处理。虽然这里是阻塞的，但是它能够同时返回多个就绪的套接字，而不是之前单进程中只能够处理一个套接字，大大提升了效率</p><p>优点：</p><ul><li>实现了对多个套接字的同时、集中管理</li><li>通过遍历所有的套接字集合，能够获取所有已就绪的套接字，对这些就绪的套接字进行操作不会阻塞</li></ul><p>缺点：</p><ul><li>select管理的套接字描述符们存在数量限制。在Unix中，一个进程最多同时监听1024个套接字描述符</li><li>select返回的时候，并不知道具体是哪个套接字描述符已经就绪，所以需要遍历所有套接字来判断哪个已经就绪，可以继续进行读写</li></ul><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><b>poll解决了select带来的套接字描述符的最大数量限制问题</b></p><p>poll的fds参数集合了select的read、write和exception套接字数组，合三为一。poll中的fds没有了1024个的数量限制。当有些描述符状态发生变化并就绪之后，poll同select一样会返回。但是遗憾的是，我们同样不知道具体是哪个或哪些套接字已经就绪，我们仍需要遍历套接字集合去判断究竟是哪个套接字已经就绪，这一点并没有解决刚才提到select的第二个问题。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是最先进的套接字管理员，解决了上述select和poll中所存在的问题。它将一个阻塞的select、poll系统调用拆分成了三个步骤。一次select或poll可以看作是由一次 epoll_create、若干次 epoll_ctl、若干次 epoll_wait构成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure></p><ul><li>epoll_create()：创建一个epoll实例。后续操作会使用</li><li>epoll_ctl()：对套接字描述符集合进行增删改操作，并告诉内核需要监听套接字描述符的什么事件</li><li>epoll_wait()：等待监听列表中的连接事件（监听套接字描述符才会发生）或读写事件（连接套接字描述符才会发生）。如果有某个或某些套接字事件已经准备就绪，就会返回这些已就绪的套接字们</li></ul><p>我们调用epoll_wait()等待连接或读写等事件，在某个套接字描述符上准备就绪。当有事件准备就绪之后，会存到第二个参数epoll_event结构体中。通过访问这个结构体就可以得到所有已经准备好事件的套接字描述符。这里就不用再像之前select和poll那样，遍历所有的套接字描述符之后才能知道究竟是哪个描述符已经准备就绪了，这样减少了一次O(n)的遍历，大大提高了效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络编程概念&quot;&gt;&lt;a href=&quot;#网络编程概念&quot; class=&quot;headerlink&quot; title=&quot;网络编程概念&quot;&gt;&lt;/a&gt;网络编程概念&lt;/h2&gt;&lt;p&gt;在网络当中，数据的传输是基于HTTP/TCP协议簇来实现的。TCP协议仅仅是把这些数据看做是一串二进制流来进行处理。&lt;br&gt;所以：&lt;b&gt;客户端和服务器是通过在建立的连接上发送字节流来进行通信&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;一个连接由它两端的套接字地址唯一确定，结构为&lt;code&gt;(客户端地址:客户端端口号，服务端地址:服务端端口号)&lt;/code&gt;。有了通信双方的连接地址信息后，就可以进行数据传输了。&lt;/p&gt;
&lt;p&gt;在Unix系统中，实现了一套套接字接口来描述和规范双方通信的整个过程。&lt;br&gt;创建-&amp;gt;连接-&amp;gt;绑定-&amp;gt;监听-&amp;gt;响应&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1galrpl667mj30hs0dzwfp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;socket()：创建一个套接字描述符&lt;/li&gt;
&lt;li&gt;connect()：客户端通过调用connect函数来建立和服务器的连接&lt;/li&gt;
&lt;li&gt;bind()：告诉内核将socket()创建的套接字与某个服务端地址与端口连接起来，后续会对这个地址和端口进行监听&lt;/li&gt;
&lt;li&gt;listen()：告诉内核，将这个套接字当成服务器这种被动实体来看待(服务器是等待客户端连接的被动实体，而内核认为socket()创建的套接字默认是主动实体，所以才需要listen()函数，告诉内核进行主动到被动实体的转换)&lt;/li&gt;
&lt;li&gt;accept()：等待客户端的连接请求并返回一个新的已连接描述符&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>提问的智慧</title>
    <link href="http://yoursite.com/2020/01/05/new/other/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/"/>
    <id>http://yoursite.com/2020/01/05/new/other/提问的智慧/</id>
    <published>2020-01-05T05:40:58.000Z</published>
    <updated>2020-01-05T05:46:49.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在你提问之前"><a href="#在你提问之前" class="headerlink" title="在你提问之前"></a>在你提问之前</h1><ul><li>尝试在你准备提问的论坛的旧文章中搜索答案</li><li>尝试上网搜索以找到答案</li><li>尝试阅读手册以找到答案</li><li>尝试阅读常见问题文件（FAQ）以找到答案</li><li>尝试自己检查或试验以找到答案</li><li>向你身边的强者朋友打听以找到答案</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案</li></ul><h1 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h1><ul><li>慎选提问的论坛</li><li>Stack Overflow</li><li>网站和 IRC 论坛</li><li>第二步，使用项目邮件列表</li><li>使用有意义且描述明确的标题</li><li>使问题容易回复</li><li>用清晰、正确、精准并合法语法的语句</li><li>使用易于读取且标准的文件格式发送问题</li><li>精确地描述问题并言之有物</li><li>话不在多而在精</li><li>别动辄声称找到 Bug</li><li>低声下气不能代替你的功课</li><li>描述问题症状而非你的猜测</li><li>按发生时间先后列出问题症状</li><li>描述目标而不是过程</li><li>别要求使用私人电邮回复</li><li>清楚明确的表达你的问题以及需求</li><li>询问有关代码的问题时</li><li>别把自己家庭作业的问题贴上来</li><li>去掉无意义的提问句</li><li>即使你很急也不要在标题写紧急</li><li>礼多人不怪，而且有时还很有帮助</li><li>问题解决后，加个简短的补充说明</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1galmxel3nqj30u00vk43j.jpg" alt=""></p><blockquote><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener">原文地址</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在你提问之前&quot;&gt;&lt;a href=&quot;#在你提问之前&quot; class=&quot;headerlink&quot; title=&quot;在你提问之前&quot;&gt;&lt;/a&gt;在你提问之前&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;尝试在你准备提问的论坛的旧文章中搜索答案&lt;/li&gt;
&lt;li&gt;尝试上网搜索以找到答案&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="生活杂记" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>听《工作三年我学到了什么》总结</title>
    <link href="http://yoursite.com/2020/01/05/new/other/%E5%90%AC%E3%80%8A%E5%B7%A5%E4%BD%9C%E4%B8%89%E5%B9%B4%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/05/new/other/听《工作三年我学到了什么》总结/</id>
    <published>2020-01-04T16:53:03.000Z</published>
    <updated>2020-01-04T16:54:59.543Z</updated>
    
    <content type="html"><![CDATA[<p>最近听到一篇文章，觉得其中很多的点给了我很多收获。所以反复听了很多遍，并做了大概的总结。关键词：沟通、尝试、上升、思考、落地。</p><ul><li>不要把自己局限于某一个位置，试着多尝试不同的东西，“管理”好自己,“管理”好身边的人。</li><li>你的技术能力决定了你能多快去完成目标。而你的非技术能力决定了你在朝哪个方向努力。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakzw4xmkcj30u00ubn5h.jpg" alt=""></p><a id="more"></a><p>总的来说，就是站在不同角色的角度来看待事情，思他人之所思。(领导、依赖人、客户、被求助者、被依赖人)</p><h2 id="向上管理"><a href="#向上管理" class="headerlink" title="向上管理"></a>向上管理</h2><p>在工作当中，我们经常都是领导分配什么任务，我们就去努力完成任务。<br>而没有去思考这个任务到底能不能胜任，有没有更适合去做这个任务的人，以及更适合自己的任务却被分配给了其他的人。<br><b>领导是一个统筹管理的角色</b>，他大多时候只会关注总体任务是否完成。而没在意谁完成，怎么完成。</p><p><font color="red">我们应该站在领导的角度上去思考整个项目任务</font>当我们遇到不合理任务时，及时表达自己的想法和看法，看是否存在更好解决方案。<br>一个适合自己的任务，不仅能够节省大量完成任务的时间，还能保证完成的质量。</p><p>当然，在更多时候人手并不是很充足，所以并不是说一味的去拒绝任务；完成任务仍然是第一优先级，只有在完成任务的基础上，才能去发表和实现自己的想法。</p><h2 id="沟通先行"><a href="#沟通先行" class="headerlink" title="沟通先行"></a>沟通先行</h2><p>在整个项目流程当中，我们会遇到很多依赖别人的点。我们尽量在到达这个点之间就提前跟相关依赖人沟通，确定资源，而不是在需要的时候才去申请资源。</p><h2 id="高效会议"><a href="#高效会议" class="headerlink" title="高效会议"></a>高效会议</h2><p>在参加会议前，我们需要明确自己在其中的角色、需要了解、表达的东西。明确需要沟通的相关人员及其负责部分。<br>在会议当中，我们需要准确的提出自己的问题以及看法，避免形成沟通黑洞。<br>会议之后，需要及时记录会议记录，避免忘记。不同紧急程度的任务可以采用不同的方式去联系相关人员。</p><h2 id="上升意识"><a href="#上升意识" class="headerlink" title="上升意识"></a>上升意识</h2><p>不要将自己的角色给限制死，需要时常的跳出去，从不同的维度发展自己。不断的去尝试边界，并尝试突破。<br>主动的去发现项目的风险点、改进点。多从其他人手中争取锻炼自己的机会。</p><blockquote><p><a href="https://pythonhunter.org/episodes/sp02" target="_blank" rel="noopener">原文：https://pythonhunter.org/episodes/sp02</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近听到一篇文章，觉得其中很多的点给了我很多收获。所以反复听了很多遍，并做了大概的总结。关键词：沟通、尝试、上升、思考、落地。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要把自己局限于某一个位置，试着多尝试不同的东西，“管理”好自己,“管理”好身边的人。&lt;/li&gt;
&lt;li&gt;你的技术能力决定了你能多快去完成目标。而你的非技术能力决定了你在朝哪个方向努力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gakzw4xmkcj30u00ubn5h.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活杂记" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JB全家桶激活教程</title>
    <link href="http://yoursite.com/2020/01/04/new/other/JB%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/01/04/new/other/JB全家桶激活教程/</id>
    <published>2020-01-04T04:31:38.000Z</published>
    <updated>2020-01-04T04:32:26.238Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本教程适用于jetbrains全家桶开发工具（Pycharm、Idea、WebStorm、phpstorm、CLion、RubyMine、AppCode、DataGrid）</li><li>本教程适用于所有版本</li><li>软件直接从官网下载即可</li><li>不需要修改host</li></ul><h2 id="激活教程"><a href="#激活教程" class="headerlink" title="激活教程"></a>激活教程</h2><h3 id="1-下载破解补丁"><a href="#1-下载破解补丁" class="headerlink" title="1. 下载破解补丁"></a>1. 下载破解补丁</h3><p>下载补丁文件：<a href="https://pan.baidu.com/s/1Kc-byjcH_pvrN4CTgfKSFA" target="_blank" rel="noopener">jetbrains-agent.jar</a><br>文件保存位置可以任意，建议放置到软件安装路径的bin目录下。避免误删文件。</p><a id="more"></a><h3 id="2-点击试用"><a href="#2-点击试用" class="headerlink" title="2. 点击试用"></a>2. 点击试用</h3><p>如果你是刚下载的IDEA，则需要点击激活窗口的“Evaluate for free”免费试用，然后再创建一个空项目，这样就可以进入到IDEA的工作页面<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaketkrmc0j30su0aigmp.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeuydlulj30zw0u0ahk.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakev1f4tcj314a0qojty.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakev6d8cxj314a0qo0ux.jpg" alt=""></p><h3 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3. 修改配置文件"></a>3. 修改配置文件</h3><p><font color="red"> 配置文件修改已经不在bin目录下直接修改，而是通过IDEA修改</font><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakexpa10mj31100qs0uc.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakextkszmj31c60u0jvx.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakexxczvlj31c60u076b.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeyew4ilj31c60u0tb5.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeyicahmj31hc0sktcn.jpg" alt=""></p><p>进入到项目界面后，点击IDEA最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options …”<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeyw6muqj31gf0u0n2b.jpg" alt=""></p><p>如果提示是否要创建文件，请点”Yes”。</p><p>在打开的vmoptions编辑窗口末行添加：<font color="red"> -javaagent:你IDEA的安装目录\jetbrains-agent.jar</font> 请仔细检查补丁路径是否正确，如果错误则会出现IDEA打不开的情况。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakezxp1tij31hc0tsq8e.jpg" alt=""><br><b>修改完配置文件之后切记重启IDEA软件</b></p><p>如果修改完打不开软件，或者提示没有jdk等问题，这时候可以删除用户目录下的IDEA文件夹，注意这个文件夹是隐藏目录！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windwos：C:\Users\用户名\</span><br><span class="line">macos：~/Library/Preferences/</span><br><span class="line">ubuntu：~/.</span><br></pre></td></tr></table></figure></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf0tyctij31gd0u046p.jpg" alt=""></p><h3 id="4-输入激活码"><a href="#4-输入激活码" class="headerlink" title="4. 输入激活码"></a>4. 输入激活码</h3><p>修改完配置文件之后重启IDEA，点击菜单栏中的 “Help” -&gt; “Register …”<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf1mhjaaj31ga0u0jyg.jpg" alt=""></p><p>选择最后一种License server激活方式，地址填入：<a href="http://jetbrains-license-server" target="_blank" rel="noopener">http://jetbrains-license-server</a> （应该会自动填上），或者点击按钮：”Discover Server”来自动填充地址，完成激活。</p><p>注意：服务器激活需要联网！<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf2mn7tdj31hc0tr438.jpg" alt=""></p><p>如果服务器激活方式无法激活，还可以选择Activation code方式激活，复制下面激活码即可<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf3hatfwj314a0qogrb.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JQE11SV0BR-eyJsaWNlbnNlSWQiOiJKUUUxMVNWMEJSIiwibGljZW5zZWVOYW1lIjoicGlnNiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-khgsQrnDiglknF0m+yyoYGJXX4vFE3IIVaoMd0bkpfAlMiYM4FUK1JM7uMnVSN0NBC7qtZjYlNzPscEyKE8634uGuY/uToFQnIOCtyUfBxB6j0wF/DcCjhKMNDbnJ1RKZ2VaALuC9B6d6lhtEKm9+urXWTBq7h2VfIBv5wk1Ul9T/m9Dwkz/LccTqnxO0PP288fF13ZbmcLI1/D0dqp/QxYshW6CLR+2Tvk6QCPoaOTKDU/eL1AssD7/mO1g2ZJA+k//8qfRMLgdLmLrMdyiaIhrsM/jJk2qDfTaMcCNylkWXLgKwSvEQG95IhitLN9+GQ4pBW3gOTNl82Gem7jEkA==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure></p><h3 id="5-查看有效期"><a href="#5-查看有效期" class="headerlink" title="5. 查看有效期"></a>5. 查看有效期</h3><p>当你激活完毕后，IDEA右下角会有个Registration小长条提示框，大致的内容为：You copy is Licensed to XXX意思就会告诉你：兄弟，你已经激活成功了，激活码的许可来源是：XXX。<br>查看有效期的步骤为点击：Help-&gt;About这里可以看到你的IDEA的版本号、许可来源、有效期、以及一些环境<br>服务器激活是没有期限的，即为永久有效<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf4dn7abj31hc0th44m.jpg" alt=""></p><blockquote><p>资源来源：<br><a href="https://zhile.io/" target="_blank" rel="noopener">https://zhile.io/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本教程适用于jetbrains全家桶开发工具（Pycharm、Idea、WebStorm、phpstorm、CLion、RubyMine、AppCode、DataGrid）&lt;/li&gt;
&lt;li&gt;本教程适用于所有版本&lt;/li&gt;
&lt;li&gt;软件直接从官网下载即可&lt;/li&gt;
&lt;li&gt;不需要修改host&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;激活教程&quot;&gt;&lt;a href=&quot;#激活教程&quot; class=&quot;headerlink&quot; title=&quot;激活教程&quot;&gt;&lt;/a&gt;激活教程&lt;/h2&gt;&lt;h3 id=&quot;1-下载破解补丁&quot;&gt;&lt;a href=&quot;#1-下载破解补丁&quot; class=&quot;headerlink&quot; title=&quot;1. 下载破解补丁&quot;&gt;&lt;/a&gt;1. 下载破解补丁&lt;/h3&gt;&lt;p&gt;下载补丁文件：&lt;a href=&quot;https://pan.baidu.com/s/1Kc-byjcH_pvrN4CTgfKSFA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jetbrains-agent.jar&lt;/a&gt;&lt;br&gt;文件保存位置可以任意，建议放置到软件安装路径的bin目录下。避免误删文件。&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="破解教程" scheme="http://yoursite.com/tags/%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>pika学习之数据结构篇</title>
    <link href="http://yoursite.com/2019/12/29/new/pika/pika%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>http://yoursite.com/2019/12/29/new/pika/pika学习之数据结构篇/</id>
    <published>2019-12-29T15:58:59.000Z</published>
    <updated>2019-12-29T16:00:07.049Z</updated>
    
    <content type="html"><![CDATA[<p>pika的持久化存储模块称为nemo存储引擎，其本质上是对rocksDB(只支持KV存储)的改造和封装。使其支持多数据结构的存储。<br>pika作为类redis数据库，所以肯定得兼容redis最基本的五种数据结构：string、hash、list、set、zset。 </p><h2 id="KV存储"><a href="#KV存储" class="headerlink" title="KV存储"></a>KV存储</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae07se7opj30k204tq33.jpg" alt=""><br>KV存储作为rocksDB原生支持的存储方式，所以并没有做太多的处理。仅仅只是在value的结尾加上8个字节的附加信息(前4个字节表示version，后4个字节表示ttl)。<br>version字段用于对该键值对进行标记，以便后续处理，如删除一个键值对时，可以在该version进行标记，后续再进行真正的删除，这样可以减少删除操作造成的服务阻塞时间。</p><h2 id="Hash存储"><a href="#Hash存储" class="headerlink" title="Hash存储"></a>Hash存储</h2><p>对于每一个Hash结构，它都包含hash键(key)、域名(field)、值(value)。<br>nome的存储方式是将key和field组合成为一个新的key，将这个新生成的key与要存储的value组成最终落盘的kv键值对。<br>对于每一个hash键，nome还为它添加了一个存储元数据信息的落盘kv，它保存的是对应hash键下的所有域值对的个数。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae07pcssxj30jx04y0t0.jpg" alt=""></p><ul><li>左图字段保存的是hash键的对象，它由标记位+key+version+ttl组成</li><li>右图字段仅仅只保存一个数字，表示该hash下field的数量</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae0docgmtj30rg06iq3b.jpg" alt=""><br>上图表示nome对传统hash结构转换成kv结构的拆分存储模式。</p><ul><li>k结构部分由标记位+长度+key+field组成。size表示的是hash键key的长度。</li><li>v结构部分就由具体的value+version+ttl组成。<a id="more"></a></li></ul><h2 id="List存储"><a href="#List存储" class="headerlink" title="List存储"></a>List存储</h2><p>每个List结构的底层存储也是采用链表结构来完成，对于每个List键，它的每个元素都落盘成一个kv键值对。<br>和Hash结构一样，每个List也需要拥有一个它的元素信息结构。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae0oa3gxuj30m806mjrq.jpg" alt=""></p><ul><li>List的key存储和hash的一样，只有标记位不一样而已。</li><li>value则存储了List的元数据信息，它有四个字段，从前到后分别为该List键内的元素个数、最左边元素节点的sequence(表头)、最右边元素节点的sequence(表尾)、下一个插入元素节点应该使用的sequence。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae0oe8d2tj30qx06mq3b.jpg" alt=""></p><ul><li>k结构部分由标记位+长度+key+sequence组成。size表示的是hash键key的长度。</li><li>v结构部分由前一个元素的sequence+后一个元素的sequence+value+version+ttl组成。从而实现了一个双向链表的结构。</li></ul><h2 id="Set存储"><a href="#Set存储" class="headerlink" title="Set存储"></a>Set存储</h2><p>Set，本质上就是一个value值为nil的Hash结构。在Java和Redis中，都是利用hashtable来实现的。nome并没有做什么特殊处理，只是在存储value时，只保存了version和ttl结构。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae10jcgjdj30lw06oglt.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae10oq2i8j30kw06mq35.jpg" alt=""></p><h2 id="Zset存储"><a href="#Zset存储" class="headerlink" title="Zset存储"></a>Zset存储</h2><p>Zset就是一个有序的Set结构，所以对于每个元素，增加了一个scope值。把该元素对应的score值整合进去，这样便于依据Score值进行排序（因为从rocksdb内拿出的数据时按键排序的）<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae13azcgrj30ii068q33.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae13e4n73j30oa068wep.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae13hlow6j30oa068wep.jpg" alt=""><br>score是从double类型转变过来的int64_t类型，这样做是为了可以让原来的浮点型的score直接参与到字符串的排序当中（浮点型的存储格式与字符串的比较方式不兼容）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pika的持久化存储模块称为nemo存储引擎，其本质上是对rocksDB(只支持KV存储)的改造和封装。使其支持多数据结构的存储。&lt;br&gt;pika作为类redis数据库，所以肯定得兼容redis最基本的五种数据结构：string、hash、list、set、zset。 &lt;/p&gt;
&lt;h2 id=&quot;KV存储&quot;&gt;&lt;a href=&quot;#KV存储&quot; class=&quot;headerlink&quot; title=&quot;KV存储&quot;&gt;&lt;/a&gt;KV存储&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gae07se7opj30k204tq33.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;KV存储作为rocksDB原生支持的存储方式，所以并没有做太多的处理。仅仅只是在value的结尾加上8个字节的附加信息(前4个字节表示version，后4个字节表示ttl)。&lt;br&gt;version字段用于对该键值对进行标记，以便后续处理，如删除一个键值对时，可以在该version进行标记，后续再进行真正的删除，这样可以减少删除操作造成的服务阻塞时间。&lt;/p&gt;
&lt;h2 id=&quot;Hash存储&quot;&gt;&lt;a href=&quot;#Hash存储&quot; class=&quot;headerlink&quot; title=&quot;Hash存储&quot;&gt;&lt;/a&gt;Hash存储&lt;/h2&gt;&lt;p&gt;对于每一个Hash结构，它都包含hash键(key)、域名(field)、值(value)。&lt;br&gt;nome的存储方式是将key和field组合成为一个新的key，将这个新生成的key与要存储的value组成最终落盘的kv键值对。&lt;br&gt;对于每一个hash键，nome还为它添加了一个存储元数据信息的落盘kv，它保存的是对应hash键下的所有域值对的个数。&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gae07pcssxj30jx04y0t0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左图字段保存的是hash键的对象，它由标记位+key+version+ttl组成&lt;/li&gt;
&lt;li&gt;右图字段仅仅只保存一个数字，表示该hash下field的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gae0docgmtj30rg06iq3b.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;上图表示nome对传统hash结构转换成kv结构的拆分存储模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;k结构部分由标记位+长度+key+field组成。size表示的是hash键key的长度。&lt;/li&gt;
&lt;li&gt;v结构部分就由具体的value+version+ttl组成。
    
    </summary>
    
      <category term="Pika" scheme="http://yoursite.com/categories/Pika/"/>
    
    
      <category term="Pika" scheme="http://yoursite.com/tags/Pika/"/>
    
  </entry>
  
  <entry>
    <title>redis复制过程演变</title>
    <link href="http://yoursite.com/2019/12/29/new/Redis/redis%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E6%BC%94%E5%8F%98/"/>
    <id>http://yoursite.com/2019/12/29/new/Redis/redis复制过程演变/</id>
    <published>2019-12-29T14:19:06.000Z</published>
    <updated>2019-12-29T14:21:46.576Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的主从复制主要经历以下的几个阶段：</p><ol><li>2.8版本以下—-sync</li><li>2.8-4.0版本—-psync</li><li>4.0版本+ —-psync2</li></ol><p>下面我就来简单的讲讲Redis主从复制的演变过程。</p><h2 id="Redis主从复制过程"><a href="#Redis主从复制过程" class="headerlink" title="Redis主从复制过程"></a>Redis主从复制过程</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadwq7etd2j31r50u0464.jpg" alt=""></p><ul><li>客户端发送slaveof命令给Redis实例</li><li>准备阶段函数为<code>replicationSetMaster</code>，这个函数主要会做一些复制之前的数据和状态清理工作。</li><li>更新server.master</li><li>将实例状态修改为REPL_STATE_CONNECT<a id="more"></a><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadwqm9ps9j31pc0u045z.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadxodwcpuj31pf0u0dns.jpg" alt=""><br>Redis每秒会调用一次<code>replicationCron</code>定时任务。根据Redis当前所处状态来决定下一步操作。</li><li>当Redis状态为<code>REPL_STATE_CONNECT</code>时会调用<code>connectWithMaster</code>创建连接master事件。该函数会将Redis状态修改为<code>REPL_STATE_CONNECTING</code></li><li>接下来进行心跳检查、权限校验等操作</li><li>master接收到slave的复制命令后，就会触发一次rdb全备，并记录下全备期间的命令。</li><li>master将全备文件发送给slave后，将增量命令发送给slave。</li><li>心跳维持和持续复制</li></ul><h2 id="主从复制的演变"><a href="#主从复制的演变" class="headerlink" title="主从复制的演变"></a>主从复制的演变</h2><p>在2.8之前的版本中，如果由于网络等原因导致主从复制断开。那么就会将从节点状态修改为<code>REPL_STATE_CONNECTING</code>。进而会重新进行全量同步流程。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadxz7g5aoj31rq0gcju1.jpg" alt=""><br>在2.8版本中，Redis增加了psync命令，并且增加了一个复制积压缓冲区的数据结构（默认为1M）。<br>复制积压缓冲区是一个环形的结构，保存了最近可用的写命令数据。<br>在<code>replicationCron</code>定时任务中每秒发送一个<code>REPLCONF ACK OFFSET</code>命令将自身的偏移量信息发送给master，如果offset的命令在复制积压缓冲区中，那么说明增量数据是可用的。就没必要进行全量同步，直接将复制积压缓冲区中的增量数据发送给slave就可以了。</p><p>在redis4.0+版本中又引进了psync2命令来避免一些特殊场景(主从架构、级联架构)下发生主从切换后不必要的全量同步操作。<br>将一组replid和offset给增加成为两组。主要用来记录上一次复制中主实例的runid值。然后在slaveof时判断是否有必要进行全量同步操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">replid1：</span><br><span class="line">主节点：自身的replid和offset</span><br><span class="line">从节点：主节点的replid和offset</span><br><span class="line"></span><br><span class="line">replid2:</span><br><span class="line">上一次主实例的replid和offset</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的主从复制主要经历以下的几个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;2.8版本以下—-sync&lt;/li&gt;
&lt;li&gt;2.8-4.0版本—-psync&lt;/li&gt;
&lt;li&gt;4.0版本+ —-psync2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我就来简单的讲讲Redis主从复制的演变过程。&lt;/p&gt;
&lt;h2 id=&quot;Redis主从复制过程&quot;&gt;&lt;a href=&quot;#Redis主从复制过程&quot; class=&quot;headerlink&quot; title=&quot;Redis主从复制过程&quot;&gt;&lt;/a&gt;Redis主从复制过程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gadwq7etd2j31r50u0464.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送slaveof命令给Redis实例&lt;/li&gt;
&lt;li&gt;准备阶段函数为&lt;code&gt;replicationSetMaster&lt;/code&gt;，这个函数主要会做一些复制之前的数据和状态清理工作。&lt;/li&gt;
&lt;li&gt;更新server.master&lt;/li&gt;
&lt;li&gt;将实例状态修改为REPL_STATE_CONNECT
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>浅析GeoHash</title>
    <link href="http://yoursite.com/2019/12/26/new/Redis/%E6%B5%85%E6%9E%90GeoHash/"/>
    <id>http://yoursite.com/2019/12/26/new/Redis/浅析GeoHash/</id>
    <published>2019-12-26T12:16:58.000Z</published>
    <updated>2019-12-29T16:03:59.377Z</updated>
    
    <content type="html"><![CDATA[<p>GeoHash算法能够将二维的经纬度转换成字符串。主要有以下几个特性:</p><ol><li>每一个字符串代表了某一矩形区域.</li><li>字符串的长度越长，所表示的位置越精确。</li><li>字符串越相近的表示的举例越接近.</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>GeoHash将经纬度转换为hash字符串主要分为三步：</p><ol><li>将纬度(-90, 90)平均分成两个区间(-90, 0)、(0, 90)，如果坐标位置的纬度值在第一区间，则编码是0，否则编码为1</li><li>经纬度的编码合并，从0开始，奇数为是纬度，偶数为是经度</li><li>对经纬度合并后的编码，进行base32编码</li></ol><p>大概过程如下图，不断的对经纬度进行切割，直到精准度达到要求。<br><img src="https://user-gold-cdn.xitu.io/2018/7/4/1646397a223e2019?imageslim" alt="IMAGE"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote><p>将经纬度转换成二进制编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void convert(double min, double max, double value, List&lt;Character&gt; list) &#123;</span><br><span class="line">        if (list.size() &gt; (length - 1)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        double mid = (max + min) / 2;</span><br><span class="line">        if (value &lt; mid) &#123;</span><br><span class="line">            list.add(&apos;0&apos;);</span><br><span class="line">            convert(min, mid, value, list);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            list.add(&apos;1&apos;);</span><br><span class="line">            convert(mid, max, value, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><blockquote><p>合并经纬度的二进制编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Character&gt; latList = new ArrayList&lt;Character&gt;();</span><br><span class="line">List&lt;Character&gt; lngList = new ArrayList&lt;Character&gt;();</span><br><span class="line">convert(Min_Lat, Max_Lat, lat, latList);</span><br><span class="line">convert(Min_Lng, Max_Lng, lng, lngList);</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">for (int index = 0; index &lt; latList.size(); index++) &#123;</span><br><span class="line">    sb.append(lngList.get(index)).append(latList.get(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>base32编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private final String[] base32Lookup =</span><br><span class="line">            &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;,</span><br><span class="line">                    &quot;j&quot;, &quot;k&quot;, &quot;m&quot;, &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#125;;</span><br><span class="line">    private String base32Encode(final String str) &#123;</span><br><span class="line">        String unit = &quot;&quot;;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int start = 0; start &lt; str.length(); start = start + 5) &#123;</span><br><span class="line">            unit = str.substring(start, start + 5);</span><br><span class="line">            sb.append(base32Lookup[convertToIndex(unit.split(&quot;&quot;))]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    private int convertToIndex(String str) &#123;</span><br><span class="line">        int length = str.length();</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int index = 0; index &lt; length; index++) &#123;</span><br><span class="line">            result += str.charAt(index) == &apos;0&apos; ? 0 : 1 &lt;&lt; (length - 1 - index);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="Redis中的Geo使用"><a href="#Redis中的Geo使用" class="headerlink" title="Redis中的Geo使用"></a>Redis中的Geo使用</h2><p>在Redis中，Geo的内部结构实际上是一个zset。<br>Redis提供给Geo指定只有6个，但是它可以使用zset的所有指令。</p><h3 id="增加-geoadd"><a href="#增加-geoadd" class="headerlink" title="增加-geoadd"></a>增加-geoadd</h3><p>geoadd指令传入多个经纬度名称三元组，Redis内存会调用函数计算出相应的geohash字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd company 116.48105 39.996794 juejin</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.514203 39.905409 ireader</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.489033 40.007669 meituan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p><h3 id="距离-geodist"><a href="#距离-geodist" class="headerlink" title="距离-geodist"></a>距离-geodist</h3><p>geodist 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist company juejin ireader km</span><br><span class="line">&quot;10.5501&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin meituan km</span><br><span class="line">&quot;1.3878&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin jd km</span><br><span class="line">&quot;24.2739&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin xiaomi km</span><br><span class="line">&quot;12.9606&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin juejin km</span><br><span class="line">&quot;0.0000&quot;</span><br></pre></td></tr></table></figure></p><h3 id="获取元素位置-geopos"><a href="#获取元素位置-geopos" class="headerlink" title="获取元素位置-geopos"></a>获取元素位置-geopos</h3><p>geopos 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos company juejin</span><br><span class="line">1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">   2) &quot;39.99679348858259686&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company ireader</span><br><span class="line">1) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">   2) &quot;39.90540918662494363&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company juejin ireader</span><br><span class="line">1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">   2) &quot;39.99679348858259686&quot;</span><br><span class="line">2) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">   2) &quot;39.90540918662494363&quot;</span><br></pre></td></tr></table></figure></p><h3 id="获取元素的-hash-值-geohash"><a href="#获取元素的-hash-值-geohash" class="headerlink" title="获取元素的 hash 值-geohash"></a>获取元素的 hash 值-geohash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash company ireader</span><br><span class="line">1) &quot;wx4g52e1ce0&quot;</span><br><span class="line">127.0.0.1:6379&gt; geohash company juejin</span><br><span class="line">1) &quot;wx4gd94yjn0&quot;</span><br></pre></td></tr></table></figure><h3 id="附近元素-georadiusbymember"><a href="#附近元素-georadiusbymember" class="headerlink" title="附近元素-georadiusbymember"></a>附近元素-georadiusbymember</h3><p>georadiusbymember 指令是最为关键的指令，它可以用来查询指定元素附近的其它元素，它的参数非常复杂。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 asc</span><br><span class="line">1) &quot;ireader&quot;</span><br><span class="line">2) &quot;juejin&quot;</span><br><span class="line">3) &quot;meituan&quot;</span><br><span class="line"># 范围 20 公里以内最多 3 个元素按距离倒排</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 desc</span><br><span class="line">1) &quot;jd&quot;</span><br><span class="line">2) &quot;meituan&quot;</span><br><span class="line">3) &quot;juejin&quot;</span><br><span class="line"># 三个可选参数 withcoord withdist withhash 用来携带附加参数</span><br><span class="line"># withdist 很有用，它可以用来显示距离</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc</span><br><span class="line">1) 1) &quot;ireader&quot;</span><br><span class="line">   2) &quot;0.0000&quot;</span><br><span class="line">   3) (integer) 4069886008361398</span><br><span class="line">   4) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">      2) &quot;39.90540918662494363&quot;</span><br><span class="line">2) 1) &quot;juejin&quot;</span><br><span class="line">   2) &quot;10.5501&quot;</span><br><span class="line">   3) (integer) 4069887154388167</span><br><span class="line">   4) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">      2) &quot;39.99679348858259686&quot;</span><br><span class="line">3) 1) &quot;meituan&quot;</span><br><span class="line">   2) &quot;11.5748&quot;</span><br><span class="line">   3) (integer) 4069887179083478</span><br><span class="line">   4) 1) &quot;116.48903220891952515&quot;</span><br><span class="line">      2) &quot;40.00766997707732031&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GeoHash算法能够将二维的经纬度转换成字符串。主要有以下几个特性:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每一个字符串代表了某一矩形区域.&lt;/li&gt;
&lt;li&gt;字符串的长度越长，所表示的位置越精确。&lt;/li&gt;
&lt;li&gt;字符串越相近的表示的举例越接近.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;GeoHash将经纬度转换为hash字符串主要分为三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将纬度(-90, 90)平均分成两个区间(-90, 0)、(0, 90)，如果坐标位置的纬度值在第一区间，则编码是0，否则编码为1&lt;/li&gt;
&lt;li&gt;经纬度的编码合并，从0开始，奇数为是纬度，偶数为是经度&lt;/li&gt;
&lt;li&gt;对经纬度合并后的编码，进行base32编码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大概过程如下图，不断的对经纬度进行切割，直到精准度达到要求。&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/4/1646397a223e2019?imageslim&quot; alt=&quot;IMAGE&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;将经纬度转换成二进制编码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void convert(double min, double max, double value, List&amp;lt;Character&amp;gt; list) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (list.size() &amp;gt; (length - 1)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        double mid = (max + min) / 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (value &amp;lt; mid) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            list.add(&amp;apos;0&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            convert(min, mid, value, list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            list.add(&amp;apos;1&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            convert(mid, max, value, list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis4.0的大key发现和删除</title>
    <link href="http://yoursite.com/2019/12/19/new/Redis/Redis4.0%E7%9A%84%E5%A4%A7key%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2019/12/19/new/Redis/Redis4.0的大key发现和删除/</id>
    <published>2019-12-18T17:22:47.000Z</published>
    <updated>2019-12-18T17:25:03.941Z</updated>
    
    <content type="html"><![CDATA[<p>Redis4.0版本之后引入了memory usage命令和lazyfree机制。不管是对大key的发现，还是解决删除大key造成的阻塞问题都有了很大的提升。</p><h3 id="大key发现"><a href="#大key发现" class="headerlink" title="大key发现"></a>大key发现</h3><p>memory usage的实现主要在<code>object.c-&gt;memoryCommand</code>方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;memory&quot;,memoryCommand,-2,</span><br><span class="line">     &quot;random read-only&quot;,</span><br><span class="line">     0,NULL,0,0,0,0,0,0&#125;,</span><br><span class="line">     </span><br><span class="line">else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;usage&quot;) &amp;&amp; c-&gt;argc &gt;= 3) &#123;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;</span><br><span class="line">        for (int j = 3; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">            if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;samples&quot;) &amp;&amp;</span><br><span class="line">                j+1 &lt; c-&gt;argc)</span><br><span class="line">            &#123;</span><br><span class="line">                if (getLongLongFromObjectOrReply(c,c-&gt;argv[j+1],&amp;samples,NULL)</span><br><span class="line">                     == C_ERR) return;</span><br><span class="line">                if (samples &lt; 0) &#123;</span><br><span class="line">                    addReply(c,shared.syntaxerr);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (samples == 0) samples = LLONG_MAX;;</span><br><span class="line">                j++; /* skip option argument. */</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                addReply(c,shared.syntaxerr);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((de = dictFind(c-&gt;db-&gt;dict,c-&gt;argv[2]-&gt;ptr)) == NULL) &#123;</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        size_t usage = objectComputeSize(dictGetVal(de),samples);</span><br><span class="line">        usage += sdsAllocSize(dictGetKey(de));</span><br><span class="line">        usage += sizeof(dictEntry);</span><br><span class="line">        addReplyLongLong(c,usage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>我们可以看到计算使用内存大小核心逻辑是在<code>objectComputeSize</code>函数中，对不同类型的键值计算方式不一样，这里以hash类型举例。<br>在使用<code>memory usage</code>命令时可以指定一个抽样元素个数。默认为5，决定了内存计算的准确性和计算成本。<br>这个值越大，循环次数越多，计算结果越精准，性能损耗也越高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*...代码对数据类型进行了分类，此处只取hash类型说明*/</span><br><span class="line">    /*...*/</span><br><span class="line">        /*循环抽样个field，累加获取抽样样本内存值，默认抽样样本为5*/</span><br><span class="line">        while((de = dictNext(di)) != NULL &amp;&amp; samples &lt; sample_size) &#123;</span><br><span class="line">            ele = dictGetKey(de);</span><br><span class="line">            ele2 = dictGetVal(de);</span><br><span class="line">            elesize += sdsAllocSize(ele) + sdsAllocSize(ele2);</span><br><span class="line">            elesize += sizeof(struct dictEntry);</span><br><span class="line">            samples++;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        /*根据上一步计算的抽样样本内存值除以样本量，再乘以总的filed个数计算总内存值*/</span><br><span class="line">        if (samples) asize += (double)elesize/samples*dictSize(d);</span><br><span class="line">    /*...*/</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="lazyfree"><a href="#lazyfree" class="headerlink" title="lazyfree"></a>lazyfree</h3><p>在Redis4.0版本中，新增了一个删除命令<code>unlink</code>。实现了懒删除方式，减少了在删除大key时引起的阻塞影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;unlink&quot;,unlinkCommand,-2,</span><br><span class="line">     &quot;write fast @keyspace&quot;,</span><br><span class="line">     0,NULL,1,-1,1,0,0,0&#125;,</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">void unlinkCommand(client *c) &#123;</span><br><span class="line">    delGenericCommand(c,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* This command implements DEL and LAZYDEL. */</span><br><span class="line">void delGenericCommand(client *c, int lazy) &#123;</span><br><span class="line">    int numdel = 0, j;</span><br><span class="line"></span><br><span class="line">    for (j = 1; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        int deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        if (deleted) &#123;</span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                &quot;del&quot;,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看出，<code>del</code>和<code>unlink</code>命令调用的都是<code>delGenericCommand</code>方法。区别主要在于第二个参数，是否为懒删除标记。<br>如果是懒删除，调用的是异步删除方法<code>dbAsyncDelete</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/* Delete a key, value, and associated expiration entry if any, from the DB.</span><br><span class="line"> * If there are enough allocations to free the value object may be put into</span><br><span class="line"> * a lazy free list instead of being freed synchronously. The lazy free list</span><br><span class="line"> * will be reclaimed in a different bio.c thread. */</span><br><span class="line">#define LAZYFREE_THRESHOLD 64</span><br><span class="line">int dbAsyncDelete(redisDb *db, robj *key) &#123;</span><br><span class="line">    /* Deleting an entry from the expires dict will not free the sds of</span><br><span class="line">     * the key, because it is shared with the main dictionary. */</span><br><span class="line">    if (dictSize(db-&gt;expires) &gt; 0) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    /* If the value is composed of a few allocations, to free in a lazy way</span><br><span class="line">     * is actually just slower... So under a certain limit we just free</span><br><span class="line">     * the object synchronously. */</span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        /*lazyfreeGetFreeEffort来获取val对象所包含的元素个数*/</span><br><span class="line">        size_t free_effort = lazyfreeGetFreeEffort(val);</span><br><span class="line"></span><br><span class="line">        /* If releasing the object is too much work, do it in the background</span><br><span class="line">         * by adding the object to the lazy free list.</span><br><span class="line">         * Note that if the object is shared, to reclaim it now it is not</span><br><span class="line">         * possible. This rarely happens, however sometimes the implementation</span><br><span class="line">         * of parts of the Redis core may call incrRefCount() to protect</span><br><span class="line">         * objects, and then call dbDelete(). In this case we&apos;ll fall</span><br><span class="line">         * through and reach the dictFreeUnlinkedEntry() call, that will be</span><br><span class="line">         * equivalent to just calling decrRefCount(). */</span><br><span class="line">        /* 对删除key进行判断，满足阈值条件时进行后台删除 */</span><br><span class="line">        if (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == 1) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,1);</span><br><span class="line">            /*将删除对象放入BIO_LAZY_FREE后台线程任务队列*/</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,NULL,NULL);</span><br><span class="line">            /*将第一步获取到的val值设置为null*/</span><br><span class="line">            dictSetVal(db-&gt;dict,de,NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Release the key-val pair, or just the key if we set the val</span><br><span class="line">     * field to NULL in order to lazy free it later. */</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        if (server.cluster_enabled) slotToKeyDel(key);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数实现中可以看出，Redis并不是单纯的将所有懒删除操作都放后台线程中进行。而是会先对需要懒删除的key进行判断，不满足条件的key将会直接进行删除操作。<br>只有满足条件的key才放入到后台线程任务处理队列中。并且立即将其value设置为NULL，避免造成脏读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">else if (type == BIO_LAZY_FREE) &#123;</span><br><span class="line">           /* What we free changes depending on what arguments are set:</span><br><span class="line">            * arg1 -&gt; free the object at pointer.</span><br><span class="line">            * arg2 &amp; arg3 -&gt; free two dictionaries (a Redis DB).</span><br><span class="line">            * only arg3 -&gt; free the skiplist. */</span><br><span class="line">           if (job-&gt;arg1)</span><br><span class="line">               lazyfreeFreeObjectFromBioThread(job-&gt;arg1);</span><br><span class="line">           else if (job-&gt;arg2 &amp;&amp; job-&gt;arg3)</span><br><span class="line">               lazyfreeFreeDatabaseFromBioThread(job-&gt;arg2,job-&gt;arg3);</span><br><span class="line">           else if (job-&gt;arg3)</span><br><span class="line">               lazyfreeFreeSlotsMapFromBioThread(job-&gt;arg3);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis4.0版本之后引入了memory usage命令和lazyfree机制。不管是对大key的发现，还是解决删除大key造成的阻塞问题都有了很大的提升。&lt;/p&gt;
&lt;h3 id=&quot;大key发现&quot;&gt;&lt;a href=&quot;#大key发现&quot; class=&quot;headerlink&quot; title=&quot;大key发现&quot;&gt;&lt;/a&gt;大key发现&lt;/h3&gt;&lt;p&gt;memory usage的实现主要在&lt;code&gt;object.c-&amp;gt;memoryCommand&lt;/code&gt;方法中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;quot;memory&amp;quot;,memoryCommand,-2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;quot;random read-only&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     0,NULL,0,0,0,0,0,0&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else if (!strcasecmp(c-&amp;gt;argv[1]-&amp;gt;ptr,&amp;quot;usage&amp;quot;) &amp;amp;&amp;amp; c-&amp;gt;argc &amp;gt;= 3) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dictEntry *de;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int j = 3; j &amp;lt; c-&amp;gt;argc; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (!strcasecmp(c-&amp;gt;argv[j]-&amp;gt;ptr,&amp;quot;samples&amp;quot;) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j+1 &amp;lt; c-&amp;gt;argc)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (getLongLongFromObjectOrReply(c,c-&amp;gt;argv[j+1],&amp;amp;samples,NULL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     == C_ERR) return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (samples &amp;lt; 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    addReply(c,shared.syntaxerr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (samples == 0) samples = LLONG_MAX;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j++; /* skip option argument. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                addReply(c,shared.syntaxerr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ((de = dictFind(c-&amp;gt;db-&amp;gt;dict,c-&amp;gt;argv[2]-&amp;gt;ptr)) == NULL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            addReplyNull(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        size_t usage = objectComputeSize(dictGetVal(de),samples);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        usage += sdsAllocSize(dictGetKey(de));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        usage += sizeof(dictEntry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        addReplyLongLong(c,usage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis初始化启动过程</title>
    <link href="http://yoursite.com/2019/12/15/new/Redis/Redis%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/12/15/new/Redis/Redis初始化启动过程/</id>
    <published>2019-12-14T17:48:31.000Z</published>
    <updated>2019-12-14T17:49:05.175Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文将基于Redis5.0 unstable版本介绍其在启动过程中所做的主要操作以及相关流程函数方法。<br>在此，先放上一张Redis初始化流程的大意图。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wqij4tmaj30a008edfz.jpg" alt=""></p><a id="more"></a><p>Redis的启动函数位于<code>server.c</code>文件main方法下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    int j;</span><br><span class="line">#ifdef REDIS_TEST</span><br><span class="line">    if (argc == 3 &amp;&amp; !strcasecmp(argv[1], &quot;test&quot;)) &#123;</span><br><span class="line">        if (!strcasecmp(argv[2], &quot;ziplist&quot;)) &#123;</span><br><span class="line">            return ziplistTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;quicklist&quot;)) &#123;</span><br><span class="line">            quicklistTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;intset&quot;)) &#123;</span><br><span class="line">            return intsetTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;zipmap&quot;)) &#123;</span><br><span class="line">            return zipmapTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;sha1test&quot;)) &#123;</span><br><span class="line">            return sha1Test(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;util&quot;)) &#123;</span><br><span class="line">            return utilTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;sds&quot;)) &#123;</span><br><span class="line">            return sdsTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;endianconv&quot;)) &#123;</span><br><span class="line">            return endianconvTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;crc64&quot;)) &#123;</span><br><span class="line">            return crc64Test(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;zmalloc&quot;)) &#123;</span><br><span class="line">            return zmalloc_test(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1; /* test not found */</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* We need to initialize our libraries, and the server configuration. */</span><br><span class="line">#ifdef INIT_SETPROCTITLE_REPLACEMENT</span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line">#endif</span><br><span class="line">    setlocale(LC_COLLATE,&quot;&quot;);</span><br><span class="line">    tzset(); /* Populates &apos;timezone&apos; global. */</span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(NULL)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,NULL);</span><br><span class="line"></span><br><span class="line">    char hashseed[16];</span><br><span class="line">    getRandomHexChars(hashseed,sizeof(hashseed));</span><br><span class="line">    dictSetHashFunctionSeed((uint8_t*)hashseed);</span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">    initServerConfig();</span><br><span class="line">    ACLInit(); /* The ACL subsystem must be initialized ASAP because the</span><br><span class="line">                  basic networking code and client creation depends on it. */</span><br><span class="line">    moduleInitModulesSystem();</span><br><span class="line"></span><br><span class="line">    /* Store the executable path and arguments in a safe place in order</span><br><span class="line">     * to be able to restart the server later. */</span><br><span class="line">    server.executable = getAbsolutePath(argv[0]);</span><br><span class="line">    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</span><br><span class="line">    server.exec_argv[argc] = NULL;</span><br><span class="line">    for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br><span class="line"></span><br><span class="line">    /* We need to init sentinel right now as parsing the configuration file</span><br><span class="line">     * in sentinel mode will have the effect of populating the sentinel</span><br><span class="line">     * data structures with master nodes to monitor. */</span><br><span class="line">    if (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig();</span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Check if we need to start in redis-check-rdb/aof mode. We just execute</span><br><span class="line">     * the program main. However the program is part of the Redis executable</span><br><span class="line">     * so that we can easily execute an RDB check on loading errors. */</span><br><span class="line">    if (strstr(argv[0],&quot;redis-check-rdb&quot;) != NULL)</span><br><span class="line">        redis_check_rdb_main(argc,argv,NULL);</span><br><span class="line">    else if (strstr(argv[0],&quot;redis-check-aof&quot;) != NULL)</span><br><span class="line">        redis_check_aof_main(argc,argv);</span><br><span class="line"></span><br><span class="line">    if (argc &gt;= 2) &#123;</span><br><span class="line">        j = 1; /* First option to parse in argv[] */</span><br><span class="line">        sds options = sdsempty();</span><br><span class="line">        char *configfile = NULL;</span><br><span class="line"></span><br><span class="line">        /* Handle special options --help and --version */</span><br><span class="line">        if (strcmp(argv[1], &quot;-v&quot;) == 0 ||</span><br><span class="line">            strcmp(argv[1], &quot;--version&quot;) == 0) version();</span><br><span class="line">        if (strcmp(argv[1], &quot;--help&quot;) == 0 ||</span><br><span class="line">            strcmp(argv[1], &quot;-h&quot;) == 0) usage();</span><br><span class="line">        if (strcmp(argv[1], &quot;--test-memory&quot;) == 0) &#123;</span><br><span class="line">            if (argc == 3) &#123;</span><br><span class="line">                memtest(atoi(argv[2]),50);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fprintf(stderr,&quot;Please specify the amount of memory to test in megabytes.\n&quot;);</span><br><span class="line">                fprintf(stderr,&quot;Example: ./redis-server --test-memory 4096\n\n&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* First argument is the config file name? */</span><br><span class="line">        if (argv[j][0] != &apos;-&apos; || argv[j][1] != &apos;-&apos;) &#123;</span><br><span class="line">            configfile = argv[j];</span><br><span class="line">            server.configfile = getAbsolutePath(configfile);</span><br><span class="line">            /* Replace the config file in server.exec_argv with</span><br><span class="line">             * its absolute path. */</span><br><span class="line">            zfree(server.exec_argv[j]);</span><br><span class="line">            server.exec_argv[j] = zstrdup(server.configfile);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* All the other options are parsed and conceptually appended to the</span><br><span class="line">         * configuration file. For instance --port 6380 will generate the</span><br><span class="line">         * string &quot;port 6380\n&quot; to be parsed after the actual file name</span><br><span class="line">         * is parsed, if any. */</span><br><span class="line">        while(j != argc) &#123;</span><br><span class="line">            if (argv[j][0] == &apos;-&apos; &amp;&amp; argv[j][1] == &apos;-&apos;) &#123;</span><br><span class="line">                /* Option name */</span><br><span class="line">                if (!strcmp(argv[j], &quot;--check-rdb&quot;)) &#123;</span><br><span class="line">                    /* Argument has no options, need to skip for parsing. */</span><br><span class="line">                    j++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (sdslen(options)) options = sdscat(options,&quot;\n&quot;);</span><br><span class="line">                options = sdscat(options,argv[j]+2);</span><br><span class="line">                options = sdscat(options,&quot; &quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* Option argument */</span><br><span class="line">                options = sdscatrepr(options,argv[j],strlen(argv[j]));</span><br><span class="line">                options = sdscat(options,&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == &apos;-&apos;) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Sentinel config from STDIN not allowed.&quot;);</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Sentinel needs config file on disk to save state.  Exiting...&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        resetServerSaveParams();</span><br><span class="line">        loadServerConfig(configfile,options);</span><br><span class="line">        sdsfree(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_WARNING, &quot;oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo&quot;);</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        &quot;Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started&quot;,</span><br><span class="line">            REDIS_VERSION,</span><br><span class="line">            (sizeof(long) == 8) ? 64 : 32,</span><br><span class="line">            redisGitSHA1(),</span><br><span class="line">            strtol(redisGitDirty(),NULL,10) &gt; 0,</span><br><span class="line">            (int)getpid());</span><br><span class="line"></span><br><span class="line">    if (argc == 1) &#123;</span><br><span class="line">        serverLog(LL_WARNING, &quot;Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf&quot;, argv[0], server.sentinel_mode ? &quot;sentinel&quot; : &quot;redis&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        serverLog(LL_WARNING, &quot;Configuration loaded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line">    int background = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line">    if (background) daemonize();</span><br><span class="line"></span><br><span class="line">    initServer();</span><br><span class="line">    if (background || server.pidfile) createPidFile();</span><br><span class="line">    redisSetProcTitle(argv[0]);</span><br><span class="line">    redisAsciiArt();</span><br><span class="line">    checkTcpBacklogSettings();</span><br><span class="line"></span><br><span class="line">    if (!server.sentinel_mode) &#123;</span><br><span class="line">        /* Things not needed when running in Sentinel mode. */</span><br><span class="line">        serverLog(LL_WARNING,&quot;Server initialized&quot;);</span><br><span class="line">    #ifdef __linux__</span><br><span class="line">        linuxMemoryWarnings();</span><br><span class="line">    #endif</span><br><span class="line">        moduleLoadFromQueue();</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        if (server.cluster_enabled) &#123;</span><br><span class="line">            if (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    &quot;You can&apos;t have keys in a DB different than DB 0 when in &quot;</span><br><span class="line">                    &quot;Cluster mode. Exiting.&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (server.ipfd_count &gt; 0)</span><br><span class="line">            serverLog(LL_NOTICE,&quot;Ready to accept connections&quot;);</span><br><span class="line">        if (server.sofd &gt; 0)</span><br><span class="line">            serverLog(LL_NOTICE,&quot;The server is now ready to accept connections at %s&quot;, server.unixsocket);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Warning the user about suspicious maxmemory setting. */</span><br><span class="line">    if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) &#123;</span><br><span class="line">        serverLog(LL_WARNING,&quot;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&quot;, server.maxmemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">    aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="初始化默认状态"><a href="#初始化默认状态" class="headerlink" title="初始化默认状态"></a>初始化默认状态</h2><p>我们可以看到在main方法中，进行的第一步操作就是初始化默认配置<code>initServerConfig</code>。有很多初始化操作都需要设置了一些默认配置后才能够继续进行的。</p><p>在这一阶段中进行初始化的主要有：</p><ul><li>Redis server的状态默认值</li><li>Redis服务运行的默认参数配置</li><li>复制参数配置</li><li>客户端输入输出缓冲区设置</li><li>部分命令参数初始化</li><li>slow log初始化</li></ul><p>为什么需要先对部分命令进行初始化：<br>因为这一部分命令是Redis对外提供服务之前时，就需要先调用的，所以必须先进行初始化。而其他非必须的命令此时仍未进行初始化。</p><h2 id="权限初始化"><a href="#权限初始化" class="headerlink" title="权限初始化"></a>权限初始化</h2><p>用户这个概念，是Redis在6.0版本中提出的。虽然还未正式投入线上使用，但是已经在unstable版本中开始投入开发。<br><code>ACLInit()</code>这个方法非常简单，只会初始化一个拥有所有权限的默认用户。</p><h2 id="初始化模块系统"><a href="#初始化模块系统" class="headerlink" title="初始化模块系统"></a>初始化模块系统</h2><p>模块系统，是Redis4.0版本中推出的一个新特性，它允许用户自己编写适合于自己的模块，并以插件的形式导入到Redis当中。<br>通过<code>moduleInitModulesSystem()</code>方法，创建模块系统所需要数据结构和资源。</p><h2 id="解析命令行参数以及读取配置"><a href="#解析命令行参数以及读取配置" class="headerlink" title="解析命令行参数以及读取配置"></a>解析命令行参数以及读取配置</h2><p>在启动Redis的时候，是允许用户在命令行中指定Redis运行的模式和参数。<br>将配置文件和运行时参数等信息通过遍历的方式确认后，调用<code>loadServerConfig</code>方法，将运行时参数写入到配置文件中。如果没有指定配置文件，就会使用默认的配置文件来运行服务。</p><p>最终会通过<code>initServer</code>方法来初始化参数配置。<br>这个方法主要会做以下的一些初始化操作：</p><ul><li>初始化共享对象<code>createSharedObjects</code></li><li>检查系统参数配置<code>adjustOpenFilesLimit</code></li><li>开启端口监听</li><li>创建事件监听和时间监听文件句柄</li><li>创建数据库并初始化状态<br>在这个方法中创建创建文件驱动和时间驱动的监听句柄。并且会进行以下的一些初始数据的初始化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (server.cluster_enabled) clusterInit();</span><br><span class="line">replicationScriptCacheInit();</span><br><span class="line">scriptingInit(1);</span><br><span class="line">slowlogInit();</span><br><span class="line">latencyMonitorInit();</span><br><span class="line">bioInit();</span><br><span class="line">server.initial_memory_usage = zmalloc_used_memory();</span><br></pre></td></tr></table></figure></li></ul><h2 id="模块文件、用户权限、数据导入"><a href="#模块文件、用户权限、数据导入" class="headerlink" title="模块文件、用户权限、数据导入"></a>模块文件、用户权限、数据导入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moduleLoadFromQueue();</span><br><span class="line">ACLLoadUsersAtStartup();</span><br><span class="line">loadDataFromDisk();</span><br></pre></td></tr></table></figure><p>如果数据文件中有数据，则需要进行数据的初始化操作。<br>如果开启了AOF，那么会优先从AOF文件中进行数据导入操作。如果没有开启AOF文件，才会去查找RDB文件。<code>loadDataFromDisk</code></p><h2 id="循环监听时间"><a href="#循环监听时间" class="headerlink" title="循环监听时间"></a>循环监听时间</h2><p>Redis服务主要运行函数为<code>aeMain()</code>。在函数中，是一个死循环操作。一旦监听的文件事件存在了可操作事件，就会进行处理逻辑流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line">aeMain(server.el);</span><br><span class="line">aeDeleteEventLoop(server.el);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文将基于Redis5.0 unstable版本介绍其在启动过程中所做的主要操作以及相关流程函数方法。&lt;br&gt;在此，先放上一张Redis初始化流程的大意图。&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1g9wqij4tmaj30a008edfz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>缓存雪崩穿透击穿介绍</title>
    <link href="http://yoursite.com/2019/12/15/new/Redis/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/12/15/new/Redis/缓存雪崩穿透击穿介绍/</id>
    <published>2019-12-14T16:40:24.000Z</published>
    <updated>2019-12-14T16:49:41.954Z</updated>
    
    <content type="html"><![CDATA[<p>看到这个标题，你肯定在想：什么是雪崩？什么是穿透？什么是击穿？怎么感觉都是一个意思，都是缓存失效导致的数据库压力问题。</p><p>这三个问题的确都会导致数据库压力问题，但是出现的场景还是存在区别滴。在处理手段上也有很大的区别。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>需要使用的热点数据都做了缓存，但是为了保证Redis的内存够用，所以会对一些数据进行设置过期时间操作。一般情况下存在定时任务去刷新缓存信息，这个时候就存在一个隐患的问题：假设在定时任务中设置的过期时间都一样，那么在某一个时间点时，大量的key同时过期。本来缓存抵挡住了大量的请求，key过期后，这些压力全部同时打到了数据库中，数据库可能就扛不住。直接被打挂了，重启数据库后，立马又被新的流量打挂了。这就是缓存雪崩。<br>(注：这里还有个隐患，Redis可能会频繁的处理过期key，从而导致Redis性能降低)<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wq4egoo5j30er0a6aao.jpg" alt=""></p><p>处理缓存雪崩主要有以下几个思路：</p><ol><li>分散过期时间。把每个key的过期时间都加上一个随机的过期值。保证数据不会在同一时间大面积失效。</li><li>设置过期标志更新缓存。给每一个缓存数据都增加一个相应的缓存标记，记录缓存是否失效。如果缓存失效，则更新数据缓存。这样虽然在缓存首次失效时，仍会带来数据库压力问题。但是能够在一定程度上缓解后续被新流量打挂以及所有服务不可用的情况。</li><li>在代码层面上设定一定策略，比如加锁等待、减慢请求速度。给数据库留下启动和重建缓存的机会。</li></ol><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透就是指客户端不断的查询缓存和数据库都没有的数据。相当于进行了两次无用的查询。降低缓存的命中率，增加数据库的压力。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wq4nqarcj30dx0ak751.jpg" alt=""></p><p>解决手段：</p><ol><li>客户端进行校验，先将明显不符合的key给过滤掉。</li><li>对于查询不到的数据，直接赋值一个null给它。</li><li>使用布隆过滤器来对不存在数据进行过滤掉。</li><li>限流。</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿和缓存雪崩有点像。但是又不一样，缓存雪崩是大面积的缓存同时失效，打崩了DB。而缓存击穿是指一个key非常热点，在不停的扛着大并发，当这个key失效的瞬间，持续的大并发就击穿缓存，直接请求数据库。</p><p>解决手段:<br>主要场景是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。<br>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到这个标题，你肯定在想：什么是雪崩？什么是穿透？什么是击穿？怎么感觉都是一个意思，都是缓存失效导致的数据库压力问题。&lt;/p&gt;
&lt;p&gt;这三个问题的确都会导致数据库压力问题，但是出现的场景还是存在区别滴。在处理手段上也有很大的区别。&lt;/p&gt;
&lt;h2 id=&quot;缓存雪崩&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="概念介绍" scheme="http://yoursite.com/tags/%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot整合SpringTask实现定时任务</title>
    <link href="http://yoursite.com/2019/07/26/SpringBoot/Spring-boot%E6%95%B4%E5%90%88SpringTask%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/07/26/SpringBoot/Spring-boot整合SpringTask实现定时任务/</id>
    <published>2019-07-26T07:45:09.000Z</published>
    <updated>2019-12-18T17:21:15.103Z</updated>
    
    <content type="html"><![CDATA[<p>SpringTask是Spring自主研发的一个定时任务工具，不需要引入其他依赖就可以使用。</p><h2 id="SpringTask-Cron语法"><a href="#SpringTask-Cron语法" class="headerlink" title="SpringTask Cron语法"></a>SpringTask Cron语法</h2><p>类似于shell中的<code>crontab</code>，只不过最前面多了一个<code>Seconds</code>秒级别。<br>Seconds Minutes Hours DayofMonth Month DayofWeek</p><table><thead><tr><th>时间元素</th><th>可出现的字符</th><th>数值范围</th></tr></thead><tbody><tr><td>Seconds</td><td>,-*/</td><td>0-59</td></tr><tr><td>Minutes</td><td>,-*/</td><td>0-59</td></tr><tr><td>Hours</td><td>,-*/</td><td>0-23</td></tr><tr><td>Day of Month</td><td>,-*/?LW</td><td>0-31</td></tr><tr><td>Month</td><td>,-*/</td><td>1-12</td></tr><tr><td>Day of Week</td><td>,-*/?L#</td><td>1-7</td></tr></tbody></table><ul><li>“,” 列出枚举值</li><li>“-“ 触发范围</li><li>“*” 任意值</li><li>“/“ 每隔一段时间执行</li><li>“?” 任意值</li><li>“#” 确定第几个星期几</li><li>“L” 表示最后的有效值</li><li>“W” 表示有效工作日<a id="more"></a><h2 id="整合使用SpringTask"><a href="#整合使用SpringTask" class="headerlink" title="整合使用SpringTask"></a>整合使用SpringTask</h2>因为SpringTask已经存在于Spring框架中，所有不需要引入任何依赖。<br>只需要在配置类中添加一个<code>@EnableScheduling</code>注解就可以开启SpringTask的定时任务功能。<br>然后可以通过在方法上增加<code>@Scheduled</code>注解配置定时任务。或者通过代码动态创建定时任务。</li></ul><h3 id="通过spring-boot注解实现"><a href="#通过spring-boot注解实现" class="headerlink" title="通过spring boot注解实现"></a>通过spring boot注解实现</h3><p>在Spring boot的主类或者配置类中加入<code>@EnableScheduling</code>注解，启动定时任务的配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class SpringbootApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建定时任务实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringTaskDemo &#123;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span><br><span class="line">    public void printHello()&#123;</span><br><span class="line">        System.out.println(&quot;scheduled is running.........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态创建定时任务"><a href="#动态创建定时任务" class="headerlink" title="动态创建定时任务"></a>动态创建定时任务</h3><p>使用注解的方式，无法实现动态的修改、添加、关闭定时任务。这个时候就需要使用编程的方式进行任务的更新操作了。可以使用<code>ThreadPoolTaskScheduler</code>或<code>SchedulingConfigurer</code>接口来创建自定义定时任务。</p><p><strong>SchedulingConfigurer</strong><br>通过实现<code>SchedulingConfigurer</code>接口，重写<code>configureTasks</code>方法添加定时任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ScheduleConfig implements SchedulingConfigurer &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line">taskRegistrar.setTaskScheduler(taskScheduler());</span><br><span class="line"></span><br><span class="line">taskRegistrar.getScheduler().schedule(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;|SchedulingConfigurer cron task01&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, new CronTrigger(&quot;0/3 * * * * ?&quot;));</span><br><span class="line"></span><br><span class="line">taskRegistrar.addCronTask(new CronTask(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;|SchedulingConfigurer cron task02&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, new CronTrigger(&quot;0/2 * * * * ?&quot;)));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Bean</span><br><span class="line">public TaskScheduler taskScheduler() &#123;</span><br><span class="line">ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();</span><br><span class="line">taskScheduler.setPoolSize(10);</span><br><span class="line">taskScheduler.setThreadNamePrefix(&quot;spring-task-scheduler-thread-&quot;);</span><br><span class="line">taskScheduler.setAwaitTerminationSeconds(60);</span><br><span class="line">taskScheduler.setWaitForTasksToCompleteOnShutdown(true);</span><br><span class="line">taskScheduler.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">return taskScheduler;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><hr><p><code>ThreadPoolTaskScheduler</code>是Spring Task的核心实现类，该类提供了大量的重载方法进行任务调度。首先配置一个自定义任务调度线程池<code>ThreadPoolTaskScheduler</code>，然后调用<code>schedule</code>等方法对定时任务进行动态管理操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/task&quot;)</span><br><span class="line">public class SpringTaskDemo&#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ThreadPoolTaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    private ScheduledFuture&lt;?&gt; scheduledFuture;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;timing-task.cron1&#125;&quot;)</span><br><span class="line">    private String cronStr1;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;timing-task.cron2&#125;&quot;)</span><br><span class="line">    private String cronStr2;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/start&quot;)</span><br><span class="line">    public String startTask() &#123;</span><br><span class="line">        scheduledFuture = taskScheduler.schedule(new RunTask01(), new Trigger() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Date nextExecutionTime(TriggerContext triggerContext) &#123;</span><br><span class="line">                return new CronTrigger(cronStr1).nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(&quot;start timed task success ..&quot;);</span><br><span class="line">        return &quot;start task suceess&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/stop&quot;)</span><br><span class="line">    public String stopTask() &#123;</span><br><span class="line">        Boolean result = null;</span><br><span class="line">        if (scheduledFuture != null) &#123;</span><br><span class="line">            result = scheduledFuture.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;stop timed task result: &quot; + result);</span><br><span class="line">        return &quot;stop task result: &quot; + result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/modify&quot;)</span><br><span class="line">    public String modifyTask() &#123;</span><br><span class="line">        Boolean stopResult = null;</span><br><span class="line">        // 停止定时任务</span><br><span class="line">        if (scheduledFuture != null) &#123;</span><br><span class="line">            stopResult = scheduledFuture.cancel(true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;modify task error -&gt; scheduledFuture is null&quot;);</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 更换cron重新开启定时任务</span><br><span class="line">        if (stopResult) &#123;</span><br><span class="line">            scheduledFuture = taskScheduler.schedule(new RunTask01(), new Trigger() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Date nextExecutionTime(TriggerContext triggerContext) &#123;</span><br><span class="line">                    return new CronTrigger(cronStr2).nextExecutionTime(triggerContext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            log.info(&quot;modify task success ..&quot;);</span><br><span class="line">            return &quot;success&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;modify task failed ..&quot;);</span><br><span class="line">        return &quot;failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class RunTask01 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            log.info(Thread.currentThread().getName() + &quot;|schedule task01&quot; + &quot;|&quot; + new Date().toLocaleString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class RunTask02 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            log.info(Thread.currentThread().getName() + &quot;|schedule task02&quot; + &quot;|&quot; + new Date().toLocaleString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringTask是Spring自主研发的一个定时任务工具，不需要引入其他依赖就可以使用。&lt;/p&gt;
&lt;h2 id=&quot;SpringTask-Cron语法&quot;&gt;&lt;a href=&quot;#SpringTask-Cron语法&quot; class=&quot;headerlink&quot; title=&quot;SpringTask Cron语法&quot;&gt;&lt;/a&gt;SpringTask Cron语法&lt;/h2&gt;&lt;p&gt;类似于shell中的&lt;code&gt;crontab&lt;/code&gt;，只不过最前面多了一个&lt;code&gt;Seconds&lt;/code&gt;秒级别。&lt;br&gt;Seconds Minutes Hours DayofMonth Month DayofWeek&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间元素&lt;/th&gt;
&lt;th&gt;可出现的字符&lt;/th&gt;
&lt;th&gt;数值范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Seconds&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;0-59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Minutes&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;0-59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hours&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;0-23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Day of Month&lt;/td&gt;
&lt;td&gt;,-*/?LW&lt;/td&gt;
&lt;td&gt;0-31&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Month&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;1-12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Day of Week&lt;/td&gt;
&lt;td&gt;,-*/?L#&lt;/td&gt;
&lt;td&gt;1-7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;“,” 列出枚举值&lt;/li&gt;
&lt;li&gt;“-“ 触发范围&lt;/li&gt;
&lt;li&gt;“*” 任意值&lt;/li&gt;
&lt;li&gt;“/“ 每隔一段时间执行&lt;/li&gt;
&lt;li&gt;“?” 任意值&lt;/li&gt;
&lt;li&gt;“#” 确定第几个星期几&lt;/li&gt;
&lt;li&gt;“L” 表示最后的有效值&lt;/li&gt;
&lt;li&gt;“W” 表示有效工作日
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
  </entry>
  
</feed>

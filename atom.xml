<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OMG_By</title>
  
  <subtitle>你走与不走，路就在那里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-26T12:18:03.795Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OMG_By</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析GeoHash</title>
    <link href="http://yoursite.com/2019/12/26/new/%E6%B5%85%E6%9E%90GeoHash/"/>
    <id>http://yoursite.com/2019/12/26/new/浅析GeoHash/</id>
    <published>2019-12-26T12:16:58.000Z</published>
    <updated>2019-12-26T12:18:03.795Z</updated>
    
    <content type="html"><![CDATA[<p>GeoHash算法能够将二维的经纬度转换成字符串。主要有以下几个特性:</p><ol><li>每一个字符串代表了某一矩形区域.</li><li>字符串的长度越长，所表示的位置越精确。</li><li>字符串越相近的表示的举例越接近.</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>GeoHash将经纬度转换为hash字符串主要分为三步：</p><ol><li>将纬度(-90, 90)平均分成两个区间(-90, 0)、(0, 90)，如果坐标位置的纬度值在第一区间，则编码是0，否则编码为1</li><li>经纬度的编码合并，从0开始，奇数为是纬度，偶数为是经度</li><li>对经纬度合并后的编码，进行base32编码</li></ol><p>大概过程如下图，不断的对经纬度进行切割，直到精准度达到要求。<br><img src="https://user-gold-cdn.xitu.io/2018/7/4/1646397a223e2019?imageslim" alt="IMAGE"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote><p>将经纬度转换成二进制编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void convert(double min, double max, double value, List&lt;Character&gt; list) &#123;</span><br><span class="line">        if (list.size() &gt; (length - 1)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        double mid = (max + min) / 2;</span><br><span class="line">        if (value &lt; mid) &#123;</span><br><span class="line">            list.add(&apos;0&apos;);</span><br><span class="line">            convert(min, mid, value, list);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            list.add(&apos;1&apos;);</span><br><span class="line">            convert(mid, max, value, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><blockquote><p>合并经纬度的二进制编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Character&gt; latList = new ArrayList&lt;Character&gt;();</span><br><span class="line">List&lt;Character&gt; lngList = new ArrayList&lt;Character&gt;();</span><br><span class="line">convert(Min_Lat, Max_Lat, lat, latList);</span><br><span class="line">convert(Min_Lng, Max_Lng, lng, lngList);</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">for (int index = 0; index &lt; latList.size(); index++) &#123;</span><br><span class="line">    sb.append(lngList.get(index)).append(latList.get(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>base32编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private final String[] base32Lookup =</span><br><span class="line">            &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;,</span><br><span class="line">                    &quot;j&quot;, &quot;k&quot;, &quot;m&quot;, &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#125;;</span><br><span class="line">    private String base32Encode(final String str) &#123;</span><br><span class="line">        String unit = &quot;&quot;;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int start = 0; start &lt; str.length(); start = start + 5) &#123;</span><br><span class="line">            unit = str.substring(start, start + 5);</span><br><span class="line">            sb.append(base32Lookup[convertToIndex(unit.split(&quot;&quot;))]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    private int convertToIndex(String str) &#123;</span><br><span class="line">        int length = str.length();</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int index = 0; index &lt; length; index++) &#123;</span><br><span class="line">            result += str.charAt(index) == &apos;0&apos; ? 0 : 1 &lt;&lt; (length - 1 - index);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="Redis中的Geo使用"><a href="#Redis中的Geo使用" class="headerlink" title="Redis中的Geo使用"></a>Redis中的Geo使用</h2><p>在Redis中，Geo的内部结构实际上是一个zset。<br>Redis提供给Geo指定只有6个，但是它可以使用zset的所有指令。</p><h3 id="增加-geoadd"><a href="#增加-geoadd" class="headerlink" title="增加-geoadd"></a>增加-geoadd</h3><p>geoadd指令传入多个经纬度名称三元组，Redis内存会调用函数计算出相应的geohash字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd company 116.48105 39.996794 juejin</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.514203 39.905409 ireader</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.489033 40.007669 meituan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p><h3 id="距离-geodist"><a href="#距离-geodist" class="headerlink" title="距离-geodist"></a>距离-geodist</h3><p>geodist 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist company juejin ireader km</span><br><span class="line">&quot;10.5501&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin meituan km</span><br><span class="line">&quot;1.3878&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin jd km</span><br><span class="line">&quot;24.2739&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin xiaomi km</span><br><span class="line">&quot;12.9606&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin juejin km</span><br><span class="line">&quot;0.0000&quot;</span><br></pre></td></tr></table></figure></p><h3 id="获取元素位置-geopos"><a href="#获取元素位置-geopos" class="headerlink" title="获取元素位置-geopos"></a>获取元素位置-geopos</h3><p>geopos 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos company juejin</span><br><span class="line">1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">   2) &quot;39.99679348858259686&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company ireader</span><br><span class="line">1) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">   2) &quot;39.90540918662494363&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company juejin ireader</span><br><span class="line">1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">   2) &quot;39.99679348858259686&quot;</span><br><span class="line">2) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">   2) &quot;39.90540918662494363&quot;</span><br></pre></td></tr></table></figure></p><h3 id="获取元素的-hash-值-geohash"><a href="#获取元素的-hash-值-geohash" class="headerlink" title="获取元素的 hash 值-geohash"></a>获取元素的 hash 值-geohash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash company ireader</span><br><span class="line">1) &quot;wx4g52e1ce0&quot;</span><br><span class="line">127.0.0.1:6379&gt; geohash company juejin</span><br><span class="line">1) &quot;wx4gd94yjn0&quot;</span><br></pre></td></tr></table></figure><h3 id="附近元素-georadiusbymember"><a href="#附近元素-georadiusbymember" class="headerlink" title="附近元素-georadiusbymember"></a>附近元素-georadiusbymember</h3><p>georadiusbymember 指令是最为关键的指令，它可以用来查询指定元素附近的其它元素，它的参数非常复杂。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 asc</span><br><span class="line">1) &quot;ireader&quot;</span><br><span class="line">2) &quot;juejin&quot;</span><br><span class="line">3) &quot;meituan&quot;</span><br><span class="line"># 范围 20 公里以内最多 3 个元素按距离倒排</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 desc</span><br><span class="line">1) &quot;jd&quot;</span><br><span class="line">2) &quot;meituan&quot;</span><br><span class="line">3) &quot;juejin&quot;</span><br><span class="line"># 三个可选参数 withcoord withdist withhash 用来携带附加参数</span><br><span class="line"># withdist 很有用，它可以用来显示距离</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc</span><br><span class="line">1) 1) &quot;ireader&quot;</span><br><span class="line">   2) &quot;0.0000&quot;</span><br><span class="line">   3) (integer) 4069886008361398</span><br><span class="line">   4) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">      2) &quot;39.90540918662494363&quot;</span><br><span class="line">2) 1) &quot;juejin&quot;</span><br><span class="line">   2) &quot;10.5501&quot;</span><br><span class="line">   3) (integer) 4069887154388167</span><br><span class="line">   4) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">      2) &quot;39.99679348858259686&quot;</span><br><span class="line">3) 1) &quot;meituan&quot;</span><br><span class="line">   2) &quot;11.5748&quot;</span><br><span class="line">   3) (integer) 4069887179083478</span><br><span class="line">   4) 1) &quot;116.48903220891952515&quot;</span><br><span class="line">      2) &quot;40.00766997707732031&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GeoHash算法能够将二维的经纬度转换成字符串。主要有以下几个特性:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每一个字符串代表了某一矩形区域.&lt;/li&gt;
&lt;li&gt;字符串的长度越长，所表示的位置越精确。&lt;/li&gt;
&lt;li&gt;字符串越相近的表示的举例越接近.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;GeoHash将经纬度转换为hash字符串主要分为三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将纬度(-90, 90)平均分成两个区间(-90, 0)、(0, 90)，如果坐标位置的纬度值在第一区间，则编码是0，否则编码为1&lt;/li&gt;
&lt;li&gt;经纬度的编码合并，从0开始，奇数为是纬度，偶数为是经度&lt;/li&gt;
&lt;li&gt;对经纬度合并后的编码，进行base32编码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大概过程如下图，不断的对经纬度进行切割，直到精准度达到要求。&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/4/1646397a223e2019?imageslim&quot; alt=&quot;IMAGE&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;将经纬度转换成二进制编码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void convert(double min, double max, double value, List&amp;lt;Character&amp;gt; list) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (list.size() &amp;gt; (length - 1)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        double mid = (max + min) / 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (value &amp;lt; mid) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            list.add(&amp;apos;0&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            convert(min, mid, value, list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            list.add(&amp;apos;1&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            convert(mid, max, value, list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis4.0的大key发现和删除</title>
    <link href="http://yoursite.com/2019/12/19/new/Redis4.0%E7%9A%84%E5%A4%A7key%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2019/12/19/new/Redis4.0的大key发现和删除/</id>
    <published>2019-12-18T17:22:47.000Z</published>
    <updated>2019-12-18T17:25:03.941Z</updated>
    
    <content type="html"><![CDATA[<p>Redis4.0版本之后引入了memory usage命令和lazyfree机制。不管是对大key的发现，还是解决删除大key造成的阻塞问题都有了很大的提升。</p><h3 id="大key发现"><a href="#大key发现" class="headerlink" title="大key发现"></a>大key发现</h3><p>memory usage的实现主要在<code>object.c-&gt;memoryCommand</code>方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;memory&quot;,memoryCommand,-2,</span><br><span class="line">     &quot;random read-only&quot;,</span><br><span class="line">     0,NULL,0,0,0,0,0,0&#125;,</span><br><span class="line">     </span><br><span class="line">else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;usage&quot;) &amp;&amp; c-&gt;argc &gt;= 3) &#123;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;</span><br><span class="line">        for (int j = 3; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">            if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;samples&quot;) &amp;&amp;</span><br><span class="line">                j+1 &lt; c-&gt;argc)</span><br><span class="line">            &#123;</span><br><span class="line">                if (getLongLongFromObjectOrReply(c,c-&gt;argv[j+1],&amp;samples,NULL)</span><br><span class="line">                     == C_ERR) return;</span><br><span class="line">                if (samples &lt; 0) &#123;</span><br><span class="line">                    addReply(c,shared.syntaxerr);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (samples == 0) samples = LLONG_MAX;;</span><br><span class="line">                j++; /* skip option argument. */</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                addReply(c,shared.syntaxerr);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((de = dictFind(c-&gt;db-&gt;dict,c-&gt;argv[2]-&gt;ptr)) == NULL) &#123;</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        size_t usage = objectComputeSize(dictGetVal(de),samples);</span><br><span class="line">        usage += sdsAllocSize(dictGetKey(de));</span><br><span class="line">        usage += sizeof(dictEntry);</span><br><span class="line">        addReplyLongLong(c,usage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>我们可以看到计算使用内存大小核心逻辑是在<code>objectComputeSize</code>函数中，对不同类型的键值计算方式不一样，这里以hash类型举例。<br>在使用<code>memory usage</code>命令时可以指定一个抽样元素个数。默认为5，决定了内存计算的准确性和计算成本。<br>这个值越大，循环次数越多，计算结果越精准，性能损耗也越高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*...代码对数据类型进行了分类，此处只取hash类型说明*/</span><br><span class="line">    /*...*/</span><br><span class="line">        /*循环抽样个field，累加获取抽样样本内存值，默认抽样样本为5*/</span><br><span class="line">        while((de = dictNext(di)) != NULL &amp;&amp; samples &lt; sample_size) &#123;</span><br><span class="line">            ele = dictGetKey(de);</span><br><span class="line">            ele2 = dictGetVal(de);</span><br><span class="line">            elesize += sdsAllocSize(ele) + sdsAllocSize(ele2);</span><br><span class="line">            elesize += sizeof(struct dictEntry);</span><br><span class="line">            samples++;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        /*根据上一步计算的抽样样本内存值除以样本量，再乘以总的filed个数计算总内存值*/</span><br><span class="line">        if (samples) asize += (double)elesize/samples*dictSize(d);</span><br><span class="line">    /*...*/</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="lazyfree"><a href="#lazyfree" class="headerlink" title="lazyfree"></a>lazyfree</h3><p>在Redis4.0版本中，新增了一个删除命令<code>unlink</code>。实现了懒删除方式，减少了在删除大key时引起的阻塞影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;unlink&quot;,unlinkCommand,-2,</span><br><span class="line">     &quot;write fast @keyspace&quot;,</span><br><span class="line">     0,NULL,1,-1,1,0,0,0&#125;,</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">void unlinkCommand(client *c) &#123;</span><br><span class="line">    delGenericCommand(c,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* This command implements DEL and LAZYDEL. */</span><br><span class="line">void delGenericCommand(client *c, int lazy) &#123;</span><br><span class="line">    int numdel = 0, j;</span><br><span class="line"></span><br><span class="line">    for (j = 1; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        int deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        if (deleted) &#123;</span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                &quot;del&quot;,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看出，<code>del</code>和<code>unlink</code>命令调用的都是<code>delGenericCommand</code>方法。区别主要在于第二个参数，是否为懒删除标记。<br>如果是懒删除，调用的是异步删除方法<code>dbAsyncDelete</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/* Delete a key, value, and associated expiration entry if any, from the DB.</span><br><span class="line"> * If there are enough allocations to free the value object may be put into</span><br><span class="line"> * a lazy free list instead of being freed synchronously. The lazy free list</span><br><span class="line"> * will be reclaimed in a different bio.c thread. */</span><br><span class="line">#define LAZYFREE_THRESHOLD 64</span><br><span class="line">int dbAsyncDelete(redisDb *db, robj *key) &#123;</span><br><span class="line">    /* Deleting an entry from the expires dict will not free the sds of</span><br><span class="line">     * the key, because it is shared with the main dictionary. */</span><br><span class="line">    if (dictSize(db-&gt;expires) &gt; 0) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    /* If the value is composed of a few allocations, to free in a lazy way</span><br><span class="line">     * is actually just slower... So under a certain limit we just free</span><br><span class="line">     * the object synchronously. */</span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        /*lazyfreeGetFreeEffort来获取val对象所包含的元素个数*/</span><br><span class="line">        size_t free_effort = lazyfreeGetFreeEffort(val);</span><br><span class="line"></span><br><span class="line">        /* If releasing the object is too much work, do it in the background</span><br><span class="line">         * by adding the object to the lazy free list.</span><br><span class="line">         * Note that if the object is shared, to reclaim it now it is not</span><br><span class="line">         * possible. This rarely happens, however sometimes the implementation</span><br><span class="line">         * of parts of the Redis core may call incrRefCount() to protect</span><br><span class="line">         * objects, and then call dbDelete(). In this case we&apos;ll fall</span><br><span class="line">         * through and reach the dictFreeUnlinkedEntry() call, that will be</span><br><span class="line">         * equivalent to just calling decrRefCount(). */</span><br><span class="line">        /* 对删除key进行判断，满足阈值条件时进行后台删除 */</span><br><span class="line">        if (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == 1) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,1);</span><br><span class="line">            /*将删除对象放入BIO_LAZY_FREE后台线程任务队列*/</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,NULL,NULL);</span><br><span class="line">            /*将第一步获取到的val值设置为null*/</span><br><span class="line">            dictSetVal(db-&gt;dict,de,NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Release the key-val pair, or just the key if we set the val</span><br><span class="line">     * field to NULL in order to lazy free it later. */</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        if (server.cluster_enabled) slotToKeyDel(key);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数实现中可以看出，Redis并不是单纯的将所有懒删除操作都放后台线程中进行。而是会先对需要懒删除的key进行判断，不满足条件的key将会直接进行删除操作。<br>只有满足条件的key才放入到后台线程任务处理队列中。并且立即将其value设置为NULL，避免造成脏读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">else if (type == BIO_LAZY_FREE) &#123;</span><br><span class="line">           /* What we free changes depending on what arguments are set:</span><br><span class="line">            * arg1 -&gt; free the object at pointer.</span><br><span class="line">            * arg2 &amp; arg3 -&gt; free two dictionaries (a Redis DB).</span><br><span class="line">            * only arg3 -&gt; free the skiplist. */</span><br><span class="line">           if (job-&gt;arg1)</span><br><span class="line">               lazyfreeFreeObjectFromBioThread(job-&gt;arg1);</span><br><span class="line">           else if (job-&gt;arg2 &amp;&amp; job-&gt;arg3)</span><br><span class="line">               lazyfreeFreeDatabaseFromBioThread(job-&gt;arg2,job-&gt;arg3);</span><br><span class="line">           else if (job-&gt;arg3)</span><br><span class="line">               lazyfreeFreeSlotsMapFromBioThread(job-&gt;arg3);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis4.0版本之后引入了memory usage命令和lazyfree机制。不管是对大key的发现，还是解决删除大key造成的阻塞问题都有了很大的提升。&lt;/p&gt;
&lt;h3 id=&quot;大key发现&quot;&gt;&lt;a href=&quot;#大key发现&quot; class=&quot;headerlink&quot; title=&quot;大key发现&quot;&gt;&lt;/a&gt;大key发现&lt;/h3&gt;&lt;p&gt;memory usage的实现主要在&lt;code&gt;object.c-&amp;gt;memoryCommand&lt;/code&gt;方法中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;quot;memory&amp;quot;,memoryCommand,-2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;quot;random read-only&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     0,NULL,0,0,0,0,0,0&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else if (!strcasecmp(c-&amp;gt;argv[1]-&amp;gt;ptr,&amp;quot;usage&amp;quot;) &amp;amp;&amp;amp; c-&amp;gt;argc &amp;gt;= 3) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dictEntry *de;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int j = 3; j &amp;lt; c-&amp;gt;argc; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (!strcasecmp(c-&amp;gt;argv[j]-&amp;gt;ptr,&amp;quot;samples&amp;quot;) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j+1 &amp;lt; c-&amp;gt;argc)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (getLongLongFromObjectOrReply(c,c-&amp;gt;argv[j+1],&amp;amp;samples,NULL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     == C_ERR) return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (samples &amp;lt; 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    addReply(c,shared.syntaxerr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (samples == 0) samples = LLONG_MAX;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j++; /* skip option argument. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                addReply(c,shared.syntaxerr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ((de = dictFind(c-&amp;gt;db-&amp;gt;dict,c-&amp;gt;argv[2]-&amp;gt;ptr)) == NULL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            addReplyNull(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        size_t usage = objectComputeSize(dictGetVal(de),samples);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        usage += sdsAllocSize(dictGetKey(de));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        usage += sizeof(dictEntry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        addReplyLongLong(c,usage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis初始化启动过程</title>
    <link href="http://yoursite.com/2019/12/15/new/Redis%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/12/15/new/Redis初始化启动过程/</id>
    <published>2019-12-14T17:48:31.000Z</published>
    <updated>2019-12-14T17:49:05.175Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文将基于Redis5.0 unstable版本介绍其在启动过程中所做的主要操作以及相关流程函数方法。<br>在此，先放上一张Redis初始化流程的大意图。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wqij4tmaj30a008edfz.jpg" alt=""></p><a id="more"></a><p>Redis的启动函数位于<code>server.c</code>文件main方法下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    int j;</span><br><span class="line">#ifdef REDIS_TEST</span><br><span class="line">    if (argc == 3 &amp;&amp; !strcasecmp(argv[1], &quot;test&quot;)) &#123;</span><br><span class="line">        if (!strcasecmp(argv[2], &quot;ziplist&quot;)) &#123;</span><br><span class="line">            return ziplistTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;quicklist&quot;)) &#123;</span><br><span class="line">            quicklistTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;intset&quot;)) &#123;</span><br><span class="line">            return intsetTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;zipmap&quot;)) &#123;</span><br><span class="line">            return zipmapTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;sha1test&quot;)) &#123;</span><br><span class="line">            return sha1Test(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;util&quot;)) &#123;</span><br><span class="line">            return utilTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;sds&quot;)) &#123;</span><br><span class="line">            return sdsTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;endianconv&quot;)) &#123;</span><br><span class="line">            return endianconvTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;crc64&quot;)) &#123;</span><br><span class="line">            return crc64Test(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;zmalloc&quot;)) &#123;</span><br><span class="line">            return zmalloc_test(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1; /* test not found */</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* We need to initialize our libraries, and the server configuration. */</span><br><span class="line">#ifdef INIT_SETPROCTITLE_REPLACEMENT</span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line">#endif</span><br><span class="line">    setlocale(LC_COLLATE,&quot;&quot;);</span><br><span class="line">    tzset(); /* Populates &apos;timezone&apos; global. */</span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(NULL)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,NULL);</span><br><span class="line"></span><br><span class="line">    char hashseed[16];</span><br><span class="line">    getRandomHexChars(hashseed,sizeof(hashseed));</span><br><span class="line">    dictSetHashFunctionSeed((uint8_t*)hashseed);</span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">    initServerConfig();</span><br><span class="line">    ACLInit(); /* The ACL subsystem must be initialized ASAP because the</span><br><span class="line">                  basic networking code and client creation depends on it. */</span><br><span class="line">    moduleInitModulesSystem();</span><br><span class="line"></span><br><span class="line">    /* Store the executable path and arguments in a safe place in order</span><br><span class="line">     * to be able to restart the server later. */</span><br><span class="line">    server.executable = getAbsolutePath(argv[0]);</span><br><span class="line">    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</span><br><span class="line">    server.exec_argv[argc] = NULL;</span><br><span class="line">    for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br><span class="line"></span><br><span class="line">    /* We need to init sentinel right now as parsing the configuration file</span><br><span class="line">     * in sentinel mode will have the effect of populating the sentinel</span><br><span class="line">     * data structures with master nodes to monitor. */</span><br><span class="line">    if (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig();</span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Check if we need to start in redis-check-rdb/aof mode. We just execute</span><br><span class="line">     * the program main. However the program is part of the Redis executable</span><br><span class="line">     * so that we can easily execute an RDB check on loading errors. */</span><br><span class="line">    if (strstr(argv[0],&quot;redis-check-rdb&quot;) != NULL)</span><br><span class="line">        redis_check_rdb_main(argc,argv,NULL);</span><br><span class="line">    else if (strstr(argv[0],&quot;redis-check-aof&quot;) != NULL)</span><br><span class="line">        redis_check_aof_main(argc,argv);</span><br><span class="line"></span><br><span class="line">    if (argc &gt;= 2) &#123;</span><br><span class="line">        j = 1; /* First option to parse in argv[] */</span><br><span class="line">        sds options = sdsempty();</span><br><span class="line">        char *configfile = NULL;</span><br><span class="line"></span><br><span class="line">        /* Handle special options --help and --version */</span><br><span class="line">        if (strcmp(argv[1], &quot;-v&quot;) == 0 ||</span><br><span class="line">            strcmp(argv[1], &quot;--version&quot;) == 0) version();</span><br><span class="line">        if (strcmp(argv[1], &quot;--help&quot;) == 0 ||</span><br><span class="line">            strcmp(argv[1], &quot;-h&quot;) == 0) usage();</span><br><span class="line">        if (strcmp(argv[1], &quot;--test-memory&quot;) == 0) &#123;</span><br><span class="line">            if (argc == 3) &#123;</span><br><span class="line">                memtest(atoi(argv[2]),50);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fprintf(stderr,&quot;Please specify the amount of memory to test in megabytes.\n&quot;);</span><br><span class="line">                fprintf(stderr,&quot;Example: ./redis-server --test-memory 4096\n\n&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* First argument is the config file name? */</span><br><span class="line">        if (argv[j][0] != &apos;-&apos; || argv[j][1] != &apos;-&apos;) &#123;</span><br><span class="line">            configfile = argv[j];</span><br><span class="line">            server.configfile = getAbsolutePath(configfile);</span><br><span class="line">            /* Replace the config file in server.exec_argv with</span><br><span class="line">             * its absolute path. */</span><br><span class="line">            zfree(server.exec_argv[j]);</span><br><span class="line">            server.exec_argv[j] = zstrdup(server.configfile);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* All the other options are parsed and conceptually appended to the</span><br><span class="line">         * configuration file. For instance --port 6380 will generate the</span><br><span class="line">         * string &quot;port 6380\n&quot; to be parsed after the actual file name</span><br><span class="line">         * is parsed, if any. */</span><br><span class="line">        while(j != argc) &#123;</span><br><span class="line">            if (argv[j][0] == &apos;-&apos; &amp;&amp; argv[j][1] == &apos;-&apos;) &#123;</span><br><span class="line">                /* Option name */</span><br><span class="line">                if (!strcmp(argv[j], &quot;--check-rdb&quot;)) &#123;</span><br><span class="line">                    /* Argument has no options, need to skip for parsing. */</span><br><span class="line">                    j++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (sdslen(options)) options = sdscat(options,&quot;\n&quot;);</span><br><span class="line">                options = sdscat(options,argv[j]+2);</span><br><span class="line">                options = sdscat(options,&quot; &quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* Option argument */</span><br><span class="line">                options = sdscatrepr(options,argv[j],strlen(argv[j]));</span><br><span class="line">                options = sdscat(options,&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == &apos;-&apos;) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Sentinel config from STDIN not allowed.&quot;);</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Sentinel needs config file on disk to save state.  Exiting...&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        resetServerSaveParams();</span><br><span class="line">        loadServerConfig(configfile,options);</span><br><span class="line">        sdsfree(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_WARNING, &quot;oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo&quot;);</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        &quot;Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started&quot;,</span><br><span class="line">            REDIS_VERSION,</span><br><span class="line">            (sizeof(long) == 8) ? 64 : 32,</span><br><span class="line">            redisGitSHA1(),</span><br><span class="line">            strtol(redisGitDirty(),NULL,10) &gt; 0,</span><br><span class="line">            (int)getpid());</span><br><span class="line"></span><br><span class="line">    if (argc == 1) &#123;</span><br><span class="line">        serverLog(LL_WARNING, &quot;Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf&quot;, argv[0], server.sentinel_mode ? &quot;sentinel&quot; : &quot;redis&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        serverLog(LL_WARNING, &quot;Configuration loaded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line">    int background = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line">    if (background) daemonize();</span><br><span class="line"></span><br><span class="line">    initServer();</span><br><span class="line">    if (background || server.pidfile) createPidFile();</span><br><span class="line">    redisSetProcTitle(argv[0]);</span><br><span class="line">    redisAsciiArt();</span><br><span class="line">    checkTcpBacklogSettings();</span><br><span class="line"></span><br><span class="line">    if (!server.sentinel_mode) &#123;</span><br><span class="line">        /* Things not needed when running in Sentinel mode. */</span><br><span class="line">        serverLog(LL_WARNING,&quot;Server initialized&quot;);</span><br><span class="line">    #ifdef __linux__</span><br><span class="line">        linuxMemoryWarnings();</span><br><span class="line">    #endif</span><br><span class="line">        moduleLoadFromQueue();</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        if (server.cluster_enabled) &#123;</span><br><span class="line">            if (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    &quot;You can&apos;t have keys in a DB different than DB 0 when in &quot;</span><br><span class="line">                    &quot;Cluster mode. Exiting.&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (server.ipfd_count &gt; 0)</span><br><span class="line">            serverLog(LL_NOTICE,&quot;Ready to accept connections&quot;);</span><br><span class="line">        if (server.sofd &gt; 0)</span><br><span class="line">            serverLog(LL_NOTICE,&quot;The server is now ready to accept connections at %s&quot;, server.unixsocket);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Warning the user about suspicious maxmemory setting. */</span><br><span class="line">    if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) &#123;</span><br><span class="line">        serverLog(LL_WARNING,&quot;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&quot;, server.maxmemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">    aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="初始化默认状态"><a href="#初始化默认状态" class="headerlink" title="初始化默认状态"></a>初始化默认状态</h2><p>我们可以看到在main方法中，进行的第一步操作就是初始化默认配置<code>initServerConfig</code>。有很多初始化操作都需要设置了一些默认配置后才能够继续进行的。</p><p>在这一阶段中进行初始化的主要有：</p><ul><li>Redis server的状态默认值</li><li>Redis服务运行的默认参数配置</li><li>复制参数配置</li><li>客户端输入输出缓冲区设置</li><li>部分命令参数初始化</li><li>slow log初始化</li></ul><p>为什么需要先对部分命令进行初始化：<br>因为这一部分命令是Redis对外提供服务之前时，就需要先调用的，所以必须先进行初始化。而其他非必须的命令此时仍未进行初始化。</p><h2 id="权限初始化"><a href="#权限初始化" class="headerlink" title="权限初始化"></a>权限初始化</h2><p>用户这个概念，是Redis在6.0版本中提出的。虽然还未正式投入线上使用，但是已经在unstable版本中开始投入开发。<br><code>ACLInit()</code>这个方法非常简单，只会初始化一个拥有所有权限的默认用户。</p><h2 id="初始化模块系统"><a href="#初始化模块系统" class="headerlink" title="初始化模块系统"></a>初始化模块系统</h2><p>模块系统，是Redis4.0版本中推出的一个新特性，它允许用户自己编写适合于自己的模块，并以插件的形式导入到Redis当中。<br>通过<code>moduleInitModulesSystem()</code>方法，创建模块系统所需要数据结构和资源。</p><h2 id="解析命令行参数以及读取配置"><a href="#解析命令行参数以及读取配置" class="headerlink" title="解析命令行参数以及读取配置"></a>解析命令行参数以及读取配置</h2><p>在启动Redis的时候，是允许用户在命令行中指定Redis运行的模式和参数。<br>将配置文件和运行时参数等信息通过遍历的方式确认后，调用<code>loadServerConfig</code>方法，将运行时参数写入到配置文件中。如果没有指定配置文件，就会使用默认的配置文件来运行服务。</p><p>最终会通过<code>initServer</code>方法来初始化参数配置。<br>这个方法主要会做以下的一些初始化操作：</p><ul><li>初始化共享对象<code>createSharedObjects</code></li><li>检查系统参数配置<code>adjustOpenFilesLimit</code></li><li>开启端口监听</li><li>创建事件监听和时间监听文件句柄</li><li>创建数据库并初始化状态<br>在这个方法中创建创建文件驱动和时间驱动的监听句柄。并且会进行以下的一些初始数据的初始化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (server.cluster_enabled) clusterInit();</span><br><span class="line">replicationScriptCacheInit();</span><br><span class="line">scriptingInit(1);</span><br><span class="line">slowlogInit();</span><br><span class="line">latencyMonitorInit();</span><br><span class="line">bioInit();</span><br><span class="line">server.initial_memory_usage = zmalloc_used_memory();</span><br></pre></td></tr></table></figure></li></ul><h2 id="模块文件、用户权限、数据导入"><a href="#模块文件、用户权限、数据导入" class="headerlink" title="模块文件、用户权限、数据导入"></a>模块文件、用户权限、数据导入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moduleLoadFromQueue();</span><br><span class="line">ACLLoadUsersAtStartup();</span><br><span class="line">loadDataFromDisk();</span><br></pre></td></tr></table></figure><p>如果数据文件中有数据，则需要进行数据的初始化操作。<br>如果开启了AOF，那么会优先从AOF文件中进行数据导入操作。如果没有开启AOF文件，才会去查找RDB文件。<code>loadDataFromDisk</code></p><h2 id="循环监听时间"><a href="#循环监听时间" class="headerlink" title="循环监听时间"></a>循环监听时间</h2><p>Redis服务主要运行函数为<code>aeMain()</code>。在函数中，是一个死循环操作。一旦监听的文件事件存在了可操作事件，就会进行处理逻辑流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line">aeMain(server.el);</span><br><span class="line">aeDeleteEventLoop(server.el);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文将基于Redis5.0 unstable版本介绍其在启动过程中所做的主要操作以及相关流程函数方法。&lt;br&gt;在此，先放上一张Redis初始化流程的大意图。&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1g9wqij4tmaj30a008edfz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>缓存雪崩穿透击穿介绍</title>
    <link href="http://yoursite.com/2019/12/15/new/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/12/15/new/缓存雪崩穿透击穿介绍/</id>
    <published>2019-12-14T16:40:24.000Z</published>
    <updated>2019-12-14T16:49:41.954Z</updated>
    
    <content type="html"><![CDATA[<p>看到这个标题，你肯定在想：什么是雪崩？什么是穿透？什么是击穿？怎么感觉都是一个意思，都是缓存失效导致的数据库压力问题。</p><p>这三个问题的确都会导致数据库压力问题，但是出现的场景还是存在区别滴。在处理手段上也有很大的区别。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>需要使用的热点数据都做了缓存，但是为了保证Redis的内存够用，所以会对一些数据进行设置过期时间操作。一般情况下存在定时任务去刷新缓存信息，这个时候就存在一个隐患的问题：假设在定时任务中设置的过期时间都一样，那么在某一个时间点时，大量的key同时过期。本来缓存抵挡住了大量的请求，key过期后，这些压力全部同时打到了数据库中，数据库可能就扛不住。直接被打挂了，重启数据库后，立马又被新的流量打挂了。这就是缓存雪崩。<br>(注：这里还有个隐患，Redis可能会频繁的处理过期key，从而导致Redis性能降低)<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wq4egoo5j30er0a6aao.jpg" alt=""></p><p>处理缓存雪崩主要有以下几个思路：</p><ol><li>分散过期时间。把每个key的过期时间都加上一个随机的过期值。保证数据不会在同一时间大面积失效。</li><li>设置过期标志更新缓存。给每一个缓存数据都增加一个相应的缓存标记，记录缓存是否失效。如果缓存失效，则更新数据缓存。这样虽然在缓存首次失效时，仍会带来数据库压力问题。但是能够在一定程度上缓解后续被新流量打挂以及所有服务不可用的情况。</li><li>在代码层面上设定一定策略，比如加锁等待、减慢请求速度。给数据库留下启动和重建缓存的机会。</li></ol><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透就是指客户端不断的查询缓存和数据库都没有的数据。相当于进行了两次无用的查询。降低缓存的命中率，增加数据库的压力。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wq4nqarcj30dx0ak751.jpg" alt=""></p><p>解决手段：</p><ol><li>客户端进行校验，先将明显不符合的key给过滤掉。</li><li>对于查询不到的数据，直接赋值一个null给它。</li><li>使用布隆过滤器来对不存在数据进行过滤掉。</li><li>限流。</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿和缓存雪崩有点像。但是又不一样，缓存雪崩是大面积的缓存同时失效，打崩了DB。而缓存击穿是指一个key非常热点，在不停的扛着大并发，当这个key失效的瞬间，持续的大并发就击穿缓存，直接请求数据库。</p><p>解决手段:<br>主要场景是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。<br>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到这个标题，你肯定在想：什么是雪崩？什么是穿透？什么是击穿？怎么感觉都是一个意思，都是缓存失效导致的数据库压力问题。&lt;/p&gt;
&lt;p&gt;这三个问题的确都会导致数据库压力问题，但是出现的场景还是存在区别滴。在处理手段上也有很大的区别。&lt;/p&gt;
&lt;h2 id=&quot;缓存雪崩&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="概念介绍" scheme="http://yoursite.com/tags/%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot整合SpringTask实现定时任务</title>
    <link href="http://yoursite.com/2019/07/26/SpringBoot/Spring-boot%E6%95%B4%E5%90%88SpringTask%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/07/26/SpringBoot/Spring-boot整合SpringTask实现定时任务/</id>
    <published>2019-07-26T07:45:09.000Z</published>
    <updated>2019-12-18T17:21:15.103Z</updated>
    
    <content type="html"><![CDATA[<p>SpringTask是Spring自主研发的一个定时任务工具，不需要引入其他依赖就可以使用。</p><h2 id="SpringTask-Cron语法"><a href="#SpringTask-Cron语法" class="headerlink" title="SpringTask Cron语法"></a>SpringTask Cron语法</h2><p>类似于shell中的<code>crontab</code>，只不过最前面多了一个<code>Seconds</code>秒级别。<br>Seconds Minutes Hours DayofMonth Month DayofWeek</p><table><thead><tr><th>时间元素</th><th>可出现的字符</th><th>数值范围</th></tr></thead><tbody><tr><td>Seconds</td><td>,-*/</td><td>0-59</td></tr><tr><td>Minutes</td><td>,-*/</td><td>0-59</td></tr><tr><td>Hours</td><td>,-*/</td><td>0-23</td></tr><tr><td>Day of Month</td><td>,-*/?LW</td><td>0-31</td></tr><tr><td>Month</td><td>,-*/</td><td>1-12</td></tr><tr><td>Day of Week</td><td>,-*/?L#</td><td>1-7</td></tr></tbody></table><ul><li>“,” 列出枚举值</li><li>“-“ 触发范围</li><li>“*” 任意值</li><li>“/“ 每隔一段时间执行</li><li>“?” 任意值</li><li>“#” 确定第几个星期几</li><li>“L” 表示最后的有效值</li><li>“W” 表示有效工作日<a id="more"></a><h2 id="整合使用SpringTask"><a href="#整合使用SpringTask" class="headerlink" title="整合使用SpringTask"></a>整合使用SpringTask</h2>因为SpringTask已经存在于Spring框架中，所有不需要引入任何依赖。<br>只需要在配置类中添加一个<code>@EnableScheduling</code>注解就可以开启SpringTask的定时任务功能。<br>然后可以通过在方法上增加<code>@Scheduled</code>注解配置定时任务。或者通过代码动态创建定时任务。</li></ul><h3 id="通过spring-boot注解实现"><a href="#通过spring-boot注解实现" class="headerlink" title="通过spring boot注解实现"></a>通过spring boot注解实现</h3><p>在Spring boot的主类或者配置类中加入<code>@EnableScheduling</code>注解，启动定时任务的配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class SpringbootApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建定时任务实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringTaskDemo &#123;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span><br><span class="line">    public void printHello()&#123;</span><br><span class="line">        System.out.println(&quot;scheduled is running.........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态创建定时任务"><a href="#动态创建定时任务" class="headerlink" title="动态创建定时任务"></a>动态创建定时任务</h3><p>使用注解的方式，无法实现动态的修改、添加、关闭定时任务。这个时候就需要使用编程的方式进行任务的更新操作了。可以使用<code>ThreadPoolTaskScheduler</code>或<code>SchedulingConfigurer</code>接口来创建自定义定时任务。</p><p><strong>SchedulingConfigurer</strong><br>通过实现<code>SchedulingConfigurer</code>接口，重写<code>configureTasks</code>方法添加定时任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ScheduleConfig implements SchedulingConfigurer &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line">taskRegistrar.setTaskScheduler(taskScheduler());</span><br><span class="line"></span><br><span class="line">taskRegistrar.getScheduler().schedule(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;|SchedulingConfigurer cron task01&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, new CronTrigger(&quot;0/3 * * * * ?&quot;));</span><br><span class="line"></span><br><span class="line">taskRegistrar.addCronTask(new CronTask(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;|SchedulingConfigurer cron task02&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, new CronTrigger(&quot;0/2 * * * * ?&quot;)));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Bean</span><br><span class="line">public TaskScheduler taskScheduler() &#123;</span><br><span class="line">ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();</span><br><span class="line">taskScheduler.setPoolSize(10);</span><br><span class="line">taskScheduler.setThreadNamePrefix(&quot;spring-task-scheduler-thread-&quot;);</span><br><span class="line">taskScheduler.setAwaitTerminationSeconds(60);</span><br><span class="line">taskScheduler.setWaitForTasksToCompleteOnShutdown(true);</span><br><span class="line">taskScheduler.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">return taskScheduler;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><hr><p><code>ThreadPoolTaskScheduler</code>是Spring Task的核心实现类，该类提供了大量的重载方法进行任务调度。首先配置一个自定义任务调度线程池<code>ThreadPoolTaskScheduler</code>，然后调用<code>schedule</code>等方法对定时任务进行动态管理操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/task&quot;)</span><br><span class="line">public class SpringTaskDemo&#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ThreadPoolTaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    private ScheduledFuture&lt;?&gt; scheduledFuture;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;timing-task.cron1&#125;&quot;)</span><br><span class="line">    private String cronStr1;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;timing-task.cron2&#125;&quot;)</span><br><span class="line">    private String cronStr2;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/start&quot;)</span><br><span class="line">    public String startTask() &#123;</span><br><span class="line">        scheduledFuture = taskScheduler.schedule(new RunTask01(), new Trigger() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Date nextExecutionTime(TriggerContext triggerContext) &#123;</span><br><span class="line">                return new CronTrigger(cronStr1).nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(&quot;start timed task success ..&quot;);</span><br><span class="line">        return &quot;start task suceess&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/stop&quot;)</span><br><span class="line">    public String stopTask() &#123;</span><br><span class="line">        Boolean result = null;</span><br><span class="line">        if (scheduledFuture != null) &#123;</span><br><span class="line">            result = scheduledFuture.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;stop timed task result: &quot; + result);</span><br><span class="line">        return &quot;stop task result: &quot; + result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/modify&quot;)</span><br><span class="line">    public String modifyTask() &#123;</span><br><span class="line">        Boolean stopResult = null;</span><br><span class="line">        // 停止定时任务</span><br><span class="line">        if (scheduledFuture != null) &#123;</span><br><span class="line">            stopResult = scheduledFuture.cancel(true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;modify task error -&gt; scheduledFuture is null&quot;);</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 更换cron重新开启定时任务</span><br><span class="line">        if (stopResult) &#123;</span><br><span class="line">            scheduledFuture = taskScheduler.schedule(new RunTask01(), new Trigger() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Date nextExecutionTime(TriggerContext triggerContext) &#123;</span><br><span class="line">                    return new CronTrigger(cronStr2).nextExecutionTime(triggerContext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            log.info(&quot;modify task success ..&quot;);</span><br><span class="line">            return &quot;success&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;modify task failed ..&quot;);</span><br><span class="line">        return &quot;failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class RunTask01 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            log.info(Thread.currentThread().getName() + &quot;|schedule task01&quot; + &quot;|&quot; + new Date().toLocaleString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class RunTask02 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            log.info(Thread.currentThread().getName() + &quot;|schedule task02&quot; + &quot;|&quot; + new Date().toLocaleString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringTask是Spring自主研发的一个定时任务工具，不需要引入其他依赖就可以使用。&lt;/p&gt;
&lt;h2 id=&quot;SpringTask-Cron语法&quot;&gt;&lt;a href=&quot;#SpringTask-Cron语法&quot; class=&quot;headerlink&quot; title=&quot;SpringTask Cron语法&quot;&gt;&lt;/a&gt;SpringTask Cron语法&lt;/h2&gt;&lt;p&gt;类似于shell中的&lt;code&gt;crontab&lt;/code&gt;，只不过最前面多了一个&lt;code&gt;Seconds&lt;/code&gt;秒级别。&lt;br&gt;Seconds Minutes Hours DayofMonth Month DayofWeek&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间元素&lt;/th&gt;
&lt;th&gt;可出现的字符&lt;/th&gt;
&lt;th&gt;数值范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Seconds&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;0-59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Minutes&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;0-59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hours&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;0-23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Day of Month&lt;/td&gt;
&lt;td&gt;,-*/?LW&lt;/td&gt;
&lt;td&gt;0-31&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Month&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;1-12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Day of Week&lt;/td&gt;
&lt;td&gt;,-*/?L#&lt;/td&gt;
&lt;td&gt;1-7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;“,” 列出枚举值&lt;/li&gt;
&lt;li&gt;“-“ 触发范围&lt;/li&gt;
&lt;li&gt;“*” 任意值&lt;/li&gt;
&lt;li&gt;“/“ 每隔一段时间执行&lt;/li&gt;
&lt;li&gt;“?” 任意值&lt;/li&gt;
&lt;li&gt;“#” 确定第几个星期几&lt;/li&gt;
&lt;li&gt;“L” 表示最后的有效值&lt;/li&gt;
&lt;li&gt;“W” 表示有效工作日
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
  </entry>
  
  <entry>
    <title>java实现快排</title>
    <link href="http://yoursite.com/2019/07/24/java%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8E%92/"/>
    <id>http://yoursite.com/2019/07/24/java实现快排/</id>
    <published>2019-07-24T07:04:30.000Z</published>
    <updated>2019-12-18T17:21:15.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>在数组中选出一个元素做为中枢值，把所有比它小的元素都移动到它的左边，比它大的元素都移动到它的右边。直到数组有序。<br><img src="https://img-blog.csdnimg.cn/20190723124826723.gif" alt=""></p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static void qSort(int[] a,int left,int right)&#123;</span><br><span class="line">    if(left &lt; right)&#123;</span><br><span class="line">        int mid = divide(a,left,right);</span><br><span class="line">        qSort(a,left,mid);</span><br><span class="line">        qSort(a,mid+1,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int divide(int[] a,int left,int right)&#123;</span><br><span class="line">    int mid = left;</span><br><span class="line"></span><br><span class="line">    while(left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; a[right] &gt;= a[mid]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (left &lt; right &amp;&amp; a[left] &lt; a[mid]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            swap(a, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] a, int left, int right) &#123;</span><br><span class="line">    int tmp = a[left];</span><br><span class="line">    a[left] = a[right];</span><br><span class="line">    a[right] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体流程：</p><ol><li>定义两个指针<code>left</code>和<code>right</code>代表两个初始化位置，分别表示需要排序数组的最左和最右。</li><li>一直遍历，right向左移动，直到找到小于中枢值的位置。</li><li>一直遍历，left向右移动，直到找到大于中枢值的位置。</li><li>如果left&lt;right，交换这两个元素。</li><li>重复上面步骤。</li><li>使用递归再对两边子数组进行排序。</li></ol><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//    非递归实现快排</span><br><span class="line">    private static void qSort2(int[] a,int left,int right)&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();</span><br><span class="line">        s.push(left);</span><br><span class="line">        s.push(right);</span><br><span class="line"></span><br><span class="line">        while(!s.isEmpty())&#123;</span><br><span class="line">            int r = s.pop();</span><br><span class="line">            int l = s.pop();</span><br><span class="line">            int mid = divide(a,l,r);</span><br><span class="line">            if(l &lt; mid)&#123;</span><br><span class="line">                s.push(l);</span><br><span class="line">                s.push(mid);</span><br><span class="line">            &#125;</span><br><span class="line">            if(mid + 1 &lt; right)&#123;</span><br><span class="line">                s.push(mid+1);</span><br><span class="line">                s.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对需要排序的数组的左指针和右指针l、r记录起来，压入到栈中，每次循环都会弹出一对l、r。<br>当栈为空时，说明都已经排序了。接收循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h2&gt;&lt;p&gt;在数组中选出一个元素做为中枢值，把所有比它小的元素都移动到它的左边，比它大的元素都移动到它的右边。直到数组有序。&lt;br&gt;&lt;i
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之sort</title>
    <link href="http://yoursite.com/2019/07/23/Linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bsort/"/>
    <id>http://yoursite.com/2019/07/23/Linux/Linux命令之sort/</id>
    <published>2019-07-23T04:48:18.000Z</published>
    <updated>2019-12-18T17:21:15.065Z</updated>
    
    <content type="html"><![CDATA[<p>Linux自带排序命令：<code>sort</code><br>在一些临时性排序需求的时候，使用该命令可以快速的处理。小巧的工具使我们使用非常便捷。<br>语法：<code>sort [-bcCdfghiRMmnrsuVz] [-k field1[,field2]] [-S memsize] [-T dir] [-t char] [-o output] [file ...]</code></p><h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-b 忽略每行前面开始出的空格字符。</span><br><span class="line">-c 检查文件是否已经按照顺序排序。</span><br><span class="line">-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</span><br><span class="line">-f 排序时，将小写字母视为大写字母。</span><br><span class="line">-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</span><br><span class="line">-k：以哪个区间 (field) 来进行排序</span><br><span class="line">-m：将几个排序好的文件进行合并，只是单纯合并，不做排序</span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序</span><br><span class="line">-n：依照数值的大小排序</span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入指定的文件</span><br><span class="line">-r：降序</span><br><span class="line">-R: 乱序</span><br><span class="line">-u：忽略相同行</span><br><span class="line">-t&lt;分隔字符&gt;：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ cat sort.log</span><br><span class="line">[@huzhibindeMacBook-Pro:tmp]$ cat sort.log</span><br><span class="line">amac2000    500 2K</span><br><span class="line">dwinxp4000    300 3G</span><br><span class="line">ebsd1000    600 4M</span><br><span class="line">blinux1000200 5K</span><br><span class="line">fSUSE4000    300 6M</span><br><span class="line">gwinxp500     300 3G</span><br><span class="line">cwin72000    100 7G</span><br><span class="line">cDebian600     200 8K</span><br></pre></td></tr></table></figure><h3 id="打印从哪列开始是乱序"><a href="#打印从哪列开始是乱序" class="headerlink" title="打印从哪列开始是乱序"></a>打印从哪列开始是乱序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -c sort.log</span><br><span class="line">sort: sort.log:4: disorder: b   linux   1000    200 5K</span><br></pre></td></tr></table></figure><h3 id="指定列排序"><a href="#指定列排序" class="headerlink" title="指定列排序"></a>指定列排序</h3><p>默认按照字符排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3 sort.log</span><br><span class="line">blinux10002005K</span><br><span class="line">ebsd10006004M</span><br><span class="line">cwin720001007G</span><br><span class="line">amac20005002K</span><br><span class="line">dwinxp40003003G</span><br><span class="line">fSUSE40003006M</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br></pre></td></tr></table></figure></p><p>按照数字排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n sort.log</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br><span class="line">blinux10002005K</span><br><span class="line">ebsd10006004M</span><br><span class="line">amac20005002K</span><br><span class="line">cwin720001007G</span><br><span class="line">dwinxp40003003G</span><br><span class="line">fSUSE40003006M</span><br></pre></td></tr></table></figure></p><h3 id="u和uniq的区别"><a href="#u和uniq的区别" class="headerlink" title="-u和uniq的区别"></a>-u和uniq的区别</h3><p>在指定<code>-k</code>的时候，<code>-u</code>是会按照指定的列来忽略重复，<code>uniq</code>是按照整行来去重<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n -u  sort.log</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br><span class="line">ebsd10006004M</span><br><span class="line">amac20005002K</span><br><span class="line">dwinxp40003003G</span><br><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n   sort.log  | uniq</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br><span class="line">blinux10002005K</span><br><span class="line">ebsd10006004M</span><br><span class="line">amac20005002K</span><br><span class="line">cwin720001007G</span><br><span class="line">dwinxp40003003G</span><br><span class="line">fSUSE40003006M</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux自带排序命令：&lt;code&gt;sort&lt;/code&gt;&lt;br&gt;在一些临时性排序需求的时候，使用该命令可以快速的处理。小巧的工具使我们使用非常便捷。&lt;br&gt;语法：&lt;code&gt;sort [-bcCdfghiRMmnrsuVz] [-k field1[,field2]] [-S memsize] [-T dir] [-t char] [-o output] [file ...]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;可选项&quot;&gt;&lt;a href=&quot;#可选项&quot; class=&quot;headerlink&quot; title=&quot;可选项&quot;&gt;&lt;/a&gt;可选项&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-b 忽略每行前面开始出的空格字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-c 检查文件是否已经按照顺序排序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-f 排序时，将小写字母视为大写字母。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-k：以哪个区间 (field) 来进行排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-m：将几个排序好的文件进行合并，只是单纯合并，不做排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-M：将前面3个字母依照月份的缩写进行排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n：依照数值的大小排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o&amp;lt;输出文件&amp;gt;：将排序后的结果存入指定的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-r：降序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-R: 乱序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-u：忽略相同行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-t&amp;lt;分隔字符&amp;gt;：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Redis</title>
    <link href="http://yoursite.com/2019/07/21/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Redis/"/>
    <id>http://yoursite.com/2019/07/21/SpringBoot/SpringBoot整合Redis/</id>
    <published>2019-07-21T14:34:11.000Z</published>
    <updated>2019-12-18T17:21:15.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-boot中使用Redis"><a href="#Spring-boot中使用Redis" class="headerlink" title="Spring boot中使用Redis"></a>Spring boot中使用Redis</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=0</span><br><span class="line"></span><br><span class="line">## Redis自定义key配置选项</span><br></pre></td></tr></table></figure><h2 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// 保存字符串</span><br><span class="line">stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;);</span><br><span class="line">Assert.assertEquals(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-boot中使用Redis&quot;&gt;&lt;a href=&quot;#Spring-boot中使用Redis&quot; class=&quot;headerlink&quot; title=&quot;Spring boot中使用Redis&quot;&gt;&lt;/a&gt;Spring boot中使用Redis&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Swagger2</title>
    <link href="http://yoursite.com/2019/07/21/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Swagger2/"/>
    <id>http://yoursite.com/2019/07/21/SpringBoot/SpringBoot整合Swagger2/</id>
    <published>2019-07-21T13:57:43.000Z</published>
    <updated>2019-12-18T17:21:15.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a>Swagger2</h1><p>Swagger2用于解决前后端开发人员之间的api对接，减少与其他团队开发期间的沟通成本。Swagger2可以轻松的整合到Spring boot中，并与SpringMVC程序配合组织处强大的Restful API文档。即可以减少我们创建文档的工作量，同时说明内容整合到实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。<br>另外，Swagger2也提供了强大的页面测试功能来调试每个Restful API</p><h2 id="添加Swagger2依赖"><a href="#添加Swagger2依赖" class="headerlink" title="添加Swagger2依赖"></a>添加Swagger2依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="创建Swagger2配置类"><a href="#创建Swagger2配置类" class="headerlink" title="创建Swagger2配置类"></a>创建Swagger2配置类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket CreateRestApi()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.hoo.springboot&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo()&#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如以上代码，通过<code>@Configuration</code>注解，让Spring来加载该类配置。再通过<code>@EnabledSwagger2</code>注解来启用Swagger2。</p><p>再通过<code>createRestApi</code>函数创建<code>Docket</code>的Bean之后，<code>apiInfo()</code>用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。<code>select()</code>函数返回一个<code>ApiSelectorBuilder</code>实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被<code>@ApiIgnore</code>指定的请求）。</p><h2 id="添加文档内容"><a href="#添加文档内容" class="headerlink" title="添加文档内容"></a>添加文档内容</h2><p>在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过<code>@ApiOperation</code>注解来给API增加说明、通过<code>@ApiImplicitParams</code>、<code>@ApiImplicitParam</code>注解来给参数增加说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(value = &quot;/users&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  创建一个线程安全的Map模拟数据用户信息</span><br><span class="line">     */</span><br><span class="line">    static Map&lt;Integer, User&gt; userMap = Collections.synchronizedMap(new HashMap&lt;Integer,User&gt;());</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&quot;,method = RequestMethod.GET)</span><br><span class="line">    public List&lt;User&gt; getUserList()&#123;</span><br><span class="line">        List&lt;User&gt; r = new ArrayList&lt;User&gt;(userMap.values());</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&quot;,method = RequestMethod.POST)</span><br><span class="line">    public String postUser(@ModelAttribute User user)&#123;</span><br><span class="line">        userMap.put(user.getId(),user);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br><span class="line">    public User getUser(@PathVariable Integer id)&#123;</span><br><span class="line"></span><br><span class="line">        return userMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.PUT)</span><br><span class="line">    public String putUser(@PathVariable Integer id,@ModelAttribute User user)&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        User u = userMap.get(id);</span><br><span class="line">        u.setAge(user.getAge());</span><br><span class="line">        u.setName(user.getName());</span><br><span class="line"></span><br><span class="line">        userMap.put(id,u);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除对象&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span><br><span class="line">    public String deleteUser(@PathVariable Integer id)&#123;</span><br><span class="line"></span><br><span class="line">        userMap.remove(id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成上述代码添加上，启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a><br><a href="https://imgchr.com/i/eCParT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/21/eCParT.md.jpg" alt="eCParT.md.jpg"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Swagger2&quot;&gt;&lt;a href=&quot;#Swagger2&quot; class=&quot;headerlink&quot; title=&quot;Swagger2&quot;&gt;&lt;/a&gt;Swagger2&lt;/h1&gt;&lt;p&gt;Swagger2用于解决前后端开发人员之间的api对接，减少与其他团队开发期间的沟通成本。Swagger2可以轻松的整合到Spring boot中，并与SpringMVC程序配合组织处强大的Restful API文档。即可以减少我们创建文档的工作量，同时说明内容整合到实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。&lt;br&gt;另外，Swagger2也提供了强大的页面测试功能来调试每个Restful API&lt;/p&gt;
&lt;h2 id=&quot;添加Swagger2依赖&quot;&gt;&lt;a href=&quot;#添加Swagger2依赖&quot; class=&quot;headerlink&quot; title=&quot;添加Swagger2依赖&quot;&gt;&lt;/a&gt;添加Swagger2依赖&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
      <category term="mall" scheme="http://yoursite.com/categories/SpringBoot/mall/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring boot整合MyBatis逆向工程</title>
    <link href="http://yoursite.com/2019/07/18/SpringBoot/Spring-boot%E6%95%B4%E5%90%88MyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/18/SpringBoot/Spring-boot整合MyBatis逆向工程/</id>
    <published>2019-07-18T15:03:57.000Z</published>
    <updated>2019-12-18T17:21:15.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pom-xml中添加依赖"><a href="#pom-xml中添加依赖" class="headerlink" title="pom.xml中添加依赖"></a>pom.xml中添加依赖</h2><p>在这里引入了<code>pagehelper</code>，<code>pagehelper</code>是MyBatis的分页插件，通过几行简单的代码就是实现分页功能；在与Spring boot整合的时候，只要整合了<code>pagehelper</code>就自动整合了MyBatis。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- spring boot健康检查、审计、统计、监控--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--MyBatis分页插件--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- MyBatis 生成器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="修改Spring-boot配置文件"><a href="#修改Spring-boot配置文件" class="headerlink" title="修改Spring boot配置文件"></a>修改Spring boot配置文件</h2><p>在<code>application.yml</code>中添加数据源配置和MyBatis的mapper.xml的路径配置。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:13307/spring</span><br><span class="line">    password: hoo</span><br><span class="line">    username: hoo</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mapper/*.xml</span><br><span class="line">    - classpath*:com/**/mapper/*.xml</span><br></pre></td></tr></table></figure><h2 id="修改Mybatis-generator配置文件"><a href="#修改Mybatis-generator配置文件" class="headerlink" title="修改Mybatis generator配置文件"></a>修改Mybatis generator配置文件</h2><p>主要是修改数据库连接配置，MyBatis generator生成的model、mapper接口、mapper.xml文件的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;properties resource=&quot;generator.properties&quot;/&gt;</span><br><span class="line">    &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">        &lt;!-- 为模型生成序列化方法--&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 为生成的Java模型创建一个toString方法 --&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 数据库资源配置 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">                        connectionURL=&quot;jdbc:mysql://127.0.0.1:13307/spring&quot;</span><br><span class="line">                        userId=&quot;hoo&quot;</span><br><span class="line">                        password=&quot;hoo&quot;&gt;</span><br><span class="line">            &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt;</span><br><span class="line">            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!-- 生成的model放置路径 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.hoo.springboot.mbg.model&quot; targetProject=&quot;./src/main/java&quot;/&gt;</span><br><span class="line">        &lt;!-- 生成的mapper接口放置路径 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.hoo.springboot.mbg.mapper&quot; targetProject=&quot;./src/main/resources&quot;/&gt;</span><br><span class="line">        &lt;!-- 生成的mapper配置文件放置路径 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.hoo.springboot.mbg.mapper&quot;</span><br><span class="line">                             targetProject=&quot;./src/main/java&quot;/&gt;</span><br><span class="line">        &lt;!--生成全部表tableName设为%--&gt;</span><br><span class="line">        &lt;table tableName=&quot;%&quot;&gt;</span><br><span class="line">            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure></p><h2 id="运行Generator的main函数生成代码"><a href="#运行Generator的main函数生成代码" class="headerlink" title="运行Generator的main函数生成代码"></a>运行Generator的main函数生成代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Generator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //MBG 执行过程中的警告信息</span><br><span class="line">        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">        //当生成的代码重复时，覆盖原代码</span><br><span class="line">        boolean overwrite = true;</span><br><span class="line">        //读取我们的 MBG 配置文件</span><br><span class="line">        InputStream is = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;);</span><br><span class="line">        ConfigurationParser cp = new ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(is);</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">        /* 创建 MBG */</span><br><span class="line">        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        //执行生成代码</span><br><span class="line">        myBatisGenerator.generate(null);</span><br><span class="line">        //输出警告信息</span><br><span class="line">        for (String warning : warnings) &#123;</span><br><span class="line">            System.out.println(warning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pom-xml中添加依赖&quot;&gt;&lt;a href=&quot;#pom-xml中添加依赖&quot; class=&quot;headerlink&quot; title=&quot;pom.xml中添加依赖&quot;&gt;&lt;/a&gt;pom.xml中添加依赖&lt;/h2&gt;&lt;p&gt;在这里引入了&lt;code&gt;pagehelper&lt;/code&gt;，
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
      <category term="mall" scheme="http://yoursite.com/categories/SpringBoot/mall/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制</title>
    <link href="http://yoursite.com/2019/07/16/Java/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/16/Java/Java类加载机制/</id>
    <published>2019-07-16T14:59:41.000Z</published>
    <updated>2019-12-18T17:21:15.061Z</updated>
    
    <content type="html"><![CDATA[<p>类的加载是指将类的<code>.class</code>文件中的<strong>二进制数据读入到内存</strong>中，将其放在运行时数据区的方法区，然后在Java堆中创建一个java.lang.Class对象(类也是对象)，用来封装类在方法区内的数据结构。<br>类加载的最终产物是位于堆中的Class对象，该Class对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。<br><a href="https://imgchr.com/i/ZqjkUs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjkUs.jpg" alt="ZqjkUs.jpg"></a></p><p>类加载器不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用的时候就预先加载，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器必须在程序<font color="red">首次主动使用该类</font>时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p><a href="https://imgchr.com/i/ZqjPbQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjPbQ.jpg" alt="ZqjPbQ.jpg"></a></p><p>类的生命周期主要包含<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>、<code>使用</code>、<code>卸载</code>。<br>在加载过程中的五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>初始化</code>发生的顺序是一定的，而<code>解析</code>在某些情况下可以在<code>初始化</code>阶段之后执行。这是为了支持Java语言的运行时绑定。<br>另外需要注意的是：这几个阶段是按照顺序开始，而不是按照顺序进行或完成，因为这些阶段通常是相互交叉混合进行的，通常在一个阶段执行的过程中需要调用或激活另一个阶段。<br><a id="more"></a></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>查找并加载类的二进制数据是类加载过程的第一个阶段，在这个阶段，虚拟机需要完成以下事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流代表的静态存储结构转化成方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，连接阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。</p><p>在验证阶段，主要是完成以下的校验动作：</p><h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>验证字节流是否符合Class文件格式的规范。例如：是否以<code>OxCAFEBASE</code>开头、主版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p><h3 id="元数据校验"><a href="#元数据校验" class="headerlink" title="元数据校验"></a>元数据校验</h3><p>对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求；列如：这个类是否有父类，除了<code>java.lang.Object</code></p><h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>确保解析动作能正确执行</p><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为类的<code>静态变量</code>分配内存，并将其初始化为默认值</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区分配。</p><ul><li>这个阶段进行内存分配的<font color="red">仅包括类变量(static)</font>，不包括实例变量；实例变量会在对象实例化时随着实例一块分配在Java堆中。</li><li>这个阶段设置的初始值通常是数据类型的默认值，而不是在Java程序中被显式赋予的值。</li><li>如果是同时被final和static修饰的属性，这在准备阶段会被初始化为定义的值。</li></ul><blockquote><p>假设有一个变量public static int value = 3<br>那么变量value在准备阶段过后的初始值是0，而不是3，因为这个时候还没开始执行任何Java方法，把value赋值为3的public static指令是在程序编译后，存放在类构造器<clinit>()方法中，所以value赋值为3的动作在初始化阶段才会执行。</clinit></p></blockquote><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。<br>解析动作主要是针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号类型进行，</p><ul><li>符号引用：用一组符号描述目标，可以是任何字面量</li><li>直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><h3 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h3><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><h3 id="类初始化情况"><a href="#类初始化情况" class="headerlink" title="类初始化情况"></a>类初始化情况</h3><ul><li>使用new创建类的实例</li><li>第一次访问某个类或接口的静态变量，或者对静态变量赋值</li><li>第一次调用类的静态方法</li><li>使用反射加载类(Class.forName(“xxx.xxx”))</li><li>初始化某个类的子类，其父类也会被初始化</li><li>Java虚拟机启动的时候标明启动的类(Java Test)，直接使用<code>java.exe</code>运行某个主类。</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>JVM预定义了三种类加载器，当一个JVM启动的时候，Java会默认使用类加载器进行类加载。</p><ul><li>启动类加载器:负责加载存放在<code>JDK\jre\lib</code>下或被<code>-Xbootclasspath</code>指定路径中的类库。</li><li>扩展类加载器:负责加载<code>JDK\jre\lib\ext</code>或由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库。</li><li>引用类加载器:负责加载用户类路径（ClassPath）所指定的类。程序默认的类加载器。<br><a href="https://imgchr.com/i/ZqjFEj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjFEj.jpg" alt="ZqjFEj.jpg"></a></li></ul><blockquote><p>注：父类加载器并不是通过继承关系实现的，而是采用组合的方式<br>启动类加载器是C++实现，属于虚拟机的一部分；其他类加载器都是由启动类加载器加载到内存中的。</p></blockquote><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><ul><li>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>双亲委派：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h2 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h2><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类的加载是指将类的&lt;code&gt;.class&lt;/code&gt;文件中的&lt;strong&gt;二进制数据读入到内存&lt;/strong&gt;中，将其放在运行时数据区的方法区，然后在Java堆中创建一个java.lang.Class对象(类也是对象)，用来封装类在方法区内的数据结构。&lt;br&gt;类加载的最终产物是位于堆中的Class对象，该Class对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/ZqjkUs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/17/ZqjkUs.jpg&quot; alt=&quot;ZqjkUs.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类加载器不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用的时候就预先加载，如果在预先加载的过程中遇到了&lt;code&gt;.class&lt;/code&gt;文件缺失或存在错误，类加载器必须在程序&lt;font color=&quot;red&quot;&gt;首次主动使用该类&lt;/font&gt;时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。&lt;/p&gt;
&lt;h1 id=&quot;类加载过程&quot;&gt;&lt;a href=&quot;#类加载过程&quot; class=&quot;headerlink&quot; title=&quot;类加载过程&quot;&gt;&lt;/a&gt;类加载过程&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/ZqjPbQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/17/ZqjPbQ.jpg&quot; alt=&quot;ZqjPbQ.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类的生命周期主要包含&lt;code&gt;加载&lt;/code&gt;、&lt;code&gt;验证&lt;/code&gt;、&lt;code&gt;准备&lt;/code&gt;、&lt;code&gt;解析&lt;/code&gt;、&lt;code&gt;初始化&lt;/code&gt;、&lt;code&gt;使用&lt;/code&gt;、&lt;code&gt;卸载&lt;/code&gt;。&lt;br&gt;在加载过程中的五个阶段中，&lt;code&gt;加载&lt;/code&gt;、&lt;code&gt;验证&lt;/code&gt;、&lt;code&gt;准备&lt;/code&gt;、&lt;code&gt;初始化&lt;/code&gt;发生的顺序是一定的，而&lt;code&gt;解析&lt;/code&gt;在某些情况下可以在&lt;code&gt;初始化&lt;/code&gt;阶段之后执行。这是为了支持Java语言的运行时绑定。&lt;br&gt;另外需要注意的是：这几个阶段是按照顺序开始，而不是按照顺序进行或完成，因为这些阶段通常是相互交叉混合进行的，通常在一个阶段执行的过程中需要调用或激活另一个阶段。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Arrays.sort和Collections.sort实现原理</title>
    <link href="http://yoursite.com/2019/07/16/Java/Arrays-sort%E5%92%8CCollections-sort%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/16/Java/Arrays-sort和Collections-sort实现原理/</id>
    <published>2019-07-16T14:51:54.000Z</published>
    <updated>2019-12-18T17:21:15.060Z</updated>
    
    <content type="html"><![CDATA[<p>事实上，在使用<code>Collections.sort(list)</code>的时候，就调用list.sort()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;</span><br><span class="line">        list.sort(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在深入进去后，发现其实调用的就是Array.sort()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">    default void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">        Object[] a = this.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = this.listIterator();</span><br><span class="line">        for (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>而在Array.sort中，会根据该对象是否能够通过归并排序来选择不同的排序方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            else</span><br><span class="line">                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>legacyMergeSort：归并排序</li><li><a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">TimSort</a><br>：结合归并排序和插入排序的一种排序算法</li></ul><blockquote><p>TimSort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。排序的输入的单位不是一个个单独的数字，而是一个个的块-分区。其中每一个分区叫一个run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run合并到只剩一个 run 为止。这时这个仅剩的 run 便是排好序的结果。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事实上，在使用&lt;code&gt;Collections.sort(list)&lt;/code&gt;的时候，就调用list.sort()&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池解析</title>
    <link href="http://yoursite.com/2019/07/15/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/15/面试准备/Java线程池解析/</id>
    <published>2019-07-15T14:02:22.000Z</published>
    <updated>2019-12-18T17:21:15.113Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线程池</strong>：可以根据字面意思简单的理解，一个管理线程的池子。</p><ul><li>帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。</li><li>提高响应速度。</li><li>重复利用。</li></ul><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize：线程池核心线程数最大值</li><li>maximumPoolSize： 线程池最大线程数大小</li><li>keepAliveTime： 线程池中非核心线程空闲的存活时间大小</li><li>unit： 线程空闲存活时间单位</li><li>workQueue： 存放任务的阻塞队列</li><li>threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li><li>handler：  线城池的饱和策略事件，主要有四种类型。</li></ul><h1 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h1><p>线程池执行流程，对应<code>execute()</code>方法。<br><a href="https://imgchr.com/i/Z7iOzt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7iOzt.md.jpg" alt="Z7iOzt.md.jpg"></a><br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        /*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">         * start a new thread with the given command as its first</span><br><span class="line">         * task.  The call to addWorker atomically checks runState and</span><br><span class="line">         * workerCount, and so prevents false alarms that would add</span><br><span class="line">         * threads when it shouldn&apos;t, by returning false.</span><br><span class="line">         *</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need</span><br><span class="line">         * to double-check whether we should have added a thread</span><br><span class="line">         * (because existing ones died since last checking) or that</span><br><span class="line">         * the pool shut down since entry into this method. So we</span><br><span class="line">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">         * stopped, or start a new thread if there are none.</span><br><span class="line">         *</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">         * and so reject the task.</span><br><span class="line">         */</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            else if (workerCountOf(recheck) == 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从execute代码注释中可以看出，任务执行流程主要是以下几步：</p><ul><li>提交任务，如果线程池里存活的核心线程数小于线程数<code>corePoolSize</code>时，线程池就会创建一个核心线程去处理提交的任务</li><li>如果线程池核心线程数满了，那么新提交的任务就会被放进任务队列<code>workQueue</code>中排队等待执行。</li><li>当线程池里面存活的线程数已经等于<code>corePoolSize</code>，并且任务队列<code>workQueue</code>也满了，判断线程数是否达到<code>maximumPoolSize</code>，如果没有达到，创建一个非核心线程执行提交的任务。</li><li>如果当前线程数达到了<code>maximumPoolSize</code>，那么直接采取拒绝策略处理。</li></ul><h1 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h1><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li></ul><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue(有界队列)是一个用数组实现的有界阻塞队列，按照FIFO排序。</p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue(可设置容量队列)基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，就是一个没有边界的阻塞队列，最大长度为Integer.MAX_VALUE。</p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue(延迟队列)是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后顺序排序。</p><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlockingQueue(优先阻塞队列)具有优先级的无界阻塞队列。</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue(同步队列)一个不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移除操作，否则插入操作一直处于阻塞状态。</p><h1 id="几种常用的线程池"><a href="#几种常用的线程池" class="headerlink" title="几种常用的线程池"></a>几种常用的线程池</h1><h2 id="newSingleThreadPool"><a href="#newSingleThreadPool" class="headerlink" title="newSingleThreadPool"></a>newSingleThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>这个线程池只有一个核心线程在工作，也就是相当于单线程串化执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。阻塞队列使用的是<code>LinkedBlockingQueue</code><br><a href="https://imgchr.com/i/Z7i4sK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7i4sK.jpg" alt="Z7i4sK.jpg"></a></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于串行执行任务的场景，一个任务一个任务地执行。<br><!-- more --></p><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>这个线程池的大小(核心线程)是固定的。每次提交一个任务就创建一个线程，直到线程数达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，会将后面的任务加入到阻塞队列。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。使用的阻塞队列是<code>LinkedBlockingQueue</code><br><a href="https://imgchr.com/i/Z7ihM6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7ihM6.md.jpg" alt="Z7ihM6.md.jpg"></a></p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于处理CPU密集型任务，确保CPU在长期被工作线程使用的情况下，尽可能少的分配线程，适用于执行长期的任务。</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">     return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                   60L, TimeUnit.SECONDS,</span><br><span class="line">                                   new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>创建一个可缓存的线程池(即核心线程数为0)，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲(60s不执行任务)的线程，当任务数增加时，此线程池又可以智能的添加新的线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统能够创建的最大线程大小。阻塞队列使用的是<code>SynchronousQueue</code><br><a href="https://imgchr.com/i/Z7iWxx" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7iWxx.md.jpg" alt="Z7iWxx.md.jpg"></a></p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>用于并发执行大量短期的小任务</p><h2 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>创建一个大小为<code>Integer.MAX_VALUE</code>的线程池，此线程池支持定时以及周期性执行任务的需求。阻塞队列使用的是<code>DelayedWorkQueue</code></p><ol><li>添加一个任务</li><li>线程池中的线程从DelayQueue中取任务</li><li>线程从DelayQueue中获取time大于等于当前时间的task</li><li>执行完后修改这个task的time为下一次被执行的时间</li><li>这个task返回到DelayQueue队列中</li></ol><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要周期性执行任务的场景，需要限制线程数量的场景</p><blockquote><p><a href="https://juejin.im/post/5d1882b1f265da1ba84aa676?utm_source=gold_browser_extension#heading-37" target="_blank" rel="noopener">https://juejin.im/post/5d1882b1f265da1ba84aa676?utm_source=gold_browser_extension#heading-37</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;线程池&lt;/strong&gt;：可以根据字面意思简单的理解，一个管理线程的池子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。&lt;/li&gt;
&lt;li&gt;提高响应速度。&lt;/li&gt;
&lt;li&gt;重复利用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public ThreadPoolExecutor(int corePoolSize,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              int maximumPoolSize,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              long keepAliveTime,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              TimeUnit unit,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             Executors.defaultThreadFactory(), defaultHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;corePoolSize：线程池核心线程数最大值&lt;/li&gt;
&lt;li&gt;maximumPoolSize： 线程池最大线程数大小&lt;/li&gt;
&lt;li&gt;keepAliveTime： 线程池中非核心线程空闲的存活时间大小&lt;/li&gt;
&lt;li&gt;unit： 线程空闲存活时间单位&lt;/li&gt;
&lt;li&gt;workQueue： 存放任务的阻塞队列&lt;/li&gt;
&lt;li&gt;threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。&lt;/li&gt;
&lt;li&gt;handler：  线城池的饱和策略事件，主要有四种类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;任务执行流程&quot;&gt;&lt;a href=&quot;#任务执行流程&quot; class=&quot;headerlink&quot; title=&quot;任务执行流程&quot;&gt;&lt;/a&gt;任务执行流程&lt;/h1&gt;&lt;p&gt;线程池执行流程，对应&lt;code&gt;execute()&lt;/code&gt;方法。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/Z7iOzt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/15/Z7iOzt.md.jpg&quot; alt=&quot;Z7iOzt.md.jpg&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Bitmap、Bloom Filter、Cuckoo Filter</title>
    <link href="http://yoursite.com/2019/07/15/Bitmap%E3%80%81Bloom-Filter%E3%80%81Cuckoo-Filter/"/>
    <id>http://yoursite.com/2019/07/15/Bitmap、Bloom-Filter、Cuckoo-Filter/</id>
    <published>2019-07-15T04:11:26.000Z</published>
    <updated>2019-12-18T17:21:15.059Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，在跟同学&amp;同事谈人生谈理想的时候。他告诉我他学长面试头条，其中一道题是如何判断一个整数在不在40亿整数集中；他说他学长竟然不知道<code>bitmap</code>(<a href="https://mp.weixin.qq.com/s/pUq213AJDpTGdGw4ywIS7g" target="_blank" rel="noopener">原题链接</a>)!!!然后我又给他科普了一下<code>布隆过滤器</code>和<code>布谷鸟过滤器</code>。<br>所以借此文章来记录一下这些知识，并巩固一下。</p><h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><p>Bitmap，直译就叫位图。可以理解为通过一个bit数组存储特定数据的一种数据结构；由于bit是数据的最小单位，所以这种数据结构往往是非常节省存储空间的。在Java和Redis中都存在同名实现结构。<br>在一个记录只有两种状态，是或不是的场景下，如果使用其他数据结构存储则会存在大量空间空间的浪费。即使存在海量的数据，我们也只需要为每个数据分配<code>1byte</code>的空间就可以记录了。比如：用户画像<br>Bitmap可以<font color="red">节省大量的存储空间</font>，所以可以很容易的倍一次性加载到内存中。Bitmap结构还有一个很重要的特点:<font color="red">可以很方便的进行位运算</font><br>比如我们需要统计用户满足以下条件的用户：程序员、带眼镜、长头发。。。。那么我们可以将对相应条件的用户画像的<code>Bitmap</code>结构做<code>AND</code>操作，就可以方便的过滤出满足条件的对象了。</p><h2 id="Bitmap的优化"><a href="#Bitmap的优化" class="headerlink" title="Bitmap的优化"></a>Bitmap的优化</h2><a id="more"></a><p>假如一个Bitmap中只有稀疏的那个几个1，那么其他空间是不是就被浪费了呢？</p><p>谷歌开发的EWAHComressedBitmap对Bitmap存储空间做了一定的优化操作。</p><p>EWAH把Bitmap存储在一个long数组中，long数组的每一个元素都可以当做64位的二进制数，也就是整个Bitmap的子集，称为<code>Word</code>。<br>当创建一个空的Bitmap时，只有4个<code>Word</code>，也就是只有4个long数组，随着数据的不断插入，<code>Word</code>数组会随着进行扩容。<br><code>Word</code>节点分为两种，直接存储数据的叫做<code>Literal Word</code>，简称LW。存储跨度信息的叫<code>Running Length Word</code>，简称RLW。<br>每一个RLW分为两部分，低32位表示当前Word横跨了多少个空Word，高32位表示当前RLW后面又多少个连续的LW。这样即使存在很多个0的位置，也能进行合并，减少浪费。<br><a href="https://imgchr.com/i/ZoGNon" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGNon.md.jpg" alt="ZoGNon.md.jpg"></a></p><h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><p>Bitmap适合处理<font color="red">按顺序字段映射</font>，如ID。但是当遇到其他情况时就无能为力了，比如判断一个单词是否存在于单词集中，这个时候如果需要映射的话，只能够对该单词进行相应的<code>hash</code>计算后映射到Bitmap上，But！绝大情况下会存在hash冲突，无法确认是不是。</p><p>于是便引入了<font color="red">布隆过滤器</font>。布隆过滤器也不能完全的消除误差。只能说大大的减少了误差率。</p><p>布隆过滤器的原理就是<font color="red">将需要判断的对象进行多次不同的hash计算后，同时判断那几位是否都为1</font>，由此可见，布隆过滤器的误差率取决于hash函数的选取。<br><a href="https://imgchr.com/i/ZoGYZj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGYZj.md.jpg" alt="ZoGYZj.md.jpg"></a></p><h1 id="Cuckoo-Filter"><a href="#Cuckoo-Filter" class="headerlink" title="Cuckoo Filter"></a>Cuckoo Filter</h1><p>布隆过滤器存在一个致命的缺点，那就是已经置为1的位不能再重置为0。这是因为你并不能判断该位具体被多少个对象映射了。只能在你认为误差率已经不能接受时进行重建。</p><p>我也是最近才了解到有<code>布谷鸟过滤器</code>的存在。</p><h2 id="布谷鸟哈希"><a href="#布谷鸟哈希" class="headerlink" title="布谷鸟哈希"></a>布谷鸟哈希</h2><p>最简单的布谷鸟哈希结构时一维数组结构，会有两个hash算法将新来的元素映射到数组的两个位置。如果两个位置中有一个位置为空，那么就可以把元素放进去；但是如果这两个位置都满了，那么会随机踢走一个，然后自己霸占这个位置。<br>被踢走的那个元素会寻找其他位置，重复上面的行为。知道所有的元素都找到了对应的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = hash1(x) % l</span><br><span class="line">p2 = hash2(x) % l</span><br></pre></td></tr></table></figure></p><p>布谷鸟算法为了避免重复踢的这个过程执行次数过多，会设置一个阈值，如果执行次数超过这个值，那么就会进行扩容操作，重新放置所有的元素。<br><a href="https://imgchr.com/i/ZoGGLQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGGLQ.md.jpg" alt="ZoGGLQ.md.jpg"></a><br><a href="https://imgchr.com/i/ZoG8sg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoG8sg.md.jpg" alt="ZoG8sg.md.jpg"></a></p><h2 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h2><p>布谷鸟过滤器和布谷鸟哈希结构一样，也是一维数组，但是不同于布谷鸟哈希的是，布谷鸟哈希会存储整个元素，而布谷鸟过滤器只会储存元素的指纹信息（只有几个bit，类似于布隆过滤器）。</p><p>首先布谷鸟过滤器还是只会选用两个 hash 函数，但是每个位置可以放置多个座位。这两个 hash 函数选择的比较特殊，因为过滤器中只能存储指纹信息。当这个位置上的指纹被挤兑之后，它需要计算出另一个对偶位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fp = fingerprint(x)</span><br><span class="line">p1 = hash(x)</span><br><span class="line">p2 = p1 ^ hash(fp)  // 异或</span><br></pre></td></tr></table></figure></p><p>我们可以看出p1和p2具有<code>对偶性</code>。所以我们根本不需要知道当前的位置是 p1 还是 p2，只需要将当前的位置和 hash(fp) 进行异或计算就可以得到对偶位置。而且只需要确保 hash(fp) != 0 就可以确保 p1 != p2，如此就不会出现自己踢自己导致死循环的问题。</p><p>由于布谷鸟过滤器保证了一个byte只被一个元素映射，所以允许删除操作，但是会存在误删的情况。</p><blockquote><p><a href="http://blog.talkingdata.net/?p=2493" target="_blank" rel="noopener">http://blog.talkingdata.net/?p=2493</a><br><a href="https://juejin.im/post/5c4fd2af51882525da267385" target="_blank" rel="noopener">https://juejin.im/post/5c4fd2af51882525da267385</a><br><a href="https://cloud.tencent.com/developer/article/1447177" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1447177</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天，在跟同学&amp;amp;同事谈人生谈理想的时候。他告诉我他学长面试头条，其中一道题是如何判断一个整数在不在40亿整数集中；他说他学长竟然不知道&lt;code&gt;bitmap&lt;/code&gt;(&lt;a href=&quot;https://mp.weixin.qq.com/s/pUq213AJDpTGdGw4ywIS7g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;)!!!然后我又给他科普了一下&lt;code&gt;布隆过滤器&lt;/code&gt;和&lt;code&gt;布谷鸟过滤器&lt;/code&gt;。&lt;br&gt;所以借此文章来记录一下这些知识，并巩固一下。&lt;/p&gt;
&lt;h1 id=&quot;Bitmap&quot;&gt;&lt;a href=&quot;#Bitmap&quot; class=&quot;headerlink&quot; title=&quot;Bitmap&quot;&gt;&lt;/a&gt;Bitmap&lt;/h1&gt;&lt;p&gt;Bitmap，直译就叫位图。可以理解为通过一个bit数组存储特定数据的一种数据结构；由于bit是数据的最小单位，所以这种数据结构往往是非常节省存储空间的。在Java和Redis中都存在同名实现结构。&lt;br&gt;在一个记录只有两种状态，是或不是的场景下，如果使用其他数据结构存储则会存在大量空间空间的浪费。即使存在海量的数据，我们也只需要为每个数据分配&lt;code&gt;1byte&lt;/code&gt;的空间就可以记录了。比如：用户画像&lt;br&gt;Bitmap可以&lt;font color=&quot;red&quot;&gt;节省大量的存储空间&lt;/font&gt;，所以可以很容易的倍一次性加载到内存中。Bitmap结构还有一个很重要的特点:&lt;font color=&quot;red&quot;&gt;可以很方便的进行位运算&lt;/font&gt;&lt;br&gt;比如我们需要统计用户满足以下条件的用户：程序员、带眼镜、长头发。。。。那么我们可以将对相应条件的用户画像的&lt;code&gt;Bitmap&lt;/code&gt;结构做&lt;code&gt;AND&lt;/code&gt;操作，就可以方便的过滤出满足条件的对象了。&lt;/p&gt;
&lt;h2 id=&quot;Bitmap的优化&quot;&gt;&lt;a href=&quot;#Bitmap的优化&quot; class=&quot;headerlink&quot; title=&quot;Bitmap的优化&quot;&gt;&lt;/a&gt;Bitmap的优化&lt;/h2&gt;
    
    </summary>
    
      <category term="一些奇淫技巧" scheme="http://yoursite.com/categories/%E4%B8%80%E4%BA%9B%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>mac安装多版本JDK</title>
    <link href="http://yoursite.com/2019/07/13/mac%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACJDK/"/>
    <id>http://yoursite.com/2019/07/13/mac安装多版本JDK/</id>
    <published>2019-07-13T09:55:42.000Z</published>
    <updated>2019-12-18T17:21:15.108Z</updated>
    
    <content type="html"><![CDATA[<p>随着JDK版本的快速迭代，作为优秀(kubi)的Java拥护者，为了跟随时代的潮流，也开始使用1.8版本。</p><p>但是，某一天。。。。苦逼的事情发生了，一个项目原本是好好的，突然报错起不来了。最终查到的原因是某个项目的Jar包使用的JDK为1.7….于是就有了这篇记录。</p><p>在终端下面使用<code>java -version</code>查看就可以查看使用的JDK版本了。<br>使用<code>/usr/libexec/java_home -V</code>可以查看本地已经安装的JDK</p><p>关于JDK1.x for mac的安装略过，网上有大把的教程。<br>我这里以安装3个版本1.6/1.7/1.8为例。</p><p>一、编辑.bash_profile<br><code>vim ~/.bash_profile</code></p><p>二、在.bash_profile中添加下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`</span><br><span class="line">export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7`</span><br><span class="line">export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`</span><br><span class="line"></span><br><span class="line">#默认设为JDK1.7</span><br><span class="line">export JAVA_HOME=$JAVA_7_HOME</span><br><span class="line"></span><br><span class="line">#alias命令动态切换JDK版本</span><br><span class="line">alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot;</span><br><span class="line">alias jdk7=&quot;export JAVA_HOME=$JAVA_7_HOME&quot;</span><br><span class="line">alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;</span><br></pre></td></tr></table></figure></p><p>三、刷新环境<br><code>source ~/.bash_profile</code></p><p>四、测试<br>执行：<code>jdk8</code>，再执行<code>java -version</code>，看看是不是1.8版本？<br>执行：<code>jdk6</code>，再执行<code>java -version</code>，看看是不是1.6版本？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着JDK版本的快速迭代，作为优秀(kubi)的Java拥护者，为了跟随时代的潮流，也开始使用1.8版本。&lt;/p&gt;
&lt;p&gt;但是，某一天。。。。苦逼的事情发生了，一个项目原本是好好的，突然报错起不来了。最终查到的原因是某个项目的Jar包使用的JDK为1.7….于是就有了这篇记
      
    
    </summary>
    
      <category term="一些奇淫技巧" scheme="http://yoursite.com/categories/%E4%B8%80%E4%BA%9B%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Cloneable接口实现原理</title>
    <link href="http://yoursite.com/2019/06/04/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Cloneable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/06/04/面试准备/Cloneable实现原理/</id>
    <published>2019-06-04T14:41:31.000Z</published>
    <updated>2019-12-18T17:21:15.113Z</updated>
    
    <content type="html"><![CDATA[<p>Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例当中。</p><p>在开发过程中，如果一个类中的字段比较多，而我们如果采用在客户端中逐字段复制的方法来进行拷贝操作的话，将不可避免的造成客户端代码繁杂，而且也无法对类中的私有对象进行复制，而如果让需要具备拷贝功能的类实现<code>Cloneable</code>接口，并重写<code>clone()</code>方法的方式来简洁地实现实例拷贝功能。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><code>private class Demo implements Cloneable{}</code><br>我们创建一个Demo类，并让他实现Cloneable接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Cloneable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们发现<code>Cloneable</code>几口里面并没有定义任何接口方法。<br>这是因为在<code>Object</code>类中已经将<code>clone()</code>方法定义为所有类都应该具有的基本功能，只是将该方法声明为了<code>protected</code>类型。它是一个<code>native</code>本地方法。</p><p>如果一个类不实现该接口就直接调用<code>clone()</code>方法的话，就会抛出“不支持拷贝”异常。<br>所以如果要让一个类具有拷贝实例的功能，那么除了要重写<code>Object</code>类中<code>clone()</code>方法外，还必须实现Cloneable接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例当中。&lt;/p&gt;
&lt;p&gt;在开发过程中，如果一个类中的字段比较多，而我们如果采用在客户端中逐字段复制的方法来进行拷贝操作的话，将不可避免的造成客户端代码繁杂，而且也无法对
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2019/06/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/06/03/面试准备/单例模式/</id>
    <published>2019-06-03T14:41:31.000Z</published>
    <updated>2019-12-18T17:21:15.116Z</updated>
    
    <content type="html"><![CDATA[<p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h2 id="单例模式多种写法"><a href="#单例模式多种写法" class="headerlink" title="单例模式多种写法"></a>单例模式多种写法</h2><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>这种方式在类加载时就完成了初始化，所以类加载比较慢，但是获取对象的速度快。这种方式基于类加载机制避免了多线程的同步问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="懒汉模式（线程不安全）"><a href="#懒汉模式（线程不安全）" class="headerlink" title="懒汉模式（线程不安全）"></a>懒汉模式（线程不安全）</h3><p>懒汉模式声明了一个静态对象，在用户第一次调用时进行初始化，虽然节约了资源，但第一次加载时需要实例化，反应稍微慢一点，而且在多线程下不能工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="懒汉模式（线程安全）"><a href="#懒汉模式（线程安全）" class="headerlink" title="懒汉模式（线程安全）"></a>懒汉模式（线程安全）</h3><p>这种写法能够在多线程中很好的工作，但是每次调用getSingleton时都需要同步，造成不必要的同步开销，而且大部分时候我们都是用不到同步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双重检查模式（DCL）"><a href="#双重检查模式（DCL）" class="headerlink" title="双重检查模式（DCL）"></a>双重检查模式（DCL）</h3><p>这种写法对singleton进行了两次的判空操作，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。这里用到了volatile关键字，或多或少还是会影响性能，但是考虑到程序的正确性，牺牲这点性能还是值得的。</p><h4 id="PS：这里为什么要用volatile关键字？"><a href="#PS：这里为什么要用volatile关键字？" class="headerlink" title="PS：这里为什么要用volatile关键字？"></a>PS：这里为什么要用volatile关键字？</h4><p>这个地方使用volatile关键字是很有必要的，因为new一个新的对象其实是分了三步执行：</p><ol><li>为该对象分配内存空间</li><li>初始化对象</li><li>将对象指向分配的内存地址</li></ol><p>由于JVM指令重排的特性，执行顺序可能会变成1-&gt;3-&gt;2；在单线程环境下不会有问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。比如：</p><ol><li>线程1执行了1、3</li><li>线程2调用方法，发现该实例不为空，因此返回该实例。但此时实例还没被初始化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if(singleton == null)&#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton sInstance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，上述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。</p><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     public void doSomeThing() &#123;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用容器实现单例模式"><a href="#使用容器实现单例模式" class="headerlink" title="使用容器实现单例模式"></a>使用容器实现单例模式</h3><p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonManager &#123; </span><br><span class="line">　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();</span><br><span class="line">　　private Singleton() &#123; </span><br><span class="line">　　&#125;</span><br><span class="line">　　public static void registerService(String key, Objectinstance) &#123;</span><br><span class="line">　　　　if (!objMap.containsKey(key) ) &#123;</span><br><span class="line">　　　　　　objMap.put(key, instance) ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　public static ObjectgetService(String key) &#123;</span><br><span class="line">　　　　return objMap.get(key) ;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;h2 id=&quot;单例模式多种写法&quot;&gt;&lt;a href=&quot;#单例模式多种写法&quot; class=&quot;headerlink&quot; title=&quot;单例模式多种写法&quot;&gt;&lt;/a&gt;单例模式多种写法&lt;/h2&gt;&lt;h3 id=&quot;饿汉模式&quot;&gt;&lt;a href=&quot;#饿汉模式&quot; class=&quot;headerlink&quot; title=&quot;饿汉模式&quot;&gt;&lt;/a&gt;饿汉模式&lt;/h3&gt;&lt;p&gt;这种方式在类加载时就完成了初始化，所以类加载比较慢，但是获取对象的速度快。这种方式基于类加载机制避免了多线程的同步问题。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static Singleton singleton = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;懒汉模式（线程不安全）&quot;&gt;&lt;a href=&quot;#懒汉模式（线程不安全）&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式（线程不安全）&quot;&gt;&lt;/a&gt;懒汉模式（线程不安全）&lt;/h3&gt;&lt;p&gt;懒汉模式声明了一个静态对象，在用户第一次调用时进行初始化，虽然节约了资源，但第一次加载时需要实例化，反应稍微慢一点，而且在多线程下不能工作。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static Singleton singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Singleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(singleton == null)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            singleton = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程思想" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap详解</title>
    <link href="http://yoursite.com/2019/06/02/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/HashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/06/02/面试准备/HashMap详解/</id>
    <published>2019-06-02T14:41:31.000Z</published>
    <updated>2019-12-18T17:21:15.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是HashMap"><a href="#什么是HashMap" class="headerlink" title="什么是HashMap"></a>什么是HashMap</h2><p>HashMap一个用于存储Key-Value键值对的集合，每一个键值对称之为<code>Entry</code>分散存储在一个数组中。这个数组每一个元首初始值都是Null。</p><p>HashMap的常用操作就是<b>GET</b>和<b>PUT</b></p><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>我们在调用put方法的时候，会利用一个哈希函数来确定<code>Entry</code>的插入位置。为了解决哈希冲突的问题，HashMap采用<font color="red">链表法</font>来解决这个问题。<br><code>注意：位置0上存放的一定是Null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">modCount++;</span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line">return null;</span><br></pre></td></tr></table></figure></p><p>在遇到Hash冲突的时候，就将<code>Entry</code>以链表的形式给插入到相应的位置，这里需要注意的是：HashMap采用的是<font color="red">头插法</font>的形式。这是因为设计者认为最新加入的<code>Entry</code>更有可能被访问。<br>此时HashMap的结构为<b>数组加链表</b><br><img src="https://s2.ax1x.com/2019/06/16/V7M7nO.jpg" alt=""></p><a id="more"></a><p>当HashMap中有大量的元素都存放在同一个位置的时候，这个位置就有存在一条很长的链表；这个时候的HashMap相当于一个单链表。<br>于是在<b>JDK1.8</b>中引入了<font color="red">红黑树</font>来优化这个问题。当某一个位置上的<font color="red">链表长度大于等于8</font>的时就使用红黑树来进行存储。<br>在元素值小于6的时候就将红黑树又转换成链表形式。<br>此时HashMap的结构为<b>数组加链表加红黑树</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//一个桶的树化阈值</span><br><span class="line">//当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点</span><br><span class="line">//这个值必须为 8，要不然频繁转换效率也不高</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"> </span><br><span class="line">//一个树的链表还原阈值</span><br><span class="line">//当扩容时，桶中元素个数小于这个值，就会把树形的桶元素 还原（切分）为链表结构</span><br><span class="line">//这个值应该比上面那个小，至少为 6，避免频繁转换</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"> </span><br><span class="line">//哈希表的最小树形化容量</span><br><span class="line">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span><br><span class="line">//否则桶内元素太多时会扩容，而不是树形化</span><br><span class="line">//为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure></p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>在HashMap的GET函数中，首先会通过计算键值的哈希值获取到<code>Entry</code>所在的位置，然后通过遍历链表或红黑树中的<code>Entry</code>来确定是否是我们需要的值。</p><p>HashMap在遍历链表比较时使用的Java对象的equals()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != null;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>通过这段代码，我们也可以看出：HashMap是可以存放键为Null的对象</code></p><h4 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line">        while (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + next.getKey() + &quot; value=&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + key + &quot; value=&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>推荐使用第一种方式，第一种方式会将KV同时取出，而第二种方式还需要通过key取一次value，效率比较低。</p><h2 id="HashMap默认初始化长度"><a href="#HashMap默认初始化长度" class="headerlink" title="HashMap默认初始化长度"></a>HashMap默认初始化长度</h2><p>首先，我们要明确的一点就是：<font color="red">HashMap的默认初始化长度是16</font>，并且每次扩容和缩容后的长度大小都是2的幂。</p><p>为什么会有以上的限制呢？<br>这是因为需要实现尽可能分布均匀的Hash函数。HashMap中使用了<font color="red">位取模</font>的方式来计算哈希值。<br><code>index =  HashCode（Key） &amp;  （Length - 1）</code></p><p>这样做不但效果上等同于取模，而且大大提升了性能。<br>使用<code>位运算</code>的方式，相当于只取hash函数的后几位，分布情况取决于hash函数。<br>而使用其他方式，如<code>取模</code>，则可能会导致某些index结果出现的几率大大提升;此外，如果length不是2的幂的话，有些index的结果可能永远不会出现。</p><h2 id="Hash的Rehash"><a href="#Hash的Rehash" class="headerlink" title="Hash的Rehash"></a>Hash的Rehash</h2><p>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。<br>这个时候的HashMap会需要进行扩容行为了。</p><p>影响HashMap扩容的因素有两个：</p><ul><li>Capacity：当前长度</li><li>LoadFactor：负载因子，默认是0.75f</li></ul><p><code>HashMap.Size   &gt;=  Capacity * LoadFactor时就会进行扩容操作了</code></p><p>HashMap的扩容操作分两步：</p><ol><li>创建一个新的数组，大小是原来数组的2倍。</li><li>遍历原数组，将原数组的所有元素重新Hash到新数组。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Transfers all entries from current table to newTable.</span><br><span class="line"> */</span><br><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap每次扩容或缩容都是以2的倍数进行的。<br>这是因为在这样的流程中，HashMap中的<code>Entry</code>需要迁移的只有一半，大大的节省了扩缩容的消耗。</p><h2 id="高并发下的HashMap"><a href="#高并发下的HashMap" class="headerlink" title="高并发下的HashMap"></a>高并发下的HashMap</h2><p>HashMap并不是线程安全的，在多线程操作下可能会导致很多意想不到的情况发生。比如死循环。</p><p>比如在上一小节中讲的Rehash，如果有多个线程同时进行扩容操作就会出现问题。<br>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作：<br><img src="https://s2.ax1x.com/2019/06/16/V7MbHe.jpg" alt="-w564"><br><img src="https://s2.ax1x.com/2019/06/16/V7MONd.jpg" alt="-w496"><br>此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：<br><img src="https://s2.ax1x.com/2019/06/16/V7MLAH.jpg" alt="-w748"><br>这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：<br><img src="https://s2.ax1x.com/2019/06/16/V7MHBD.jpg" alt=""><br>假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：<br><img src="https://s2.ax1x.com/2019/06/16/V7MX4A.jpg" alt="-w778"><br>直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p><img src="https://s2.ax1x.com/2019/06/16/V7MzgP.jpg" alt=""><br>当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。<br><img src="https://s2.ax1x.com/2019/06/16/V7Mv9I.jpg" alt=""><br>我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且e指向了Entry2。此时e和next的指向如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry2</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QPHg.jpg" alt="-w702"><br>接着是新一轮循环，又执行到红框内的代码行：<br><img src="https://s2.ax1x.com/2019/06/16/V7Mx3t.jpg" alt=""><br>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QSjf.jpg" alt="-w762"><br>接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：<br><img src="https://s2.ax1x.com/2019/06/16/V7Q9u8.jpg" alt=""><br>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QCDS.jpg" alt="-w746"><br>第三次循环开始，又执行到红框的代码：<br><img src="https://s2.ax1x.com/2019/06/16/V7QkNj.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry3.next = null</span><br></pre></td></tr></table></figure></p><p>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：<br><img src="https://s2.ax1x.com/2019/06/16/V7QFEQ.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = Entry2</span><br><span class="line">e = Entry3</span><br><span class="line">Entry2.next = Entry3</span><br><span class="line">Entry3.next = Entry2</span><br></pre></td></tr></table></figure></p><p>链表出现了环形！</p><p>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QA4s.jpg" alt="-w751"><br>此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是HashMap&quot;&gt;&lt;a href=&quot;#什么是HashMap&quot; class=&quot;headerlink&quot; title=&quot;什么是HashMap&quot;&gt;&lt;/a&gt;什么是HashMap&lt;/h2&gt;&lt;p&gt;HashMap一个用于存储Key-Value键值对的集合，每一个键值对称之为&lt;code&gt;Entry&lt;/code&gt;分散存储在一个数组中。这个数组每一个元首初始值都是Null。&lt;/p&gt;
&lt;p&gt;HashMap的常用操作就是&lt;b&gt;GET&lt;/b&gt;和&lt;b&gt;PUT&lt;/b&gt;&lt;/p&gt;
&lt;h4 id=&quot;PUT&quot;&gt;&lt;a href=&quot;#PUT&quot; class=&quot;headerlink&quot; title=&quot;PUT&quot;&gt;&lt;/a&gt;PUT&lt;/h4&gt;&lt;p&gt;我们在调用put方法的时候，会利用一个哈希函数来确定&lt;code&gt;Entry&lt;/code&gt;的插入位置。为了解决哈希冲突的问题，HashMap采用&lt;font color=&quot;red&quot;&gt;链表法&lt;/font&gt;来解决这个问题。&lt;br&gt;&lt;code&gt;注意：位置0上存放的一定是Null&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Object k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                V oldValue = e.value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.recordAccess(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return oldValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addEntry(hash, key, value, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return null;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在遇到Hash冲突的时候，就将&lt;code&gt;Entry&lt;/code&gt;以链表的形式给插入到相应的位置，这里需要注意的是：HashMap采用的是&lt;font color=&quot;red&quot;&gt;头插法&lt;/font&gt;的形式。这是因为设计者认为最新加入的&lt;code&gt;Entry&lt;/code&gt;更有可能被访问。&lt;br&gt;此时HashMap的结构为&lt;b&gt;数组加链表&lt;/b&gt;&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/16/V7M7nO.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Object的常用方法</title>
    <link href="http://yoursite.com/2019/06/01/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Object%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/06/01/面试准备/Object的常用方法/</id>
    <published>2019-06-01T14:41:31.000Z</published>
    <updated>2019-12-18T17:21:15.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object类常见方法"><a href="#Object类常见方法" class="headerlink" title="Object类常见方法"></a>Object类常见方法</h1><p>Object是一个特殊的类，所有的类都会隐式的继承Object类。Object中主要有以下11个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">注：native方法：使用这个关键字说明这个方法是原生方法，底层使用C/C++实现，并且被编译成了DLL，由Java调用。函数实现在DLL中，JDK源码并不包含。</span><br><span class="line"></span><br><span class="line">public final native Class&lt;?&gt; getClass()</span><br><span class="line">用于返回当前运行时对象的Class对象，使用final关键字修饰，不允许子类重写。</span><br><span class="line"></span><br><span class="line">public native int hashCode()</span><br><span class="line">用于返回对象的哈希码，主要使用在哈希表中。</span><br><span class="line"></span><br><span class="line">public boolean equals(Object obj)</span><br><span class="line">用于比较2个对象的内存地址是否相等，String类对该方法进行了重写。</span><br><span class="line"></span><br><span class="line">protected native Object clone() throws CloneNotSupportedException</span><br><span class="line">用于创建当前对象的一份拷贝。Object本身并没有实现Cloneable接口，所以不重写clone方法并且进行调用就会发生CloneNotSupportedException异常。</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">默认返回类的名字@实例的哈希码的16进制的字符串，建议所有子类都重写该方法。</span><br><span class="line"></span><br><span class="line">public final native void notify()</span><br><span class="line">final方法，用于唤醒一个在此对象监视器上等待的线程。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="line"></span><br><span class="line">public final native void notifyAll()</span><br><span class="line">用于唤醒该对象上所有的等待线程。</span><br><span class="line"></span><br><span class="line">public final native void wait(long timeout) throws InterruptedException</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException</span><br><span class="line">public final void wait() throws InterruptedException</span><br><span class="line">暂停线程的执行，第二个超时时间需要增加nanos毫秒，第三个没有超时时间。</span><br><span class="line"></span><br><span class="line">protected void finalize() throws Throwable &#123; &#125;</span><br><span class="line">实例被垃圾回收器回收的时候触发的操作。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object类常见方法&quot;&gt;&lt;a href=&quot;#Object类常见方法&quot; class=&quot;headerlink&quot; title=&quot;Object类常见方法&quot;&gt;&lt;/a&gt;Object类常见方法&lt;/h1&gt;&lt;p&gt;Object是一个特殊的类，所有的类都会隐式的继承Object类。O
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>GET和POST的区别</title>
    <link href="http://yoursite.com/2019/04/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/04/05/面试准备/GET和POST的区别/</id>
    <published>2019-04-05T14:16:26.000Z</published>
    <updated>2019-12-18T17:21:15.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h1><p>GET和POST是HTTP请求的两种发送方式，其本质上并没有多大区别。HTTP的底层是TCP/IP协议，所以GET和POST底层实现也是TCP/IP协议，也就是GET和POST都是TCP连接，GET和POST做的事情都是一样的。如果在GET上加上<code>request body</code>，POST上加上<code>url</code>在技术上完全是可行的。</p><p>但是GET和POST在一些表现上还是有区别的。主要体现在以下几个方面：</p><ul><li>GET请求在URL中传送的参数是有长度限制的，POST没有</li><li>GET会将参数直接显示在URL上，所以POST更为安全</li><li>GET参数传递通过URL，POST参数传递通过request body</li><li>GET请求参数记录会被保留在浏览器记录中，POST不会</li><li>POST支持多种编码方式</li><li>POST在回退的时候会再次提交数据，GET不会</li><li>在某些浏览器下，GET只会发送一次数据包，而POST需要发送两次</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GET和POST请求的区别&quot;&gt;&lt;a href=&quot;#GET和POST请求的区别&quot; class=&quot;headerlink&quot; title=&quot;GET和POST请求的区别&quot;&gt;&lt;/a&gt;GET和POST请求的区别&lt;/h1&gt;&lt;p&gt;GET和POST是HTTP请求的两种发送方式，其本质
      
    
    </summary>
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OMG_By</title>
  
  <subtitle>你走与不走，路就在那里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-24T07:05:44.833Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OMG_By</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java实现快排</title>
    <link href="http://yoursite.com/2019/07/24/java%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8E%92/"/>
    <id>http://yoursite.com/2019/07/24/java实现快排/</id>
    <published>2019-07-24T07:04:30.000Z</published>
    <updated>2019-07-24T07:05:44.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>在数组中选出一个元素做为中枢值，把所有比它小的元素都移动到它的左边，比它大的元素都移动到它的右边。直到数组有序。<br><img src="https://img-blog.csdnimg.cn/20190723124826723.gif" alt=""></p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static void qSort(int[] a,int left,int right)&#123;</span><br><span class="line">    if(left &lt; right)&#123;</span><br><span class="line">        int mid = divide(a,left,right);</span><br><span class="line">        qSort(a,left,mid);</span><br><span class="line">        qSort(a,mid+1,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int divide(int[] a,int left,int right)&#123;</span><br><span class="line">    int mid = left;</span><br><span class="line"></span><br><span class="line">    while(left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; a[right] &gt;= a[mid]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (left &lt; right &amp;&amp; a[left] &lt; a[mid]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            swap(a, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] a, int left, int right) &#123;</span><br><span class="line">    int tmp = a[left];</span><br><span class="line">    a[left] = a[right];</span><br><span class="line">    a[right] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体流程：</p><ol><li>定义两个指针<code>left</code>和<code>right</code>代表两个初始化位置，分别表示需要排序数组的最左和最右。</li><li>一直遍历，right向左移动，直到找到小于中枢值的位置。</li><li>一直遍历，left向右移动，直到找到大于中枢值的位置。</li><li>如果left&lt;right，交换这两个元素。</li><li>重复上面步骤。</li><li>使用递归再对两边子数组进行排序。</li></ol><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//    非递归实现快排</span><br><span class="line">    private static void qSort2(int[] a,int left,int right)&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();</span><br><span class="line">        s.push(left);</span><br><span class="line">        s.push(right);</span><br><span class="line"></span><br><span class="line">        while(!s.isEmpty())&#123;</span><br><span class="line">            int r = s.pop();</span><br><span class="line">            int l = s.pop();</span><br><span class="line">            int mid = divide(a,l,r);</span><br><span class="line">            if(l &lt; mid)&#123;</span><br><span class="line">                s.push(l);</span><br><span class="line">                s.push(mid);</span><br><span class="line">            &#125;</span><br><span class="line">            if(mid + 1 &lt; right)&#123;</span><br><span class="line">                s.push(mid+1);</span><br><span class="line">                s.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对需要排序的数组的左指针和右指针l、r记录起来，压入到栈中，每次循环都会弹出一对l、r。<br>当栈为空时，说明都已经排序了。接收循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h2&gt;&lt;p&gt;在数组中选出一个元素做为中枢值，把所有比它小的元素都移动到它的左边，比它大的元素都移动到它的右边。直到数组有序。&lt;br&gt;&lt;i
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之sort</title>
    <link href="http://yoursite.com/2019/07/23/Linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bsort/"/>
    <id>http://yoursite.com/2019/07/23/Linux/Linux命令之sort/</id>
    <published>2019-07-23T04:48:18.000Z</published>
    <updated>2019-07-23T05:26:13.970Z</updated>
    
    <content type="html"><![CDATA[<p>Linux自带排序命令：<code>sort</code><br>在一些临时性排序需求的时候，使用该命令可以快速的处理。小巧的工具使我们使用非常便捷。<br>语法：<code>sort [-bcCdfghiRMmnrsuVz] [-k field1[,field2]] [-S memsize] [-T dir] [-t char] [-o output] [file ...]</code></p><h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-b 忽略每行前面开始出的空格字符。</span><br><span class="line">-c 检查文件是否已经按照顺序排序。</span><br><span class="line">-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</span><br><span class="line">-f 排序时，将小写字母视为大写字母。</span><br><span class="line">-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</span><br><span class="line">-k：以哪个区间 (field) 来进行排序</span><br><span class="line">-m：将几个排序好的文件进行合并，只是单纯合并，不做排序</span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序</span><br><span class="line">-n：依照数值的大小排序</span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入指定的文件</span><br><span class="line">-r：降序</span><br><span class="line">-R: 乱序</span><br><span class="line">-u：忽略相同行</span><br><span class="line">-t&lt;分隔字符&gt;：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ cat sort.log</span><br><span class="line">[@huzhibindeMacBook-Pro:tmp]$ cat sort.log</span><br><span class="line">amac2000    500 2K</span><br><span class="line">dwinxp4000    300 3G</span><br><span class="line">ebsd1000    600 4M</span><br><span class="line">blinux1000200 5K</span><br><span class="line">fSUSE4000    300 6M</span><br><span class="line">gwinxp500     300 3G</span><br><span class="line">cwin72000    100 7G</span><br><span class="line">cDebian600     200 8K</span><br></pre></td></tr></table></figure><h3 id="打印从哪列开始是乱序"><a href="#打印从哪列开始是乱序" class="headerlink" title="打印从哪列开始是乱序"></a>打印从哪列开始是乱序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -c sort.log</span><br><span class="line">sort: sort.log:4: disorder: b   linux   1000    200 5K</span><br></pre></td></tr></table></figure><h3 id="指定列排序"><a href="#指定列排序" class="headerlink" title="指定列排序"></a>指定列排序</h3><p>默认按照字符排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3 sort.log</span><br><span class="line">blinux10002005K</span><br><span class="line">ebsd10006004M</span><br><span class="line">cwin720001007G</span><br><span class="line">amac20005002K</span><br><span class="line">dwinxp40003003G</span><br><span class="line">fSUSE40003006M</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br></pre></td></tr></table></figure></p><p>按照数字排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n sort.log</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br><span class="line">blinux10002005K</span><br><span class="line">ebsd10006004M</span><br><span class="line">amac20005002K</span><br><span class="line">cwin720001007G</span><br><span class="line">dwinxp40003003G</span><br><span class="line">fSUSE40003006M</span><br></pre></td></tr></table></figure></p><h3 id="u和uniq的区别"><a href="#u和uniq的区别" class="headerlink" title="-u和uniq的区别"></a>-u和uniq的区别</h3><p>在指定<code>-k</code>的时候，<code>-u</code>是会按照指定的列来忽略重复，<code>uniq</code>是按照整行来去重<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n -u  sort.log</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br><span class="line">ebsd10006004M</span><br><span class="line">amac20005002K</span><br><span class="line">dwinxp40003003G</span><br><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n   sort.log  | uniq</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br><span class="line">blinux10002005K</span><br><span class="line">ebsd10006004M</span><br><span class="line">amac20005002K</span><br><span class="line">cwin720001007G</span><br><span class="line">dwinxp40003003G</span><br><span class="line">fSUSE40003006M</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux自带排序命令：&lt;code&gt;sort&lt;/code&gt;&lt;br&gt;在一些临时性排序需求的时候，使用该命令可以快速的处理。小巧的工具使我们使用非常便捷。&lt;br&gt;语法：&lt;code&gt;sort [-bcCdfghiRMmnrsuVz] [-k field1[,field2]] [-S memsize] [-T dir] [-t char] [-o output] [file ...]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;可选项&quot;&gt;&lt;a href=&quot;#可选项&quot; class=&quot;headerlink&quot; title=&quot;可选项&quot;&gt;&lt;/a&gt;可选项&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-b 忽略每行前面开始出的空格字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-c 检查文件是否已经按照顺序排序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-f 排序时，将小写字母视为大写字母。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-k：以哪个区间 (field) 来进行排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-m：将几个排序好的文件进行合并，只是单纯合并，不做排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-M：将前面3个字母依照月份的缩写进行排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n：依照数值的大小排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o&amp;lt;输出文件&amp;gt;：将排序后的结果存入指定的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-r：降序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-R: 乱序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-u：忽略相同行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-t&amp;lt;分隔字符&amp;gt;：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Redis</title>
    <link href="http://yoursite.com/2019/07/21/mall/SpringBoot%E6%95%B4%E5%90%88Redis/"/>
    <id>http://yoursite.com/2019/07/21/mall/SpringBoot整合Redis/</id>
    <published>2019-07-21T14:34:11.000Z</published>
    <updated>2019-07-21T14:34:53.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-boot中使用Redis"><a href="#Spring-boot中使用Redis" class="headerlink" title="Spring boot中使用Redis"></a>Spring boot中使用Redis</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=0</span><br><span class="line"></span><br><span class="line">## Redis自定义key配置选项</span><br></pre></td></tr></table></figure><h2 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// 保存字符串</span><br><span class="line">stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;);</span><br><span class="line">Assert.assertEquals(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-boot中使用Redis&quot;&gt;&lt;a href=&quot;#Spring-boot中使用Redis&quot; class=&quot;headerlink&quot; title=&quot;Spring boot中使用Redis&quot;&gt;&lt;/a&gt;Spring boot中使用Redis&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Swagger2</title>
    <link href="http://yoursite.com/2019/07/21/mall/SpringBoot%E6%95%B4%E5%90%88Swagger2/"/>
    <id>http://yoursite.com/2019/07/21/mall/SpringBoot整合Swagger2/</id>
    <published>2019-07-21T13:57:43.000Z</published>
    <updated>2019-07-21T14:34:57.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a>Swagger2</h1><p>Swagger2用于解决前后端开发人员之间的api对接，减少与其他团队开发期间的沟通成本。Swagger2可以轻松的整合到Spring boot中，并与SpringMVC程序配合组织处强大的Restful API文档。即可以减少我们创建文档的工作量，同时说明内容整合到实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。<br>另外，Swagger2也提供了强大的页面测试功能来调试每个Restful API</p><h2 id="添加Swagger2依赖"><a href="#添加Swagger2依赖" class="headerlink" title="添加Swagger2依赖"></a>添加Swagger2依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="创建Swagger2配置类"><a href="#创建Swagger2配置类" class="headerlink" title="创建Swagger2配置类"></a>创建Swagger2配置类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket CreateRestApi()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.hoo.springboot&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo()&#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如以上代码，通过<code>@Configuration</code>注解，让Spring来加载该类配置。再通过<code>@EnabledSwagger2</code>注解来启用Swagger2。</p><p>再通过<code>createRestApi</code>函数创建<code>Docket</code>的Bean之后，<code>apiInfo()</code>用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。<code>select()</code>函数返回一个<code>ApiSelectorBuilder</code>实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被<code>@ApiIgnore</code>指定的请求）。</p><h2 id="添加文档内容"><a href="#添加文档内容" class="headerlink" title="添加文档内容"></a>添加文档内容</h2><p>在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过<code>@ApiOperation</code>注解来给API增加说明、通过<code>@ApiImplicitParams</code>、<code>@ApiImplicitParam</code>注解来给参数增加说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(value = &quot;/users&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  创建一个线程安全的Map模拟数据用户信息</span><br><span class="line">     */</span><br><span class="line">    static Map&lt;Integer, User&gt; userMap = Collections.synchronizedMap(new HashMap&lt;Integer,User&gt;());</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&quot;,method = RequestMethod.GET)</span><br><span class="line">    public List&lt;User&gt; getUserList()&#123;</span><br><span class="line">        List&lt;User&gt; r = new ArrayList&lt;User&gt;(userMap.values());</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&quot;,method = RequestMethod.POST)</span><br><span class="line">    public String postUser(@ModelAttribute User user)&#123;</span><br><span class="line">        userMap.put(user.getId(),user);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br><span class="line">    public User getUser(@PathVariable Integer id)&#123;</span><br><span class="line"></span><br><span class="line">        return userMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.PUT)</span><br><span class="line">    public String putUser(@PathVariable Integer id,@ModelAttribute User user)&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        User u = userMap.get(id);</span><br><span class="line">        u.setAge(user.getAge());</span><br><span class="line">        u.setName(user.getName());</span><br><span class="line"></span><br><span class="line">        userMap.put(id,u);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除对象&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span><br><span class="line">    public String deleteUser(@PathVariable Integer id)&#123;</span><br><span class="line"></span><br><span class="line">        userMap.remove(id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成上述代码添加上，启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a><br><a href="https://imgchr.com/i/eCParT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/21/eCParT.md.jpg" alt="eCParT.md.jpg"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Swagger2&quot;&gt;&lt;a href=&quot;#Swagger2&quot; class=&quot;headerlink&quot; title=&quot;Swagger2&quot;&gt;&lt;/a&gt;Swagger2&lt;/h1&gt;&lt;p&gt;Swagger2用于解决前后端开发人员之间的api对接，减少与其他团队开发期间的沟通成本。Swagger2可以轻松的整合到Spring boot中，并与SpringMVC程序配合组织处强大的Restful API文档。即可以减少我们创建文档的工作量，同时说明内容整合到实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。&lt;br&gt;另外，Swagger2也提供了强大的页面测试功能来调试每个Restful API&lt;/p&gt;
&lt;h2 id=&quot;添加Swagger2依赖&quot;&gt;&lt;a href=&quot;#添加Swagger2依赖&quot; class=&quot;headerlink&quot; title=&quot;添加Swagger2依赖&quot;&gt;&lt;/a&gt;添加Swagger2依赖&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
      <category term="mall" scheme="http://yoursite.com/categories/SpringBoot/mall/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring boot整合MyBatis逆向工程</title>
    <link href="http://yoursite.com/2019/07/18/mall/Spring-boot%E6%95%B4%E5%90%88MyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/18/mall/Spring-boot整合MyBatis逆向工程/</id>
    <published>2019-07-18T15:03:57.000Z</published>
    <updated>2019-07-21T14:38:28.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pom-xml中添加依赖"><a href="#pom-xml中添加依赖" class="headerlink" title="pom.xml中添加依赖"></a>pom.xml中添加依赖</h2><p>在这里引入了<code>pagehelper</code>，<code>pagehelper</code>是MyBatis的分页插件，通过几行简单的代码就是实现分页功能；在与Spring boot整合的时候，只要整合了<code>pagehelper</code>就自动整合了MyBatis。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- spring boot健康检查、审计、统计、监控--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--MyBatis分页插件--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- MyBatis 生成器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="修改Spring-boot配置文件"><a href="#修改Spring-boot配置文件" class="headerlink" title="修改Spring boot配置文件"></a>修改Spring boot配置文件</h2><p>在<code>application.yml</code>中添加数据源配置和MyBatis的mapper.xml的路径配置。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:13307/spring</span><br><span class="line">    password: hoo</span><br><span class="line">    username: hoo</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mapper/*.xml</span><br><span class="line">    - classpath*:com/**/mapper/*.xml</span><br></pre></td></tr></table></figure><h2 id="修改Mybatis-generator配置文件"><a href="#修改Mybatis-generator配置文件" class="headerlink" title="修改Mybatis generator配置文件"></a>修改Mybatis generator配置文件</h2><p>主要是修改数据库连接配置，MyBatis generator生成的model、mapper接口、mapper.xml文件的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;properties resource=&quot;generator.properties&quot;/&gt;</span><br><span class="line">    &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">        &lt;!-- 为模型生成序列化方法--&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 为生成的Java模型创建一个toString方法 --&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 数据库资源配置 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">                        connectionURL=&quot;jdbc:mysql://127.0.0.1:13307/spring&quot;</span><br><span class="line">                        userId=&quot;hoo&quot;</span><br><span class="line">                        password=&quot;hoo&quot;&gt;</span><br><span class="line">            &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt;</span><br><span class="line">            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!-- 生成的model放置路径 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.hoo.springboot.mbg.model&quot; targetProject=&quot;./src/main/java&quot;/&gt;</span><br><span class="line">        &lt;!-- 生成的mapper接口放置路径 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.hoo.springboot.mbg.mapper&quot; targetProject=&quot;./src/main/resources&quot;/&gt;</span><br><span class="line">        &lt;!-- 生成的mapper配置文件放置路径 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.hoo.springboot.mbg.mapper&quot;</span><br><span class="line">                             targetProject=&quot;./src/main/java&quot;/&gt;</span><br><span class="line">        &lt;!--生成全部表tableName设为%--&gt;</span><br><span class="line">        &lt;table tableName=&quot;%&quot;&gt;</span><br><span class="line">            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure></p><h2 id="运行Generator的main函数生成代码"><a href="#运行Generator的main函数生成代码" class="headerlink" title="运行Generator的main函数生成代码"></a>运行Generator的main函数生成代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Generator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //MBG 执行过程中的警告信息</span><br><span class="line">        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">        //当生成的代码重复时，覆盖原代码</span><br><span class="line">        boolean overwrite = true;</span><br><span class="line">        //读取我们的 MBG 配置文件</span><br><span class="line">        InputStream is = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;);</span><br><span class="line">        ConfigurationParser cp = new ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(is);</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">        /* 创建 MBG */</span><br><span class="line">        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        //执行生成代码</span><br><span class="line">        myBatisGenerator.generate(null);</span><br><span class="line">        //输出警告信息</span><br><span class="line">        for (String warning : warnings) &#123;</span><br><span class="line">            System.out.println(warning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pom-xml中添加依赖&quot;&gt;&lt;a href=&quot;#pom-xml中添加依赖&quot; class=&quot;headerlink&quot; title=&quot;pom.xml中添加依赖&quot;&gt;&lt;/a&gt;pom.xml中添加依赖&lt;/h2&gt;&lt;p&gt;在这里引入了&lt;code&gt;pagehelper&lt;/code&gt;，
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
      <category term="mall" scheme="http://yoursite.com/categories/SpringBoot/mall/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制</title>
    <link href="http://yoursite.com/2019/07/16/Java/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/16/Java/Java类加载机制/</id>
    <published>2019-07-16T14:59:41.000Z</published>
    <updated>2019-07-17T05:20:10.808Z</updated>
    
    <content type="html"><![CDATA[<p>类的加载是指将类的<code>.class</code>文件中的<strong>二进制数据读入到内存</strong>中，将其放在运行时数据区的方法区，然后在Java堆中创建一个java.lang.Class对象(类也是对象)，用来封装类在方法区内的数据结构。<br>类加载的最终产物是位于堆中的Class对象，该Class对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。<br><a href="https://imgchr.com/i/ZqjkUs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjkUs.jpg" alt="ZqjkUs.jpg"></a></p><p>类加载器不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用的时候就预先加载，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器必须在程序<font color="red">首次主动使用该类</font>时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p><a href="https://imgchr.com/i/ZqjPbQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjPbQ.jpg" alt="ZqjPbQ.jpg"></a></p><p>类的生命周期主要包含<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>、<code>使用</code>、<code>卸载</code>。<br>在加载过程中的五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>初始化</code>发生的顺序是一定的，而<code>解析</code>在某些情况下可以在<code>初始化</code>阶段之后执行。这是为了支持Java语言的运行时绑定。<br>另外需要注意的是：这几个阶段是按照顺序开始，而不是按照顺序进行或完成，因为这些阶段通常是相互交叉混合进行的，通常在一个阶段执行的过程中需要调用或激活另一个阶段。<br><a id="more"></a></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>查找并加载类的二进制数据是类加载过程的第一个阶段，在这个阶段，虚拟机需要完成以下事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流代表的静态存储结构转化成方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，连接阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。</p><p>在验证阶段，主要是完成以下的校验动作：</p><h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>验证字节流是否符合Class文件格式的规范。例如：是否以<code>OxCAFEBASE</code>开头、主版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p><h3 id="元数据校验"><a href="#元数据校验" class="headerlink" title="元数据校验"></a>元数据校验</h3><p>对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求；列如：这个类是否有父类，除了<code>java.lang.Object</code></p><h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>确保解析动作能正确执行</p><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为类的<code>静态变量</code>分配内存，并将其初始化为默认值</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区分配。</p><ul><li>这个阶段进行内存分配的<font color="red">仅包括类变量(static)</font>，不包括实例变量；实例变量会在对象实例化时随着实例一块分配在Java堆中。</li><li>这个阶段设置的初始值通常是数据类型的默认值，而不是在Java程序中被显式赋予的值。</li><li>如果是同时被final和static修饰的属性，这在准备阶段会被初始化为定义的值。</li></ul><blockquote><p>假设有一个变量public static int value = 3<br>那么变量value在准备阶段过后的初始值是0，而不是3，因为这个时候还没开始执行任何Java方法，把value赋值为3的public static指令是在程序编译后，存放在类构造器<clinit>()方法中，所以value赋值为3的动作在初始化阶段才会执行。</clinit></p></blockquote><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。<br>解析动作主要是针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号类型进行，</p><ul><li>符号引用：用一组符号描述目标，可以是任何字面量</li><li>直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><h3 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h3><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><h3 id="类初始化情况"><a href="#类初始化情况" class="headerlink" title="类初始化情况"></a>类初始化情况</h3><ul><li>使用new创建类的实例</li><li>第一次访问某个类或接口的静态变量，或者对静态变量赋值</li><li>第一次调用类的静态方法</li><li>使用反射加载类(Class.forName(“xxx.xxx”))</li><li>初始化某个类的子类，其父类也会被初始化</li><li>Java虚拟机启动的时候标明启动的类(Java Test)，直接使用<code>java.exe</code>运行某个主类。</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>JVM预定义了三种类加载器，当一个JVM启动的时候，Java会默认使用类加载器进行类加载。</p><ul><li>启动类加载器:负责加载存放在<code>JDK\jre\lib</code>下或被<code>-Xbootclasspath</code>指定路径中的类库。</li><li>扩展类加载器:负责加载<code>JDK\jre\lib\ext</code>或由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库。</li><li>引用类加载器:负责加载用户类路径（ClassPath）所指定的类。程序默认的类加载器。<br><a href="https://imgchr.com/i/ZqjFEj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjFEj.jpg" alt="ZqjFEj.jpg"></a></li></ul><blockquote><p>注：父类加载器并不是通过继承关系实现的，而是采用组合的方式<br>启动类加载器是C++实现，属于虚拟机的一部分；其他类加载器都是由启动类加载器加载到内存中的。</p></blockquote><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><ul><li>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>双亲委派：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h2 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h2><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类的加载是指将类的&lt;code&gt;.class&lt;/code&gt;文件中的&lt;strong&gt;二进制数据读入到内存&lt;/strong&gt;中，将其放在运行时数据区的方法区，然后在Java堆中创建一个java.lang.Class对象(类也是对象)，用来封装类在方法区内的数据结构。&lt;br&gt;类加载的最终产物是位于堆中的Class对象，该Class对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/ZqjkUs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/17/ZqjkUs.jpg&quot; alt=&quot;ZqjkUs.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类加载器不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用的时候就预先加载，如果在预先加载的过程中遇到了&lt;code&gt;.class&lt;/code&gt;文件缺失或存在错误，类加载器必须在程序&lt;font color=&quot;red&quot;&gt;首次主动使用该类&lt;/font&gt;时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。&lt;/p&gt;
&lt;h1 id=&quot;类加载过程&quot;&gt;&lt;a href=&quot;#类加载过程&quot; class=&quot;headerlink&quot; title=&quot;类加载过程&quot;&gt;&lt;/a&gt;类加载过程&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/ZqjPbQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/17/ZqjPbQ.jpg&quot; alt=&quot;ZqjPbQ.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类的生命周期主要包含&lt;code&gt;加载&lt;/code&gt;、&lt;code&gt;验证&lt;/code&gt;、&lt;code&gt;准备&lt;/code&gt;、&lt;code&gt;解析&lt;/code&gt;、&lt;code&gt;初始化&lt;/code&gt;、&lt;code&gt;使用&lt;/code&gt;、&lt;code&gt;卸载&lt;/code&gt;。&lt;br&gt;在加载过程中的五个阶段中，&lt;code&gt;加载&lt;/code&gt;、&lt;code&gt;验证&lt;/code&gt;、&lt;code&gt;准备&lt;/code&gt;、&lt;code&gt;初始化&lt;/code&gt;发生的顺序是一定的，而&lt;code&gt;解析&lt;/code&gt;在某些情况下可以在&lt;code&gt;初始化&lt;/code&gt;阶段之后执行。这是为了支持Java语言的运行时绑定。&lt;br&gt;另外需要注意的是：这几个阶段是按照顺序开始，而不是按照顺序进行或完成，因为这些阶段通常是相互交叉混合进行的，通常在一个阶段执行的过程中需要调用或激活另一个阶段。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Arrays.sort和Collections.sort实现原理</title>
    <link href="http://yoursite.com/2019/07/16/Java/Arrays-sort%E5%92%8CCollections-sort%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/16/Java/Arrays-sort和Collections-sort实现原理/</id>
    <published>2019-07-16T14:51:54.000Z</published>
    <updated>2019-07-16T14:54:32.017Z</updated>
    
    <content type="html"><![CDATA[<p>事实上，在使用<code>Collections.sort(list)</code>的时候，就调用list.sort()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;</span><br><span class="line">        list.sort(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在深入进去后，发现其实调用的就是Array.sort()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">    default void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">        Object[] a = this.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = this.listIterator();</span><br><span class="line">        for (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>而在Array.sort中，会根据该对象是否能够通过归并排序来选择不同的排序方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            else</span><br><span class="line">                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>legacyMergeSort：归并排序</li><li><a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">TimSort</a><br>：结合归并排序和插入排序的一种排序算法</li></ul><blockquote><p>TimSort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。排序的输入的单位不是一个个单独的数字，而是一个个的块-分区。其中每一个分区叫一个run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run合并到只剩一个 run 为止。这时这个仅剩的 run 便是排好序的结果。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事实上，在使用&lt;code&gt;Collections.sort(list)&lt;/code&gt;的时候，就调用list.sort()&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池解析</title>
    <link href="http://yoursite.com/2019/07/15/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/15/面试准备/Java线程池解析/</id>
    <published>2019-07-15T14:02:22.000Z</published>
    <updated>2019-07-15T14:59:24.827Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线程池</strong>：可以根据字面意思简单的理解，一个管理线程的池子。</p><ul><li>帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。</li><li>提高响应速度。</li><li>重复利用。</li></ul><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize：线程池核心线程数最大值</li><li>maximumPoolSize： 线程池最大线程数大小</li><li>keepAliveTime： 线程池中非核心线程空闲的存活时间大小</li><li>unit： 线程空闲存活时间单位</li><li>workQueue： 存放任务的阻塞队列</li><li>threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li><li>handler：  线城池的饱和策略事件，主要有四种类型。</li></ul><h1 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h1><p>线程池执行流程，对应<code>execute()</code>方法。<br><a href="https://imgchr.com/i/Z7iOzt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7iOzt.md.jpg" alt="Z7iOzt.md.jpg"></a><br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        /*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">         * start a new thread with the given command as its first</span><br><span class="line">         * task.  The call to addWorker atomically checks runState and</span><br><span class="line">         * workerCount, and so prevents false alarms that would add</span><br><span class="line">         * threads when it shouldn&apos;t, by returning false.</span><br><span class="line">         *</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need</span><br><span class="line">         * to double-check whether we should have added a thread</span><br><span class="line">         * (because existing ones died since last checking) or that</span><br><span class="line">         * the pool shut down since entry into this method. So we</span><br><span class="line">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">         * stopped, or start a new thread if there are none.</span><br><span class="line">         *</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">         * and so reject the task.</span><br><span class="line">         */</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            else if (workerCountOf(recheck) == 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从execute代码注释中可以看出，任务执行流程主要是以下几步：</p><ul><li>提交任务，如果线程池里存活的核心线程数小于线程数<code>corePoolSize</code>时，线程池就会创建一个核心线程去处理提交的任务</li><li>如果线程池核心线程数满了，那么新提交的任务就会被放进任务队列<code>workQueue</code>中排队等待执行。</li><li>当线程池里面存活的线程数已经等于<code>corePoolSize</code>，并且任务队列<code>workQueue</code>也满了，判断线程数是否达到<code>maximumPoolSize</code>，如果没有达到，创建一个非核心线程执行提交的任务。</li><li>如果当前线程数达到了<code>maximumPoolSize</code>，那么直接采取拒绝策略处理。</li></ul><h1 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h1><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li></ul><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue(有界队列)是一个用数组实现的有界阻塞队列，按照FIFO排序。</p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue(可设置容量队列)基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，就是一个没有边界的阻塞队列，最大长度为Integer.MAX_VALUE。</p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue(延迟队列)是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后顺序排序。</p><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlockingQueue(优先阻塞队列)具有优先级的无界阻塞队列。</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue(同步队列)一个不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移除操作，否则插入操作一直处于阻塞状态。</p><h1 id="几种常用的线程池"><a href="#几种常用的线程池" class="headerlink" title="几种常用的线程池"></a>几种常用的线程池</h1><h2 id="newSingleThreadPool"><a href="#newSingleThreadPool" class="headerlink" title="newSingleThreadPool"></a>newSingleThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>这个线程池只有一个核心线程在工作，也就是相当于单线程串化执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。阻塞队列使用的是<code>LinkedBlockingQueue</code><br><a href="https://imgchr.com/i/Z7i4sK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7i4sK.jpg" alt="Z7i4sK.jpg"></a></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于串行执行任务的场景，一个任务一个任务地执行。</p><!-- more --><p>##newFixedThreadPool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>这个线程池的大小(核心线程)是固定的。每次提交一个任务就创建一个线程，直到线程数达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，会将后面的任务加入到阻塞队列。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。使用的阻塞队列是<code>LinkedBlockingQueue</code><br><a href="https://imgchr.com/i/Z7ihM6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7ihM6.md.jpg" alt="Z7ihM6.md.jpg"></a></p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于处理CPU密集型任务，确保CPU在长期被工作线程使用的情况下，尽可能少的分配线程，适用于执行长期的任务。</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">     return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                   60L, TimeUnit.SECONDS,</span><br><span class="line">                                   new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>创建一个可缓存的线程池(即核心线程数为0)，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲(60s不执行任务)的线程，当任务数增加时，此线程池又可以智能的添加新的线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统能够创建的最大线程大小。阻塞队列使用的是<code>SynchronousQueue</code><br><a href="https://imgchr.com/i/Z7iWxx" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7iWxx.md.jpg" alt="Z7iWxx.md.jpg"></a></p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>用于并发执行大量短期的小任务</p><h2 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>创建一个大小为<code>Integer.MAX_VALUE</code>的线程池，此线程池支持定时以及周期性执行任务的需求。阻塞队列使用的是<code>DelayedWorkQueue</code></p><ol><li>添加一个任务</li><li>线程池中的线程从DelayQueue中取任务</li><li>线程从DelayQueue中获取time大于等于当前时间的task</li><li>执行完后修改这个task的time为下一次被执行的时间</li><li>这个task返回到DelayQueue队列中</li></ol><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要周期性执行任务的场景，需要限制线程数量的场景</p><blockquote><p><a href="https://juejin.im/post/5d1882b1f265da1ba84aa676?utm_source=gold_browser_extension#heading-37" target="_blank" rel="noopener">https://juejin.im/post/5d1882b1f265da1ba84aa676?utm_source=gold_browser_extension#heading-37</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;线程池&lt;/strong&gt;：可以根据字面意思简单的理解，一个管理线程的池子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。&lt;/li&gt;
&lt;li&gt;提高响应速度。&lt;/li&gt;
&lt;li&gt;重复利用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public ThreadPoolExecutor(int corePoolSize,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              int maximumPoolSize,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              long keepAliveTime,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              TimeUnit unit,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             Executors.defaultThreadFactory(), defaultHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;corePoolSize：线程池核心线程数最大值&lt;/li&gt;
&lt;li&gt;maximumPoolSize： 线程池最大线程数大小&lt;/li&gt;
&lt;li&gt;keepAliveTime： 线程池中非核心线程空闲的存活时间大小&lt;/li&gt;
&lt;li&gt;unit： 线程空闲存活时间单位&lt;/li&gt;
&lt;li&gt;workQueue： 存放任务的阻塞队列&lt;/li&gt;
&lt;li&gt;threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。&lt;/li&gt;
&lt;li&gt;handler：  线城池的饱和策略事件，主要有四种类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;任务执行流程&quot;&gt;&lt;a href=&quot;#任务执行流程&quot; class=&quot;headerlink&quot; title=&quot;任务执行流程&quot;&gt;&lt;/a&gt;任务执行流程&lt;/h1&gt;&lt;p&gt;线程池执行流程，对应&lt;code&gt;execute()&lt;/code&gt;方法。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/Z7iOzt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/15/Z7iOzt.md.jpg&quot; alt=&quot;Z7iOzt.md.jpg&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Bitmap、Bloom Filter、Cuckoo Filter</title>
    <link href="http://yoursite.com/2019/07/15/Bitmap%E3%80%81Bloom-Filter%E3%80%81Cuckoo-Filter/"/>
    <id>http://yoursite.com/2019/07/15/Bitmap、Bloom-Filter、Cuckoo-Filter/</id>
    <published>2019-07-15T04:11:26.000Z</published>
    <updated>2019-07-15T04:16:44.081Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，在跟同学&amp;同事谈人生谈理想的时候。他告诉我他学长面试头条，其中一道题是如何判断一个整数在不在40亿整数集中；他说他学长竟然不知道<code>bitmap</code>(<a href="https://mp.weixin.qq.com/s/pUq213AJDpTGdGw4ywIS7g" target="_blank" rel="noopener">原题链接</a>)!!!然后我又给他科普了一下<code>布隆过滤器</code>和<code>布谷鸟过滤器</code>。<br>所以借此文章来记录一下这些知识，并巩固一下。</p><h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><p>Bitmap，直译就叫位图。可以理解为通过一个bit数组存储特定数据的一种数据结构；由于bit是数据的最小单位，所以这种数据结构往往是非常节省存储空间的。在Java和Redis中都存在同名实现结构。<br>在一个记录只有两种状态，是或不是的场景下，如果使用其他数据结构存储则会存在大量空间空间的浪费。即使存在海量的数据，我们也只需要为每个数据分配<code>1byte</code>的空间就可以记录了。比如：用户画像<br>Bitmap可以<font color="red">节省大量的存储空间</font>，所以可以很容易的倍一次性加载到内存中。Bitmap结构还有一个很重要的特点:<font color="red">可以很方便的进行位运算</font><br>比如我们需要统计用户满足以下条件的用户：程序员、带眼镜、长头发。。。。那么我们可以将对相应条件的用户画像的<code>Bitmap</code>结构做<code>AND</code>操作，就可以方便的过滤出满足条件的对象了。</p><h2 id="Bitmap的优化"><a href="#Bitmap的优化" class="headerlink" title="Bitmap的优化"></a>Bitmap的优化</h2><a id="more"></a><p>假如一个Bitmap中只有稀疏的那个几个1，那么其他空间是不是就被浪费了呢？</p><p>谷歌开发的EWAHComressedBitmap对Bitmap存储空间做了一定的优化操作。</p><p>EWAH把Bitmap存储在一个long数组中，long数组的每一个元素都可以当做64位的二进制数，也就是整个Bitmap的子集，称为<code>Word</code>。<br>当创建一个空的Bitmap时，只有4个<code>Word</code>，也就是只有4个long数组，随着数据的不断插入，<code>Word</code>数组会随着进行扩容。<br><code>Word</code>节点分为两种，直接存储数据的叫做<code>Literal Word</code>，简称LW。存储跨度信息的叫<code>Running Length Word</code>，简称RLW。<br>每一个RLW分为两部分，低32位表示当前Word横跨了多少个空Word，高32位表示当前RLW后面又多少个连续的LW。这样即使存在很多个0的位置，也能进行合并，减少浪费。<br><a href="https://imgchr.com/i/ZoGNon" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGNon.md.jpg" alt="ZoGNon.md.jpg"></a></p><h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><p>Bitmap适合处理<font color="red">按顺序字段映射</font>，如ID。但是当遇到其他情况时就无能为力了，比如判断一个单词是否存在于单词集中，这个时候如果需要映射的话，只能够对该单词进行相应的<code>hash</code>计算后映射到Bitmap上，But！绝大情况下会存在hash冲突，无法确认是不是。</p><p>于是便引入了<font color="red">布隆过滤器</font>。布隆过滤器也不能完全的消除误差。只能说大大的减少了误差率。</p><p>布隆过滤器的原理就是<font color="red">将需要判断的对象进行多次不同的hash计算后，同时判断那几位是否都为1</font>，由此可见，布隆过滤器的误差率取决于hash函数的选取。<br><a href="https://imgchr.com/i/ZoGYZj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGYZj.md.jpg" alt="ZoGYZj.md.jpg"></a></p><h1 id="Cuckoo-Filter"><a href="#Cuckoo-Filter" class="headerlink" title="Cuckoo Filter"></a>Cuckoo Filter</h1><p>布隆过滤器存在一个致命的缺点，那就是已经置为1的位不能再重置为0。这是因为你并不能判断该位具体被多少个对象映射了。只能在你认为误差率已经不能接受时进行重建。</p><p>我也是最近才了解到有<code>布谷鸟过滤器</code>的存在。</p><h2 id="布谷鸟哈希"><a href="#布谷鸟哈希" class="headerlink" title="布谷鸟哈希"></a>布谷鸟哈希</h2><p>最简单的布谷鸟哈希结构时一维数组结构，会有两个hash算法将新来的元素映射到数组的两个位置。如果两个位置中有一个位置为空，那么就可以把元素放进去；但是如果这两个位置都满了，那么会随机踢走一个，然后自己霸占这个位置。<br>被踢走的那个元素会寻找其他位置，重复上面的行为。知道所有的元素都找到了对应的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = hash1(x) % l</span><br><span class="line">p2 = hash2(x) % l</span><br></pre></td></tr></table></figure></p><p>布谷鸟算法为了避免重复踢的这个过程执行次数过多，会设置一个阈值，如果执行次数超过这个值，那么就会进行扩容操作，重新放置所有的元素。<br><a href="https://imgchr.com/i/ZoGGLQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGGLQ.md.jpg" alt="ZoGGLQ.md.jpg"></a><br><a href="https://imgchr.com/i/ZoG8sg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoG8sg.md.jpg" alt="ZoG8sg.md.jpg"></a></p><h2 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h2><p>布谷鸟过滤器和布谷鸟哈希结构一样，也是一维数组，但是不同于布谷鸟哈希的是，布谷鸟哈希会存储整个元素，而布谷鸟过滤器只会储存元素的指纹信息（只有几个bit，类似于布隆过滤器）。</p><p>首先布谷鸟过滤器还是只会选用两个 hash 函数，但是每个位置可以放置多个座位。这两个 hash 函数选择的比较特殊，因为过滤器中只能存储指纹信息。当这个位置上的指纹被挤兑之后，它需要计算出另一个对偶位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fp = fingerprint(x)</span><br><span class="line">p1 = hash(x)</span><br><span class="line">p2 = p1 ^ hash(fp)  // 异或</span><br></pre></td></tr></table></figure></p><p>我们可以看出p1和p2具有<code>对偶性</code>。所以我们根本不需要知道当前的位置是 p1 还是 p2，只需要将当前的位置和 hash(fp) 进行异或计算就可以得到对偶位置。而且只需要确保 hash(fp) != 0 就可以确保 p1 != p2，如此就不会出现自己踢自己导致死循环的问题。</p><p>由于布谷鸟过滤器保证了一个byte只被一个元素映射，所以允许删除操作，但是会存在误删的情况。</p><blockquote><p><a href="http://blog.talkingdata.net/?p=2493" target="_blank" rel="noopener">http://blog.talkingdata.net/?p=2493</a><br><a href="https://juejin.im/post/5c4fd2af51882525da267385" target="_blank" rel="noopener">https://juejin.im/post/5c4fd2af51882525da267385</a><br><a href="https://cloud.tencent.com/developer/article/1447177" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1447177</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天，在跟同学&amp;amp;同事谈人生谈理想的时候。他告诉我他学长面试头条，其中一道题是如何判断一个整数在不在40亿整数集中；他说他学长竟然不知道&lt;code&gt;bitmap&lt;/code&gt;(&lt;a href=&quot;https://mp.weixin.qq.com/s/pUq213AJDpTGdGw4ywIS7g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;)!!!然后我又给他科普了一下&lt;code&gt;布隆过滤器&lt;/code&gt;和&lt;code&gt;布谷鸟过滤器&lt;/code&gt;。&lt;br&gt;所以借此文章来记录一下这些知识，并巩固一下。&lt;/p&gt;
&lt;h1 id=&quot;Bitmap&quot;&gt;&lt;a href=&quot;#Bitmap&quot; class=&quot;headerlink&quot; title=&quot;Bitmap&quot;&gt;&lt;/a&gt;Bitmap&lt;/h1&gt;&lt;p&gt;Bitmap，直译就叫位图。可以理解为通过一个bit数组存储特定数据的一种数据结构；由于bit是数据的最小单位，所以这种数据结构往往是非常节省存储空间的。在Java和Redis中都存在同名实现结构。&lt;br&gt;在一个记录只有两种状态，是或不是的场景下，如果使用其他数据结构存储则会存在大量空间空间的浪费。即使存在海量的数据，我们也只需要为每个数据分配&lt;code&gt;1byte&lt;/code&gt;的空间就可以记录了。比如：用户画像&lt;br&gt;Bitmap可以&lt;font color=&quot;red&quot;&gt;节省大量的存储空间&lt;/font&gt;，所以可以很容易的倍一次性加载到内存中。Bitmap结构还有一个很重要的特点:&lt;font color=&quot;red&quot;&gt;可以很方便的进行位运算&lt;/font&gt;&lt;br&gt;比如我们需要统计用户满足以下条件的用户：程序员、带眼镜、长头发。。。。那么我们可以将对相应条件的用户画像的&lt;code&gt;Bitmap&lt;/code&gt;结构做&lt;code&gt;AND&lt;/code&gt;操作，就可以方便的过滤出满足条件的对象了。&lt;/p&gt;
&lt;h2 id=&quot;Bitmap的优化&quot;&gt;&lt;a href=&quot;#Bitmap的优化&quot; class=&quot;headerlink&quot; title=&quot;Bitmap的优化&quot;&gt;&lt;/a&gt;Bitmap的优化&lt;/h2&gt;
    
    </summary>
    
      <category term="一些奇淫技巧" scheme="http://yoursite.com/categories/%E4%B8%80%E4%BA%9B%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>mac安装多版本JDK</title>
    <link href="http://yoursite.com/2019/07/13/mac%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACJDK/"/>
    <id>http://yoursite.com/2019/07/13/mac安装多版本JDK/</id>
    <published>2019-07-13T09:55:42.000Z</published>
    <updated>2019-07-14T10:04:25.341Z</updated>
    
    <content type="html"><![CDATA[<p>随着JDK版本的快速迭代，作为优秀(kubi)的Java拥护者，为了跟随时代的潮流，也开始使用1.8版本。</p><p>但是，某一天。。。。苦逼的事情发生了，一个项目原本是好好的，突然报错起不来了。最终查到的原因是某个项目的Jar包使用的JDK为1.7….于是就有了这篇记录。</p><p>在终端下面使用<code>java -version</code>查看就可以查看使用的JDK版本了。<br>使用<code>/usr/libexec/java_home -V</code>可以查看本地已经安装的JDK</p><p>关于JDK1.x for mac的安装略过，网上有大把的教程。<br>我这里以安装3个版本1.6/1.7/1.8为例。</p><p>一、编辑.bash_profile<br><code>vim ~/.bash_profile</code></p><p>二、在.bash_profile中添加下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`</span><br><span class="line">export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7`</span><br><span class="line">export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`</span><br><span class="line"></span><br><span class="line">#默认设为JDK1.7</span><br><span class="line">export JAVA_HOME=$JAVA_7_HOME</span><br><span class="line"></span><br><span class="line">#alias命令动态切换JDK版本</span><br><span class="line">alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot;</span><br><span class="line">alias jdk7=&quot;export JAVA_HOME=$JAVA_7_HOME&quot;</span><br><span class="line">alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;</span><br></pre></td></tr></table></figure></p><p>三、刷新环境<br><code>source ~/.bash_profile</code></p><p>四、测试<br>执行：<code>jdk8</code>，再执行<code>java -version</code>，看看是不是1.8版本？<br>执行：<code>jdk6</code>，再执行<code>java -version</code>，看看是不是1.6版本？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着JDK版本的快速迭代，作为优秀(kubi)的Java拥护者，为了跟随时代的潮流，也开始使用1.8版本。&lt;/p&gt;
&lt;p&gt;但是，某一天。。。。苦逼的事情发生了，一个项目原本是好好的，突然报错起不来了。最终查到的原因是某个项目的Jar包使用的JDK为1.7….于是就有了这篇记
      
    
    </summary>
    
      <category term="一些奇淫技巧" scheme="http://yoursite.com/categories/%E4%B8%80%E4%BA%9B%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Cloneable接口实现原理</title>
    <link href="http://yoursite.com/2019/06/04/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Cloneable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/06/04/面试准备/Cloneable实现原理/</id>
    <published>2019-06-04T14:41:31.000Z</published>
    <updated>2019-06-23T13:13:08.542Z</updated>
    
    <content type="html"><![CDATA[<p>Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例当中。</p><p>在开发过程中，如果一个类中的字段比较多，而我们如果采用在客户端中逐字段复制的方法来进行拷贝操作的话，将不可避免的造成客户端代码繁杂，而且也无法对类中的私有对象进行复制，而如果让需要具备拷贝功能的类实现<code>Cloneable</code>接口，并重写<code>clone()</code>方法的方式来简洁地实现实例拷贝功能。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><code>private class Demo implements Cloneable{}</code><br>我们创建一个Demo类，并让他实现Cloneable接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Cloneable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们发现<code>Cloneable</code>几口里面并没有定义任何接口方法。<br>这是因为在<code>Object</code>类中已经将<code>clone()</code>方法定义为所有类都应该具有的基本功能，只是将该方法声明为了<code>protected</code>类型。它是一个<code>native</code>本地方法。</p><p>如果一个类不实现该接口就直接调用<code>clone()</code>方法的话，就会抛出“不支持拷贝”异常。<br>所以如果要让一个类具有拷贝实例的功能，那么除了要重写<code>Object</code>类中<code>clone()</code>方法外，还必须实现Cloneable接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例当中。&lt;/p&gt;
&lt;p&gt;在开发过程中，如果一个类中的字段比较多，而我们如果采用在客户端中逐字段复制的方法来进行拷贝操作的话，将不可避免的造成客户端代码繁杂，而且也无法对
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2019/06/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/06/03/面试准备/单例模式/</id>
    <published>2019-06-03T14:41:31.000Z</published>
    <updated>2019-06-19T09:30:38.728Z</updated>
    
    <content type="html"><![CDATA[<p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h2 id="单例模式多种写法"><a href="#单例模式多种写法" class="headerlink" title="单例模式多种写法"></a>单例模式多种写法</h2><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>这种方式在类加载时就完成了初始化，所以类加载比较慢，但是获取对象的速度快。这种方式基于类加载机制避免了多线程的同步问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="懒汉模式（线程不安全）"><a href="#懒汉模式（线程不安全）" class="headerlink" title="懒汉模式（线程不安全）"></a>懒汉模式（线程不安全）</h3><p>懒汉模式声明了一个静态对象，在用户第一次调用时进行初始化，虽然节约了资源，但第一次加载时需要实例化，反应稍微慢一点，而且在多线程下不能工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="懒汉模式（线程安全）"><a href="#懒汉模式（线程安全）" class="headerlink" title="懒汉模式（线程安全）"></a>懒汉模式（线程安全）</h3><p>这种写法能够在多线程中很好的工作，但是每次调用getSingleton时都需要同步，造成不必要的同步开销，而且大部分时候我们都是用不到同步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双重检查模式（DCL）"><a href="#双重检查模式（DCL）" class="headerlink" title="双重检查模式（DCL）"></a>双重检查模式（DCL）</h3><p>这种写法对singleton进行了两次的判空操作，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。这里用到了volatile关键字，或多或少还是会影响性能，但是考虑到程序的正确性，牺牲这点性能还是值得的。</p><h4 id="PS：这里为什么要用volatile关键字？"><a href="#PS：这里为什么要用volatile关键字？" class="headerlink" title="PS：这里为什么要用volatile关键字？"></a>PS：这里为什么要用volatile关键字？</h4><p>这个地方使用volatile关键字是很有必要的，因为new一个新的对象其实是分了三步执行：</p><ol><li>为该对象分配内存空间</li><li>初始化对象</li><li>将对象指向分配的内存地址</li></ol><p>由于JVM指令重排的特性，执行顺序可能会变成1-&gt;3-&gt;2；在单线程环境下不会有问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。比如：</p><ol><li>线程1执行了1、3</li><li>线程2调用方法，发现该实例不为空，因此返回该实例。但此时实例还没被初始化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if(singleton == null)&#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton sInstance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，上述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。</p><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     public void doSomeThing() &#123;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用容器实现单例模式"><a href="#使用容器实现单例模式" class="headerlink" title="使用容器实现单例模式"></a>使用容器实现单例模式</h3><p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonManager &#123; </span><br><span class="line">　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();</span><br><span class="line">　　private Singleton() &#123; </span><br><span class="line">　　&#125;</span><br><span class="line">　　public static void registerService(String key, Objectinstance) &#123;</span><br><span class="line">　　　　if (!objMap.containsKey(key) ) &#123;</span><br><span class="line">　　　　　　objMap.put(key, instance) ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　public static ObjectgetService(String key) &#123;</span><br><span class="line">　　　　return objMap.get(key) ;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;h2 id=&quot;单例模式多种写法&quot;&gt;&lt;a href=&quot;#单例模式多种写法&quot; class=&quot;headerlink&quot; title=&quot;单例模式多种写法&quot;&gt;&lt;/a&gt;单例模式多种写法&lt;/h2&gt;&lt;h3 id=&quot;饿汉模式&quot;&gt;&lt;a href=&quot;#饿汉模式&quot; class=&quot;headerlink&quot; title=&quot;饿汉模式&quot;&gt;&lt;/a&gt;饿汉模式&lt;/h3&gt;&lt;p&gt;这种方式在类加载时就完成了初始化，所以类加载比较慢，但是获取对象的速度快。这种方式基于类加载机制避免了多线程的同步问题。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static Singleton singleton = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;懒汉模式（线程不安全）&quot;&gt;&lt;a href=&quot;#懒汉模式（线程不安全）&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式（线程不安全）&quot;&gt;&lt;/a&gt;懒汉模式（线程不安全）&lt;/h3&gt;&lt;p&gt;懒汉模式声明了一个静态对象，在用户第一次调用时进行初始化，虽然节约了资源，但第一次加载时需要实例化，反应稍微慢一点，而且在多线程下不能工作。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static Singleton singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Singleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(singleton == null)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            singleton = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程思想" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap详解</title>
    <link href="http://yoursite.com/2019/06/02/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/HashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/06/02/面试准备/HashMap详解/</id>
    <published>2019-06-02T14:41:31.000Z</published>
    <updated>2019-06-16T13:25:49.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是HashMap"><a href="#什么是HashMap" class="headerlink" title="什么是HashMap"></a>什么是HashMap</h2><p>HashMap一个用于存储Key-Value键值对的集合，每一个键值对称之为<code>Entry</code>分散存储在一个数组中。这个数组每一个元首初始值都是Null。</p><p>HashMap的常用操作就是<b>GET</b>和<b>PUT</b></p><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>我们在调用put方法的时候，会利用一个哈希函数来确定<code>Entry</code>的插入位置。为了解决哈希冲突的问题，HashMap采用<font color="red">链表法</font>来解决这个问题。<br><code>注意：位置0上存放的一定是Null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">modCount++;</span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line">return null;</span><br></pre></td></tr></table></figure></p><p>在遇到Hash冲突的时候，就将<code>Entry</code>以链表的形式给插入到相应的位置，这里需要注意的是：HashMap采用的是<font color="red">头插法</font>的形式。这是因为设计者认为最新加入的<code>Entry</code>更有可能被访问。<br>此时HashMap的结构为<b>数组加链表</b><br><img src="https://s2.ax1x.com/2019/06/16/V7M7nO.jpg" alt=""></p><a id="more"></a><p>当HashMap中有大量的元素都存放在同一个位置的时候，这个位置就有存在一条很长的链表；这个时候的HashMap相当于一个单链表。<br>于是在<b>JDK1.8</b>中引入了<font color="red">红黑树</font>来优化这个问题。当某一个位置上的<font color="red">链表长度大于等于8</font>的时就使用红黑树来进行存储。<br>在元素值小于6的时候就将红黑树又转换成链表形式。<br>此时HashMap的结构为<b>数组加链表加红黑树</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//一个桶的树化阈值</span><br><span class="line">//当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点</span><br><span class="line">//这个值必须为 8，要不然频繁转换效率也不高</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"> </span><br><span class="line">//一个树的链表还原阈值</span><br><span class="line">//当扩容时，桶中元素个数小于这个值，就会把树形的桶元素 还原（切分）为链表结构</span><br><span class="line">//这个值应该比上面那个小，至少为 6，避免频繁转换</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"> </span><br><span class="line">//哈希表的最小树形化容量</span><br><span class="line">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span><br><span class="line">//否则桶内元素太多时会扩容，而不是树形化</span><br><span class="line">//为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure></p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>在HashMap的GET函数中，首先会通过计算键值的哈希值获取到<code>Entry</code>所在的位置，然后通过遍历链表或红黑树中的<code>Entry</code>来确定是否是我们需要的值。</p><p>HashMap在遍历链表比较时使用的Java对象的equals()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != null;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>通过这段代码，我们也可以看出：HashMap是可以存放键为Null的对象</code></p><h4 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line">        while (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + next.getKey() + &quot; value=&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + key + &quot; value=&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>推荐使用第一种方式，第一种方式会将KV同时取出，而第二种方式还需要通过key取一次value，效率比较低。</p><h2 id="HashMap默认初始化长度"><a href="#HashMap默认初始化长度" class="headerlink" title="HashMap默认初始化长度"></a>HashMap默认初始化长度</h2><p>首先，我们要明确的一点就是：<font color="red">HashMap的默认初始化长度是16</font>，并且每次扩容和缩容后的长度大小都是2的幂。</p><p>为什么会有以上的限制呢？<br>这是因为需要实现尽可能分布均匀的Hash函数。HashMap中使用了<font color="red">位取模</font>的方式来计算哈希值。<br><code>index =  HashCode（Key） &amp;  （Length - 1）</code></p><p>这样做不但效果上等同于取模，而且大大提升了性能。<br>使用<code>位运算</code>的方式，相当于只取hash函数的后几位，分布情况取决于hash函数。<br>而使用其他方式，如<code>取模</code>，则可能会导致某些index结果出现的几率大大提升;此外，如果length不是2的幂的话，有些index的结果可能永远不会出现。</p><h2 id="Hash的Rehash"><a href="#Hash的Rehash" class="headerlink" title="Hash的Rehash"></a>Hash的Rehash</h2><p>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。<br>这个时候的HashMap会需要进行扩容行为了。</p><p>影响HashMap扩容的因素有两个：</p><ul><li>Capacity：当前长度</li><li>LoadFactor：负载因子，默认是0.75f</li></ul><p><code>HashMap.Size   &gt;=  Capacity * LoadFactor时就会进行扩容操作了</code></p><p>HashMap的扩容操作分两步：</p><ol><li>创建一个新的数组，大小是原来数组的2倍。</li><li>遍历原数组，将原数组的所有元素重新Hash到新数组。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Transfers all entries from current table to newTable.</span><br><span class="line"> */</span><br><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap每次扩容或缩容都是以2的倍数进行的。<br>这是因为在这样的流程中，HashMap中的<code>Entry</code>需要迁移的只有一半，大大的节省了扩缩容的消耗。</p><h2 id="高并发下的HashMap"><a href="#高并发下的HashMap" class="headerlink" title="高并发下的HashMap"></a>高并发下的HashMap</h2><p>HashMap并不是线程安全的，在多线程操作下可能会导致很多意想不到的情况发生。比如死循环。</p><p>比如在上一小节中讲的Rehash，如果有多个线程同时进行扩容操作就会出现问题。<br>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作：<br><img src="https://s2.ax1x.com/2019/06/16/V7MbHe.jpg" alt="-w564"><br><img src="https://s2.ax1x.com/2019/06/16/V7MONd.jpg" alt="-w496"><br>此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：<br><img src="https://s2.ax1x.com/2019/06/16/V7MLAH.jpg" alt="-w748"><br>这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：<br><img src="https://s2.ax1x.com/2019/06/16/V7MHBD.jpg" alt=""><br>假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：<br><img src="https://s2.ax1x.com/2019/06/16/V7MX4A.jpg" alt="-w778"><br>直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p><img src="https://s2.ax1x.com/2019/06/16/V7MzgP.jpg" alt=""><br>当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。<br><img src="https://s2.ax1x.com/2019/06/16/V7Mv9I.jpg" alt=""><br>我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且e指向了Entry2。此时e和next的指向如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry2</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QPHg.jpg" alt="-w702"><br>接着是新一轮循环，又执行到红框内的代码行：<br><img src="https://s2.ax1x.com/2019/06/16/V7Mx3t.jpg" alt=""><br>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QSjf.jpg" alt="-w762"><br>接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：<br><img src="https://s2.ax1x.com/2019/06/16/V7Q9u8.jpg" alt=""><br>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QCDS.jpg" alt="-w746"><br>第三次循环开始，又执行到红框的代码：<br><img src="https://s2.ax1x.com/2019/06/16/V7QkNj.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry3.next = null</span><br></pre></td></tr></table></figure></p><p>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：<br><img src="https://s2.ax1x.com/2019/06/16/V7QFEQ.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = Entry2</span><br><span class="line">e = Entry3</span><br><span class="line">Entry2.next = Entry3</span><br><span class="line">Entry3.next = Entry2</span><br></pre></td></tr></table></figure></p><p>链表出现了环形！</p><p>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QA4s.jpg" alt="-w751"><br>此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是HashMap&quot;&gt;&lt;a href=&quot;#什么是HashMap&quot; class=&quot;headerlink&quot; title=&quot;什么是HashMap&quot;&gt;&lt;/a&gt;什么是HashMap&lt;/h2&gt;&lt;p&gt;HashMap一个用于存储Key-Value键值对的集合，每一个键值对称之为&lt;code&gt;Entry&lt;/code&gt;分散存储在一个数组中。这个数组每一个元首初始值都是Null。&lt;/p&gt;
&lt;p&gt;HashMap的常用操作就是&lt;b&gt;GET&lt;/b&gt;和&lt;b&gt;PUT&lt;/b&gt;&lt;/p&gt;
&lt;h4 id=&quot;PUT&quot;&gt;&lt;a href=&quot;#PUT&quot; class=&quot;headerlink&quot; title=&quot;PUT&quot;&gt;&lt;/a&gt;PUT&lt;/h4&gt;&lt;p&gt;我们在调用put方法的时候，会利用一个哈希函数来确定&lt;code&gt;Entry&lt;/code&gt;的插入位置。为了解决哈希冲突的问题，HashMap采用&lt;font color=&quot;red&quot;&gt;链表法&lt;/font&gt;来解决这个问题。&lt;br&gt;&lt;code&gt;注意：位置0上存放的一定是Null&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Object k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                V oldValue = e.value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.recordAccess(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return oldValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addEntry(hash, key, value, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return null;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在遇到Hash冲突的时候，就将&lt;code&gt;Entry&lt;/code&gt;以链表的形式给插入到相应的位置，这里需要注意的是：HashMap采用的是&lt;font color=&quot;red&quot;&gt;头插法&lt;/font&gt;的形式。这是因为设计者认为最新加入的&lt;code&gt;Entry&lt;/code&gt;更有可能被访问。&lt;br&gt;此时HashMap的结构为&lt;b&gt;数组加链表&lt;/b&gt;&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/16/V7M7nO.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Object的常用方法</title>
    <link href="http://yoursite.com/2019/06/01/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Object%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/06/01/面试准备/Object的常用方法/</id>
    <published>2019-06-01T14:41:31.000Z</published>
    <updated>2019-06-16T13:11:41.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object类常见方法"><a href="#Object类常见方法" class="headerlink" title="Object类常见方法"></a>Object类常见方法</h1><p>Object是一个特殊的类，所有的类都会隐式的继承Object类。Object中主要有以下11个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">注：native方法：使用这个关键字说明这个方法是原生方法，底层使用C/C++实现，并且被编译成了DLL，由Java调用。函数实现在DLL中，JDK源码并不包含。</span><br><span class="line"></span><br><span class="line">public final native Class&lt;?&gt; getClass()</span><br><span class="line">用于返回当前运行时对象的Class对象，使用final关键字修饰，不允许子类重写。</span><br><span class="line"></span><br><span class="line">public native int hashCode()</span><br><span class="line">用于返回对象的哈希码，主要使用在哈希表中。</span><br><span class="line"></span><br><span class="line">public boolean equals(Object obj)</span><br><span class="line">用于比较2个对象的内存地址是否相等，String类对该方法进行了重写。</span><br><span class="line"></span><br><span class="line">protected native Object clone() throws CloneNotSupportedException</span><br><span class="line">用于创建当前对象的一份拷贝。Object本身并没有实现Cloneable接口，所以不重写clone方法并且进行调用就会发生CloneNotSupportedException异常。</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">默认返回类的名字@实例的哈希码的16进制的字符串，建议所有子类都重写该方法。</span><br><span class="line"></span><br><span class="line">public final native void notify()</span><br><span class="line">final方法，用于唤醒一个在此对象监视器上等待的线程。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="line"></span><br><span class="line">public final native void notifyAll()</span><br><span class="line">用于唤醒该对象上所有的等待线程。</span><br><span class="line"></span><br><span class="line">public final native void wait(long timeout) throws InterruptedException</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException</span><br><span class="line">public final void wait() throws InterruptedException</span><br><span class="line">暂停线程的执行，第二个超时时间需要增加nanos毫秒，第三个没有超时时间。</span><br><span class="line"></span><br><span class="line">protected void finalize() throws Throwable &#123; &#125;</span><br><span class="line">实例被垃圾回收器回收的时候触发的操作。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object类常见方法&quot;&gt;&lt;a href=&quot;#Object类常见方法&quot; class=&quot;headerlink&quot; title=&quot;Object类常见方法&quot;&gt;&lt;/a&gt;Object类常见方法&lt;/h1&gt;&lt;p&gt;Object是一个特殊的类，所有的类都会隐式的继承Object类。O
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>GET和POST的区别</title>
    <link href="http://yoursite.com/2019/04/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/04/05/面试准备/GET和POST的区别/</id>
    <published>2019-04-05T14:16:26.000Z</published>
    <updated>2019-07-21T14:18:18.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h1><p>GET和POST是HTTP请求的两种发送方式，其本质上并没有多大区别。HTTP的底层是TCP/IP协议，所以GET和POST底层实现也是TCP/IP协议，也就是GET和POST都是TCP连接，GET和POST做的事情都是一样的。如果在GET上加上<code>request body</code>，POST上加上<code>url</code>在技术上完全是可行的。</p><p>但是GET和POST在一些表现上还是有区别的。主要体现在以下几个方面：</p><ul><li>GET请求在URL中传送的参数是有长度限制的，POST没有</li><li>GET会将参数直接显示在URL上，所以POST更为安全</li><li>GET参数传递通过URL，POST参数传递通过request body</li><li>GET请求参数记录会被保留在浏览器记录中，POST不会</li><li>POST支持多种编码方式</li><li>POST在回退的时候会再次提交数据，GET不会</li><li>在某些浏览器下，GET只会发送一次数据包，而POST需要发送两次</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GET和POST请求的区别&quot;&gt;&lt;a href=&quot;#GET和POST请求的区别&quot; class=&quot;headerlink&quot; title=&quot;GET和POST请求的区别&quot;&gt;&lt;/a&gt;GET和POST请求的区别&lt;/h1&gt;&lt;p&gt;GET和POST是HTTP请求的两种发送方式，其本质
      
    
    </summary>
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="http://yoursite.com/2019/04/04/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2019/04/04/面试准备/三次握手和四次挥手/</id>
    <published>2019-04-04T15:03:37.000Z</published>
    <updated>2019-07-15T15:06:44.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">客户端-&gt;服务端: SYNC=1,seq=x</span><br><span class="line">Note left of 客户端: SYCN_SEND</span><br><span class="line">服务端--&gt;客户端: SYNC=1,ACK=1,seq=y,ack=x+1</span><br><span class="line">Note right of 服务端: SYNC_RECV</span><br><span class="line">客户端-&gt;服务端: ACK=1,seq=x+1,ack=y+1</span><br><span class="line">Note left of 客户端: ESTAB-LISHED</span><br><span class="line">Note right of 服务端: ESTAB-LISHED</span><br></pre></td></tr></table></figure><p>第一次握手：建立连接时，客户端发送sync包(syn=x)到服务器，并进入SYN_SENT状态，等待服务器确认；</p><p>第二次握手：服务器收到syn包，发送确认号(ack=x+1)，同时自己也发送一个syn包(syn=y)，即ACK+SYN包；服务器进入SYN_RECV状态。</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)；发送完毕后，客户端和服务端都进入ESTABLISHED状态完成三次握手。</p><a id="more"></a><h2 id="四次挥手流程"><a href="#四次挥手流程" class="headerlink" title="四次挥手流程"></a>四次挥手流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端-&gt;服务端: FIN=1,seq=u</span><br><span class="line">Note left of 客户端: FIN_WAIT_1</span><br><span class="line">服务端--&gt;客户端: ACK=1,seq=v,ack=u+1</span><br><span class="line">Note right of 服务端: CLOSE_WAIT</span><br><span class="line">服务端--&gt;客户端: FIN=1,ACK=1,seq=w,ack=u+1</span><br><span class="line">Note right of 服务端: LAST_ACK</span><br><span class="line">客户端-&gt;服务端: ACK=1,seq=u+1,ack=w+1</span><br><span class="line">Note right of 服务端: CLOSED</span><br><span class="line">Note left of 客户端: 等待2MSL后，进入CLOSED</span><br></pre></td></tr></table></figure><p>1、 客户端进程发送连接释放报文，并且停止发送数据。报文中带<code>FIN=1</code>标记。并且其序列号<code>seq=u</code>（等于前面已经传送过来的数据的最后一个字节的序号+1）。客户端进入<code>FIN-WAIT=1</code>状态。</p><p>2、服务器接收到连接释放报文后，发送确认报文<code>ACK=1，ack=u+1</code>，并带上自己的序列号<code>seq=v</code>，此时，服务端进入<code>CLOSE-WAIT</code>状态。这个时候处于半关闭状态；表示客户端不再发送数据，服务端不再接收数据；服务端若要发送数据，客户端依然要接收。</p><p>3、 客户端手抖服务端的确认请求后，进入<code>FIN-WAIT-2</code>状态，等待服务器发送连接释放报文。</p><p>4、 服务器将数据发送完毕后，就向客户端发送连接释放报文，<code>FIN=1,ack=u+1,seq=w</code>。此时服务端进入<code>LAST-ACK</code>状态，等待客户端的确认。</p><p>5、 客户端收到服务端的连接释放报文后，必须发出确认。<code>ACK=1,ack=w+1，seq=u+1</code>，客户端进入<code>TIME-WAIT</code>状态。此时TCP连接还没有释放，必须经过2*MSL的时间后，才进入<code>CLOSED</code>状态。</p><p>6、 服务端接收到客户端发出的确认后，立即进入<code>CLOSED</code>状态。</p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol><li><p>为什么连接的时候是三次握手，关闭的时候却是四次挥手？<br> 当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p><p> 在关闭连接的时候，服务端接收到FIN报文后，很可能不会立即关闭SOCKET，所以先回复一个ACK报文，告诉客户端“你的FIN报文我收到了”。只有当服务端的报文都发送完，才发送FIN报文给客户端。</p></li><li><p>为什么TIME_WAIT状态需要经过2MSL才进入CLOSED状态？<br> 虽然按道理，四个报文都发送完毕后，就可以直接进入CLOSED状态了，但是我们必须假设网络是不可靠的，有可能最后一个ACK丢失。</p><p> 由于网络原因，导致服务端没有收到客户端的ACK报文，不断的发送FIN给客户端。所以需要留下一段时间来处理这种情况，发送ACK报文给服务端。如果知道2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被服务端成功接收，结束TCP连接。</p></li><li><p>为什么不能只用两次握手进行连接？<br> 三次握手主要是完成两个重要功能：</p><ul><li>双方都已经做好了发送数据的准备工作</li><li><p>协商算法初始序列号，这个序列号在握手过程中发送和确认。</p><p>我们假设只进行两次握手；客户端发送连接请求给客户端，客户端收到后返回确认给客户端。<br>按照两次握手的约定，这个时候服务端已经认为成功的建立了连接，一直处于等待客户端发送消息的状态。<br>而客户端再丢失了服务端发送过来的确认报文，不知道是否建立成功，以及不知道服务端的序号状态。在这种情况下，客户端将认为连接没有建立成功，忽略客户端发送过来的任何数据报文，只等待应答报文。而服务端在发出数据报文超时后，不断的重复发送同样的数据。</p></li></ul></li><li><p>如果已经建立连接后，客户端发生了故障怎么办？<br> TCP设有一个计时器，服务器每收到一个客户端请求后都会重新复位这个计时器，如果在规定时间内还没有收到客户端的任何数据，服务器就会发送一个探测报文，每隔75s发送一次。如果连续10次都没有反应，服务端就认为客户端发生了故障，关闭连接。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;三次握手流程&quot;&gt;&lt;a href=&quot;#三次握手流程&quot; class=&quot;headerlink&quot; title=&quot;三次握手流程&quot;&gt;&lt;/a&gt;三次握手流程&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;客户端-&amp;gt;服务端: SYNC=1,seq=x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note left of 客户端: SYCN_SEND&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;服务端--&amp;gt;客户端: SYNC=1,ACK=1,seq=y,ack=x+1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note right of 服务端: SYNC_RECV&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;客户端-&amp;gt;服务端: ACK=1,seq=x+1,ack=y+1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note left of 客户端: ESTAB-LISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note right of 服务端: ESTAB-LISHED&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一次握手：建立连接时，客户端发送sync包(syn=x)到服务器，并进入SYN_SENT状态，等待服务器确认；&lt;/p&gt;
&lt;p&gt;第二次握手：服务器收到syn包，发送确认号(ack=x+1)，同时自己也发送一个syn包(syn=y)，即ACK+SYN包；服务器进入SYN_RECV状态。&lt;/p&gt;
&lt;p&gt;第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)；发送完毕后，客户端和服务端都进入ESTABLISHED状态完成三次握手。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Change Buffer</title>
    <link href="http://yoursite.com/2019/04/03/MySQL/Change%20Buffer/"/>
    <id>http://yoursite.com/2019/04/03/MySQL/Change Buffer/</id>
    <published>2019-04-03T08:11:15.000Z</published>
    <updated>2019-06-19T09:32:04.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的偷懒行为之Change-Buffer"><a href="#MySQL的偷懒行为之Change-Buffer" class="headerlink" title="MySQL的偷懒行为之Change Buffer"></a>MySQL的偷懒行为之Change Buffer</h1><p>在使用MySQL的时候，只要MySQL服务给你返回成功信息后，得到你需要的结果，你并不关注MySQL的行为；但是其实在MySQL内部，其实有很多的特性和机制来延迟真正的持久化等耗时耗资源行为。下面我将为你介绍其中的一个特性：change buffer</p><h2 id="简介-What"><a href="#简介-What" class="headerlink" title="简介(What)"></a>简介(What)</h2><p>The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool. The buffered changes, which may result from INSERT, UPDATE, or DELETE operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.</p><p>当需要改变<font color="red">二级索引</font>的数据，并且该<font color="red">数据页不在内存缓冲池中</font>；这个时候会直接向客户端返回修改成功的信息。MySQL并不实时的去更新磁盘数据，而是在之后一定条件下触发更新操作。这就是<font color="red">change buffer</font>在作祟。</p><p>change buffer在MySQL5.5版本之前，只支持insert操作，所以最初被称为insert buffer。在之后的版本中，支持了更多的修改操作，所以后面改称为change buffer。</p><a id="more"></a><h2 id="为什么需要change-buffer-Why"><a href="#为什么需要change-buffer-Why" class="headerlink" title="为什么需要change buffer(Why)"></a>为什么需要change buffer(Why)</h2><p>首先，你要明白<font color="red">二级索引的数据页在磁盘上存储得很散乱</font>，读取的时候需要消耗大量的资源去做寻址等操作。这里涉及到了操作系统知识，并不在本文的科普范围。</p><p>其次，一般情况下，二级索引的数据访问的并不是很频繁，作为冷数据的存在，<font color="red">即使读取到了内存当中，很快也会被挤出内存缓冲池</font>。如果每次更新操作都读取进来，那也是一笔很大的开销，所以MySQL会将多次更新给合并到一块去更新。（这里涉及到了LRU的淘汰知识，后续会有专门的文章讲解，这里你只需要知道有这个东西就行了）</p><p>所以，change buffer的主要作用有以下两点：</p><ol><li>减少了MySQL<font color="red">随机</font>读取磁盘的次数</li><li>将<font color="red">多次的随机写</font>磁盘操作，合并成了<font color="red">一次的顺序写</font>磁盘操作</li></ol><p>这里再介绍一下change buffer的限制条件：<font color="red">非唯一的辅助索引</font></p><p>前面我们说过二级索引的数据在磁盘上分布的很散乱，但是聚簇索引就不会这样；我们都知道Innodb的数据都存储在聚簇索引的叶子节点，Innodb为了保证能够更快的读取数据，会<font color="red">将聚簇索引的数据页尽可能在物理上顺序放在一起</font>。</p><p>此外，在修改聚簇索引和唯一辅助索引上的数据时，为了<font color="red">保证数据的唯一性</font>，总是会在进行修改操作前进行一次查询操作，这个时候已经将该数据页读取到内存缓存池中了。直接修改内存中数据页上的数据信息更快，完全没有必要使用change buffer。</p><h2 id="change-buffer干了什么-DO）"><a href="#change-buffer干了什么-DO）" class="headerlink" title="change buffer干了什么(DO）"></a>change buffer干了什么(DO）</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>下面我们来看change buffer的执行过程：</p><ol><li>如果需要修改的数据页在内存中，则直接修改内存数据并返回</li><li>如果需要修改的数据页不在内存中，则向change buffer中添加一条记录（修改数据页的记录)</li><li>在redo log中添加一条记录（change buffer页的修改记录）<br><a href="https://imgchr.com/i/V7JVC4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JVC4.jpg" alt="V7JVC4.jpg"></a></li></ol><p>从change buffer的执行过程中，我们可以看到，如果需要修改的数据页page 2不在内存中时，Innodb并不会去磁盘中读取，而是在change buffer中记录了page 2中的数据变更。</p><p>系统会周期性的将change buffer的数据写入到系统表空间中。所以不需要担心change buffer的数据丢失问题。</p><h3 id="什么时候进行合并操作"><a href="#什么时候进行合并操作" class="headerlink" title="什么时候进行合并操作"></a>什么时候进行合并操作</h3><ul><li>二级索引页被读取到buffer pool中，在页面可用之前，会先进行合并缓存操作</li><li>change buffer bitmap页追踪到该辅助索引页无可用空间时</li><li>Master Thread定时任务</li><li>在崩溃恢复时，索引页被读入到缓冲池时，会将存在系统表空间的change buffer应用到二级索引的叶子节点</li><li>当–innodb-fast-shutdown=0时，数据库实例关闭时会强制将change buffer合并到数据页中并刷盘。</li></ul><h3 id="change-buffer的存储"><a href="#change-buffer的存储" class="headerlink" title="change buffer的存储"></a>change buffer的存储</h3><p><a href="https://imgchr.com/i/V7J9uq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7J9uq.md.jpg" alt="V7J9uq.md.jpg"></a></p><p>change buffer在物理上是以一个普通的btree存储。根页是存储在系统表空间的固定页中（涉及innodb的数据存储结构，太高深了~还没到那个层次，就看个热闹)</p><p>上图是一条ibuf记录的存储格式，通过（space id, page no , counter）三列作为主键来唯一决定一条记录，其中counter是一个递增值，目的是为了维持不同操作的有序性。可以通过counter来保证merge时执行时的顺序和用户操作的顺序一致。</p><p>在插入时，会先将counter的值设置成0xFFFF；然后将定位到小于等于(space id, page no, 0xFFFF)的位置，再将counter为当前记录counter值加1。(这样做的原因是为了合并的时候能够更方便的找到同一数据页的缓存，并保证有序)</p><p><a href="https://imgchr.com/i/V7JSvn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JSvn.md.jpg" alt="V7JSvn.md.jpg"></a><br>因为ibuf缓存是针对具体的数据页的，因此在缓存操作的时候需要避免空页和满页的缓存操作。(满页：即将分裂的页，并不一定是所有空闲空间用完的页，一个数据页会有1/16的空隙)</p><ol><li>针对空页情况，在准备插入IBUF_OP_DELETE类型的操作缓存时，会预估执行完此操作后该page中还存在多少记录，如果只剩下一条记录，则走正常流程，将数据页读取到内存中。</li><li>针对满页情况，则是通过ibuf_bitmap页记录，该页存在于每个ibd的固定位置；ibuf_bitmap中记录了每个数据页的缓存状态和空闲空间大小。<br>在执行IBUF_OP_INSERT类型的操作前，会将该page的IBUF_BITMAP_BUFFERED设置为true。<br>通过IBUF_BITMAP_FREE来记录该page的空闲空间；在插入前，会去找到该page的空闲空间大小，如果本次操作超出限制，则会触发一次异步ibuf merge。</li></ol><h3 id="merge过程"><a href="#merge过程" class="headerlink" title="merge过程"></a>merge过程</h3><ol><li>一个磁盘上的数据页被读取到内存缓冲池中</li><li>到ibuf_bitmap中判断该数据页是否有缓存行为</li><li>如果存在缓存，则从ibuf的btree树中读取该数据页的缓存操作；并应用到该内存数据页上</li><li>只有当应用缓存完成，才能提供给用户查询等操作行为</li><li>在一定情况下执行刷盘操作，持久化到磁盘</li></ol><h3 id="merge触发情况"><a href="#merge触发情况" class="headerlink" title="merge触发情况"></a>merge触发情况</h3><ol><li>二级索引页被读入到内存中</li><li>插入ibuf操作时，遇到满页，会造成页分裂操作时，触发一次异步的merge</li><li>当前ibuf tree size&gt;max_size + 10时，会执行一次同步的merge</li><li>本次插入ibuf操作可能会导致ibuf tree索引分裂时，根据ibuf size的大小情况会触发不同情况的merge</li><li>master定时任务会合并相应数量的buffer</li><li>对某个表执行flush table时，会强制对该表的page进行merge</li><li>数据库关闭时，根据innodb_fast_shutdown来决定是否进行merge</li></ol><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><ol><li><p>innodb_change_buffering<br>innodb_change_buffering参数可以控制什么操作会使用change buffer。默认是all</p><p> |||<br> | — | — |<br> | all | The default value: buffer inserts, delete-marking operations, and purges. |<br> | none | Do not buffer any operations. |<br> | inserts | Buffer insert operations. |<br> | deletes | Buffer delete-marking operations. |<br> | changes | Buffer both inserts and delete-marking operations. |<br> | purges | Buffer physical deletion operations that happen in the background. |</p></li><li><p>innodb_change_buffer_max_size<br>innodb_change_buffer_max_size参数控制change buffer占buffer pool的百分比。默认25%，最大50%</p></li><li><p>查看change buffer的使用情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SHOW ENGINE INNODB STATUS \G</span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">56</span>, seg <span class="keyword">size</span> <span class="number">58</span>, <span class="number">517693</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">560451</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ol><p>Ibuf表示当前缓冲区中change buffer的页使用情况<br>size表示已使用的页数，free list len表示空闲的页，seg size表示总共的页数（等于size + free list len + 1)，merges合并数<br>merged operations表示change buffer中每个操作的次数。<br>insert表示Insert Buffer，delete mark表示Delete Buffer，delete表示Purge Buffer。<br>discarded operations表示当change buffer发生merge操作时，表已经被删除，此时不再需要将记录合并到辅助索引中去。</p><p>从上面的信息可以看出这个数据库实例的change buffer效果并不明显（通过insert/merges计算)。change buffer适用于存在大量修改二级索引页的DML活动中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>change buffer将随机IO转换成顺序IO，避免了IO带来的性能损耗，减少了随机读磁盘的次数，提高了数据库的写性能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html</a><br><a href="https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html</a><br><a href="http://mysql.taobao.org/monthly/2015/07/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2015/07/01/</a><br><a href="https://blog.csdn.net/bohu83/article/details/81837872" target="_blank" rel="noopener">https://blog.csdn.net/bohu83/article/details/81837872</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL的偷懒行为之Change-Buffer&quot;&gt;&lt;a href=&quot;#MySQL的偷懒行为之Change-Buffer&quot; class=&quot;headerlink&quot; title=&quot;MySQL的偷懒行为之Change Buffer&quot;&gt;&lt;/a&gt;MySQL的偷懒行为之Change Buffer&lt;/h1&gt;&lt;p&gt;在使用MySQL的时候，只要MySQL服务给你返回成功信息后，得到你需要的结果，你并不关注MySQL的行为；但是其实在MySQL内部，其实有很多的特性和机制来延迟真正的持久化等耗时耗资源行为。下面我将为你介绍其中的一个特性：change buffer&lt;/p&gt;
&lt;h2 id=&quot;简介-What&quot;&gt;&lt;a href=&quot;#简介-What&quot; class=&quot;headerlink&quot; title=&quot;简介(What)&quot;&gt;&lt;/a&gt;简介(What)&lt;/h2&gt;&lt;p&gt;The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool. The buffered changes, which may result from INSERT, UPDATE, or DELETE operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.&lt;/p&gt;
&lt;p&gt;当需要改变&lt;font color=&quot;red&quot;&gt;二级索引&lt;/font&gt;的数据，并且该&lt;font color=&quot;red&quot;&gt;数据页不在内存缓冲池中&lt;/font&gt;；这个时候会直接向客户端返回修改成功的信息。MySQL并不实时的去更新磁盘数据，而是在之后一定条件下触发更新操作。这就是&lt;font color=&quot;red&quot;&gt;change buffer&lt;/font&gt;在作祟。&lt;/p&gt;
&lt;p&gt;change buffer在MySQL5.5版本之前，只支持insert操作，所以最初被称为insert buffer。在之后的版本中，支持了更多的修改操作，所以后面改称为change buffer。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL忘记密码怎么办</title>
    <link href="http://yoursite.com/2019/04/02/MySQL/MySQL%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://yoursite.com/2019/04/02/MySQL/MySQL忘记密码怎么办/</id>
    <published>2019-04-02T12:14:16.000Z</published>
    <updated>2019-07-13T05:53:16.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL忘记密码怎么办？"><a href="#MySQL忘记密码怎么办？" class="headerlink" title="MySQL忘记密码怎么办？"></a>MySQL忘记密码怎么办？</h1><p>有的时候搭建MySQL后，由于密码没有保存好、忘记密码、密码过期等原因，导致登录不上数据库。这个时候该怎么办？</p><p>如果数据库使用人员，那还是乖乖的找数据库管理人员修改密码吧！<br>如果是数据库管理人员，能够登录到MySQL实例所在服务器的话。下面将介绍两种方式进行修改密码操作。</p><h2 id="skip-grant-tables"><a href="#skip-grant-tables" class="headerlink" title="skip-grant-tables"></a>skip-grant-tables</h2><p>第一种方式就是网上介绍最多的通过配置skip-grant-tables参数来跳过MySQL登录校验后，进行修改密码。</p><p>步骤就是：</p><ol><li>需要关闭MySQL实例。</li><li>配置参数。这里有两种方式：第一种就是在启动的使用，启动命令添加–skip-grant-tables；第二种就是通过修改配置文件，在[mysqld]下添加skip-grant-tables。</li><li>启动数据库</li><li>通过alter mysql.user set authentication_string=password(‘newpass’) where XXX@XXX;</li><li>去掉skip-grant-tables配置后重新启动。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">MySQL5.6的密码参数列为：password</span><br><span class="line">MySQL5.7的密码参数列为：authentication_string</span><br><span class="line"></span><br><span class="line">MySQL的账号是以`用户名`@`主机地址`计算的。同一用户名不同主机地址视为不同账号。</span><br></pre></td></tr></table></figure><p>这种方法的缺点很明显：</p><ol><li>数据库必须有一段时间不能提供服务。</li><li>开启跳过权限检查的参数后，安全性无法得到保障。所有人都能登录，即使没有改账号也能登录成功。<a id="more"></a></li></ol><h2 id="利用MyISAM表的特性"><a href="#利用MyISAM表的特性" class="headerlink" title="利用MyISAM表的特性"></a>利用MyISAM表的特性</h2><p>在MySQL8.0之前，mysql.user表都是MyISAM表，可以利用MyISAM表的特性进行修改密码操作。MySQL8.0后，放弃了MyISAM表，所以这个方法对8.0后的版本没有用。</p><p>这个方法需要有一个临时的数据库。<br>假设我们当前有两个数据库，一个3307，一个3309；3307实例的密码忘记了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vdb_172_16_123_101 /root]# ps aux | grep mysql</span><br><span class="line">mysql     2792  0.3 10.3 1067856 184220 pts/0  Sl   19:46   0:00 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3307/my.cnf</span><br><span class="line">mysql     2822  0.4 10.5 1067856 186072 pts/0  Sl   19:46   0:00 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3309/my.cnf</span><br><span class="line">root      2869  0.0  0.0 112648   960 pts/0    R+   19:47   0:00 grep --color=auto mysql</span><br></pre></td></tr></table></figure></p><p>第一步：我们首先登录3309实例，并创建一个临时库testdb(库名可以指定定)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; create database testdb;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>第二步：将3307实例下的mysql库下的user*文件都拷贝到第一步创建的3309实例的testdb库下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# cp -a /data/mysql/mysql_3307/data/mysql/user.* /data/mysql/mysql_3309/data/testdb/</span><br><span class="line">[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3309.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 6</span><br><span class="line">Server version: 5.7.17-log MySQL Community Server (GPL)</span><br><span class="line"> </span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> </span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"> </span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; use testdb;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"> </span><br><span class="line">Database changed</span><br><span class="line">root@localhost:mysql_3309.sock [testdb]&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_testdb |</span><br><span class="line">+------------------+</span><br><span class="line">| user             |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>第三步：在3309实例下修改testdb库下user表的密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3309.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 7</span><br><span class="line">Server version: 5.7.17-log MySQL Community Server (GPL)</span><br><span class="line"> </span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> </span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"> </span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; select user,host,authentication_string from testdb.user;</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">| user      | host      | authentication_string                     |</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">| root      | localhost | *527F89C205EA0A51A7537FFA7B6090D91A7D77AE |</span><br><span class="line">| mysql.sys | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; update testdb.user set authentication_string=password(&apos;newpass&apos;) where user=&apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 1</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; exit</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure></p><p>第四步：将user*文件拷贝回3307的mysql库下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# cp -a /data/mysql/mysql_3309/data/testdb/user.* /data/mysql/mysql_3307/data/mysql</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.frm’? y</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.MYD’? y</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.MYI’? y</span><br></pre></td></tr></table></figure></p><p>第五步：给一个HUP信号给3307，重新加载配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# ps aux | grep mysqld</span><br><span class="line">mysql     2792  0.0 10.7 1067856 189960 pts/0  Sl   19:46   0:01 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3307/my.cnf</span><br><span class="line">mysql     2822  0.0 11.6 1067856 206352 pts/0  Sl   19:46   0:01 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3309/my.cnf</span><br><span class="line">root      2912  0.0  0.0 112648   964 pts/0    S+   20:07   0:00 grep --color=auto mysqld</span><br><span class="line">[root@vdb_172_16_123_101 /root]# kill -HUP 2792</span><br></pre></td></tr></table></figure></p><p>第六步：用新密码登录3307实例</p><pre><code>[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3307.sock -p&apos;newpass&apos;mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.7.17-log MySQL Community Server (GPL)Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.root@localhost:mysql_3307.sock [(none)]&gt; </code></pre><p>这种方法是利用MyISAM表拷贝即可使用的特性，在一个临时实例中修改后替换。可以不用重启数据库，不会对业务造成影响。<br>为了安全起见，在操作前还是需要对原文件进行备份。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL忘记密码怎么办？&quot;&gt;&lt;a href=&quot;#MySQL忘记密码怎么办？&quot; class=&quot;headerlink&quot; title=&quot;MySQL忘记密码怎么办？&quot;&gt;&lt;/a&gt;MySQL忘记密码怎么办？&lt;/h1&gt;&lt;p&gt;有的时候搭建MySQL后，由于密码没有保存好、忘记密码、密码过期等原因，导致登录不上数据库。这个时候该怎么办？&lt;/p&gt;
&lt;p&gt;如果数据库使用人员，那还是乖乖的找数据库管理人员修改密码吧！&lt;br&gt;如果是数据库管理人员，能够登录到MySQL实例所在服务器的话。下面将介绍两种方式进行修改密码操作。&lt;/p&gt;
&lt;h2 id=&quot;skip-grant-tables&quot;&gt;&lt;a href=&quot;#skip-grant-tables&quot; class=&quot;headerlink&quot; title=&quot;skip-grant-tables&quot;&gt;&lt;/a&gt;skip-grant-tables&lt;/h2&gt;&lt;p&gt;第一种方式就是网上介绍最多的通过配置skip-grant-tables参数来跳过MySQL登录校验后，进行修改密码。&lt;/p&gt;
&lt;p&gt;步骤就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要关闭MySQL实例。&lt;/li&gt;
&lt;li&gt;配置参数。这里有两种方式：第一种就是在启动的使用，启动命令添加–skip-grant-tables；第二种就是通过修改配置文件，在[mysqld]下添加skip-grant-tables。&lt;/li&gt;
&lt;li&gt;启动数据库&lt;/li&gt;
&lt;li&gt;通过alter mysql.user set authentication_string=password(‘newpass’) where XXX@XXX;&lt;/li&gt;
&lt;li&gt;去掉skip-grant-tables配置后重新启动。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;注：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL5.6的密码参数列为：password&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL5.7的密码参数列为：authentication_string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL的账号是以`用户名`@`主机地址`计算的。同一用户名不同主机地址视为不同账号。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方法的缺点很明显：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库必须有一段时间不能提供服务。&lt;/li&gt;
&lt;li&gt;开启跳过权限检查的参数后，安全性无法得到保障。所有人都能登录，即使没有改账号也能登录成功。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB整体架构</title>
    <link href="http://yoursite.com/2019/03/03/MySQL/InnoDB%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/03/MySQL/InnoDB整体架构/</id>
    <published>2019-03-03T12:14:16.000Z</published>
    <updated>2019-07-13T06:09:15.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InnoDB整体架构"><a href="#InnoDB整体架构" class="headerlink" title="InnoDB整体架构"></a>InnoDB整体架构</h1><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><ul><li>Master Thread<br>Master Thread具有最高的线程优先级别，内部由多个循环（每秒/每10秒）组成。<ol><li>每秒的操作<ul><li>刷新日志缓冲到磁盘（总是）</li><li>合并插入缓冲</li><li>刷新脏页到磁盘（至多100个）</li><li>切换到后台进程</li></ul></li><li>每10秒的操作<ul><li>删除无用的undo页（总是）</li><li>合并20个插入缓冲（总是）</li><li>调回主循环（总是）</li></ul></li></ol></li><li>IO Thread</li><li>purge Thread</li><li>Page cleaner Thread</li></ul><a id="more"></a><h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><ul><li><p>Change buffer（Insert buffer、Delete buffer、Purge buffer）<br>在对非唯一索引的插入和更新操作过程中，如果该数据页在内存中，则直接对数据页进行修改。如果该数据页不在内存中，Innodb并不会马上到磁盘上将该数据页读入内存中，而是先将修改存入到Change buffer中，再按照一定的频率将修改合并到数据页中。</p><ol><li>为什么是需要在非唯一索引的<br>如果是对唯一索引上的数据进行修改，那么在修改前需要进行唯一性校验，这个时候会对该数据页进行查询操作，此时已经将该数据页读取到了内存当中，所以Change buffer的优化对唯一索引并没有什么效果。</li><li>如果宕机是否会导致数据的丢失？<br>Change buffer中数据，不仅会保存在内存当中，还会持久化到磁盘（系统表空间）当中。（持久化机制？）</li><li>什么情况下会合并？<ul><li>当对该数据页进行查询操作时，会将该数据页读取到内存当中。此时，会进行Change buffer的合并操作，将Change buffer中对该数据页的修改应用到该数据页。</li><li>Insert buffer Bitmap页追踪到该辅助索引页中已无可用空间</li><li>Master Thread</li></ul></li><li>合并流程怎样？<ul><li>从磁盘中读取数据页到内存（老版本）</li><li>从Change buffer中读取这个数据页的修改引用到内存中的数据页</li><li>写redo log。记录了内存也和Change buffer的变更。（此时内存中的数据页属于脏页）<br><a href="https://imgchr.com/i/Zhzndf" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/Zhzndf.md.jpg" alt="Zhzndf.md.jpg"></a></li></ul></li></ol></li><li><p>redo buffer<br>redo log中记录的是数据页的物理修改。在事务执行过程中不断的写入到redo buffer中。<br>redo buffer在以下情况会持久化到磁盘。</p><ul><li>Master Thread每秒的定时任务</li><li>每个事务提交时</li><li>写入量过大，导致redo buffer不足是<br>由innodb_flush_log_at_trx_commit控制刷盘策略</li><li>0代表当事务提交时刷盘，只由Master Thread每秒定时任务执行刷盘</li><li>1代表在执行commit时将重做日志缓冲同步到写到磁盘</li><li>2异步刷盘，直接写到文件系统的缓存中，不保证commit执行时肯定会刷盘</li></ul></li><li>数据页和索引页<br>数据都是存储在磁盘上的，当需要访问时才会从磁盘中将该数据所在的页读取到内存当中，并以一定的策略进行淘汰策略和刷盘策略。</li><li>哈希信息页</li><li>元数据信息页</li></ul><h3 id="Innodb机制"><a href="#Innodb机制" class="headerlink" title="Innodb机制"></a>Innodb机制</h3><ul><li>checkpoint<br>在一定条件下，将内存中的脏页持久化到磁盘，并记录数据页刷新的位点信息(LSN)的一种机制。<ol><li>缩短数据库的恢复时间（数据库关闭时将所有的脏页刷新到磁盘/Sharp Checkpoint）</li><li>缓冲池不够用时，刷新部分脏页（为了保证缓冲池中有足够可用的数据页，Innodb会强制进行Checkpoint/Dirty Page too much Checkpoint)</li><li>重做日志不可用时，刷新部分脏页（redo log是一个循环文件，如果redo log的写入量特别大，导致此时redo log几乎写满，Innodb会先将部分脏页先刷新到磁盘，释放redo log空间，此时会触发Checkpoint。/Async/Sync Flush Checkpoint）</li><li>Master Thread每秒任务，刷新部分脏页</li><li>LRU列表空闲页不足时，刷新部分脏页（Innodb会保证LRU列表中有一定数量空闲页可使用，如果LRU列表中没有这么多空闲页，那么Innodb会将LRU列表尾端的页移除，如果其中存在脏页，那么此时会进行Checkpoint操作/FLUSH_LRU_LIST Checkpoint）</li></ol></li><li><p>两次写（Double write）<br>在写数据之前，先把这个数据页写到一块独立物理位置后，再写到数据页中。<br>由两部分组成，一部分是Innodb内存中的double write buffer；另一部分是物理磁盘上的ibdata系统表空间的大小为2M，共128个连续的page。<br>在对缓冲池中的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer分两次，每次1M顺序地写入到共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘。<br><a href="https://imgchr.com/i/ZhzmeP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhzmeP.md.jpg" alt="ZhzmeP.md.jpg"></a></p></li><li><p>WAL（write ahead log)</p><pre><code>1. 先记录undo/redo log,确保日志刷到磁盘上持久存储。2. 更新内存数据页，并&lt;font color=&quot;red&quot;&gt;异步刷盘&lt;/font&gt;。3. 事务日志持久化到binlog，&lt;font color=&quot;red&quot;&gt;此时返回给客户端事务已提交&lt;/font&gt;。4. 提交事务，在redo log中写入到commit记录。</code></pre></li><li><p>两阶段提交<br>我们可以看到对于更新数据的操作，MySQL的处理逻辑是先将内存中的数据页更新，然后写入redolog(prepare阶段），写入binglog，redo log(commit阶段)<br><a href="https://imgchr.com/i/ZhzEQA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhzEQA.md.jpg" alt="ZhzEQA.md.jpg"></a></p><p>在两阶段不同时刻宕机，会发生什么情况？<br>innodb发现redolog中没有commit，就会拿着XA号去binlog中寻找是否存在</p><ul><li>在时刻A宕机，此时是不存在的，所以事务回滚。</li><li>在时刻B宕机，此时Binlog中存在该XA号，所以会恢复该事务。</li></ul></li><li><p>MVCC(多版本并发控制）<br>事务在开启的时候会获取一个一致性快照，每个事务都有一个唯一的事务ID，叫做transaction ID。<br>每行数据也有多个版本，每次事务更新数据的时候都会生成一个新的数据版本，并且将transaction ID赋值给这个数据版本的事务ID。<br>图中的虚线代表的就是undo log,V1、V2、V3并不物理真实存在，需要获取V2则需要从V4依次应用U3、U2。<br>一个数据版本，对于一个事务视图来说，除了自己更新的总是可见以外：</p><ol><li>版本未提交，不可见</li><li>版本已提交，但是是在视图创建后提交的，不可见</li><li>版本已提交，而且是在视图创建前提交的，可见<br><a href="https://imgchr.com/i/Zhzuo8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/Zhzuo8.md.jpg" alt="Zhzuo8.md.jpg"></a></li></ol></li><li><p>自适应哈希</p></li><li>异步IO</li><li>刷新临近页</li><li>组提交<h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;InnoDB整体架构&quot;&gt;&lt;a href=&quot;#InnoDB整体架构&quot; class=&quot;headerlink&quot; title=&quot;InnoDB整体架构&quot;&gt;&lt;/a&gt;InnoDB整体架构&lt;/h1&gt;&lt;h3 id=&quot;后台线程&quot;&gt;&lt;a href=&quot;#后台线程&quot; class=&quot;headerlink&quot; title=&quot;后台线程&quot;&gt;&lt;/a&gt;后台线程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Master Thread&lt;br&gt;Master Thread具有最高的线程优先级别，内部由多个循环（每秒/每10秒）组成。&lt;ol&gt;
&lt;li&gt;每秒的操作&lt;ul&gt;
&lt;li&gt;刷新日志缓冲到磁盘（总是）&lt;/li&gt;
&lt;li&gt;合并插入缓冲&lt;/li&gt;
&lt;li&gt;刷新脏页到磁盘（至多100个）&lt;/li&gt;
&lt;li&gt;切换到后台进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每10秒的操作&lt;ul&gt;
&lt;li&gt;删除无用的undo页（总是）&lt;/li&gt;
&lt;li&gt;合并20个插入缓冲（总是）&lt;/li&gt;
&lt;li&gt;调回主循环（总是）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;IO Thread&lt;/li&gt;
&lt;li&gt;purge Thread&lt;/li&gt;
&lt;li&gt;Page cleaner Thread&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL体系结构</title>
    <link href="http://yoursite.com/2019/03/02/MySQL/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/02/MySQL/MySQL体系结构/</id>
    <published>2019-03-02T12:14:16.000Z</published>
    <updated>2019-07-13T05:56:52.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h1><p><a href="https://imgchr.com/i/ZhxoZV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhxoZV.md.jpg" alt="ZhxoZV.md.jpg"></a></p><ul><li>连接器<br>连接器负责跟客户端建立连接、获取权限、维持和管理连接。<br>在这个阶段，连接器会对用户输入的账号密码进行判断。并判断用户连接和数据库连接是否都到了最大限制。以及后续对超时连接进行清理操作。<ol><li>在连接之前，不管用户名密码是够正确，权限如何，连接器会先对连接数进行检查。</li><li>权限会存在两份，一份在数据库中持久化存储，一份保存在内存当中。flush privileges操作就是将内存中的信息给清空，并从数据库中重新加载到内存中。</li><li>在执行grant和revoke操作时，会先将磁盘中的信息修改，然后同步到内存中。但是如果是直接修改的mysql.user表，此时不会主动去更新内存。</li><li>连接器只会到内存中读取用户信息以及权限。连接器只会在进行连接的时候才对用户账号密码进行校验，这意味着，如果一个用户已经连接上，修改密码并不会影响此连接。</li><li>对于全局权限是实时从内存中获取，这代表如果进行权限修改会马上生效。但是对库的权限修改稍微有点区别，虽然也是实时同步到内存，但是如果该连接已经使用了use database进入某库，那么该连接会将该库的权限保存到当前会话变量中，对该库操作权限仍是进入时的状态。</li></ol></li><li>缓存器<br>缓存器会将之前执行过的语句以key-value的形式缓存在内存当中，key是执行的语句,value是该语句执行的结果。如果能够直接获取到，那么会将结果直接返回。（返回结果前还会进行一次权限校验）<br>但是，如果对该表存在更新等数据修改操作，那么这个表上所有的缓存将会清空以保证读取数据的一致性。</li><li>分析器<br>对sql进行词法和语法分析，此时会生成一颗解析树。此时会将sql语句转化成数据库能够看懂的形式，如将字符串’T’识别成’表名T’。此时会去读取库表结构，判断该表是否存在，该字段是够存在。</li><li>优化器<br>根据自身的信息采集、以往执行计划分析等选择自认为最优的执行计划、选择相应的索引。<br>MySQL有一整套规则来判断SQL语句的最优方案，但是该方案不一定是最快的。<br>可以人为的对优化器进行控制，使其选择相应的方案。如force index/ignore index/STRAIGHT_JOIN等。</li><li>执行器<br>根据优化器生成的执行计划来调用存储引擎的接口获取数据并对数据进行处理返回给客户端。</li><li>存储引擎</li></ul><h1 id="MySQL内存结构"><a href="#MySQL内存结构" class="headerlink" title="MySQL内存结构"></a>MySQL内存结构</h1><p><a href="https://imgchr.com/i/ZhxTaT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhxTaT.md.jpg" alt="ZhxTaT.md.jpg"></a></p><h2 id="全局内存"><a href="#全局内存" class="headerlink" title="全局内存"></a>全局内存</h2><ul><li>innodb_buffer_pool_size  innodb缓冲池大小</li><li>innodb_log_buffer_size   redo日志缓冲</li><li>key_buffer_size          MyISAM索引缓冲</li><li>table_definition_cache   表定义文件描述缓存</li><li>table_open_cache         表空间文件描述缓存</li><li>max_heap_table_size      memory、heap表的最大容量</li></ul><h2 id="线程内存"><a href="#线程内存" class="headerlink" title="线程内存"></a>线程内存</h2><ul><li>read_buffer_size</li><li>read_rnd_buffer_size</li><li>sort_buffer_size</li><li>join_buffer_size</li><li>binlog_cache_size</li><li>tmp_table_size</li><li>thread_stack</li><li>thread_chche_size</li><li>net_buffer_length</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL体系结构&quot;&gt;&lt;a href=&quot;#MySQL体系结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL体系结构&quot;&gt;&lt;/a&gt;MySQL体系结构&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/ZhxoZV&quot; targ
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
</feed>

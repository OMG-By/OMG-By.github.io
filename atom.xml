<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OMG_By</title>
  
  <subtitle>你走与不走，路就在那里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-24T16:22:04.176Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OMG_By</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis原理----管道</title>
    <link href="http://yoursite.com/2018/10/24/Redis/Redis%E5%8E%9F%E7%90%86----%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2018/10/24/Redis/Redis原理----管道/</id>
    <published>2018-10-24T13:34:13.000Z</published>
    <updated>2018-10-24T16:22:04.176Z</updated>
    
    <content type="html"><![CDATA[<p>大多数人一直对Redis管道有一个误解，他们以为这是Redis服务器提供的一种特别的技术，有了这种技术就可以加速Redis的存取效率。但是实际上Redis管道（Pipeline）本身并不是Redis服务器直接提供的技术，这个技术本质上是由客户端提供的，跟服务器没有什么直接的关系。</p><h2 id="Redis的消息交互"><a href="#Redis的消息交互" class="headerlink" title="Redis的消息交互"></a>Redis的消息交互</h2><p>当我们使用客户端对Redis进行一次操作时，如下图所示，客户端将请求传送给服务器，服务器处理完毕后，再将响应回复给客户端。这要花费一个网络数据包的来回时间。  </p><p><img src="https://i.imgur.com/ulCYBhP.jpg" alt=""><br><a id="more"></a><br>如果连续执行多条指令，那就会花费多个网络数据包来回的时间。如下图所示。  </p><p><img src="https://i.imgur.com/zxGuLwE.jpg" alt="">  </p><p>回到客户端代码层面，客户端是经历了写-读-写-读四个操作才完整的执行了两条指令。  </p><p><img src="https://i.imgur.com/kW9apz0.jpg" alt="">  </p><p>现在如果我们调整读写顺序，改成写-写-读-读，这两个指令同样可以正常完成。  </p><p><img src="https://i.imgur.com/V6yvFoA.jpg" alt=""><br>两个连续的写操作和两个连续的读操作总共只会花费一次网络来回，就好比连续的write操作合并了，连续的read操作也合并了一样。</p><p><img src="https://i.imgur.com/qvHYXje.jpg" alt="">    </p><p>这便是管道操作的本质，服务器根本没有任何区别对待，还是收到一条消息，执行一条消息，回复一条消息的正常流程。客户端通过对管道中的指令列表改变读写顺序就可以大幅度节省IO时间，管道中指令越多，效果越好。  </p><h2 id="深入理解管道本质"><a href="#深入理解管道本质" class="headerlink" title="深入理解管道本质"></a>深入理解管道本质</h2><p>接下来我们深入分析一个请求交互的流程，真实的情况是它很复杂，因为要经过网络协议栈，这个就得深入内核了。  </p><p><img src="https://i.imgur.com/Ub6GJ4Z.jpg" alt="">  </p><p>上图就是一个完整的请求交互图。  </p><ol><li>客户端进程挑用write将消息写到操作系统内核为套接字分配的发送缓冲send buffer。  </li><li>客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过[网际路由]送到服务器的网卡。  </li><li>服务器操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲recv buffer。  </li><li>服务器进程调用read从接收缓冲中取出消息进行处理。  </li><li>服务器进程调用write将响应消息写到内核为套接字分配的发送缓冲send buffer。  </li><li>服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过[网际路由]送到客户端网卡。  </li><li>客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲recv buffer。  </li><li>客户端进程调用read从接收缓冲中取出消息返回给上层业务逻辑进行处理。  </li><li>结束。  </li></ol><p>其中步骤5-8和1-4是一样的，只不过方向是反过来的，一个是请求，一个是响应。  </p><p>我们开始以为write操作是要等到对方收到消息才会返回，但实际上不是这样的。write操作只负责将数据写到本地操作系统内核的发送缓冲然后就返回了。剩下的事交给操作系统内核异步将数据送到目标机器。但是如果发送缓冲满了，那么就需要等待缓冲空出空间来，这个就是写IO操作的真正耗时。  </p><p>我们开始以为read操作是从目标机器拉取数据，但实际上不是这样的。read操作只负责将数据从本地操作系统内核的接收缓冲中取出来。但是如果缓冲是空的，那么就需要等待数据到来，这个就是读IO操作的真正耗时。  </p><p>所以对于value = redis.get(key)这样一个简单的请求来说，write操作几乎没有耗时，直接写到发送缓冲就返回，而read就比较耗时了，因为他要等待消息经过网际路由到目标机器处理后的响应消息，再回送到当前的内核读缓冲才可以返回。<b>这是才是一个网络来回的真正开销。</b>  </p><p>而对于管道来说，连续的write操作根本没有耗时，之后第一个read操作会等待一个网络的来回开销，然后所有的响应消息就都已经回送到内核的读缓存了，后续的read操作直接就可以从缓冲拿到结果，瞬间就返回了。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大多数人一直对Redis管道有一个误解，他们以为这是Redis服务器提供的一种特别的技术，有了这种技术就可以加速Redis的存取效率。但是实际上Redis管道（Pipeline）本身并不是Redis服务器直接提供的技术，这个技术本质上是由客户端提供的，跟服务器没有什么直接的关系。&lt;/p&gt;
&lt;h2 id=&quot;Redis的消息交互&quot;&gt;&lt;a href=&quot;#Redis的消息交互&quot; class=&quot;headerlink&quot; title=&quot;Redis的消息交互&quot;&gt;&lt;/a&gt;Redis的消息交互&lt;/h2&gt;&lt;p&gt;当我们使用客户端对Redis进行一次操作时，如下图所示，客户端将请求传送给服务器，服务器处理完毕后，再将响应回复给客户端。这要花费一个网络数据包的来回时间。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ulCYBhP.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理----持久化</title>
    <link href="http://yoursite.com/2018/10/22/Redis/Redis%E5%8E%9F%E7%90%86----%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2018/10/22/Redis/Redis原理----持久化/</id>
    <published>2018-10-22T13:30:13.000Z</published>
    <updated>2018-10-23T15:25:24.296Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证Redis的数据不会因为故障而丢失，这种机制就是Redis的持久化机制。  </p><p>Redis的持久化机制有两种，第一种就是快照（RDB文件），第二种就是AOF日志。快照是一次全量备份，AOF日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而AOF日志记录的是内存数据修改的指令记录文本。AOF日志在长期的运行过程中会变得非常大，数据库重启时需要加载AOF日志进行指令重放，这个时间会变得无比漫长。所以需要定期进行AOF重写，给AOF文件瘦身。</p><h2 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h2><p>我们知道Redis是单线程程序，这个线程要同时负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写。  </p><p>在服务线上请求的同时，Redis还需要进行内存快照，内存快照要求Redis必须进行文件IO操作，可文件IO操作是不能使用多路复用API。  </p><p>这意味着单线程同时在服务线上的请求和吉林文件IO操作，文件IO操作会严重拖垮服务器请求的性能。还有个<b>重要的问题就是为了不阻塞线上的业务，就需要边持久化边响应客户端请求</b>。持久化的同时，内存数据结构还在变化，比如一个大型的hash字典正在持久化，结果一个请求过来把它给删除了，还没持久化，这该怎么办？  </p><font color="red">Redis使用操作系统的多进程COW（copy On Write）机制来实现快照持久化。</font><a id="more"></a><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>Redis在持久化时会调用glibc的函数fork产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。这时你可以将父子进程想象成一个连体婴儿，共享身体。这时liunx操作系统的机制，为了节约内存资源，所以尽可能让他们共享。在进程分离的一瞬间，内存的增长几乎没有明显变化。  </p><p>子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断修改。  </p><p>这个时候就会使用操作系统的COW机制进行数据段页的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程像一粒的页面是没有变化的，还是进程产生时那一瞬间的数据。  </p><p>随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的2倍大小。另外一个Redis实例里冷数据占的比例往往是比较高的，所以很少会出现所有的页面都会被分离，被分离的往往只有其中一部分。每个页面的大小只有4k，一个Redis实例里面一般会有成千上万的页面。  </p><p>子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么Redis的持久化交【快照】的原因。接下来子进程就可以非常安心的遍历数据进行序列化写磁盘了。</p><h2 id="AOF原理"><a href="#AOF原理" class="headerlink" title="AOF原理"></a>AOF原理</h2><p>AOF日志存储的Redis服务器的顺序指令序列，AOF日志只记录对内存进行修改的指令记录。  </p><p>假设AOF日志记录了自Redis实例创建以来所有的修改性指令序列，那么就可以通过对一个空的Redis实例顺序执行所有的指令，也就是重放来恢复Redis当前实例的内存数据结构的状态。  </p><p>Redis会在收到客户端修改指令后，进行参数校验进行逻辑处理后，如果没有问题，就立即将该指令存储到AOF日志中，也就是先执行指令才将日志存盘。这点不同于leveldb、hbase等存储引擎，他们都是先存储日志再做逻辑处理。  </p><p>Redis在长期运行的过程中，AOF的日志会变得越来越多。如果实例宕机重启，重放整个AOF日志会非常耗时，导致 长时间Redis无法对外提供服务，所以需要对AOF进行日志瘦身。</p><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>Redis提供了bgrewriteaof指令用于对AOF日志进行瘦身。其原理就是开辟一个子进程对内存进行遍历转换成一系列Redis的操作指令，序列化到一个新的AOF日志文件中。序列化完毕后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，追加完毕后就立即替换旧的日志文件。</p><h2 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h2><p>AOF日志是以文件的形式存在的，当程序对AOF日志文件进行写操作时，实际上就是内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回到磁盘。  </p><p>这意味着如果机器突然宕机，AOF日志内容可能还没来得及完全刷到磁盘，这个时候就会出现日志丢失。  </p><p>Linux的glibc提供了fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷到磁盘。只要Redis进程实时调用fsync函数就可以保证aof日志不丢失。但是fsync是一个磁盘IO操作，这意味着他很慢。如果Reids执行一条指令就要fsync一次，那么Redis的高性能地位就不保了。  </p><p>所以在生产环境的服务器中，Redis通常是每隔1s左右执行一次fsync操作，这是在数据安全性和性能之间做了一个折中，在保持高性能的同时，尽可能使得数据少丢失。  </p><p>Redis提供了另外两种策略：永不fsync（让操作系统来决定何时同步磁盘），用一个指令就fsync一次（非常慢，基本不会在生产中使用）</p><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><p>快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。<br>1、遍历整个内存，大块写磁盘会加重系统负载。<br>2、AOF的fsync是一个比较耗时的IO操作，它会降低Redis性能，同时也会增加系统IO负担。  </p><p>所以通常Redis的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源比较充沛。  </p><p>但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，所以在生产环境要做好实例监控工作，保证网络畅通或者能快速修复。另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失。</p><h2 id="Redis4-0混合持久化"><a href="#Redis4-0混合持久化" class="headerlink" title="Redis4.0混合持久化"></a>Redis4.0混合持久化</h2><p>重启Redis时，我们很少使用rdb来恢复内存状态，因为会丢失大量数据。我们通常使用AOF日志重做，但是重放AOF日志性能相对RDB来说要慢很多，这样在Redis实例很大的情况下，启动需要花费很长的时间。  </p><p>Redis4.0为了解决这个问题，带来了一个新的持久化选项–混合持久化。将RDB文件的内容和增量的AOF日志文件存在一起。这里的AOF日志不在是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量AOF日志，通常这部分AOF日志很小。  </p><p>于是在Redis重启的时候，可以先加载rdb的内容，然后再重放增量AOF日志就可以完全替代之前的AOF全量文件重放，重启效率大幅度提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证Redis的数据不会因为故障而丢失，这种机制就是Redis的持久化机制。  &lt;/p&gt;
&lt;p&gt;Redis的持久化机制有两种，第一种就是快照（RDB文件），第二种就是AOF日志。快照是一次全量备份，AOF日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而AOF日志记录的是内存数据修改的指令记录文本。AOF日志在长期的运行过程中会变得非常大，数据库重启时需要加载AOF日志进行指令重放，这个时间会变得无比漫长。所以需要定期进行AOF重写，给AOF文件瘦身。&lt;/p&gt;
&lt;h2 id=&quot;快照原理&quot;&gt;&lt;a href=&quot;#快照原理&quot; class=&quot;headerlink&quot; title=&quot;快照原理&quot;&gt;&lt;/a&gt;快照原理&lt;/h2&gt;&lt;p&gt;我们知道Redis是单线程程序，这个线程要同时负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写。  &lt;/p&gt;
&lt;p&gt;在服务线上请求的同时，Redis还需要进行内存快照，内存快照要求Redis必须进行文件IO操作，可文件IO操作是不能使用多路复用API。  &lt;/p&gt;
&lt;p&gt;这意味着单线程同时在服务线上的请求和吉林文件IO操作，文件IO操作会严重拖垮服务器请求的性能。还有个&lt;b&gt;重要的问题就是为了不阻塞线上的业务，就需要边持久化边响应客户端请求&lt;/b&gt;。持久化的同时，内存数据结构还在变化，比如一个大型的hash字典正在持久化，结果一个请求过来把它给删除了，还没持久化，这该怎么办？  &lt;/p&gt;
&lt;font color=&quot;red&quot;&gt;Redis使用操作系统的多进程COW（copy On Write）机制来实现快照持久化。&lt;/font&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码阅读目录</title>
    <link href="http://yoursite.com/2018/10/21/Redis/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/10/21/Redis/Redis源码阅读/</id>
    <published>2018-10-21T13:34:13.000Z</published>
    <updated>2018-10-21T15:51:50.920Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>文件</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>adlist.c 、 adlist.h</td><td style="text-align:center">双端链表数据结构的实现。</td></tr><tr><td>ae.c 、 ae.h 、 ae_epoll.c 、 ae_evport.c 、 ae_kqueue.c 、 ae_select.c</td><td style="text-align:center">事件处理器，以及各个具体实现。</td></tr><tr><td>anet.c 、 anet.h</td><td style="text-align:center">Redis 的异步网络框架，内容主要为对 socket 库的包装。</td></tr><tr><td>aof.c</td><td style="text-align:center">AOF 功能的实现。</td></tr><tr><td>asciilogo.h</td><td style="text-align:center">保存了 Redis 的 ASCII LOGO 。</td></tr><tr><td>bio.c 、 bio.h</td><td style="text-align:center">Redis 的后台 I/O 程序，用于将 I/O 操作放到子线程里面执行， 减少 I/O 操作对主线程的阻塞。</td></tr><tr><td>bitops.c</td><td style="text-align:center">二进制位操作命令的实现文件。</td></tr><tr><td>blocked.c</td><td style="text-align:center">用于实现 BLPOP 命令和 WAIT 命令的阻塞效果。</td></tr><tr><td>cluster.c 、 cluster.h</td><td style="text-align:center">Redis 的集群实现。</td></tr><tr><td>config.c 、 config.h</td><td style="text-align:center">Redis 的配置管理实现，负责读取并分析配置文件， 然后根据这些配置修改 Redis 服务器的各个选项。</td></tr><tr><td>crc16.c 、 crc64.c 、 crc64.h</td><td style="text-align:center">计算 CRC 校验和。</td></tr><tr><td>db.c</td><td style="text-align:center">数据库实现。</td></tr><tr><td>debug.c</td><td style="text-align:center">调试实现。</td></tr><tr><td>dict.c 、 dict.h</td><td style="text-align:center">字典数据结构的实现。</td></tr><tr><td>endianconv.c 、 endianconv.h</td><td style="text-align:center">二进制的大端、小端转换函数。</td></tr><tr><td>fmacros.h</td><td style="text-align:center">一些移植性方面的宏。</td></tr><tr><td>help.h</td><td style="text-align:center">utils/generate-command-help.rb 程序自动生成的命令帮助信息。</td></tr><tr><td>hyperloglog.c</td><td style="text-align:center">HyperLogLog 数据结构的实现。</td></tr><tr><td>intset.c 、 intset.h</td><td style="text-align:center">整数集合数据结构的实现，用于优化 SET 类型。</td></tr><tr><td>lzf_c.c 、 lzf_d.c 、 lzf.h 、 lzfP.h</td><td style="text-align:center">Redis 对字符串和 RDB 文件进行压缩时使用的 LZF 压缩算法的实现。</td></tr><tr><td>Makefile 、 Makefile.dep</td><td style="text-align:center">构建文件。</td></tr><tr><td>memtest.c</td><td style="text-align:center">内存测试。</td></tr><tr><td>mkreleasehdr.sh</td><td style="text-align:center">用于生成释出信息的脚本。</td></tr><tr><td>multi.c</td><td style="text-align:center">Redis 的事务实现。</td></tr><tr><td>networking.c</td><td style="text-align:center">Redis 的客户端网络操作库， 用于实现命令请求接收、发送命令回复等工作， 文件中的函数大多为 write 、 read 、 close 等函数的包装， 以及各种协议的分析和构建函数。</td></tr><tr><td>notify.c</td><td style="text-align:center">Redis 的数据库通知实现。</td></tr><tr><td>object.c</td><td style="text-align:center">Redis 的对象系统实现。</td></tr><tr><td>pqsort.c 、 pqsort.h</td><td style="text-align:center">快速排序（QuickSort）算法的实现。</td></tr><tr><td>pubsub.c</td><td style="text-align:center">发布与订阅功能的实现。</td></tr><tr><td>rand.c 、 rand.h</td><td style="text-align:center">伪随机数生成器。</td></tr><tr><td>rdb.c 、 rdb.h</td><td style="text-align:center">RDB 持久化功能的实现。</td></tr><tr><td>redisassert.h</td><td style="text-align:center">Redis 自建的断言系统。</td></tr><tr><td>redis-benchmark.c</td><td style="text-align:center">Redis 的性能测试程序。</td></tr><tr><td>redis.c</td><td style="text-align:center">负责服务器的启动、维护和关闭等事项。</td></tr><tr><td>redis-check-aof.c 、 redis-check-dump.c</td><td style="text-align:center">RDB 文件和 AOF 文件的合法性检查程序。</td></tr><tr><td>redis-cli.c</td><td style="text-align:center">Redis 客户端的实现。</td></tr><tr><td>redis.h</td><td style="text-align:center">Redis 的主要头文件，记录了 Redis 中的大部分数据结构， 包括服务器状态和客户端状态。</td></tr><tr><td>redis-trib.rb</td><td style="text-align:center">Redis 集群的管理程序。</td></tr><tr><td>release.c 、 release.h</td><td style="text-align:center">记录和生成 Redis 的释出版本信息。</td></tr><tr><td>replication.c</td><td style="text-align:center">复制功能的实现。</td></tr><tr><td>rio.c 、 rio.h</td><td style="text-align:center">Redis 对文件 I/O 函数的包装， 在普通 I/O 函数的基础上增加了显式缓存、以及计算校验和等功能。</td></tr><tr><td>scripting.c</td><td style="text-align:center">脚本功能的实现。</td></tr><tr><td>sds.c 、 sds.h</td><td style="text-align:center">SDS 数据结构的实现，SDS 为 Redis 的默认字符串表示。</td></tr><tr><td>sentinel.c</td><td style="text-align:center">Redis Sentinel 的实现。</td></tr><tr><td>setproctitle.c</td><td style="text-align:center">进程环境设置函数。</td></tr><tr><td>sha1.c 、 sha1.h</td><td style="text-align:center">SHA1 校验和计算函数。</td></tr><tr><td>slowlog.c 、 slowlog.h</td><td style="text-align:center">慢查询功能的实现。</td></tr><tr><td>solarisfixes.h</td><td style="text-align:center">针对 Solaris 系统的补丁。</td></tr><tr><td>sort.c</td><td style="text-align:center">SORT 命令的实现。</td></tr><tr><td>syncio.c</td><td style="text-align:center">同步 I/O 操作。</td></tr><tr><td>testhelp.h</td><td style="text-align:center">测试辅助宏。</td></tr><tr><td>t_hash.c 、 t_list.c 、 t_set.c、 t_string.c 、 t_zset.c</td><td style="text-align:center">定义了 Redis 的各种数据类型，以及这些数据类型的命令。</td></tr><tr><td>util.c 、 util.h</td><td style="text-align:center">各种辅助函数。</td></tr><tr><td>valgrind.sup</td><td style="text-align:center">valgrind 的suppression文件。</td></tr><tr><td>version.h</td><td style="text-align:center">记录了 Redis 的版本号。</td></tr><tr><td>ziplist.c 、 ziplist.h</td><td style="text-align:center">ZIPLIST 数据结构的实现，用于优化 LIST 类型。</td></tr><tr><td>zipmap.c 、 zipmap.h</td><td style="text-align:center">ZIPMAP 数据结构的实现，在 Redis 2.6 以前用与优化 HASH 类型， Redis 2.6 开始已经废弃。</td></tr><tr><td>zmalloc.c 、 zmalloc.h</td><td style="text-align:center">内存管理程序。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;adlist.c 、 adlist.h&lt;/td&gt;
&lt;td style=&quot;t
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理----通信协议</title>
    <link href="http://yoursite.com/2018/10/21/Redis/Redis%E5%8E%9F%E7%90%86----%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/10/21/Redis/Redis原理----通信协议/</id>
    <published>2018-10-21T11:34:13.000Z</published>
    <updated>2018-10-21T15:19:00.906Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的作者认为数据库系统的瓶颈一般不在于网络流量，而是数据库自身内部逻辑处理上。所以即使Redis使用了浪费流量的文本协议，依然可以取得极高的访问性能。Redis将所有数据都放在内存，用一个单线程对外提供服务，单个节点在跑满一个CPU核心的情况下可以达到10w/s的超高QPS。</p><h2 id="RESP"><a href="#RESP" class="headerlink" title="RESP"></a>RESP</h2><p>RESP（Redis Serialization Protocol）是Redis序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简单，解析性能极好。</p><p>Redis歇息将传输的数据结构分为5种最小单元类型，单元结束时统一加上回车换行符号\r\n。  </p><ul><li>单行字符以<font color="red">+</font>符号开头</li><li>多行字符以<font color="red">$</font>符号开头，后跟字符串长度</li><li>整数值以<font color="red">：</font>符号开头，后跟整数的字符串形式</li><li>错误消息以<font color="red">-</font>符号开头</li><li>数组以<font color="red">*</font>符号开头，后跟数组的长度</li></ul><p>单行字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+hello world\r\n</div></pre></td></tr></table></figure></p><p>多行字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$11\r\n  </div><div class="line">hello world\r\n</div></pre></td></tr></table></figure></p><p>整数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:1024\r\n</div></pre></td></tr></table></figure></p><p>错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-WRONGTYPE Operation ....</div></pre></td></tr></table></figure></p><p>数组[1,2,3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*3\r\n  </div><div class="line">:1\r\n</div><div class="line">:2\r\n  </div><div class="line">:3\r\n</div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="客户端-gt-服务器"><a href="#客户端-gt-服务器" class="headerlink" title="客户端-&gt;服务器"></a>客户端-&gt;服务器</h2><p>客户端向服务器发送的指令只有一种格式，多行字符串数组。比如一个简单的set指令set k v会被序列化成以下字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">*3\r\n  </div><div class="line">$3\r\n  </div><div class="line">set\r\n</div><div class="line">$1\r\n</div><div class="line">k\r\n</div><div class="line">$1\r\n</div><div class="line">v\r\n</div></pre></td></tr></table></figure></p><h2 id="服务器-gt-客户端"><a href="#服务器-gt-客户端" class="headerlink" title="服务器-&gt;客户端"></a>服务器-&gt;客户端</h2><p>服务器向客户端恢复的响应要支持多种数据结构，所以消息响应在结构上要复杂不少。不过在复杂的响应消息也是以上的5种基本类型的组合。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redis协议里有大量冗余的回车换行符，但是这并不影响它成为互联网技术领域非常受欢迎的一个文本歇息。有很多开源项目目前使用RESP作为它的通讯协议。在技术领域性能并不是一切，还有简单性、易理解性和易实现性，这些都是需要进行适当权衡的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的作者认为数据库系统的瓶颈一般不在于网络流量，而是数据库自身内部逻辑处理上。所以即使Redis使用了浪费流量的文本协议，依然可以取得极高的访问性能。Redis将所有数据都放在内存，用一个单线程对外提供服务，单个节点在跑满一个CPU核心的情况下可以达到10w/s的超高QPS。&lt;/p&gt;
&lt;h2 id=&quot;RESP&quot;&gt;&lt;a href=&quot;#RESP&quot; class=&quot;headerlink&quot; title=&quot;RESP&quot;&gt;&lt;/a&gt;RESP&lt;/h2&gt;&lt;p&gt;RESP（Redis Serialization Protocol）是Redis序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简单，解析性能极好。&lt;/p&gt;
&lt;p&gt;Redis歇息将传输的数据结构分为5种最小单元类型，单元结束时统一加上回车换行符号\r\n。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单行字符以&lt;font color=&quot;red&quot;&gt;+&lt;/font&gt;符号开头&lt;/li&gt;
&lt;li&gt;多行字符以&lt;font color=&quot;red&quot;&gt;$&lt;/font&gt;符号开头，后跟字符串长度&lt;/li&gt;
&lt;li&gt;整数值以&lt;font color=&quot;red&quot;&gt;：&lt;/font&gt;符号开头，后跟整数的字符串形式&lt;/li&gt;
&lt;li&gt;错误消息以&lt;font color=&quot;red&quot;&gt;-&lt;/font&gt;符号开头&lt;/li&gt;
&lt;li&gt;数组以&lt;font color=&quot;red&quot;&gt;*&lt;/font&gt;符号开头，后跟数组的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单行字符&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;+hello world\r\n&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;多行字符串&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$11\r\n  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;hello world\r\n&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;整数&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;:1024\r\n&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;错误&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;-WRONGTYPE Operation ....&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;数组[1,2,3]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;*3\r\n  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;:1\r\n&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;:2\r\n  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;:3\r\n&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理----线程IO模型</title>
    <link href="http://yoursite.com/2018/10/20/Redis/Redis%E5%8E%9F%E7%90%86----%E7%BA%BF%E7%A8%8BIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/10/20/Redis/Redis原理----线程IO模型/</id>
    <published>2018-10-20T11:34:13.000Z</published>
    <updated>2018-10-20T15:45:50.396Z</updated>
    
    <content type="html"><![CDATA[<p><b>Redis是一个单线程程序</b></p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>当我们调用套接字的读写方法，默认他们是阻塞的，比如read方法要传递一个参数n，表示最多读取这门多字节后返回，如果一个字节都没有，那么线程就会卡在那里，直到新的数据到来或者连接关闭，read方法才可以返回，线程才能够继续处理。而write方法一般来说不会阻塞，除非内核为套接字分配的写缓冲区已经写满了，write方法才会阻塞，直到缓冲区有空闲空间。<img src="https://i.imgur.com/0sE9kXD.png" alt=""><br>非阻塞IO在套接字对象上提供了一个选项Non_Blocking,当这个选项打开时，读写方法不会阻塞。能读多少取决于内核为套接字分配的读缓冲区的空闲空间字节数，能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数。读方法和写方法都会通过返回值来告知程序实际读写了多少字节。</p><h2 id="事件轮询（多路复用）"><a href="#事件轮询（多路复用）" class="headerlink" title="事件轮询（多路复用）"></a>事件轮询（多路复用）</h2><p>非阻塞IO有个问题，就是线程要读数据，但是读了一部分就返回了，线程如何知道什么时候应该继续读，也就是当数据到来时，线程如何得到通知。写也是一样。<img src="https://i.imgur.com/bxF8jbN.png" alt=""><br>事件轮询API就是用来解决这个问题的，最简单的时间轮询API是select函数，它是操作系统提供给用户程序的API。输入时读写描述符列表read_fds &amp; write_fds，输出是与之对应的可读可写时间。同时还提供了一个timeout参数，如果没有任何事件的到来，那么最多等待timeout时间，线程处于阻塞状态。一旦期间有事件到来，就可以立即返回。线程就可以继续挨个处理相应的事件。处理完了继续过来轮询。于是线程就进入了一个死循环。我们把这个死循环称为事件轮询，一个循环为一个周期。<br><b>事件轮询API就是Java语言中的NIO技术</b></p><h2 id="指令队列"><a href="#指令队列" class="headerlink" title="指令队列"></a>指令队列</h2><p>Redis会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。</p><h2 id="响应队列"><a href="#响应队列" class="headerlink" title="响应队列"></a>响应队列</h2><p>Redis同样会为每个客户端套接字关联一个响应队列。<br>Redis服务器通过响应队列来将指令的返回结果回复给客户端。如果队列为空，那么以为这连接暂时处于空闲状态，不需要去获取写事件，也就是可以将当前的客户端描述符从write_fds里面移除。等到队列有数据了，再将描述符放进去。避免select系统调用立即返回写事件，结果发现没什么数据可以写。<b>出现这种情况的线程会飙高CPU</b></p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>服务器处理要响应的IO事件外，还要处理其他事情。比如定时任务。<br>如果线程阻塞在select系统调用上，定时任务将无法得到准时调度。那么Redis是如何解决这个问题的呢？  </p><p>Redis的定时任务会记录在一个最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是select系统调用的timeout参数。因为Redis知道未来timeout时间内，没有其他定时任务需要处理，所以可以安心睡眠timeout时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;Redis是一个单线程程序&lt;/b&gt;&lt;/p&gt;
&lt;h2 id=&quot;非阻塞IO&quot;&gt;&lt;a href=&quot;#非阻塞IO&quot; class=&quot;headerlink&quot; title=&quot;非阻塞IO&quot;&gt;&lt;/a&gt;非阻塞IO&lt;/h2&gt;&lt;p&gt;当我们调用套接字的读写方法，默认他们是阻塞的，比如read方
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>reset master和reset slave</title>
    <link href="http://yoursite.com/2018/09/23/mysql/reset%20master%E5%92%8Crester%20slave/"/>
    <id>http://yoursite.com/2018/09/23/mysql/reset master和rester slave/</id>
    <published>2018-09-23T08:11:15.000Z</published>
    <updated>2018-09-23T15:03:05.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="reset-master"><a href="#reset-master" class="headerlink" title="reset master"></a>reset master</h3><p>删除index file中记录的所有binlog文件，将日志索引文件清空，创建一个新的日志文件，这个命令通常用于第一次搭建主从关系的主库。  </p><h4 id="reset-master和purge-binary-log的区别"><a href="#reset-master和purge-binary-log的区别" class="headerlink" title="reset master和purge binary log的区别"></a>reset master和purge binary log的区别</h4><ol><li>reset master 删除日志索引文件中记录的所有binlog文件，出纳金一个新的日志文件，起始值从000001开始，purge binary log 命令不会修改记录binlog顺序的数值</li><li>reset master 不能用于有任何slave正在运行的主从关系的主库。因为在slave运行时刻reset master命令不被支持。从库此时会报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">In MySQL 5.6.5 and later, RESET MASTER also clears the values of the gtid_purged system variable (known as gtid_lost in MySQL 5.6.8 and earlier) as well as the global value of the gtid_executed (gtid_done, prior to MySQL 5.6.9) system variable (but not its session value); that is, executing this statement sets each of these values to an empty string (&apos;&apos;)</div></pre></td></tr></table></figure></li></ol><h3 id="reset-slave"><a href="#reset-slave" class="headerlink" title="reset slave"></a>reset slave</h3><p>reset slave 将使slave忘记主从复制关系的位置信息。该语句用于干净的启动，它删除master.info文件和relay-log.info文件以及所有的relay log文件并重新启用一个新的relay-log文件。</p><h3 id="reset-slave-all"><a href="#reset-slave-all" class="headerlink" title="reset slave all"></a>reset slave all</h3><p>在 5.6 版本中 reset slave 并不会清理存储于内存中的复制信息比如  master host, master port, master user, or master password,也就是说如果没有使用change master 命令做重新定向，执行start slave 还是会指向旧的master 上面。<br>当从库执行reset slave之后,将mysqld shutdown 复制参数将被重置。<br>在5.6.3 版本以及以后 使用使用 RESET SLAVE ALL 来完全的清理复制连接参数信息。(Bug #11809016)<br>RESET SLAVE ALL does not clear the IGNORE_SERVER_IDS list set by CHANGE MASTER TO. This issue is fixed in MySQL 5.7. (Bug #18816897)<br>In MySQL 5.6.7 and later, RESET SLAVE causes an implicit commit of an ongoing transaction. See Section 13.3.3, “Statements That Cause an Implicit Commit”.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;reset-master&quot;&gt;&lt;a href=&quot;#reset-master&quot; class=&quot;headerlink&quot; title=&quot;reset master&quot;&gt;&lt;/a&gt;reset master&lt;/h3&gt;&lt;p&gt;删除index file中记录的所有binlog文件，将日志
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>python装饰器</title>
    <link href="http://yoursite.com/2018/08/19/python/python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2018/08/19/python/python装饰器/</id>
    <published>2018-08-19T13:40:56.000Z</published>
    <updated>2018-08-19T14:08:06.739Z</updated>
    
    <content type="html"><![CDATA[<p>python装饰器就是用于<font color="red">扩展原来函数功能的一种函数</font>，这个函数的特殊之处在于它的返回值也是一个函数。使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原函数</div><div class="line">def func():</div><div class="line">print(&quot;hello&quot;)</div></pre></td></tr></table></figure></p><p>要想扩展一个函数的功能，最简单的方法就是直接修改原函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def func():</div><div class="line">print(&quot;before&quot;)</div><div class="line">print(&quot;hello&quot;)</div><div class="line">print(&quot;after&quot;)</div></pre></td></tr></table></figure></p><p>如果不想修改原函数，还是想增强函数的功能时，可以另外定义一个函数调用原函数。（类似于设计模式中的装饰模式，有组合和代理两种方式）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def deco(func):</div><div class="line">print(&quot;before&quot;)</div><div class="line">func()</div><div class="line">print(&quot;after&quot;)</div><div class="line"></div><div class="line">def func():</div><div class="line">print(&quot;hello&quot;)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    f = func</div><div class="line">    deco(f)#只有把func()或者f()作为参数执行，新加入功能才会生效</div><div class="line">    print(&quot;f.__name__ is&quot;,f.__name__)#f的name就是func()</div><div class="line">    print()</div><div class="line">    #func()</div></pre></td></tr></table></figure></p><p>但是如果存在很多个类似于func的函数需要相同的扩展，那岂不是要执行deco函数许多次？<br>下面我们实现一个最简陋的装饰器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def deco(func):</div><div class="line">def wrapper(*args, **kwargs):</div><div class="line">print(&quot;before&quot;)</div><div class="line">func(*args, **kwargs)</div><div class="line">print(&quot;after&quot;)</div><div class="line">return wrapper</div><div class="line"></div><div class="line">@deco</div><div class="line">def func():</div><div class="line">print(&quot;hello&quot;)</div></pre></td></tr></table></figure></p><p>这里的deco函数就是最原始的装饰器，它的参数是一个函数，然后返回值也是一个函数。其中作为参数的这个函数func()就在返回函数wrapper()的内部执行。然后在函数func()前面加上@deco。<br>所以这里装饰器就像一个注入符号：有了它，拓展了原来函数的功能既不需要侵入函数内更改代码，也不需要重复执行原函数。<br>在func函数前还可以使用多个@的方式来执行多个装饰器，多个装饰器的执行顺序就是从最后一个装饰器开始执行到第一个装饰器，在执行函数本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">def dec1(func):  </div><div class="line">    print(&quot;1111&quot;)  </div><div class="line">    def one():  </div><div class="line">        print(&quot;2222&quot;)  </div><div class="line">        func()  </div><div class="line">        print(&quot;3333&quot;)  </div><div class="line">    return one  </div><div class="line"></div><div class="line">def dec2(func):  </div><div class="line">    print(&quot;aaaa&quot;)  </div><div class="line">    def two():  </div><div class="line">        print(&quot;bbbb&quot;)  </div><div class="line">        func()  </div><div class="line">        print(&quot;cccc&quot;)  </div><div class="line">    return two  </div><div class="line"></div><div class="line">@dec1  </div><div class="line">@dec2  </div><div class="line">def test():  </div><div class="line">    print(&quot;test test&quot;)  </div><div class="line"></div><div class="line">test()  </div><div class="line"></div><div class="line">aaaa  </div><div class="line">1111  </div><div class="line">2222  </div><div class="line">bbbb  </div><div class="line">test test  </div><div class="line">cccc  </div><div class="line">3333</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python装饰器就是用于&lt;font color=&quot;red&quot;&gt;扩展原来函数功能的一种函数&lt;/font&gt;，这个函数的特殊之处在于它的返回值也是一个函数。使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>innobackupex的备份和恢复</title>
    <link href="http://yoursite.com/2018/08/17/mysql/innobackupex%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2018/08/17/mysql/innobackupex的备份和恢复/</id>
    <published>2018-08-17T03:05:58.000Z</published>
    <updated>2018-08-19T14:09:58.649Z</updated>
    
    <content type="html"><![CDATA[<p>还原分为3个阶段：backup（备份）、prepare（预恢复）、restore（恢复）  </p><p>首先复制所有的innodb数据文件，这样复制出来的文件肯定是不一致的，然后对每个文件进行崩溃恢复处理，最终达到一致。  </p><p>XtraBackup在启动的时候会记录一个LSN（log sequence number)，然后就把所有的innodb数据文件复制出来，这样复制出来的数据文件是不一致的。但是XtraBackup会在后台运行一个进程把所有对redo log file的修改记录下来。</p><p>以上步骤完成后innobackupex就会去备份MyIsam表和.frm文件，这时要保证数据的一致性就会先锁表，通过FLUSH TABLES WITH READ LOCK命令锁表后把文件复制出来，再释放掉这个锁。</p><p>在恢复数据的时候，要经过prepare和restore两个步骤。在prepare结束以后，innodb的表恢复到了复制innodb文件结束的时间点，这个时间点也就是锁表复制MyIsam表的起点，所以最终数据是一致的。一般我们在恢复的时候执行了两次prepare，是因为第二次prepare会帮助我们生成redo log文件，从而加快MySQL数据库启动的速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还原分为3个阶段：backup（备份）、prepare（预恢复）、restore（恢复）  &lt;/p&gt;
&lt;p&gt;首先复制所有的innodb数据文件，这样复制出来的文件肯定是不一致的，然后对每个文件进行崩溃恢复处理，最终达到一致。  &lt;/p&gt;
&lt;p&gt;XtraBackup在启动的时
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysqldump和mysqlbinlog</title>
    <link href="http://yoursite.com/2018/08/16/mysql/mysqldump/"/>
    <id>http://yoursite.com/2018/08/16/mysql/mysqldump/</id>
    <published>2018-08-16T15:49:08.000Z</published>
    <updated>2018-08-16T16:19:53.493Z</updated>
    
    <content type="html"><![CDATA[<p>mysqldump常用于MySQL数据库逻辑备份</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>1、mysqldump -uroot -p [–all-databases] [database name] &gt; [dump file]<br>上述命令会将制定数据库备份到某dump文件（转储文件）中，生成的dump文件中包含建表语句（生成数据库结构）和插入数据的insert语句。<br>2、如果加上–opt参数  </p><ul><li>建表语句中包含drop table if exists tableName  </li><li>inert之前包含一个锁表语句lock tables tableName write,insert之后包含unlock tables<br>3、mysqldump –host=host1 –opt sourceDb|mysql –host=host2 -C targetDb<br>使用以上命令可以将host1上的sourceDb复制到host2的targetDb，前提是目标主机的targetDb已经创建。<br>4、使用–no-data将只备份表结构。<br>5、mysql [database name] &lt; [backup file name]从备份文件恢复到数据库  <a id="more"></a><h3 id="mysqldump全量备份-mysqlbinlog二进制日志增量备份"><a href="#mysqldump全量备份-mysqlbinlog二进制日志增量备份" class="headerlink" title="mysqldump全量备份+mysqlbinlog二进制日志增量备份"></a>mysqldump全量备份+mysqlbinlog二进制日志增量备份</h3>从mysqldump备份文件恢复数据会丢失掉从备份点开始的更新数据，所以还需要结合mysqlbinlog二进制日志增量备份。确保已启动二进制文件。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">log-bin = mysql-bin</div></pre></td></tr></table></figure></li></ul><p>mysqldump命令必须带上–flush-logs选项生成新的二进制文件<br>mysqldump –single-transaction –flush-logs –master-data &gt; backup.sql<br>那么在恢复时先导入mysqldump的全量备份后，再导入mysqlbinlog二进制日志的增量备份。<br>此外，mysqlbinlog还可以指定–start-data、–stop-date、–start-position和–stop-position参数，用于精确恢复数据到某个时刻之前或者跳过中间某个出问题时间段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">5.9.3.1. 指定恢复时间</div><div class="line">对于MySQL 4.1.4，可以在mysqlbinlog语句中通过--start-date和--stop-date选项指定DATETIME格式的起止时间。举例说明，假设在今天上午10:00(今天是2005年4月20日)，执行SQL语句来删除一个大表。要想恢复表和数据，你可以恢复前晚上的备份，并输入：</div><div class="line">mysqlbinlog --stop-date=&quot;2005-04-20 9:59:59&quot; /var/log/mysql/bin.123456 \</div><div class="line">     | mysql -u root -pmypwd</div><div class="line">该命令将恢复截止到在--stop-date选项中以DATETIME格式给出的日期和时间的所有数据。如果你没有检测到几个小时后输入的错误的SQL语句，可能你想要恢复后面发生的活动。根据这些，你可以用起使日期和时间再次运行mysqlbinlog：</div><div class="line"></div><div class="line">mysqlbinlog --start-date=&quot;2005-04-20 10:01:00&quot; /var/log/mysql/bin.123456 \</div><div class="line">     | mysql -u root -pmypwd \</div><div class="line">在该行中，从上午10:01登录的SQL语句将运行。组合执行前夜的转储文件和mysqlbinlog的两行可以将所有数据恢复到上午10:00前一秒钟。你应检查日志以确保时间确切。下一节介绍如何实现。</div><div class="line"></div><div class="line">5.9.3.2. 指定恢复位置</div><div class="line">也可以不指定日期和时间，而使用mysqlbinlog的选项--start-position和--stop-position来指定日志位置。它们的作用与起止日选项相同，不同的是给出了从日志起的位置号。使用日志位置是更准确的恢复方法，特别是当由于破坏性SQL语句同时发生许多事务的时候。要想确定位置号，可以运行mysqlbinlog寻找执行了不期望的事务的时间范围，但应将结果重新指向文本文件以便进行检查。操作方法为：</div><div class="line">mysqlbinlog --start-date=&quot;2005-04-20 9:55:00&quot; --stop-date=&quot;2005-04-20 10:05:00&quot; \</div><div class="line">      /var/log/mysql/bin.123456 &gt; /tmp/mysql_restore.sql</div><div class="line">该命令将在/tmp目录创建小的文本文件，将显示执行了错误的SQL语句时的SQL语句。你可以用文本编辑器打开该文件，寻找你不要想重复的语句。如果二进制日志中的位置号用于停止和继续恢复操作，应进行注释。用log_pos加一个数字来标记位置。使用位置号恢复了以前的备份文件后，你应从命令行输入下面内容：</div><div class="line"></div><div class="line">mysqlbinlog --stop-position=&quot;368312&quot; /var/log/mysql/bin.123456 \</div><div class="line">    | mysql -u root -pmypwd </div><div class="line"> </div><div class="line">mysqlbinlog --start-position=&quot;368315&quot; /var/log/mysql/bin.123456 \</div><div class="line">    | mysql -u root -pmypwd \ </div><div class="line">上面的第1行将恢复到停止位置为止的所有事务。下一行将恢复从给定的起始位置直到二进制日志结束的所有事务。因为mysqlbinlog的输出包括每个SQL语句记录之前的SET TIMESTAMP语句，恢复的数据和相关MySQL日志将反应事务执行的原时间。</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysqldump常用于MySQL数据库逻辑备份&lt;/p&gt;
&lt;h3 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h3&gt;&lt;p&gt;1、mysqldump -uroot -p [–all-databases] [database name] &amp;gt; [dump file]&lt;br&gt;上述命令会将制定数据库备份到某dump文件（转储文件）中，生成的dump文件中包含建表语句（生成数据库结构）和插入数据的insert语句。&lt;br&gt;2、如果加上–opt参数  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建表语句中包含drop table if exists tableName  &lt;/li&gt;
&lt;li&gt;inert之前包含一个锁表语句lock tables tableName write,insert之后包含unlock tables&lt;br&gt;3、mysqldump –host=host1 –opt sourceDb|mysql –host=host2 -C targetDb&lt;br&gt;使用以上命令可以将host1上的sourceDb复制到host2的targetDb，前提是目标主机的targetDb已经创建。&lt;br&gt;4、使用–no-data将只备份表结构。&lt;br&gt;5、mysql [database name] &amp;lt; [backup file name]从备份文件恢复到数据库
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制</title>
    <link href="http://yoursite.com/2018/08/16/mysql/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/16/mysql/MySQL主从复制/</id>
    <published>2018-08-16T07:11:15.000Z</published>
    <updated>2018-08-16T13:31:07.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h3><p>将主数据库中的DDL和DML操作通过二进制日志文件传输到从数据库上，然后将这些日志重新执行（重做）；从而使从数据库的数据和主数据库的数据保持一致。</p><h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ul><li>主数据库出现问题时，可以切换到从数据库</li><li>可以在数据库层面进行读写分离</li><li>可以在从数据库上进行备份操作</li></ul><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p><img src="http://ocx5m3vc3.bkt.clouddn.com/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt=""><br>Binary log：主数据库的二进制文件<br>Relay log：从服务器的中继日志<br><a id="more"></a></p><ol><li>master在每个事物更新数据完成之前，将该操作记录串行地写入binlog文件中。</li><li>salve开启一个I/O线程，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的时间。I/O线程最终的目的是将这些事件写入到中继日志中。</li><li>SQL线程会读取中继日志，并顺序执行该日志中的SQL时间，从而与主数据库中的数据保持一致。</li></ol><h3 id="配置主从"><a href="#配置主从" class="headerlink" title="配置主从"></a>配置主从</h3><p>一、主服务器</p><ul><li>开启二进制日志</li><li>配置唯一的server-id</li><li>创建一个用于slave和master通信的用户账号</li><li>获得master二进制日志文件名及位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">skip-name-resolve</div><div class="line">basedir = /home/huzb/mysql</div><div class="line">datadir = /home/huzb/mysql/data</div><div class="line">port = 23307</div><div class="line">server_id = 119961011</div><div class="line">socket = /home/huzb/mysql/mysql_23307.sock</div><div class="line">log-bin = master-bin</div><div class="line">log-bin-index = master-bin.index</div><div class="line"> </div><div class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</div><div class="line"> </div><div class="line">[client]</div><div class="line">port = 23307</div><div class="line">socket = /home/huzb/mysql/mysql_23307.sock</div></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#添加复制权限的用户</div><div class="line"></div><div class="line">mysql&gt; CREATE USER &apos;repl&apos;@&apos;100.73.41.62&apos; IDENTIFIED BY &apos;slavepass&apos;;</div><div class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;100.73.41.62&apos;;</div><div class="line"></div><div class="line">mysql&gt; flush privileges;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#查看master状态</div><div class="line"></div><div class="line">mysql&gt; show master status;</div></pre></td></tr></table></figure><p>二、从服务器：</p><ul><li>配置唯一的server-id</li><li>使用master分配的用户账号读取master二进制日志</li><li>启动slave服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">skip-name-resolve</div><div class="line">basedir = /home/huzb/mysql</div><div class="line">datadir = /home/huzb/mysql/data</div><div class="line">port = 23306</div><div class="line">server_id = 220180801</div><div class="line">socket = /home/huzb/mysql/mysql_23306.sock</div><div class="line">relay-log = slave-relay-bin</div><div class="line">relay-log-index = slave-relay-bin.index</div><div class="line"> </div><div class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</div><div class="line"> </div><div class="line">[client]</div><div class="line">port = 23306</div><div class="line">socket = /home/huzb/mysql/mysql_23306.sock</div></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#添加master信息</div><div class="line"></div><div class="line">mysql&gt; CHANGE MASTER TO</div><div class="line"></div><div class="line">MASTER_HOST=&apos;100.73.41.53&apos;,</div><div class="line">MASTER_PORT=23307,</div><div class="line">MASTER_USER=&apos;repl&apos;,</div><div class="line">MASTER_PASSWORD=&apos;slavepass&apos;,</div><div class="line">MASTER_LOG_FILE=&apos;master-bin.000001&apos;,</div><div class="line">MASTER_LOG_POS=629;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#启动slave进程</div><div class="line"></div><div class="line">mysql&gt; start slave;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#查看slave状态</div><div class="line"></div><div class="line">当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是主从复制&quot;&gt;&lt;a href=&quot;#什么是主从复制&quot; class=&quot;headerlink&quot; title=&quot;什么是主从复制&quot;&gt;&lt;/a&gt;什么是主从复制&lt;/h3&gt;&lt;p&gt;将主数据库中的DDL和DML操作通过二进制日志文件传输到从数据库上，然后将这些日志重新执行（重做）；从而使从数据库的数据和主数据库的数据保持一致。&lt;/p&gt;
&lt;h3 id=&quot;主从复制的作用&quot;&gt;&lt;a href=&quot;#主从复制的作用&quot; class=&quot;headerlink&quot; title=&quot;主从复制的作用&quot;&gt;&lt;/a&gt;主从复制的作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主数据库出现问题时，可以切换到从数据库&lt;/li&gt;
&lt;li&gt;可以在数据库层面进行读写分离&lt;/li&gt;
&lt;li&gt;可以在从数据库上进行备份操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;复制过程&quot;&gt;&lt;a href=&quot;#复制过程&quot; class=&quot;headerlink&quot; title=&quot;复制过程&quot;&gt;&lt;/a&gt;复制过程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ocx5m3vc3.bkt.clouddn.com/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Binary log：主数据库的二进制文件&lt;br&gt;Relay log：从服务器的中继日志&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之备份</title>
    <link href="http://yoursite.com/2018/08/11/mysql/MySQL%E4%B9%8B%E5%A4%87%E4%BB%BD/"/>
    <id>http://yoursite.com/2018/08/11/mysql/MySQL之备份/</id>
    <published>2018-08-11T08:11:15.000Z</published>
    <updated>2018-08-19T09:13:30.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备份的类型"><a href="#备份的类型" class="headerlink" title="备份的类型"></a>备份的类型</h2><h3 id="根据是否需要数据库离线"><a href="#根据是否需要数据库离线" class="headerlink" title="根据是否需要数据库离线"></a>根据是否需要数据库离线</h3><p>1、取决于业务的需求，而不是备份工具。<br>2、MyISAM不支持热备，INNODB支持热备，但是需要专门的工具。  </p><ul><li>冷备：需要关闭mysql服务，读写请求均不支持    状态下进行。</li><li>温备：服务在线，但仅支持读请求，不允许写请求。</li><li>热备：备份的同时，业务不受影响。</li></ul><h3 id="根据备份的数据集合的范围"><a href="#根据备份的数据集合的范围" class="headerlink" title="根据备份的数据集合的范围"></a>根据备份的数据集合的范围</h3><ul><li>完全备份：备份全部字符集。</li><li>增量备份：上一次完全备份或增量备份以来改变的数据。</li><li>差异备份：上一次完全备份以来改变的数。</li></ul><h3 id="根据备份数据或文件"><a href="#根据备份数据或文件" class="headerlink" title="根据备份数据或文件"></a>根据备份数据或文件</h3><ul><li>物理备份：直接备份数据文件。</li><li>逻辑备份：备份表中的数据和代码。<a id="more"></a></li></ul><h2 id="常用的备份工具"><a href="#常用的备份工具" class="headerlink" title="常用的备份工具"></a>常用的备份工具</h2><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>mysqldump是逻辑备份，所以使用这种备份方式数据的安全的。跨平台、版本都很容易。  </p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>mysqldump的优势是可以查看或者编辑十分方面，他可以灵活的恢复之前的数据。它也不关心底层的存储引擎，即适用于支持事务的，也适用于不支持事务的的表。  </p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>mysql的缺点是如果数据过大，即使备份步骤需要的时间不算太久，但有可能恢复数据的速度很慢，因为他涉及的SQL语句插入磁盘IO，创建索引等。</p><h3 id="mysqlhotcopy"><a href="#mysqlhotcopy" class="headerlink" title="mysqlhotcopy"></a>mysqlhotcopy</h3><p>mysqlhotcopy使用lock tables、flush tables、cp和scp来快速备份数据库。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>它是备份数据库或单个表最快的途径，完全属于物理备份。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>只能用于备份MyIsam和archive存储引擎；并且是一个服务器命令，只能运行在数据库目录所在的机器上。使用mysqlhotcopy命令之前需要安装相应的软件依赖包。</p><h3 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h3><p>Percona XtraBackup是一款基于MySQL的物理热备份的开源实用程序。xtrabackup基于innodb的crash-recovery（实例恢复）功能，先copy innodb的物理文件（这个时候数据的一致性是无法满足的），然后进行基于redo log进行恢复，达到数据的一致性。</p><h3 id="mysqlbackup"><a href="#mysqlbackup" class="headerlink" title="mysqlbackup"></a>mysqlbackup</h3><p>首先检测并应用全备事务日志文件，然后基于全备去应用增量的log。这个时候如果有多次增量备份也可以（基于LSN点向后应用）。所有的的应用完成之后就是一个可以直接cp的数据库了。</p><h2 id="备份和恢复的实现"><a href="#备份和恢复的实现" class="headerlink" title="备份和恢复的实现"></a>备份和恢复的实现</h2><ol><li>使用select into outfile实现数据的备份和还原。<br>1.1 把需要备份的数据备份出来<br>select * from test into outfile ‘/tmp/out.txt’;<br>1.2 导入<br>load data infile ‘/tmp/out.txt’ into table XXX;</li><li>利用mysqldump工具对数据进行备份和还原<br>mysqldump常用来做温备，所以需要对想备份的数据施加读锁。<br>2.1 施加读锁的方式：<br>2.1.1 直接在备份时添加选项<br>–lock-all-tables：对要备份的数据库的所有表施加读锁。<br>–lock-table：对单表施加读锁。<br>2.1.2 在服务端书写命令<br>mysql&gt;flush tables with read lock;施加锁，表示把内存上的表统统同步到磁盘上去后施加读锁。<br>mysql&gt;flush tables with read unlock;释放锁。<br>2.2 备份策略：完全备份+增量备份+二进制文件。</li></ol><ul><li>先给数据库做全量备份</li><li>回到mysql服务器更新数据</li><li>做增量备份</li><li>到处二进制文件</li><li>让mysql离线</li></ul><ol><li>利用lvm快照实现几乎热备的数据备份和恢复</li><li>基于Xtrabackup做备份恢复<br>优势：</li></ol><ul><li>快速可靠的进行完全备份</li><li>在备份过程中会影响事务</li><li>支持数据流、网络传输、压缩，所以它可以有效的节约磁盘资源和网络带宽。</li><li>可以自动备份校验数据的可用性。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;备份的类型&quot;&gt;&lt;a href=&quot;#备份的类型&quot; class=&quot;headerlink&quot; title=&quot;备份的类型&quot;&gt;&lt;/a&gt;备份的类型&lt;/h2&gt;&lt;h3 id=&quot;根据是否需要数据库离线&quot;&gt;&lt;a href=&quot;#根据是否需要数据库离线&quot; class=&quot;headerlink&quot; title=&quot;根据是否需要数据库离线&quot;&gt;&lt;/a&gt;根据是否需要数据库离线&lt;/h3&gt;&lt;p&gt;1、取决于业务的需求，而不是备份工具。&lt;br&gt;2、MyISAM不支持热备，INNODB支持热备，但是需要专门的工具。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冷备：需要关闭mysql服务，读写请求均不支持    状态下进行。&lt;/li&gt;
&lt;li&gt;温备：服务在线，但仅支持读请求，不允许写请求。&lt;/li&gt;
&lt;li&gt;热备：备份的同时，业务不受影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;根据备份的数据集合的范围&quot;&gt;&lt;a href=&quot;#根据备份的数据集合的范围&quot; class=&quot;headerlink&quot; title=&quot;根据备份的数据集合的范围&quot;&gt;&lt;/a&gt;根据备份的数据集合的范围&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;完全备份：备份全部字符集。&lt;/li&gt;
&lt;li&gt;增量备份：上一次完全备份或增量备份以来改变的数据。&lt;/li&gt;
&lt;li&gt;差异备份：上一次完全备份以来改变的数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;根据备份数据或文件&quot;&gt;&lt;a href=&quot;#根据备份数据或文件&quot; class=&quot;headerlink&quot; title=&quot;根据备份数据或文件&quot;&gt;&lt;/a&gt;根据备份数据或文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;物理备份：直接备份数据文件。&lt;/li&gt;
&lt;li&gt;逻辑备份：备份表中的数据和代码。
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之权限管理</title>
    <link href="http://yoursite.com/2018/08/11/mysql/Mysql%E4%B9%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/11/mysql/Mysql之权限管理/</id>
    <published>2018-08-11T07:11:15.000Z</published>
    <updated>2018-08-16T02:48:27.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、MySQL权限简介"><a href="#一、MySQL权限简介" class="headerlink" title="一、MySQL权限简介"></a>一、MySQL权限简介</h2><p>关于mysql的权限简单的理解就是mysql允许你做你权利以内的事情，不可以越界。</p><h3 id="mysql权限控制的实现"><a href="#mysql权限控制的实现" class="headerlink" title="mysql权限控制的实现"></a>mysql权限控制的实现</h3><p>第一阶段：服务器首先会检查你是否允许连接。因为创建用户的时候会加上主机限制，可以限制成本地、IP、网段、任何地方等。只允许你从配置的指定地方登陆。<br>第二阶段：Mysql会检查你发出的每个请求，看你是否有足够的权限实施它。</p><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">权限级别</th><th style="text-align:center">权限说明</th></tr></thead><tbody><tr><td style="text-align:center">CREATE</td><td style="text-align:center">数据库、表或索引</td><td style="text-align:center">创建</td></tr><tr><td style="text-align:center">DROP</td><td style="text-align:center">数据库或表</td><td style="text-align:center">删除</td></tr><tr><td style="text-align:center">GRANT OPTION</td><td style="text-align:center">数据库、表或保存的程序</td><td style="text-align:center">赋予权限</td></tr><tr><td style="text-align:center">REFERENCES</td><td style="text-align:center">数据库或表</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ALTER</td><td style="text-align:center">表</td><td style="text-align:center">修改表</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">表</td><td style="text-align:center">删除数据</td></tr><tr><td style="text-align:center">INDEX</td><td style="text-align:center">表</td><td style="text-align:center">索引权限</td></tr></tbody></table><a id="more"></a><h2 id="二、MySQL权限实战"><a href="#二、MySQL权限实战" class="headerlink" title="二、MySQL权限实战"></a>二、MySQL权限实战</h2><ol><li>GRANT命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; grant all privileges on *.* to jack@&apos;localhost&apos; identified by &quot;jack&quot; with grant option;</div><div class="line">Query OK, 0 rows affected (0.01 sec)</div></pre></td></tr></table></figure></li></ol><ul><li>grant:授予权限操作。</li><li>all:具体权限。(all代表所有权限，还可以为select、update、delete等单项权限选择)</li><li>on <em>.</em>:权限操作的数据库和表。(第一个<em>代表数据库，第二个</em>代表具体的表。<em>.</em>代表所有的库和表，可以指定具体库和表）</li><li>to user@ip:被授予权限的用户和ip。</li><li>identified by “passwd”:被授予用户的密码。</li><li>with grant option:是否拥有授予其他用户权限的权限。</li></ul><ol><li>刷新权限：flush privileges;</li><li><p>查看权限：show grants;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">查看当前用户的权限：</div><div class="line">mysql&gt; show grants;</div><div class="line">+---------------------------------------------------------------------+</div><div class="line">| Grants for root@localhost                                           |</div><div class="line">+---------------------------------------------------------------------+</div><div class="line">| GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION |</div><div class="line">| GRANT PROXY ON &apos;&apos;@&apos;&apos; TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION        |</div><div class="line">+---------------------------------------------------------------------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"></div><div class="line">查看某个用户的权限：</div><div class="line">mysql&gt; show grants for &apos;jack&apos;@&apos;%&apos;;</div><div class="line">+-----------------------------------------------------------------------------------------------------+</div><div class="line">| Grants for jack@%                                                                                   |</div><div class="line">+-----------------------------------------------------------------------------------------------------+</div><div class="line">| GRANT USAGE ON *.* TO &apos;jack&apos;@&apos;%&apos; IDENTIFIED BY PASSWORD &apos;*9BCDC990E611B8D852EFAF1E3919AB6AC8C8A9F0&apos; |</div><div class="line">+-----------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>回收权限：revoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; revoke delete on *.* from &apos;jack&apos;@&apos;localhost&apos;;</div><div class="line">Query OK, 0 rows affected (0.01 sec)</div></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; drop user &apos;jack&apos;@&apos;localhost&apos;;</div><div class="line">Query OK, 0 rows affected (0.01 sec)</div></pre></td></tr></table></figure></li><li><p>对用户重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; rename user &apos;jack&apos;@&apos;%&apos; to &apos;jim&apos;@&apos;%&apos;;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>修改密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">1、用set password命令</div><div class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">2、用mysqladmin</div><div class="line">[root@rhel5 ~]# mysqladmin -uroot -p123456 password 1234abcd</div><div class="line">备注：</div><div class="line">格式：mysqladmin -u用户名 -p旧密码 password 新密码</div><div class="line">3、用update直接编辑user表</div><div class="line">mysql&gt; use mysql</div><div class="line">Reading table information for completion of table and column names</div><div class="line">You can turn off this feature to get a quicker startup with -A</div><div class="line"></div><div class="line">Database changed</div><div class="line">mysql&gt; update user set PASSWORD = PASSWORD(&apos;1234abcd&apos;) where user = &apos;root&apos;;</div><div class="line">Query OK, 1 row affected (0.01 sec)</div><div class="line">Rows matched: 1  Changed: 1  Warnings: 0</div><div class="line"></div><div class="line">mysql&gt; flush privileges;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">4、在丢失root密码的时候：</div><div class="line">[root@rhel5 ~]# mysqld_safe --skip-grant-tables &amp;</div><div class="line">[1] 15953</div><div class="line">[root@rhel5 ~]# 130911 09:35:33 mysqld_safe Logging to &apos;/mysql/mysql5.5/data/rhel5.4.err&apos;.</div><div class="line">130911 09:35:33 mysqld_safe Starting mysqld daemon with databases from /mysql/mysql5.5/data</div></pre></td></tr></table></figure></li></ol><h2 id="三、MySQL权限经验原则"><a href="#三、MySQL权限经验原则" class="headerlink" title="三、MySQL权限经验原则"></a>三、MySQL权限经验原则</h2><ul><li>只授予能满足需要的最小权限。</li><li>创建用户时限制用户的登录主机，一般是限制成指定IP或内网IP段。</li><li>初始化数据库时删除没有密码的用户。</li><li>为每个用户设置满足密码复杂度的密码。</li><li>定期清理不需要的用户，回收权限或者删除用户。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、MySQL权限简介&quot;&gt;&lt;a href=&quot;#一、MySQL权限简介&quot; class=&quot;headerlink&quot; title=&quot;一、MySQL权限简介&quot;&gt;&lt;/a&gt;一、MySQL权限简介&lt;/h2&gt;&lt;p&gt;关于mysql的权限简单的理解就是mysql允许你做你权利以内的事情，不可以越界。&lt;/p&gt;
&lt;h3 id=&quot;mysql权限控制的实现&quot;&gt;&lt;a href=&quot;#mysql权限控制的实现&quot; class=&quot;headerlink&quot; title=&quot;mysql权限控制的实现&quot;&gt;&lt;/a&gt;mysql权限控制的实现&lt;/h3&gt;&lt;p&gt;第一阶段：服务器首先会检查你是否允许连接。因为创建用户的时候会加上主机限制，可以限制成本地、IP、网段、任何地方等。只允许你从配置的指定地方登陆。&lt;br&gt;第二阶段：Mysql会检查你发出的每个请求，看你是否有足够的权限实施它。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;权限&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;权限级别&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;权限说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;CREATE&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据库、表或索引&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DROP&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据库或表&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;GRANT OPTION&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据库、表或保存的程序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;赋予权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;REFERENCES&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据库或表&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ALTER&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;表&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;修改表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DELETE&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;表&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;删除数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;INDEX&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;表&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;索引权限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>information_schema</title>
    <link href="http://yoursite.com/2018/08/11/mysql/information_schema/"/>
    <id>http://yoursite.com/2018/08/11/mysql/information_schema/</id>
    <published>2018-08-11T04:11:15.000Z</published>
    <updated>2018-08-16T02:20:18.367Z</updated>
    
    <content type="html"><![CDATA[<p>information_schema数据库是mysql系统自带的数据库，它提供了数据库元数据的访问方式。可以说information_schema就是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了解的信息，比如字符集、权限相关、数据库实体对象信息、外键等。<br><a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">mysql&gt;</span> show tables;</div><div class="line">+---------------------------------------+</div><div class="line">| Tables_in_information_schema          |</div><div class="line">+---------------------------------------+</div><div class="line">| CHARACTER_SETS                        |</div><div class="line">| COLLATIONS                            |</div><div class="line">| COLLATION_CHARACTER_SET_APPLICABILITY |</div><div class="line">| COLUMNS                               |</div><div class="line">| COLUMN_PRIVILEGES                     |</div><div class="line">| ENGINES                               |</div><div class="line">| EVENTS                                |</div><div class="line">| FILES                                 |</div><div class="line">| GLOBAL_STATUS                         |</div><div class="line">| GLOBAL_VARIABLES                      |</div><div class="line">| KEY_COLUMN_USAGE                      |</div><div class="line">| OPTIMIZER_TRACE                       |</div><div class="line">| PARAMETERS                            |</div><div class="line">| PARTITIONS                            |</div><div class="line">| PLUGINS                               |</div><div class="line">| PROCESSLIST                           |</div><div class="line">| PROFILING                             |</div><div class="line">| REFERENTIAL_CONSTRAINTS               |</div><div class="line">| ROUTINES                              |</div><div class="line">| SCHEMATA                              |</div><div class="line">| SCHEMA_PRIVILEGES                     |</div><div class="line">| SESSION_STATUS                        |</div><div class="line">| SESSION_VARIABLES                     |</div><div class="line">| STATISTICS                            |</div><div class="line">| TABLES                                |</div><div class="line">| TABLESPACES                           |</div><div class="line">| TABLE_CONSTRAINTS                     |</div><div class="line">| TABLE_PRIVILEGES                      |</div><div class="line">| TRIGGERS                              |</div><div class="line">| USER_PRIVILEGES                       |</div><div class="line">| VIEWS                                 |</div><div class="line">| INNODB_LOCKS                          |</div><div class="line">| INNODB_TRX                            |</div><div class="line">| INNODB_SYS_DATAFILES                  |</div><div class="line">| INNODB_LOCK_WAITS                     |</div><div class="line">| INNODB_SYS_TABLESTATS                 |</div><div class="line">| INNODB_CMP                            |</div><div class="line">| INNODB_METRICS                        |</div><div class="line">| INNODB_CMP_RESET                      |</div><div class="line">| INNODB_CMP_PER_INDEX                  |</div><div class="line">| INNODB_CMPMEM_RESET                   |</div><div class="line">| INNODB_FT_DELETED                     |</div><div class="line">| INNODB_BUFFER_PAGE_LRU                |</div><div class="line">| INNODB_SYS_FOREIGN                    |</div><div class="line">| INNODB_SYS_COLUMNS                    |</div><div class="line">| INNODB_SYS_INDEXES                    |</div><div class="line">| INNODB_FT_DEFAULT_STOPWORD            |</div><div class="line">| INNODB_SYS_FIELDS                     |</div><div class="line">| INNODB_CMP_PER_INDEX_RESET            |</div><div class="line">| INNODB_BUFFER_PAGE                    |</div><div class="line">| INNODB_CMPMEM                         |</div><div class="line">| INNODB_FT_INDEX_TABLE                 |</div><div class="line">| INNODB_FT_BEING_DELETED               |</div><div class="line">| INNODB_SYS_TABLESPACES                |</div><div class="line">| INNODB_FT_INDEX_CACHE                 |</div><div class="line">| INNODB_SYS_FOREIGN_COLS               |</div><div class="line">| INNODB_SYS_TABLES                     |</div><div class="line">| INNODB_BUFFER_POOL_STATS              |</div><div class="line">| INNODB_FT_CONFIG                      |</div><div class="line">+---------------------------------------+</div><div class="line">59 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p><h3 id="SCHEMATA"><a href="#SCHEMATA" class="headerlink" title="SCHEMATA"></a>SCHEMATA</h3><p>schemata提供了关于数据库的信息。show databases的结果就取自此表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc schemata;</div><div class="line">+----------------------------+--------------+------+-----+---------+-------+</div><div class="line">| Field                      | Type         | Null | Key | Default | Extra |</div><div class="line">+----------------------------+--------------+------+-----+---------+-------+</div><div class="line">| CATALOG_NAME               | varchar(512) | NO   |     |         |       |</div><div class="line">| SCHEMA_NAME                | varchar(64)  | NO   |     |         |    数据库名</div><div class="line">| DEFAULT_CHARACTER_SET_NAME | varchar(32)  | NO   |     |         |    默认表字符集编码</div><div class="line">| DEFAULT_COLLATION_NAME     | varchar(32)  | NO   |     |         |    默认字符集编码排序规则</div><div class="line">| SQL_PATH                   | varchar(512) | YES  |     | NULL    |       |</div><div class="line">+----------------------------+--------------+------+-----+---------+-------+</div><div class="line">5 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from schemata;</div><div class="line">+--------------+--------------------+----------------------------+------------------------+----------+</div><div class="line">| CATALOG_NAME | SCHEMA_NAME        | DEFAULT_CHARACTER_SET_NAME | DEFAULT_COLLATION_NAME | SQL_PATH |</div><div class="line">+--------------+--------------------+----------------------------+------------------------+----------+</div><div class="line">| def          | information_schema | utf8                       | utf8_general_ci        | NULL     |</div><div class="line">| def          | hoo                | utf8                       | utf8_general_ci        | NULL     |</div><div class="line">| def          | mysql              | utf8                       | utf8_general_ci        | NULL     |</div><div class="line">| def          | performance_schema | utf8                       | utf8_general_ci        | NULL     |</div><div class="line">| def          | test               | latin1                     | latin1_swedish_ci      | NULL     |</div><div class="line">+--------------+--------------------+----------------------------+------------------------+----------+</div><div class="line">5 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p><h3 id="TABLES"><a href="#TABLES" class="headerlink" title="TABLES"></a>TABLES</h3><p>存储了数据表的元数据信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc tables;</div><div class="line">+-----------------+---------------------+------+-----+---------+-------+</div><div class="line">| Field           | Type                | Null | Key | Default | Extra |</div><div class="line">+-----------------+---------------------+------+-----+---------+-------+</div><div class="line">| TABLE_CATALOG   | varchar(512)        | NO   |     |         |       |</div><div class="line">| TABLE_SCHEMA    | varchar(64)         | NO   |     |         |     数据库名  </div><div class="line">| TABLE_NAME      | varchar(64)         | NO   |     |         |     数据表名  |</div><div class="line">| TABLE_TYPE      | varchar(64)         | NO   |     |         |       |</div><div class="line">| ENGINE          | varchar(64)         | YES  |     | NULL    |     存储引擎  |</div><div class="line">| VERSION         | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| ROW_FORMAT      | varchar(10)         | YES  |     | NULL    |     是否被压缩过  |</div><div class="line">| TABLE_ROWS      | bigint(21) unsigned | YES  |     | NULL    |     表的粗略行估计  |</div><div class="line">| AVG_ROW_LENGTH  | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| DATA_LENGTH     | bigint(21) unsigned | YES  |     | NULL    |     表的大小  |</div><div class="line">| MAX_DATA_LENGTH | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| INDEX_LENGTH    | bigint(21) unsigned | YES  |     | NULL    |     索引的大小  |</div><div class="line">| DATA_FREE       | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| AUTO_INCREMENT  | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| CREATE_TIME     | datetime            | YES  |     | NULL    |       |</div><div class="line">| UPDATE_TIME     | datetime            | YES  |     | NULL    |       |</div><div class="line">| CHECK_TIME      | datetime            | YES  |     | NULL    |       |</div><div class="line">| TABLE_COLLATION | varchar(32)         | YES  |     | NULL    |       |</div><div class="line">| CHECKSUM        | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| CREATE_OPTIONS  | varchar(255)        | YES  |     | NULL    |       |</div><div class="line">| TABLE_COMMENT   | varchar(2048)       | NO   |     |         |       |</div><div class="line">+-----------------+---------------------+------+-----+---------+-------+</div><div class="line">21 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p><h3 id="ENGINES"><a href="#ENGINES" class="headerlink" title="ENGINES"></a>ENGINES</h3><p>引擎表，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc engines;</div><div class="line">+--------------+-------------+------+-----+---------+-------+</div><div class="line">| Field        | Type        | Null | Key | Default | Extra |</div><div class="line">+--------------+-------------+------+-----+---------+-------+</div><div class="line">| ENGINE       | varchar(64) | NO   |     |         |     引擎名  |</div><div class="line">| SUPPORT      | varchar(8)  | NO   |     |         |     是否支持  |</div><div class="line">| COMMENT      | varchar(80) | NO   |     |         |     描述  |</div><div class="line">| TRANSACTIONS | varchar(3)  | YES  |     | NULL    |     是否支持事务  |</div><div class="line">| XA           | varchar(3)  | YES  |     | NULL    |     是否支持分布式事务  |</div><div class="line">| SAVEPOINTS   | varchar(3)  | YES  |     | NULL    |     是否支持事务回滚点  |</div><div class="line">+--------------+-------------+------+-----+---------+-------+</div><div class="line">6 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from engines;</div><div class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</div><div class="line">| ENGINE             | SUPPORT | COMMENT                                                        | TRANSACTIONS | XA   | SAVEPOINTS |</div><div class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</div><div class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</div><div class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</div><div class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</div><div class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</div><div class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</div><div class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</div><div class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</div><div class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</div><div class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</div><div class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</div><div class="line">9 rows in set (0.01 sec)</div></pre></td></tr></table></figure></p><h3 id="COLUMNS"><a href="#COLUMNS" class="headerlink" title="COLUMNS"></a>COLUMNS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc columns;</div><div class="line">+--------------------------+---------------------+------+-----+---------+-------+</div><div class="line">| Field                    | Type                | Null | Key | Default | Extra |</div><div class="line">+--------------------------+---------------------+------+-----+---------+-------+</div><div class="line">| TABLE_CATALOG            | varchar(512)        | NO   |     |         |       |</div><div class="line">| TABLE_SCHEMA             | varchar(64)         | NO   |     |         |    数据库名   |</div><div class="line">| TABLE_NAME               | varchar(64)         | NO   |     |         |    表名   |</div><div class="line">| COLUMN_NAME              | varchar(64)         | NO   |     |         |    列名   |</div><div class="line">| ORDINAL_POSITION         | bigint(21) unsigned | NO   |     | 0       |    创建时排第几   |</div><div class="line">| COLUMN_DEFAULT           | longtext            | YES  |     | NULL    |    默认值   |</div><div class="line">| IS_NULLABLE              | varchar(3)          | NO   |     |         |    是否能为空   |</div><div class="line">| DATA_TYPE                | varchar(64)         | NO   |     |         |    字符数据类型   |</div><div class="line">| CHARACTER_MAXIMUM_LENGTH | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| CHARACTER_OCTET_LENGTH   | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| NUMERIC_PRECISION        | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| NUMERIC_SCALE            | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| DATETIME_PRECISION       | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| CHARACTER_SET_NAME       | varchar(32)         | YES  |     | NULL    |    字符集   |</div><div class="line">| COLLATION_NAME           | varchar(32)         | YES  |     | NULL    |    字符集排序规则   |</div><div class="line">| COLUMN_TYPE              | longtext            | NO   |     | NULL    |    创表时列的类型定义   |</div><div class="line">| COLUMN_KEY               | varchar(3)          | NO   |     |         |       |</div><div class="line">| EXTRA                    | varchar(30)         | NO   |     |         |       |</div><div class="line">| PRIVILEGES               | varchar(80)         | NO   |     |         |    权限   |</div><div class="line">| COLUMN_COMMENT           | varchar(1024)       | NO   |     |         |       |</div><div class="line">+--------------------------+---------------------+------+-----+---------+-------+</div><div class="line">20 rows in set (0.00 sec)</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; select * from columns where table_schema = &apos;hoo&apos; and table_name =&apos;hoo_test&apos;\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">           TABLE_CATALOG: def</div><div class="line">            TABLE_SCHEMA: hoo</div><div class="line">              TABLE_NAME: hoo_test</div><div class="line">             COLUMN_NAME: name</div><div class="line">        ORDINAL_POSITION: 1</div><div class="line">          COLUMN_DEFAULT: NULL</div><div class="line">             IS_NULLABLE: YES</div><div class="line">               DATA_TYPE: varchar</div><div class="line">CHARACTER_MAXIMUM_LENGTH: 10</div><div class="line">  CHARACTER_OCTET_LENGTH: 30</div><div class="line">       NUMERIC_PRECISION: NULL</div><div class="line">           NUMERIC_SCALE: NULL</div><div class="line">      DATETIME_PRECISION: NULL</div><div class="line">      CHARACTER_SET_NAME: utf8</div><div class="line">          COLLATION_NAME: utf8_general_ci</div><div class="line">             COLUMN_TYPE: varchar(10)</div><div class="line">              COLUMN_KEY: </div><div class="line">                   EXTRA: </div><div class="line">              PRIVILEGES: select,insert,update,references</div><div class="line">          COLUMN_COMMENT: </div><div class="line">*************************** 2. row ***************************</div></pre></td></tr></table></figure><h3 id="KEY-COLUMN-USAGE"><a href="#KEY-COLUMN-USAGE" class="headerlink" title="KEY_COLUMN_USAGE"></a>KEY_COLUMN_USAGE</h3><p>索引列上的约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc key_column_usage;</div><div class="line">+-------------------------------+--------------+------+-----+---------+-------+</div><div class="line">| Field                         | Type         | Null | Key | Default | Extra |</div><div class="line">+-------------------------------+--------------+------+-----+---------+-------+</div><div class="line">| CONSTRAINT_CATALOG            | varchar(512) | NO   |     |         |       |</div><div class="line">| CONSTRAINT_SCHEMA             | varchar(64)  | NO   |     |         |       |</div><div class="line">| CONSTRAINT_NAME               | varchar(64)  | NO   |     |         |       |</div><div class="line">| TABLE_CATALOG                 | varchar(512) | NO   |     |         |       |</div><div class="line">| TABLE_SCHEMA                  | varchar(64)  | NO   |     |         |       |</div><div class="line">| TABLE_NAME                    | varchar(64)  | NO   |     |         |       |</div><div class="line">| COLUMN_NAME                   | varchar(64)  | NO   |     |         |       |</div><div class="line">| ORDINAL_POSITION              | bigint(10)   | NO   |     | 0       |       |</div><div class="line">| POSITION_IN_UNIQUE_CONSTRAINT | bigint(10)   | YES  |     | NULL    |       |</div><div class="line">| REFERENCED_TABLE_SCHEMA       | varchar(64)  | YES  |     | NULL    |       |</div><div class="line">| REFERENCED_TABLE_NAME         | varchar(64)  | YES  |     | NULL    |       |</div><div class="line">| REFERENCED_COLUMN_NAME        | varchar(64)  | YES  |     | NULL    |       |</div><div class="line">+-------------------------------+--------------+------+-----+---------+-------+</div><div class="line">12 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from key_column_usage where table_name = &apos;test_pri&apos;\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">           CONSTRAINT_CATALOG: def</div><div class="line">            CONSTRAINT_SCHEMA: hoo</div><div class="line">              CONSTRAINT_NAME: PRIMARY</div><div class="line">                TABLE_CATALOG: def</div><div class="line">                 TABLE_SCHEMA: hoo</div><div class="line">                   TABLE_NAME: test_pri</div><div class="line">                  COLUMN_NAME: id</div><div class="line">             ORDINAL_POSITION: 1</div><div class="line">POSITION_IN_UNIQUE_CONSTRAINT: NULL</div><div class="line">      REFERENCED_TABLE_SCHEMA: NULL</div><div class="line">        REFERENCED_TABLE_NAME: NULL</div><div class="line">       REFERENCED_COLUMN_NAME: NULL</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p><h3 id="PROCESSLIST"><a href="#PROCESSLIST" class="headerlink" title="PROCESSLIST"></a>PROCESSLIST</h3><p>processlist显示有哪些线程在运行，可以帮助识别出有问题的查询语句。<br>show processlist 和 select * from information_schema.processlist 效果一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc PROCESSLIST;</div><div class="line">+---------+---------------------+------+-----+---------+-------+</div><div class="line">| Field   | Type                | Null | Key | Default | Extra |</div><div class="line">+---------+---------------------+------+-----+---------+-------+</div><div class="line">| ID      | bigint(21) unsigned | NO   |     | 0       |    会话ID   |</div><div class="line">| USER    | varchar(16)         | NO   |     |         |    运行用户   |</div><div class="line">| HOST    | varchar(64)         | NO   |     |         |    运行主机和端口   |</div><div class="line">| DB      | varchar(64)         | YES  |     | NULL    |    操作的数据库   |</div><div class="line">| COMMAND | varchar(16)         | NO   |     |         |    显示当前线程运行的命令类型   |</div><div class="line">| TIME    | int(7)              | NO   |     | 0       |    此状态持续时间   |</div><div class="line">| STATE   | varchar(64)         | YES  |     | NULL    |    显示使用当前连接的SQL语句   |</div><div class="line">| INFO    | longtext            | YES  |     | NULL    |    显示SQL语句   |</div><div class="line">+---------+---------------------+------+-----+---------+-------+</div><div class="line">8 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from processlist;</div><div class="line">+----+------+-----------+--------------------+---------+------+-----------+---------------------------+</div><div class="line">| ID | USER | HOST      | DB                 | COMMAND | TIME | STATE     | INFO                      |</div><div class="line">+----+------+-----------+--------------------+---------+------+-----------+---------------------------+</div><div class="line">| 25 | root | localhost | information_schema | Query   |    0 | executing | select * from processlist |</div><div class="line">+----+------+-----------+--------------------+---------+------+-----------+---------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p><p>state列值：</p><ul><li>checking table：正在检查数据表。</li><li>closing tables：正在将表中修改的数据刷新到磁盘，同时关闭已用完的表。</li><li>connect out：复制从服务器正在连接主服务器。</li><li>copying to tmp table on disk：正在将临时表从内存存储转为磁盘存储以节省内存。</li><li>creating tmp table：正在创建临时表以存放部分查询结果。</li><li>deleting from main table：服务器正在执行多表删除的第一部分，刚删除第一个表。</li><li>deleting from reference tables：服务器正在执行多表删除的第二部分，正在删除其他表的记录。</li><li>flushing tables：正在执行flush tables，等待其他线程关闭数据表。</li><li>killed：发送了一个kill请求给某线程。</li><li>locked：被其他查询锁住了。</li><li>sending data：正在处理select查询的记录，同时正在把结果发送给客户端。</li><li>sorting for group：正在为group by做排序。</li><li>sorting for order：正在为order by做排序。</li><li>opening table：正在尝试打开一个表。</li><li>removing duplicates：正在执行一个select distinct方式的查询。</li><li>sleeping：正在等待客户端发送新请求</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;information_schema数据库是mysql系统自带的数据库，它提供了数据库元数据的访问方式。可以说information_schema就是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了解的信息，比如字符集、权限相关、数据库实体对象信息、外键等。&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务</title>
    <link href="http://yoursite.com/2018/08/11/mysql/mysql%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/08/11/mysql/mysql事务/</id>
    <published>2018-08-10T16:11:15.000Z</published>
    <updated>2018-08-15T08:47:10.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、事务的基本要素（ACID）"><a href="#一、事务的基本要素（ACID）" class="headerlink" title="一、事务的基本要素（ACID）"></a>一、事务的基本要素（ACID）</h2><ul><li>原子性（Atomicity):事务开始后所有的操作，要么全部做完，要么全部不做，不可能在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。</li><li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。</li><li>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同事务之间彼此没有任何干扰。</li><li>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。<a id="more"></a><h2 id="二、事务的并发问题"><a href="#二、事务的并发问题" class="headerlink" title="二、事务的并发问题"></a>二、事务的并发问题</h2></li><li>脏读：事务A读取了事务B未提交的数据。</li><li>不可重复读：事务A多次读取同一数据，事务B在事务A多次读取过程中，对数据进行了更新，导致事务A读取同一事务时结果不一致。</li><li>幻读：事务A在更新过程中，事务B对同数据库进行了操作并提交，事务A提交不成功。</li></ul><h2 id="三、Mysql事务隔离级别"><a href="#三、Mysql事务隔离级别" class="headerlink" title="三、Mysql事务隔离级别"></a>三、Mysql事务隔离级别</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>事务1对A进行操作还没提交，事务2就对A进行了读取，之后事务1对A进行再次操作或回滚，导致事务A读取的数据不对。（脏读）<br><img src="http://ocx5m3vc3.bkt.clouddn.com/%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4.png" alt="">  </p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>事务2多次读取同一数据，事务1在事务2读取过程中对数据进行了修改，导致事务1读取的数据不一致。（解决了脏读，不可重复读）<br><img src="http://ocx5m3vc3.bkt.clouddn.com/%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A42.png" alt=""><br>读已提交是大多数数据库的默认隔离级别。</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>事务与事务之间相互隔离，数据之间不相互影响。整个事务过程中多次执行同一个查询，查询得到的结果是不一样的，幻读针对的多笔记录。（解决了不可重复读，导致了幻读）</p><p>可重复读是mysql的默认隔离级别。 </p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>在事务进行操作时对表进行加锁操作，拒绝其他事务进行操作。保证了数据的安全性，但是效率大大降低。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、事务的基本要素（ACID）&quot;&gt;&lt;a href=&quot;#一、事务的基本要素（ACID）&quot; class=&quot;headerlink&quot; title=&quot;一、事务的基本要素（ACID）&quot;&gt;&lt;/a&gt;一、事务的基本要素（ACID）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原子性（Atomicity):事务开始后所有的操作，要么全部做完，要么全部不做，不可能在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同事务之间彼此没有任何干扰。&lt;/li&gt;
&lt;li&gt;持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>python获取本机IP</title>
    <link href="http://yoursite.com/2018/07/21/python/%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAIP/"/>
    <id>http://yoursite.com/2018/07/21/python/获取本机IP/</id>
    <published>2018-07-21T08:28:05.000Z</published>
    <updated>2018-07-21T15:27:47.365Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_ip</span><span class="params">()</span>:</span></div><div class="line">  <span class="keyword">try</span>:</div><div class="line">      s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line">      s.connect((<span class="string">'8.8.8.8'</span>, <span class="number">80</span>))</div><div class="line">      ip = s.getsockname()[<span class="number">0</span>]</div><div class="line">  <span class="keyword">finally</span>:</div><div class="line">      s.close()</div><div class="line">  <span class="keyword">return</span> ip</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/d
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现-数据结构篇（6）-压缩列表</title>
    <link href="http://yoursite.com/2018/06/12/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%886%EF%BC%89--%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/12/Redis/Redis设计与实现-数据结构篇（6）--压缩列表/</id>
    <published>2018-06-12T11:41:38.000Z</published>
    <updated>2018-08-11T16:33:20.944Z</updated>
    
    <content type="html"><![CDATA[<p>压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数类型，要么就是长度比较短的字符串，那么Redis会使用压缩列表来做列表键的底层实现。</p><h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序性数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/ziplist.png" alt="">  </p><ul><li>zlbytes：4字节，记录整个压缩列表占用内存的字节数</li><li>zltail：4字节，记录压缩列表尾部节点距离起始地址的偏移量</li><li>zllen：2字节，记录压缩列表包含的节点数量</li><li>entry：不定，列表中的每个节点</li><li>zlend：1字节，特殊值0xFF，标记压缩列表的结束</li></ul><a id="more"></a><h3 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h3><p>每个压缩列表节点可以保存一个字节数组或者一个整数值。其中，字节数组可以是以下的类型：  </p><ul><li>长度小于等于63字节的字节数组</li><li>长度小于等于16381字节的字节数组</li><li>长度小于等于4294967295字节的字节数组</li></ul><p>而整数值则可以是以下类型：  </p><ul><li>4位长，介于0~12之间的无符号整数</li><li>1字节长的有符号整数</li><li>3字节长的有符号整数</li><li>int16_t类型整数</li><li>int32_t类型整数</li><li>int64_t类型整数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct zlentry &#123;</div><div class="line">    unsigned int prevrawlensize, prevrawlen;</div><div class="line">    unsigned int lensize, len;</div><div class="line">    unsigned int headersize;</div><div class="line">    unsigned char encoding;</div><div class="line">    unsigned char *p;</div><div class="line">&#125; zlentry;</div></pre></td></tr></table></figure><ul><li>prevrawlen：前置节点的长度</li><li>prevrawlensize：编码 prevrawlen 所需的字节大小</li><li>len：当前节点的长度</li><li>lensize：编码 len 所需的字节大小</li><li>headersize：当前节点 header 的大小，等于 prevrawlensize + lensize</li><li>encoding：当前节点值所使用的编码类型</li><li>p：指向当前节点的指针</li></ul><p>当加入新节点后，后一个节点需要保存新节点的长度信息，当后一个节点的长度字段在内存中占有的长度不足以表示该长度信息时，就需要对后一个节点进行更新，并扩展其内存。因此这个步骤可能会导致连锁更新。而删除操作也类似<br><img src="http://ocx5m3vc3.bkt.clouddn.com/ziplist%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数类型，要么就是长度比较短的字符串，那么Redis会使用压缩列表来做列表键的底层实现。&lt;/p&gt;
&lt;h3 id=&quot;压缩列表的构成&quot;&gt;&lt;a href=&quot;#压缩列表的构成&quot; class=&quot;headerlink&quot; title=&quot;压缩列表的构成&quot;&gt;&lt;/a&gt;压缩列表的构成&lt;/h3&gt;&lt;p&gt;压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序性数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。&lt;br&gt;&lt;img src=&quot;http://ocx5m3vc3.bkt.clouddn.com/ziplist.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zlbytes：4字节，记录整个压缩列表占用内存的字节数&lt;/li&gt;
&lt;li&gt;zltail：4字节，记录压缩列表尾部节点距离起始地址的偏移量&lt;/li&gt;
&lt;li&gt;zllen：2字节，记录压缩列表包含的节点数量&lt;/li&gt;
&lt;li&gt;entry：不定，列表中的每个节点&lt;/li&gt;
&lt;li&gt;zlend：1字节，特殊值0xFF，标记压缩列表的结束&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现-数据结构篇（5）-整数集合</title>
    <link href="http://yoursite.com/2018/06/11/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%885%EF%BC%89-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2018/06/11/Redis/Redis设计与实现-数据结构篇（5）-整数集合/</id>
    <published>2018-06-11T11:41:38.000Z</published>
    <updated>2018-08-10T17:27:19.167Z</updated>
    
    <content type="html"><![CDATA[<p>整数集合是集合键的底层实现之一，当一个集合只傲寒整数值元素，并且这个集合的元素不多时，Redis就会使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef stuct intset&#123;</div><div class="line">//编码方式</div><div class="line">uint32_t encodingl</div><div class="line">//集合包含的元素数量</div><div class="line">uint32_t length;</div><div class="line">//保存元素的数组</div><div class="line">int8_t contents[];</div><div class="line">&#125;intset;</div></pre></td></tr></table></figure></p><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数据的一个数组项，每个项在数组中按值的大小从小到大有序的排列，并且数组中不包含重复项。</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面去。</p><h4 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h4><ul><li>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组中的元素都转换成与新元素相同的类型，并将元素放在对应的位置上，在放置过程中需要维持底层数组的有序性质不变。</li><li>将新元素加到底层数组中。<h4 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h4></li><li>提高灵活性</li><li>节约内存</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整数集合是集合键的底层实现之一，当一个集合只傲寒整数值元素，并且这个集合的元素不多时，Redis就会使用整数集合作为集合键的底层实现。&lt;/p&gt;
&lt;h3 id=&quot;整数集合的实现&quot;&gt;&lt;a href=&quot;#整数集合的实现&quot; class=&quot;headerlink&quot; title=&quot;整数集
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现-数据结构篇（4）--跳跃表</title>
    <link href="http://yoursite.com/2018/06/10/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%884%EF%BC%89-%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/10/Redis/Redis设计与实现-数据结构篇（4）-跳跃链表/</id>
    <published>2018-06-10T11:41:38.000Z</published>
    <updated>2018-08-10T17:13:04.108Z</updated>
    
    <content type="html"><![CDATA[<p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><p>Redis跳跃表由zskiplistNode和zskiplist两个结构定义。其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/skiplist.png" alt=""><br><a id="more"></a><br>位于图片最左边的是zskiplist结构，该结构包含以下属性：</p><ul><li>header：指向跳跃表的表头节点。</li><li>tail：指向跳跃表的表尾节点。</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li>length：记录跳跃表的长度，即是跳跃表目前包含节点的数量（表头节点不计算在内）。<br>位于图片右侧的是zskiplistNode结构，该结构包含以下属性：</li><li>层（level）：每次创建一个新的跳跃表节点的时候，程序都根据幂次定律随机生成一个介于1~32之间的值作为level数组的大小，这就是层的高度。</li><li>前进指针（forward):每层都有一个指向表尾方向的前进指针。</li><li>后退指针（backward）：用于从表尾向表头方向访问节点。</li><li>跨度（span）：用于记录两个节点之间的距离。</li><li>分值（score）</li><li>成员对象（obj）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">typedef struct zskiplistNode&#123;</div><div class="line">//后退指针</div><div class="line">struct zskiplistNode *backward;</div><div class="line">//分值</div><div class="line">double score;</div><div class="line">//成员对象</div><div class="line">robj *obj;</div><div class="line">//层</div><div class="line">struct zskiplistLevel&#123;</div><div class="line">//前进指针</div><div class="line">struct zskiplistNode *forward;</div><div class="line">//跨度</div><div class="line">unsigned int span;</div><div class="line">&#125;level[];</div><div class="line">&#125;zskiplistNode；</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。&lt;/p&gt;
&lt;h2 id=&quot;跳跃表的实现&quot;&gt;&lt;a href=&quot;#跳跃表的实现&quot; class=&quot;headerlink&quot; title=&quot;跳跃表的实现&quot;&gt;&lt;/a&gt;跳跃表的实现&lt;/h2&gt;&lt;p&gt;Redis跳跃表由zskiplistNode和zskiplist两个结构定义。其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。&lt;br&gt;&lt;img src=&quot;http://ocx5m3vc3.bkt.clouddn.com/skiplist.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现-数据结构篇（3）--字典</title>
    <link href="http://yoursite.com/2018/06/10/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%883%EF%BC%89-%E5%AD%97%E5%85%B8/"/>
    <id>http://yoursite.com/2018/06/10/Redis/Redis设计与实现-数据结构篇（3）-字典/</id>
    <published>2018-06-10T10:58:15.000Z</published>
    <updated>2018-06-10T12:35:47.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef struct dictht&#123;</div><div class="line">//哈希表数组</div><div class="line">dictEntry **table;</div><div class="line">//哈希表大小</div><div class="line">unsigned long size;</div><div class="line">//哈希表大小掩码，用于计算索引值</div><div class="line">//总是等size-1</div><div class="line">unsigned long sizemask;</div><div class="line">//该哈希表已有节点的数量</div><div class="line">unsigned long used;</div><div class="line">&#125;dictht;</div></pre></td></tr></table></figure><p><img src="http://ocx5m3vc3.bkt.clouddn.com/dictht.png" alt=""><br><a id="more"></a><br>table是一个数组，数组中的每个元素都是一个指向dictEntry结构的指针，每个dictEntry结构保存这一个键值对。</p><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct dictEntry&#123;</div><div class="line">//键</div><div class="line">void *key;</div><div class="line">//值</div><div class="line">union&#123;</div><div class="line">void *val;</div><div class="line">uint64_t u64;</div><div class="line">int64_ts64;</div><div class="line">&#125;v;</div><div class="line">//指向下个哈希表节点，形成链表</div><div class="line">struct dictEntry *next;</div><div class="line">&#125;dictEntry;</div></pre></td></tr></table></figure><p><img src="http://ocx5m3vc3.bkt.clouddn.com/dictEntry.png" alt=""></p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef struct dict&#123;</div><div class="line">//类型特定函数</div><div class="line">dictType *type;</div><div class="line">//私有数据</div><div class="line">void *privdata;</div><div class="line">//哈希表</div><div class="line">dictht ht[2];</div><div class="line">//rehash索引</div><div class="line">//当rehash不在进行时，值为-1</div><div class="line">int trehashidx;</div><div class="line">&#125;dict;</div></pre></td></tr></table></figure><p>ht是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在ht[0]哈希表进行rehash时使用。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/dict.png" alt=""></p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行，哈希表保存的键值对会逐渐增多或者减少，为了让哈希表的负债因子维持在一个合理的范围内，程序需要对哈希表大小进行相应的扩展或者收缩。<br>步骤：<br>1）为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：<br>2）将保存在ht[0]中的所有键值对rehash到ht[1]上面，rehash值的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。<br>3）当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0],将ht[1]设置为ht[0],并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。  </p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>1）为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。<br>2）在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。<br>3）在rehash期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定操作外，还会顺带将ht[0]哈希表再rehashidx索引上的所有键值对rehash到ht[1]，将rehashidx值增加1。<br>4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]，这时将rehashidx设置为-1，表示rehash操作完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字典的实现&quot;&gt;&lt;a href=&quot;#字典的实现&quot; class=&quot;headerlink&quot; title=&quot;字典的实现&quot;&gt;&lt;/a&gt;字典的实现&lt;/h2&gt;&lt;p&gt;Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。&lt;/p&gt;
&lt;h3 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;typedef struct dictht&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	//哈希表数组&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	dictEntry **table;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	//哈希表大小&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	unsigned long size;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	//哈希表大小掩码，用于计算索引值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	//总是等size-1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	unsigned long sizemask;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	//该哈希表已有节点的数量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	unsigned long used;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;dictht;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://ocx5m3vc3.bkt.clouddn.com/dictht.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现-数据结构篇（2）--链表</title>
    <link href="http://yoursite.com/2018/06/09/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%882%EF%BC%89-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/09/Redis/Redis设计与实现-数据结构篇（2）-链表/</id>
    <published>2018-06-09T13:09:46.000Z</published>
    <updated>2018-06-10T12:35:44.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><p>每个链表节点都使用一个listNode结构来表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct listNode&#123;</div><div class="line">//前置节点</div><div class="line">struct listNode *prev;</div><div class="line">//后置节点</div><div class="line">struct listNode *next;</div><div class="line">//节点的值</div><div class="line">void *value;</div><div class="line">&#125;listNode;</div></pre></td></tr></table></figure></p><p>虽然使用多个listNode结构就可以组成链表，但是使用list来持有链表的话，操作起来会更方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef struct list&#123;</div><div class="line">//表头节点</div><div class="line">listNode *head;</div><div class="line">//表尾节点</div><div class="line">listNode *tail;</div><div class="line">//链表所包含的节点数量</div><div class="line">unsigned long len;</div><div class="line">//节点值复制函数</div><div class="line">void *(*dup)(void *ptr);</div><div class="line">//节点值释放函数</div><div class="line">void *(*free)(void *ptr);</div><div class="line">//节点值对比函数</div><div class="line">void *(match)(void *ptr,void *key);</div><div class="line">&#125;list;</div></pre></td></tr></table></figure></p><p><img src="http://ocx5m3vc3.bkt.clouddn.com/list.png" alt=""></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>双端：获取某个节点的前置和后置节点的复杂度都是O(1)</li><li>无环：两端都指向NULL</li><li>获取表头节点和表尾节点的复杂度为O(1)</li><li>O(1)获取链表长度</li><li>链表可以用来保存各种不同类型的值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表和链表节点的实现&quot;&gt;&lt;a href=&quot;#链表和链表节点的实现&quot; class=&quot;headerlink&quot; title=&quot;链表和链表节点的实现&quot;&gt;&lt;/a&gt;链表和链表节点的实现&lt;/h2&gt;&lt;p&gt;每个链表节点都使用一个listNode结构来表示&lt;br&gt;&lt;figure cl
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
</feed>

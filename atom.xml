<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OMG_By</title>
  
  <subtitle>你走与不走，路就在那里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-23T07:17:28.956Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OMG_By</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sql语句练习</title>
    <link href="http://yoursite.com/2018/11/23/mysql/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/11/23/mysql/sql语句练习/</id>
    <published>2018-11-23T06:12:13.000Z</published>
    <updated>2018-11-23T07:17:28.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">--建表</div><div class="line">--学生表</div><div class="line">CREATE TABLE `Student`(</div><div class="line">    `s_id` VARCHAR(20),</div><div class="line">    `s_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">    `s_birth` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">    `s_sex` VARCHAR(10) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">    PRIMARY KEY(`s_id`)</div><div class="line">);</div><div class="line">--课程表</div><div class="line">CREATE TABLE `Course`(</div><div class="line">    `c_id`  VARCHAR(20),</div><div class="line">    `c_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">    `t_id` VARCHAR(20) NOT NULL,</div><div class="line">    PRIMARY KEY(`c_id`)</div><div class="line">);</div><div class="line">--教师表</div><div class="line">CREATE TABLE `Teacher`(</div><div class="line">    `t_id` VARCHAR(20),</div><div class="line">    `t_name` VARCHAR(20) NOT NULL DEFAULT &apos;&apos;,</div><div class="line">    PRIMARY KEY(`t_id`)</div><div class="line">);</div><div class="line">--成绩表</div><div class="line">CREATE TABLE `Score`(</div><div class="line">    `s_id` VARCHAR(20),</div><div class="line">    `c_id`  VARCHAR(20),</div><div class="line">    `s_score` INT(3),</div><div class="line">    PRIMARY KEY(`s_id`,`c_id`)</div><div class="line">);</div><div class="line">--插入学生表测试数据</div><div class="line">insert into Student values(&apos;01&apos; , &apos;赵雷&apos; , &apos;1990-01-01&apos; , &apos;男&apos;);</div><div class="line">insert into Student values(&apos;02&apos; , &apos;钱电&apos; , &apos;1990-12-21&apos; , &apos;男&apos;);</div><div class="line">insert into Student values(&apos;03&apos; , &apos;孙风&apos; , &apos;1990-05-20&apos; , &apos;男&apos;);</div><div class="line">insert into Student values(&apos;04&apos; , &apos;李云&apos; , &apos;1990-08-06&apos; , &apos;男&apos;);</div><div class="line">insert into Student values(&apos;05&apos; , &apos;周梅&apos; , &apos;1991-12-01&apos; , &apos;女&apos;);</div><div class="line">insert into Student values(&apos;06&apos; , &apos;吴兰&apos; , &apos;1992-03-01&apos; , &apos;女&apos;);</div><div class="line">insert into Student values(&apos;07&apos; , &apos;郑竹&apos; , &apos;1989-07-01&apos; , &apos;女&apos;);</div><div class="line">insert into Student values(&apos;08&apos; , &apos;王菊&apos; , &apos;1990-01-20&apos; , &apos;女&apos;);</div><div class="line">--课程表测试数据</div><div class="line">insert into Course values(&apos;01&apos; , &apos;语文&apos; , &apos;02&apos;);</div><div class="line">insert into Course values(&apos;02&apos; , &apos;数学&apos; , &apos;01&apos;);</div><div class="line">insert into Course values(&apos;03&apos; , &apos;英语&apos; , &apos;03&apos;);</div><div class="line"></div><div class="line">--教师表测试数据</div><div class="line">insert into Teacher values(&apos;01&apos; , &apos;张三&apos;);</div><div class="line">insert into Teacher values(&apos;02&apos; , &apos;李四&apos;);</div><div class="line">insert into Teacher values(&apos;03&apos; , &apos;王五&apos;);</div><div class="line"></div><div class="line">--成绩表测试数据</div><div class="line">insert into Score values(&apos;01&apos; , &apos;01&apos; , 80);</div><div class="line">insert into Score values(&apos;01&apos; , &apos;02&apos; , 90);</div><div class="line">insert into Score values(&apos;01&apos; , &apos;03&apos; , 99);  </div><div class="line">insert into Score values(&apos;02&apos; , &apos;01&apos; , 70);  </div><div class="line">insert into Score values(&apos;02&apos; , &apos;02&apos; , 60);</div><div class="line">insert into Score values(&apos;02&apos; , &apos;03&apos; , 80);</div><div class="line">insert into Score values(&apos;03&apos; , &apos;01&apos; , 80);</div><div class="line">insert into Score values(&apos;03&apos; , &apos;02&apos; , 80);</div><div class="line">insert into Score values(&apos;03&apos; , &apos;03&apos; , 80);</div><div class="line">insert into Score values(&apos;04&apos; , &apos;01&apos; , 50);</div><div class="line">insert into Score values(&apos;04&apos; , &apos;02&apos; , 30);</div><div class="line">insert into Score values(&apos;04&apos; , &apos;03&apos; , 20);</div><div class="line">insert into Score values(&apos;05&apos; , &apos;01&apos; , 76);</div><div class="line">insert into Score values(&apos;05&apos; , &apos;02&apos; , 87);</div><div class="line">insert into Score values(&apos;06&apos; , &apos;01&apos; , 31);</div><div class="line">insert into Score values(&apos;06&apos; , &apos;03&apos; , 34);</div><div class="line">insert into Score values(&apos;07&apos; , &apos;02&apos; , 89);</div><div class="line">insert into Score values(&apos;07&apos; , &apos;03&apos; , 98);</div><div class="line">---------------------</div></pre></td></tr></table></figure><a id="more"></a><h2 id="练习题和SQL语句"><a href="#练习题和SQL语句" class="headerlink" title="练习题和SQL语句"></a>练习题和SQL语句</h2><ul><li>查询”01”课程比”02”课程成绩高的学生的信息及课程分数<br>思路：<br>1&gt;先从学生表和成绩表中查询出来相应学生的01课程成绩信息视图，再与成绩表连接查询出相应的02课程成绩后根据01和02成绩条件过滤。<br>2&gt;先在成绩表中查找出01课程大于02课程的成绩比较信息后，再与学生表连接查询出结果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select s.*,b.s_score as 01_score,c.s_score  as 02 _score from </div><div class="line">    -&gt; student s join </div><div class="line">    -&gt; score b on b.s_id = s.s_id and b.c_id = &apos;01&apos; </div><div class="line">    -&gt; left join score c on c.s_id = s.s_id and c.c_id = &apos;02&apos;</div><div class="line">    -&gt; where b.s_score &gt; c.s_score;</div></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select s.*,b.s_score as 01_score,c.s_score as 02_score from</div><div class="line">    -&gt; score b  join </div><div class="line">    -&gt; score c on b.c_id = &apos;01&apos; and c.c_id = &apos;02&apos; and b.s_id = c.s_id and b.s_score &gt;  c.s_score  </div><div class="line">    -&gt; join student s on s.s_id = b.s_id;</div></pre></td></tr></table></figure><p>知识点：<br>on 和 where的区别：<br>on是在生成视图之前进行条件过滤。<br>where是生成视图后再进行条件过滤，代价比on要高。<br>join的顺序：从左到右</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;测试数据&quot;&gt;&lt;a href=&quot;#测试数据&quot; class=&quot;headerlink&quot; title=&quot;测试数据&quot;&gt;&lt;/a&gt;测试数据&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;--建表&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--学生表&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CREATE TABLE `Student`(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `s_id` VARCHAR(20),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `s_name` VARCHAR(20) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `s_birth` VARCHAR(20) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `s_sex` VARCHAR(10) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    PRIMARY KEY(`s_id`)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--课程表&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CREATE TABLE `Course`(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `c_id`  VARCHAR(20),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `c_name` VARCHAR(20) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `t_id` VARCHAR(20) NOT NULL,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    PRIMARY KEY(`c_id`)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--教师表&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CREATE TABLE `Teacher`(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `t_id` VARCHAR(20),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `t_name` VARCHAR(20) NOT NULL DEFAULT &amp;apos;&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    PRIMARY KEY(`t_id`)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--成绩表&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CREATE TABLE `Score`(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `s_id` VARCHAR(20),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `c_id`  VARCHAR(20),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    `s_score` INT(3),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    PRIMARY KEY(`s_id`,`c_id`)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--插入学生表测试数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Student values(&amp;apos;01&amp;apos; , &amp;apos;赵雷&amp;apos; , &amp;apos;1990-01-01&amp;apos; , &amp;apos;男&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Student values(&amp;apos;02&amp;apos; , &amp;apos;钱电&amp;apos; , &amp;apos;1990-12-21&amp;apos; , &amp;apos;男&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Student values(&amp;apos;03&amp;apos; , &amp;apos;孙风&amp;apos; , &amp;apos;1990-05-20&amp;apos; , &amp;apos;男&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Student values(&amp;apos;04&amp;apos; , &amp;apos;李云&amp;apos; , &amp;apos;1990-08-06&amp;apos; , &amp;apos;男&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Student values(&amp;apos;05&amp;apos; , &amp;apos;周梅&amp;apos; , &amp;apos;1991-12-01&amp;apos; , &amp;apos;女&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Student values(&amp;apos;06&amp;apos; , &amp;apos;吴兰&amp;apos; , &amp;apos;1992-03-01&amp;apos; , &amp;apos;女&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Student values(&amp;apos;07&amp;apos; , &amp;apos;郑竹&amp;apos; , &amp;apos;1989-07-01&amp;apos; , &amp;apos;女&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Student values(&amp;apos;08&amp;apos; , &amp;apos;王菊&amp;apos; , &amp;apos;1990-01-20&amp;apos; , &amp;apos;女&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--课程表测试数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Course values(&amp;apos;01&amp;apos; , &amp;apos;语文&amp;apos; , &amp;apos;02&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Course values(&amp;apos;02&amp;apos; , &amp;apos;数学&amp;apos; , &amp;apos;01&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Course values(&amp;apos;03&amp;apos; , &amp;apos;英语&amp;apos; , &amp;apos;03&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--教师表测试数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Teacher values(&amp;apos;01&amp;apos; , &amp;apos;张三&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Teacher values(&amp;apos;02&amp;apos; , &amp;apos;李四&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Teacher values(&amp;apos;03&amp;apos; , &amp;apos;王五&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--成绩表测试数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;01&amp;apos; , &amp;apos;01&amp;apos; , 80);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;01&amp;apos; , &amp;apos;02&amp;apos; , 90);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;01&amp;apos; , &amp;apos;03&amp;apos; , 99);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;02&amp;apos; , &amp;apos;01&amp;apos; , 70);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;02&amp;apos; , &amp;apos;02&amp;apos; , 60);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;02&amp;apos; , &amp;apos;03&amp;apos; , 80);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;03&amp;apos; , &amp;apos;01&amp;apos; , 80);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;03&amp;apos; , &amp;apos;02&amp;apos; , 80);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;03&amp;apos; , &amp;apos;03&amp;apos; , 80);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;04&amp;apos; , &amp;apos;01&amp;apos; , 50);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;04&amp;apos; , &amp;apos;02&amp;apos; , 30);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;04&amp;apos; , &amp;apos;03&amp;apos; , 20);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;05&amp;apos; , &amp;apos;01&amp;apos; , 76);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;05&amp;apos; , &amp;apos;02&amp;apos; , 87);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;06&amp;apos; , &amp;apos;01&amp;apos; , 31);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;06&amp;apos; , &amp;apos;03&amp;apos; , 34);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;07&amp;apos; , &amp;apos;02&amp;apos; , 89);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;insert into Score values(&amp;apos;07&amp;apos; , &amp;apos;03&amp;apos; , 98);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;---------------------&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码阅读(启动过程)</title>
    <link href="http://yoursite.com/2018/11/15/Redis/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B)/"/>
    <id>http://yoursite.com/2018/11/15/Redis/Redis源码阅读(启动过程)/</id>
    <published>2018-11-15T06:12:13.000Z</published>
    <updated>2018-11-23T07:16:35.910Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的启动函数main()在redis.c文件中。 </p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>在启动时会使用initServerConfig()函数进行初始化服务器配置工作，redisServer(redis.h)作为保存服务器配置的结构。 redisServer包含以下的一些Redis服务器的信息：  </p><ul><li>一般服务器状态。</li><li>一些服务器统计信息。</li><li>各种链表结构，如保存客户端的链表等。</li><li>配置文件及启动参数中的配置。</li><li>主从复制的状态。</li><li>持久化文件的参数和状态。</li></ul><p><img src="https://i.imgur.com/IXG8CwE.png" alt=""><br><a id="more"></a></p><h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><p>在initServer中会进行初始化服务器所需要的一些数据结构信息</p><ul><li>共享对象</li><li>事件循环</li><li>数据库结构</li><li>TCP套接字</li><li>服务器cron</li><li>事件循环</li><li>打开AOF</li></ul><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>如果开启了AOF持久化，那么加载AOF文件；否则加载RDB文件。   </p><p><font color="red">如果开启AOF，但是没有AOF文件的话也不会去读取RDB文件，这样会造成数据的丢失！！！</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void loadDataFromDisk(void) &#123;</div><div class="line">    // 记录开始时间</div><div class="line">    long long start = ustime();</div><div class="line"></div><div class="line">    // AOF 持久化已打开？</div><div class="line">    if (server.aof_state == REDIS_AOF_ON) &#123;</div><div class="line">        // 尝试载入 AOF 文件</div><div class="line">        if (loadAppendOnlyFile(server.aof_filename) == REDIS_OK)</div><div class="line">            // 打印载入信息，并计算载入耗时长度</div><div class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from append only file: %.3f seconds&quot;,(float)(ustime()-start)/1000000);</div><div class="line">    // AOF 持久化未打开</div><div class="line">    &#125; else &#123;</div><div class="line">        // 尝试载入 RDB 文件</div><div class="line">        if (rdbLoad(server.rdb_filename) == REDIS_OK) &#123;</div><div class="line">            // 打印载入信息，并计算载入耗时长度</div><div class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from disk: %.3f seconds&quot;,</div><div class="line">                (float)(ustime()-start)/1000000);</div><div class="line">        &#125; else if (errno != ENOENT) &#123;</div><div class="line">            redisLog(REDIS_WARNING,&quot;Fatal error loading the DB: %s. Exiting.&quot;,strerror(errno));</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="运行事件处理器"><a href="#运行事件处理器" class="headerlink" title="运行事件处理器"></a>运行事件处理器</h3><p>Redis在每次进入事件循环时都会想调用函数beforeSleep()。<br>beforeSleep()会做两件事：  </p><ol><li>如果启用了虚拟内存系统，将会去刷新AOF到磁盘，由flushAppendOnlyFile()函数处理。  </li><li>该函数封装了关于刷新缓冲区的一些复杂的逻辑，该缓冲区保存了AOF的写入缓存。  </li></ol><h4 id="进入事件循环"><a href="#进入事件循环" class="headerlink" title="进入事件循环"></a>进入事件循环</h4><p>Redis通过aeMain()进入主事件循环server.el。通过aeProcessEvents()处理所有已到达的时间事件和所有已就绪的文件事件。</p><h3 id="处理请求并返回响应"><a href="#处理请求并返回响应" class="headerlink" title="处理请求并返回响应"></a>处理请求并返回响应</h3><p>经过上面的启动过程后，Redis已经处于主事件轮询循环中，监听端口并等待客户端连接。<br><img src="https://i.imgur.com/J2YEVoo.png" alt=""></p><h4 id="处理新连接"><a href="#处理新连接" class="headerlink" title="处理新连接"></a>处理新连接</h4><p>在initServer()中，Redis注册acceptHandler()，当IO事件发生时被调用。acceptHandler()会创建一个客户端对象RedisClient。</p><h4 id="从客户端读取命令"><a href="#从客户端读取命令" class="headerlink" title="从客户端读取命令"></a>从客户端读取命令</h4><p>当客户端发送命令请求时，主事件循环调用readQueryFromClient()函数，它会尽可能多的读取（最多1024个字节）到临时缓冲区。<br>然后调用processInputBuffer()函数将客户端对象作为参数传递。processInputBuffer()将客户端的原始查询解析为执行Redis命令的参数，并解析每个参数的Redis字符串对象，并将它存储在客户端对象的数组中。然后调用processCommand()客户端对象来实际执行客户端发送的命令。<br>processCommand()从客户端获取命令的参数并执行。在执行前会进行许多的检查，如果检查失败，会向客户端对象附加一个错误消息并返回。</p><h4 id="执行命令并响应"><a href="#执行命令并响应" class="headerlink" title="执行命令并响应"></a>执行命令并响应</h4><p>call()函数，从客户端对象中获取具体执行命令的指针所指向的函数对象，并调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void call(redisClient *c, struct redisCommand *cmd) &#123;</div><div class="line">    long long dirty;</div><div class="line"></div><div class="line">    dirty = server.dirty;</div><div class="line">    cmd-&gt;proc(c);</div><div class="line">    dirty = server.dirty-dirty;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的启动函数main()在redis.c文件中。 &lt;/p&gt;
&lt;h3 id=&quot;初始化配置&quot;&gt;&lt;a href=&quot;#初始化配置&quot; class=&quot;headerlink&quot; title=&quot;初始化配置&quot;&gt;&lt;/a&gt;初始化配置&lt;/h3&gt;&lt;p&gt;在启动时会使用initServerConfig()函数进行初始化服务器配置工作，redisServer(redis.h)作为保存服务器配置的结构。 redisServer包含以下的一些Redis服务器的信息：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般服务器状态。&lt;/li&gt;
&lt;li&gt;一些服务器统计信息。&lt;/li&gt;
&lt;li&gt;各种链表结构，如保存客户端的链表等。&lt;/li&gt;
&lt;li&gt;配置文件及启动参数中的配置。&lt;/li&gt;
&lt;li&gt;主从复制的状态。&lt;/li&gt;
&lt;li&gt;持久化文件的参数和状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/IXG8CwE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis对象结构</title>
    <link href="http://yoursite.com/2018/11/10/Redis/Redis%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/10/Redis/Redis对象/</id>
    <published>2018-11-10T13:34:13.000Z</published>
    <updated>2018-11-23T07:17:48.419Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line"></div><div class="line">    // 类型</div><div class="line">    unsigned type:4;</div><div class="line"></div><div class="line">    // 编码</div><div class="line">    unsigned encoding:4;</div><div class="line"></div><div class="line">    // 对象最后一次被访问的时间</div><div class="line">    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */</div><div class="line"></div><div class="line">    // 引用计数</div><div class="line">    int refcount;</div><div class="line"></div><div class="line">    // 指向实际值的指针</div><div class="line">    void *ptr;</div><div class="line"></div><div class="line">&#125; robj;</div></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">typedef struct redisDb &#123;</div><div class="line"></div><div class="line">    // 数据库键空间，保存着数据库中的所有键值对</div><div class="line">    dict *dict;                 /* The keyspace for this DB */</div><div class="line"></div><div class="line">    // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</div><div class="line">    dict *expires;              /* Timeout of keys with a timeout set */</div><div class="line"></div><div class="line">    // 正处于阻塞状态的键</div><div class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */</div><div class="line"></div><div class="line">    // 可以解除阻塞的键</div><div class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</div><div class="line"></div><div class="line">    // 正在被 WATCH 命令监视的键</div><div class="line">    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */</div><div class="line"></div><div class="line">    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */</div><div class="line"></div><div class="line">    // 数据库号码</div><div class="line">    int id;                     /* Database ID */</div><div class="line"></div><div class="line">    // 数据库的键的平均 TTL ，统计信息</div><div class="line">    long long avg_ttl;          /* Average TTL, just for stats */</div><div class="line"></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">typedef struct redisClient &#123;</div><div class="line"></div><div class="line">    // 套接字描述符</div><div class="line">    int fd;</div><div class="line"></div><div class="line">    // 当前正在使用的数据库</div><div class="line">    redisDb *db;</div><div class="line"></div><div class="line">    // 当前正在使用的数据库的 id （号码）</div><div class="line">    int dictid;</div><div class="line"></div><div class="line">    // 客户端的名字</div><div class="line">    robj *name;             /* As set by CLIENT SETNAME */</div><div class="line"></div><div class="line">    // 查询缓冲区</div><div class="line">    sds querybuf;</div><div class="line"></div><div class="line">    // 查询缓冲区长度峰值</div><div class="line">    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size */</div><div class="line"></div><div class="line">    // 参数数量</div><div class="line">    int argc;</div><div class="line"></div><div class="line">    // 参数对象数组</div><div class="line">    robj **argv;</div><div class="line"></div><div class="line">    // 记录被客户端执行的命令</div><div class="line">    struct redisCommand *cmd, *lastcmd;</div><div class="line"></div><div class="line">    // 请求的类型：内联命令还是多条命令</div><div class="line">    int reqtype;</div><div class="line"></div><div class="line">    // 剩余未读取的命令内容数量</div><div class="line">    int multibulklen;       /* number of multi bulk arguments left to read */</div><div class="line"></div><div class="line">    // 命令内容的长度</div><div class="line">    long bulklen;           /* length of bulk argument in multi bulk request */</div><div class="line"></div><div class="line">    // 回复链表</div><div class="line">    list *reply;</div><div class="line"></div><div class="line">    // 回复链表中对象的总大小</div><div class="line">    unsigned long reply_bytes; /* Tot bytes of objects in reply list */</div><div class="line"></div><div class="line">    // 已发送字节，处理 short write 用</div><div class="line">    int sentlen;            /* Amount of bytes already sent in the current</div><div class="line">                               buffer or object being sent. */</div><div class="line"></div><div class="line">    // 创建客户端的时间</div><div class="line">    time_t ctime;           /* Client creation time */</div><div class="line"></div><div class="line">    // 客户端最后一次和服务器互动的时间</div><div class="line">    time_t lastinteraction; /* time of the last interaction, used for timeout */</div><div class="line"></div><div class="line">    // 客户端的输出缓冲区超过软性限制的时间</div><div class="line">    time_t obuf_soft_limit_reached_time;</div><div class="line"></div><div class="line">    // 客户端状态标志</div><div class="line">    int flags;              /* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */</div><div class="line"></div><div class="line">    // 当 server.requirepass 不为 NULL 时</div><div class="line">    // 代表认证的状态</div><div class="line">    // 0 代表未认证， 1 代表已认证</div><div class="line">    int authenticated;      /* when requirepass is non-NULL */</div><div class="line"></div><div class="line">    // 复制状态</div><div class="line">    int replstate;          /* replication state if this is a slave */</div><div class="line">    // 用于保存主服务器传来的 RDB 文件的文件描述符</div><div class="line">    int repldbfd;           /* replication DB file descriptor */</div><div class="line"></div><div class="line">    // 读取主服务器传来的 RDB 文件的偏移量</div><div class="line">    off_t repldboff;        /* replication DB file offset */</div><div class="line">    // 主服务器传来的 RDB 文件的大小</div><div class="line">    off_t repldbsize;       /* replication DB file size */</div><div class="line">    </div><div class="line">    sds replpreamble;       /* replication DB preamble. */</div><div class="line"></div><div class="line">    // 主服务器的复制偏移量</div><div class="line">    long long reploff;      /* replication offset if this is our master */</div><div class="line">    // 从服务器最后一次发送 REPLCONF ACK 时的偏移量</div><div class="line">    long long repl_ack_off; /* replication ack offset, if this is a slave */</div><div class="line">    // 从服务器最后一次发送 REPLCONF ACK 的时间</div><div class="line">    long long repl_ack_time;/* replication ack time, if this is a slave */</div><div class="line">    // 主服务器的 master run ID</div><div class="line">    // 保存在客户端，用于执行部分重同步</div><div class="line">    char replrunid[REDIS_RUN_ID_SIZE+1]; /* master run id if this is a master */</div><div class="line">    // 从服务器的监听端口号</div><div class="line">    int slave_listening_port; /* As configured with: SLAVECONF listening-port */</div><div class="line"></div><div class="line">    // 事务状态</div><div class="line">    multiState mstate;      /* MULTI/EXEC state */</div><div class="line"></div><div class="line">    // 阻塞类型</div><div class="line">    int btype;              /* Type of blocking op if REDIS_BLOCKED. */</div><div class="line">    // 阻塞状态</div><div class="line">    blockingState bpop;     /* blocking state */</div><div class="line"></div><div class="line">    // 最后被写入的全局复制偏移量</div><div class="line">    long long woff;         /* Last write global replication offset. */</div><div class="line"></div><div class="line">    // 被监视的键</div><div class="line">    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */</div><div class="line"></div><div class="line">    // 这个字典记录了客户端所有订阅的频道</div><div class="line">    // 键为频道名字，值为 NULL</div><div class="line">    // 也即是，一个频道的集合</div><div class="line">    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */</div><div class="line"></div><div class="line">    // 链表，包含多个 pubsubPattern 结构</div><div class="line">    // 记录了所有订阅频道的客户端的信息</div><div class="line">    // 新 pubsubPattern 结构总是被添加到表尾</div><div class="line">    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */</div><div class="line">    sds peerid;             /* Cached peer ID. */</div><div class="line"></div><div class="line">    /* Response buffer */</div><div class="line">    // 回复偏移量</div><div class="line">    int bufpos;</div><div class="line">    // 回复缓冲区</div><div class="line">    char buf[REDIS_REPLY_CHUNK_BYTES];</div><div class="line"></div><div class="line">&#125; redisClient;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;typedef struct redisObject &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 类型&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    unsigned type:4;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 编码&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    unsigned encoding:4;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 对象最后一次被访问的时间&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 引用计数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    int refcount;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 指向实际值的指针&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    void *ptr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; robj;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理----主从复制</title>
    <link href="http://yoursite.com/2018/10/26/Redis/Redis%E5%8E%9F%E7%90%86----%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2018/10/26/Redis/Redis原理----主从复制/</id>
    <published>2018-10-26T13:34:13.000Z</published>
    <updated>2018-10-28T15:41:44.268Z</updated>
    
    <content type="html"><![CDATA[<p>很多企业都没有使用到Redis的集群，但是至少都做了主从。有了主从，当master挂掉的时候，运维让从库过来接管，服务就可以继续，否则master需要经过数据恢复和重启的过程，这就可能会拖很长时间，影响线上业务的持续服务。  </p><p>在了解Redis主从复制之前，让我们先来理解一下现代分布式系统的理论基石–CAP原理。</p><h2 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h2><p>CAP原理就好比分布式领域的牛顿定律，它是分布式存储的理论基石。自打CAP的论文发表之后，分布式存储中间件犹如雨后春笋一个一个涌现出来。  </p><ul><li>C-Consistent 一致性</li><li>A-Availability 可用性</li><li>P-Partition tolerance 分区容忍性</li></ul><p>分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着「网络分区」。</p><a id="more"></a><p>在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的「一致性」将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲「可用性」，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。<br><img src="https://i.imgur.com/owNDznt.jpg" alt=""><br>一句话概括CAP原理就是–<b>网络分区发生时，一致性和可用性两难全。</b>  </p><p>Redis的主从数据是异步同步的，所以分布式的Redis系统并不满足[一致性]要求。当客户端在Redis的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主从节点依旧可以正常对外提供服务，所以Redis满足[可用性]。  </p><p>Redis保证[最终一致性]，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态保持一致。如果网络断开，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续经历保持和主节点一致。  </p><h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><p>Redis同步支持主从同步和从从同步，从从同步功能是Redis后续版本增加的功能，为了减轻主库的同步负担。<br><img src="https://i.imgur.com/1IiirbA.jpg" alt="">  </p><h2 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h2><p>Redis同步的是指令流，主节点会将那些对自己状态产生修改性影响的指令记录在本地的内存buffer中，然后异步将buffer中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一边向主节点反馈自己同步的偏移量。  </p><p>因为内存的buffer（复制积压缓冲区）是有限的，所以Redis主库不能将所有的指令都记录在内存buffer中。Redis的复制内存buffer是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。<br><img src="https://i.imgur.com/I9g0mo3.jpg" alt=""><br>如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么在网络状况恢复时，Redis的主节点中那些没有同步的指令在buffer中有可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制–快照同步。  </p><h2 id="快照同步"><a href="#快照同步" class="headerlink" title="快照同步"></a>快照同步</h2><p>快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次bgsave将当前内存中的数据全部快照到磁盘文件中，然后再将快照文件的传送给从节点。从节点在接收完毕后，立即执行一次全量加载，加载之前会将内存中的数据清空。加载完毕后通知主节点继续进行增量同步。  </p><p>在整个快照同步执行的过程中，主节点的复制buffer还在不停的往前移动，如果快照同步的时间过长或者复制buffer太小，都会导致同步期间的增量指令在复制buffer中被覆盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如果极有可能陷入无限的死循环，从而影响主节点的正常服务。<br><img src="https://i.imgur.com/aw8EZAS.jpg" alt=""><br><b>请务必设置一个合适复制buffer大小参数，避免这种情况的发生。</b>  </p><h2 id="无盘复制"><a href="#无盘复制" class="headerlink" title="无盘复制"></a>无盘复制</h2><p>主节点在进行快照同步时，会进行很重的文件IO操作，特别是对于非SSD磁盘存储时，快照会对系统的负载产生较大影响。特别是当系统正在进行AOF的fsync操作时如果发生快照，fsync将会被推迟执行，这就会严重影响主节点的服务效率。  </p><p>所以从Redis2.8.18版开始支持无盘复制。所谓无盘复制就是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内容，一边将序列化的内容发送给从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。  </p><h2 id="Wait指令"><a href="#Wait指令" class="headerlink" title="Wait指令"></a>Wait指令</h2><p>Redis的复制是异步进行的，wait指令可以让异步复制变身同步复制，确保系统的强一致性（不严格）。wait指令时Redis3.0版本以后出现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;set key value  </div><div class="line">OK  </div><div class="line">&gt;wait 1 0  </div><div class="line">(interge) 1</div></pre></td></tr></table></figure></p><p>wait提供两个参数，第一个参数是从库的数量N，第二个参数是时间t，以毫秒为单位。它表示等待wait指令之前的所有写操作同步到N个从库（也就是确保N个从库的同步没有滞后），最多等待时间t。如果时间t=0，代表无限等待知道N个从库同步完成达到一致。  </p><p>假设此时出现了网络分区，wait指令第二个参数时间t=0，主从同步无法继续进行，wait指令会永远阻塞，Redis服务器将丧失可用性。  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>主从复制是Redis分布式的基础，Redis的高可用离开了朱重构复制将无法进行。  </p><p>如果你将Redis只用作缓存，跟memcache一样对待，也就唔需要从库做备份，挂掉了重新启动一下就行了。但是只要你使用了Redis的持久化功能，就必须认真对待主从复制，它是系统数据安全的基础保障。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多企业都没有使用到Redis的集群，但是至少都做了主从。有了主从，当master挂掉的时候，运维让从库过来接管，服务就可以继续，否则master需要经过数据恢复和重启的过程，这就可能会拖很长时间，影响线上业务的持续服务。  &lt;/p&gt;
&lt;p&gt;在了解Redis主从复制之前，让我们先来理解一下现代分布式系统的理论基石–CAP原理。&lt;/p&gt;
&lt;h2 id=&quot;CAP原理&quot;&gt;&lt;a href=&quot;#CAP原理&quot; class=&quot;headerlink&quot; title=&quot;CAP原理&quot;&gt;&lt;/a&gt;CAP原理&lt;/h2&gt;&lt;p&gt;CAP原理就好比分布式领域的牛顿定律，它是分布式存储的理论基石。自打CAP的论文发表之后，分布式存储中间件犹如雨后春笋一个一个涌现出来。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C-Consistent 一致性&lt;/li&gt;
&lt;li&gt;A-Availability 可用性&lt;/li&gt;
&lt;li&gt;P-Partition tolerance 分区容忍性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着「网络分区」。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理----事务</title>
    <link href="http://yoursite.com/2018/10/25/Redis/Redis%E5%8E%9F%E7%90%86----%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/10/25/Redis/Redis原理----事务/</id>
    <published>2018-10-25T13:34:13.000Z</published>
    <updated>2018-10-25T16:25:55.715Z</updated>
    
    <content type="html"><![CDATA[<p>为了确保连续多个操作的原子性，一个成熟的数据库通常都会有事务支持，Redis也不例外。Redis的事务使用非常简单，不同于关系数据库，我们无需理解那么多复杂的事务模型了，就可以直接使用。不过也正是因为这种简单性，它的事务模型很不严格，这要求我们不能像使用关系数据库的事务一样使用Redis。</p><h2 id="Redis事务的基本使用"><a href="#Redis事务的基本使用" class="headerlink" title="Redis事务的基本使用"></a>Redis事务的基本使用</h2><p>每个事务的操作都有begin、commit、和rollback、begin指示事务的开始，commit指示事务的提交，rollback指示事务的回滚。</p><p>Redis与其差不多，对应的分别是multi/exec/discard。multi指示事务的开始，exec指示事务的执行，discard指示事务的丢弃。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;multi  </div><div class="line">OK  </div><div class="line">&gt;incr books  </div><div class="line">QUEUED  </div><div class="line">&gt;incr books  </div><div class="line">QUEUED  </div><div class="line">&gt;exec  </div><div class="line">(integer) 1</div><div class="line">(integer）2</div></pre></td></tr></table></figure><p>上面的指令演示了一个完整的事务过程，所有的指令在exec之前不执行，而是<font color="red">缓存在服务器的一个事务队列中</font>，服务器一旦受到exec指令，就开始执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。因为Redis的单线程特性，它不用担心自己在执行队列的时候被其他指令打搅，可以保证他们得到的[原子性]执行。<br><img src="https://i.imgur.com/l8Awrjs.jpg" alt=""><br>上图显示了以上事务过程完整的交互结果。QUEUED是一个简单字符串，同OK是一个形式，它表示指令已经被服务器缓存到队列里了。<br><a id="more"></a></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>事务的原子性是指要么事务全部成功，要么全部失败，那么Redis事务的执行时原子性的么？  </p><p>下面我们来看一个特别的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;multi  </div><div class="line">OK  </div><div class="line">&gt;set books iamstring  </div><div class="line">QUEUED  </div><div class="line">&gt;incr books  </div><div class="line">QUEUED  </div><div class="line">&gt;set poorman iamdesperate  </div><div class="line">QUEUED  </div><div class="line">&gt;exec  </div><div class="line">1) OK  </div><div class="line">2) (error)ERR value is not an integer or out of range  </div><div class="line">3) OK  </div><div class="line">&gt;get books  </div><div class="line">&quot;iamstring&quot;  </div><div class="line">&gt;get poorman  </div><div class="line">&quot;iamdesperate&quot;</div></pre></td></tr></table></figure><p>上面的例子是事务执行到中间遇到失败了，因为我们不能对一个字符串进行数学运算，事务在遇到指令执行失败后，后面的指令还继续执行，所以poorman的值能继续得到设置。  </p><p>到这里，应该明白Redis的事务根本不能算[原子性]，而仅仅是满足了事务的[隔离性]，隔离性中的串行化–当前执行的事务有着不被其他事务打断的权利。</p><h2 id="discard-丢弃"><a href="#discard-丢弃" class="headerlink" title="discard(丢弃)"></a>discard(丢弃)</h2><p>Redis为事务提供了一个discard指令，用于丢弃事务缓存队列中的所有指令，在exec执行之前。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面Redis事务在发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部的指令较多时，需要的网络IO时间也会线性增长。所以通常Redis的客户端在执行事务时都会结合pipeline一起使用，这样可以将多次IO操作压缩为单次IO操作。</p><h2 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h2><p>考虑到一个业务场景，Redis存储了我们的账户余额数据，它是一个整数。现在有两个并发的客户端要对账户余额进行修改操作，这个修改不是简单的incrby指令，而是要对余额乘以一个倍数。Redis可没有提供multiplyby这样的指令。我们需要先取出余额然后在内存里乘以倍数，再将结果写回到Redis。  </p><p>这就会出现并发问题，因为有多个客户端会并发进行操作。我们可以通过Redis的分布式锁来避免冲突，这是一个很好的解决方案。<b>分布式锁是一种悲观锁，那是不是可以使用悲观锁的方式来解决冲突呢？</b>  </p><p>Redis提供了watch的机制，它就是一种悲观锁。有了watch我们又多了一种可以用来解决并发修改的方法。watch的使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">while True:  </div><div class="line">do_watch()  </div><div class="line">commands()  </div><div class="line">multi()  </div><div class="line">send_commands()  </div><div class="line">try:  </div><div class="line">exec()  </div><div class="line">break  </div><div class="line">except WatchError:  </div><div class="line">continue</div></pre></td></tr></table></figure></p><p>watch会在事务开始之前盯住一个或多个关键变量，当事务执行时，也就是服务受到exec指令要顺序执行缓存的事务队列时，Redis会检查关键变量只watch之后，是否被修改了（包括当前事务所在客户端）。如果关键变量被人动过了，exec指令就会返回null回复告知客户端事务执行失败，这个时候客户端一般会想着重试。  </p><pre><code>&gt;watch books  OK  &gt;incr books  #被修改了  (integer) 1  &gt;multi  OK  &gt;incr books  QUEUED  &gt;exec  #事务执行失败  (nil)</code></pre><p>当服务器给exec指令返回一个null回复时，客户端知道了事务执行是失败的，通常客户端(redis-py)都会抛出一个WatchError这种错误，不过也有些语言(jedis)不会抛出异常，而是通过在exec方法里返回一个null，这样客户端需要检查一下返回结果是否为null来确定事务是否执行失败。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Redis禁止在multi和exec之间执行watch指令，而必须在multi之前做好盯住关键变量，否则会出错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了确保连续多个操作的原子性，一个成熟的数据库通常都会有事务支持，Redis也不例外。Redis的事务使用非常简单，不同于关系数据库，我们无需理解那么多复杂的事务模型了，就可以直接使用。不过也正是因为这种简单性，它的事务模型很不严格，这要求我们不能像使用关系数据库的事务一样使用Redis。&lt;/p&gt;
&lt;h2 id=&quot;Redis事务的基本使用&quot;&gt;&lt;a href=&quot;#Redis事务的基本使用&quot; class=&quot;headerlink&quot; title=&quot;Redis事务的基本使用&quot;&gt;&lt;/a&gt;Redis事务的基本使用&lt;/h2&gt;&lt;p&gt;每个事务的操作都有begin、commit、和rollback、begin指示事务的开始，commit指示事务的提交，rollback指示事务的回滚。&lt;/p&gt;
&lt;p&gt;Redis与其差不多，对应的分别是multi/exec/discard。multi指示事务的开始，exec指示事务的执行，discard指示事务的丢弃。  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;multi  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;OK  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;incr books  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;QUEUED  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;incr books  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;QUEUED  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;exec  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(integer) 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(integer）2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的指令演示了一个完整的事务过程，所有的指令在exec之前不执行，而是&lt;font color=&quot;red&quot;&gt;缓存在服务器的一个事务队列中&lt;/font&gt;，服务器一旦受到exec指令，就开始执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。因为Redis的单线程特性，它不用担心自己在执行队列的时候被其他指令打搅，可以保证他们得到的[原子性]执行。&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/l8Awrjs.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;上图显示了以上事务过程完整的交互结果。QUEUED是一个简单字符串，同OK是一个形式，它表示指令已经被服务器缓存到队列里了。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理----管道</title>
    <link href="http://yoursite.com/2018/10/24/Redis/Redis%E5%8E%9F%E7%90%86----%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2018/10/24/Redis/Redis原理----管道/</id>
    <published>2018-10-24T13:34:13.000Z</published>
    <updated>2018-10-24T16:22:04.176Z</updated>
    
    <content type="html"><![CDATA[<p>大多数人一直对Redis管道有一个误解，他们以为这是Redis服务器提供的一种特别的技术，有了这种技术就可以加速Redis的存取效率。但是实际上Redis管道（Pipeline）本身并不是Redis服务器直接提供的技术，这个技术本质上是由客户端提供的，跟服务器没有什么直接的关系。</p><h2 id="Redis的消息交互"><a href="#Redis的消息交互" class="headerlink" title="Redis的消息交互"></a>Redis的消息交互</h2><p>当我们使用客户端对Redis进行一次操作时，如下图所示，客户端将请求传送给服务器，服务器处理完毕后，再将响应回复给客户端。这要花费一个网络数据包的来回时间。  </p><p><img src="https://i.imgur.com/ulCYBhP.jpg" alt=""><br><a id="more"></a><br>如果连续执行多条指令，那就会花费多个网络数据包来回的时间。如下图所示。  </p><p><img src="https://i.imgur.com/zxGuLwE.jpg" alt="">  </p><p>回到客户端代码层面，客户端是经历了写-读-写-读四个操作才完整的执行了两条指令。  </p><p><img src="https://i.imgur.com/kW9apz0.jpg" alt="">  </p><p>现在如果我们调整读写顺序，改成写-写-读-读，这两个指令同样可以正常完成。  </p><p><img src="https://i.imgur.com/V6yvFoA.jpg" alt=""><br>两个连续的写操作和两个连续的读操作总共只会花费一次网络来回，就好比连续的write操作合并了，连续的read操作也合并了一样。</p><p><img src="https://i.imgur.com/qvHYXje.jpg" alt="">    </p><p>这便是管道操作的本质，服务器根本没有任何区别对待，还是收到一条消息，执行一条消息，回复一条消息的正常流程。客户端通过对管道中的指令列表改变读写顺序就可以大幅度节省IO时间，管道中指令越多，效果越好。  </p><h2 id="深入理解管道本质"><a href="#深入理解管道本质" class="headerlink" title="深入理解管道本质"></a>深入理解管道本质</h2><p>接下来我们深入分析一个请求交互的流程，真实的情况是它很复杂，因为要经过网络协议栈，这个就得深入内核了。  </p><p><img src="https://i.imgur.com/Ub6GJ4Z.jpg" alt="">  </p><p>上图就是一个完整的请求交互图。  </p><ol><li>客户端进程挑用write将消息写到操作系统内核为套接字分配的发送缓冲send buffer。  </li><li>客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过[网际路由]送到服务器的网卡。  </li><li>服务器操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲recv buffer。  </li><li>服务器进程调用read从接收缓冲中取出消息进行处理。  </li><li>服务器进程调用write将响应消息写到内核为套接字分配的发送缓冲send buffer。  </li><li>服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过[网际路由]送到客户端网卡。  </li><li>客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲recv buffer。  </li><li>客户端进程调用read从接收缓冲中取出消息返回给上层业务逻辑进行处理。  </li><li>结束。  </li></ol><p>其中步骤5-8和1-4是一样的，只不过方向是反过来的，一个是请求，一个是响应。  </p><p>我们开始以为write操作是要等到对方收到消息才会返回，但实际上不是这样的。write操作只负责将数据写到本地操作系统内核的发送缓冲然后就返回了。剩下的事交给操作系统内核异步将数据送到目标机器。但是如果发送缓冲满了，那么就需要等待缓冲空出空间来，这个就是写IO操作的真正耗时。  </p><p>我们开始以为read操作是从目标机器拉取数据，但实际上不是这样的。read操作只负责将数据从本地操作系统内核的接收缓冲中取出来。但是如果缓冲是空的，那么就需要等待数据到来，这个就是读IO操作的真正耗时。  </p><p>所以对于value = redis.get(key)这样一个简单的请求来说，write操作几乎没有耗时，直接写到发送缓冲就返回，而read就比较耗时了，因为他要等待消息经过网际路由到目标机器处理后的响应消息，再回送到当前的内核读缓冲才可以返回。<b>这是才是一个网络来回的真正开销。</b>  </p><p>而对于管道来说，连续的write操作根本没有耗时，之后第一个read操作会等待一个网络的来回开销，然后所有的响应消息就都已经回送到内核的读缓存了，后续的read操作直接就可以从缓冲拿到结果，瞬间就返回了。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大多数人一直对Redis管道有一个误解，他们以为这是Redis服务器提供的一种特别的技术，有了这种技术就可以加速Redis的存取效率。但是实际上Redis管道（Pipeline）本身并不是Redis服务器直接提供的技术，这个技术本质上是由客户端提供的，跟服务器没有什么直接的关系。&lt;/p&gt;
&lt;h2 id=&quot;Redis的消息交互&quot;&gt;&lt;a href=&quot;#Redis的消息交互&quot; class=&quot;headerlink&quot; title=&quot;Redis的消息交互&quot;&gt;&lt;/a&gt;Redis的消息交互&lt;/h2&gt;&lt;p&gt;当我们使用客户端对Redis进行一次操作时，如下图所示，客户端将请求传送给服务器，服务器处理完毕后，再将响应回复给客户端。这要花费一个网络数据包的来回时间。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ulCYBhP.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理----持久化</title>
    <link href="http://yoursite.com/2018/10/22/Redis/Redis%E5%8E%9F%E7%90%86----%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2018/10/22/Redis/Redis原理----持久化/</id>
    <published>2018-10-22T13:30:13.000Z</published>
    <updated>2018-10-23T15:25:24.296Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证Redis的数据不会因为故障而丢失，这种机制就是Redis的持久化机制。  </p><p>Redis的持久化机制有两种，第一种就是快照（RDB文件），第二种就是AOF日志。快照是一次全量备份，AOF日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而AOF日志记录的是内存数据修改的指令记录文本。AOF日志在长期的运行过程中会变得非常大，数据库重启时需要加载AOF日志进行指令重放，这个时间会变得无比漫长。所以需要定期进行AOF重写，给AOF文件瘦身。</p><h2 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h2><p>我们知道Redis是单线程程序，这个线程要同时负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写。  </p><p>在服务线上请求的同时，Redis还需要进行内存快照，内存快照要求Redis必须进行文件IO操作，可文件IO操作是不能使用多路复用API。  </p><p>这意味着单线程同时在服务线上的请求和吉林文件IO操作，文件IO操作会严重拖垮服务器请求的性能。还有个<b>重要的问题就是为了不阻塞线上的业务，就需要边持久化边响应客户端请求</b>。持久化的同时，内存数据结构还在变化，比如一个大型的hash字典正在持久化，结果一个请求过来把它给删除了，还没持久化，这该怎么办？  </p><font color="red">Redis使用操作系统的多进程COW（copy On Write）机制来实现快照持久化。</font><a id="more"></a><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>Redis在持久化时会调用glibc的函数fork产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。这时你可以将父子进程想象成一个连体婴儿，共享身体。这时liunx操作系统的机制，为了节约内存资源，所以尽可能让他们共享。在进程分离的一瞬间，内存的增长几乎没有明显变化。  </p><p>子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断修改。  </p><p>这个时候就会使用操作系统的COW机制进行数据段页的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程像一粒的页面是没有变化的，还是进程产生时那一瞬间的数据。  </p><p>随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的2倍大小。另外一个Redis实例里冷数据占的比例往往是比较高的，所以很少会出现所有的页面都会被分离，被分离的往往只有其中一部分。每个页面的大小只有4k，一个Redis实例里面一般会有成千上万的页面。  </p><p>子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么Redis的持久化交【快照】的原因。接下来子进程就可以非常安心的遍历数据进行序列化写磁盘了。</p><h2 id="AOF原理"><a href="#AOF原理" class="headerlink" title="AOF原理"></a>AOF原理</h2><p>AOF日志存储的Redis服务器的顺序指令序列，AOF日志只记录对内存进行修改的指令记录。  </p><p>假设AOF日志记录了自Redis实例创建以来所有的修改性指令序列，那么就可以通过对一个空的Redis实例顺序执行所有的指令，也就是重放来恢复Redis当前实例的内存数据结构的状态。  </p><p>Redis会在收到客户端修改指令后，进行参数校验进行逻辑处理后，如果没有问题，就立即将该指令存储到AOF日志中，也就是先执行指令才将日志存盘。这点不同于leveldb、hbase等存储引擎，他们都是先存储日志再做逻辑处理。  </p><p>Redis在长期运行的过程中，AOF的日志会变得越来越多。如果实例宕机重启，重放整个AOF日志会非常耗时，导致 长时间Redis无法对外提供服务，所以需要对AOF进行日志瘦身。</p><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>Redis提供了bgrewriteaof指令用于对AOF日志进行瘦身。其原理就是开辟一个子进程对内存进行遍历转换成一系列Redis的操作指令，序列化到一个新的AOF日志文件中。序列化完毕后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，追加完毕后就立即替换旧的日志文件。</p><h2 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h2><p>AOF日志是以文件的形式存在的，当程序对AOF日志文件进行写操作时，实际上就是内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回到磁盘。  </p><p>这意味着如果机器突然宕机，AOF日志内容可能还没来得及完全刷到磁盘，这个时候就会出现日志丢失。  </p><p>Linux的glibc提供了fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷到磁盘。只要Redis进程实时调用fsync函数就可以保证aof日志不丢失。但是fsync是一个磁盘IO操作，这意味着他很慢。如果Reids执行一条指令就要fsync一次，那么Redis的高性能地位就不保了。  </p><p>所以在生产环境的服务器中，Redis通常是每隔1s左右执行一次fsync操作，这是在数据安全性和性能之间做了一个折中，在保持高性能的同时，尽可能使得数据少丢失。  </p><p>Redis提供了另外两种策略：永不fsync（让操作系统来决定何时同步磁盘），用一个指令就fsync一次（非常慢，基本不会在生产中使用）</p><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><p>快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。<br>1、遍历整个内存，大块写磁盘会加重系统负载。<br>2、AOF的fsync是一个比较耗时的IO操作，它会降低Redis性能，同时也会增加系统IO负担。  </p><p>所以通常Redis的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源比较充沛。  </p><p>但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，所以在生产环境要做好实例监控工作，保证网络畅通或者能快速修复。另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失。</p><h2 id="Redis4-0混合持久化"><a href="#Redis4-0混合持久化" class="headerlink" title="Redis4.0混合持久化"></a>Redis4.0混合持久化</h2><p>重启Redis时，我们很少使用rdb来恢复内存状态，因为会丢失大量数据。我们通常使用AOF日志重做，但是重放AOF日志性能相对RDB来说要慢很多，这样在Redis实例很大的情况下，启动需要花费很长的时间。  </p><p>Redis4.0为了解决这个问题，带来了一个新的持久化选项–混合持久化。将RDB文件的内容和增量的AOF日志文件存在一起。这里的AOF日志不在是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量AOF日志，通常这部分AOF日志很小。  </p><p>于是在Redis重启的时候，可以先加载rdb的内容，然后再重放增量AOF日志就可以完全替代之前的AOF全量文件重放，重启效率大幅度提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证Redis的数据不会因为故障而丢失，这种机制就是Redis的持久化机制。  &lt;/p&gt;
&lt;p&gt;Redis的持久化机制有两种，第一种就是快照（RDB文件），第二种就是AOF日志。快照是一次全量备份，AOF日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而AOF日志记录的是内存数据修改的指令记录文本。AOF日志在长期的运行过程中会变得非常大，数据库重启时需要加载AOF日志进行指令重放，这个时间会变得无比漫长。所以需要定期进行AOF重写，给AOF文件瘦身。&lt;/p&gt;
&lt;h2 id=&quot;快照原理&quot;&gt;&lt;a href=&quot;#快照原理&quot; class=&quot;headerlink&quot; title=&quot;快照原理&quot;&gt;&lt;/a&gt;快照原理&lt;/h2&gt;&lt;p&gt;我们知道Redis是单线程程序，这个线程要同时负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写。  &lt;/p&gt;
&lt;p&gt;在服务线上请求的同时，Redis还需要进行内存快照，内存快照要求Redis必须进行文件IO操作，可文件IO操作是不能使用多路复用API。  &lt;/p&gt;
&lt;p&gt;这意味着单线程同时在服务线上的请求和吉林文件IO操作，文件IO操作会严重拖垮服务器请求的性能。还有个&lt;b&gt;重要的问题就是为了不阻塞线上的业务，就需要边持久化边响应客户端请求&lt;/b&gt;。持久化的同时，内存数据结构还在变化，比如一个大型的hash字典正在持久化，结果一个请求过来把它给删除了，还没持久化，这该怎么办？  &lt;/p&gt;
&lt;font color=&quot;red&quot;&gt;Redis使用操作系统的多进程COW（copy On Write）机制来实现快照持久化。&lt;/font&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码阅读目录</title>
    <link href="http://yoursite.com/2018/10/21/Redis/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/10/21/Redis/Redis源码阅读/</id>
    <published>2018-10-21T13:34:13.000Z</published>
    <updated>2018-10-21T15:51:50.920Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>文件</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>adlist.c 、 adlist.h</td><td style="text-align:center">双端链表数据结构的实现。</td></tr><tr><td>ae.c 、 ae.h 、 ae_epoll.c 、 ae_evport.c 、 ae_kqueue.c 、 ae_select.c</td><td style="text-align:center">事件处理器，以及各个具体实现。</td></tr><tr><td>anet.c 、 anet.h</td><td style="text-align:center">Redis 的异步网络框架，内容主要为对 socket 库的包装。</td></tr><tr><td>aof.c</td><td style="text-align:center">AOF 功能的实现。</td></tr><tr><td>asciilogo.h</td><td style="text-align:center">保存了 Redis 的 ASCII LOGO 。</td></tr><tr><td>bio.c 、 bio.h</td><td style="text-align:center">Redis 的后台 I/O 程序，用于将 I/O 操作放到子线程里面执行， 减少 I/O 操作对主线程的阻塞。</td></tr><tr><td>bitops.c</td><td style="text-align:center">二进制位操作命令的实现文件。</td></tr><tr><td>blocked.c</td><td style="text-align:center">用于实现 BLPOP 命令和 WAIT 命令的阻塞效果。</td></tr><tr><td>cluster.c 、 cluster.h</td><td style="text-align:center">Redis 的集群实现。</td></tr><tr><td>config.c 、 config.h</td><td style="text-align:center">Redis 的配置管理实现，负责读取并分析配置文件， 然后根据这些配置修改 Redis 服务器的各个选项。</td></tr><tr><td>crc16.c 、 crc64.c 、 crc64.h</td><td style="text-align:center">计算 CRC 校验和。</td></tr><tr><td>db.c</td><td style="text-align:center">数据库实现。</td></tr><tr><td>debug.c</td><td style="text-align:center">调试实现。</td></tr><tr><td>dict.c 、 dict.h</td><td style="text-align:center">字典数据结构的实现。</td></tr><tr><td>endianconv.c 、 endianconv.h</td><td style="text-align:center">二进制的大端、小端转换函数。</td></tr><tr><td>fmacros.h</td><td style="text-align:center">一些移植性方面的宏。</td></tr><tr><td>help.h</td><td style="text-align:center">utils/generate-command-help.rb 程序自动生成的命令帮助信息。</td></tr><tr><td>hyperloglog.c</td><td style="text-align:center">HyperLogLog 数据结构的实现。</td></tr><tr><td>intset.c 、 intset.h</td><td style="text-align:center">整数集合数据结构的实现，用于优化 SET 类型。</td></tr><tr><td>lzf_c.c 、 lzf_d.c 、 lzf.h 、 lzfP.h</td><td style="text-align:center">Redis 对字符串和 RDB 文件进行压缩时使用的 LZF 压缩算法的实现。</td></tr><tr><td>Makefile 、 Makefile.dep</td><td style="text-align:center">构建文件。</td></tr><tr><td>memtest.c</td><td style="text-align:center">内存测试。</td></tr><tr><td>mkreleasehdr.sh</td><td style="text-align:center">用于生成释出信息的脚本。</td></tr><tr><td>multi.c</td><td style="text-align:center">Redis 的事务实现。</td></tr><tr><td>networking.c</td><td style="text-align:center">Redis 的客户端网络操作库， 用于实现命令请求接收、发送命令回复等工作， 文件中的函数大多为 write 、 read 、 close 等函数的包装， 以及各种协议的分析和构建函数。</td></tr><tr><td>notify.c</td><td style="text-align:center">Redis 的数据库通知实现。</td></tr><tr><td>object.c</td><td style="text-align:center">Redis 的对象系统实现。</td></tr><tr><td>pqsort.c 、 pqsort.h</td><td style="text-align:center">快速排序（QuickSort）算法的实现。</td></tr><tr><td>pubsub.c</td><td style="text-align:center">发布与订阅功能的实现。</td></tr><tr><td>rand.c 、 rand.h</td><td style="text-align:center">伪随机数生成器。</td></tr><tr><td>rdb.c 、 rdb.h</td><td style="text-align:center">RDB 持久化功能的实现。</td></tr><tr><td>redisassert.h</td><td style="text-align:center">Redis 自建的断言系统。</td></tr><tr><td>redis-benchmark.c</td><td style="text-align:center">Redis 的性能测试程序。</td></tr><tr><td>redis.c</td><td style="text-align:center">负责服务器的启动、维护和关闭等事项。</td></tr><tr><td>redis-check-aof.c 、 redis-check-dump.c</td><td style="text-align:center">RDB 文件和 AOF 文件的合法性检查程序。</td></tr><tr><td>redis-cli.c</td><td style="text-align:center">Redis 客户端的实现。</td></tr><tr><td>redis.h</td><td style="text-align:center">Redis 的主要头文件，记录了 Redis 中的大部分数据结构， 包括服务器状态和客户端状态。</td></tr><tr><td>redis-trib.rb</td><td style="text-align:center">Redis 集群的管理程序。</td></tr><tr><td>release.c 、 release.h</td><td style="text-align:center">记录和生成 Redis 的释出版本信息。</td></tr><tr><td>replication.c</td><td style="text-align:center">复制功能的实现。</td></tr><tr><td>rio.c 、 rio.h</td><td style="text-align:center">Redis 对文件 I/O 函数的包装， 在普通 I/O 函数的基础上增加了显式缓存、以及计算校验和等功能。</td></tr><tr><td>scripting.c</td><td style="text-align:center">脚本功能的实现。</td></tr><tr><td>sds.c 、 sds.h</td><td style="text-align:center">SDS 数据结构的实现，SDS 为 Redis 的默认字符串表示。</td></tr><tr><td>sentinel.c</td><td style="text-align:center">Redis Sentinel 的实现。</td></tr><tr><td>setproctitle.c</td><td style="text-align:center">进程环境设置函数。</td></tr><tr><td>sha1.c 、 sha1.h</td><td style="text-align:center">SHA1 校验和计算函数。</td></tr><tr><td>slowlog.c 、 slowlog.h</td><td style="text-align:center">慢查询功能的实现。</td></tr><tr><td>solarisfixes.h</td><td style="text-align:center">针对 Solaris 系统的补丁。</td></tr><tr><td>sort.c</td><td style="text-align:center">SORT 命令的实现。</td></tr><tr><td>syncio.c</td><td style="text-align:center">同步 I/O 操作。</td></tr><tr><td>testhelp.h</td><td style="text-align:center">测试辅助宏。</td></tr><tr><td>t_hash.c 、 t_list.c 、 t_set.c、 t_string.c 、 t_zset.c</td><td style="text-align:center">定义了 Redis 的各种数据类型，以及这些数据类型的命令。</td></tr><tr><td>util.c 、 util.h</td><td style="text-align:center">各种辅助函数。</td></tr><tr><td>valgrind.sup</td><td style="text-align:center">valgrind 的suppression文件。</td></tr><tr><td>version.h</td><td style="text-align:center">记录了 Redis 的版本号。</td></tr><tr><td>ziplist.c 、 ziplist.h</td><td style="text-align:center">ZIPLIST 数据结构的实现，用于优化 LIST 类型。</td></tr><tr><td>zipmap.c 、 zipmap.h</td><td style="text-align:center">ZIPMAP 数据结构的实现，在 Redis 2.6 以前用与优化 HASH 类型， Redis 2.6 开始已经废弃。</td></tr><tr><td>zmalloc.c 、 zmalloc.h</td><td style="text-align:center">内存管理程序。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;adlist.c 、 adlist.h&lt;/td&gt;
&lt;td style=&quot;t
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理----通信协议</title>
    <link href="http://yoursite.com/2018/10/21/Redis/Redis%E5%8E%9F%E7%90%86----%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/10/21/Redis/Redis原理----通信协议/</id>
    <published>2018-10-21T11:34:13.000Z</published>
    <updated>2018-10-21T15:19:00.906Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的作者认为数据库系统的瓶颈一般不在于网络流量，而是数据库自身内部逻辑处理上。所以即使Redis使用了浪费流量的文本协议，依然可以取得极高的访问性能。Redis将所有数据都放在内存，用一个单线程对外提供服务，单个节点在跑满一个CPU核心的情况下可以达到10w/s的超高QPS。</p><h2 id="RESP"><a href="#RESP" class="headerlink" title="RESP"></a>RESP</h2><p>RESP（Redis Serialization Protocol）是Redis序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简单，解析性能极好。</p><p>Redis歇息将传输的数据结构分为5种最小单元类型，单元结束时统一加上回车换行符号\r\n。  </p><ul><li>单行字符以<font color="red">+</font>符号开头</li><li>多行字符以<font color="red">$</font>符号开头，后跟字符串长度</li><li>整数值以<font color="red">：</font>符号开头，后跟整数的字符串形式</li><li>错误消息以<font color="red">-</font>符号开头</li><li>数组以<font color="red">*</font>符号开头，后跟数组的长度</li></ul><p>单行字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+hello world\r\n</div></pre></td></tr></table></figure></p><p>多行字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$11\r\n  </div><div class="line">hello world\r\n</div></pre></td></tr></table></figure></p><p>整数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:1024\r\n</div></pre></td></tr></table></figure></p><p>错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-WRONGTYPE Operation ....</div></pre></td></tr></table></figure></p><p>数组[1,2,3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*3\r\n  </div><div class="line">:1\r\n</div><div class="line">:2\r\n  </div><div class="line">:3\r\n</div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="客户端-gt-服务器"><a href="#客户端-gt-服务器" class="headerlink" title="客户端-&gt;服务器"></a>客户端-&gt;服务器</h2><p>客户端向服务器发送的指令只有一种格式，多行字符串数组。比如一个简单的set指令set k v会被序列化成以下字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">*3\r\n  </div><div class="line">$3\r\n  </div><div class="line">set\r\n</div><div class="line">$1\r\n</div><div class="line">k\r\n</div><div class="line">$1\r\n</div><div class="line">v\r\n</div></pre></td></tr></table></figure></p><h2 id="服务器-gt-客户端"><a href="#服务器-gt-客户端" class="headerlink" title="服务器-&gt;客户端"></a>服务器-&gt;客户端</h2><p>服务器向客户端恢复的响应要支持多种数据结构，所以消息响应在结构上要复杂不少。不过在复杂的响应消息也是以上的5种基本类型的组合。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redis协议里有大量冗余的回车换行符，但是这并不影响它成为互联网技术领域非常受欢迎的一个文本歇息。有很多开源项目目前使用RESP作为它的通讯协议。在技术领域性能并不是一切，还有简单性、易理解性和易实现性，这些都是需要进行适当权衡的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的作者认为数据库系统的瓶颈一般不在于网络流量，而是数据库自身内部逻辑处理上。所以即使Redis使用了浪费流量的文本协议，依然可以取得极高的访问性能。Redis将所有数据都放在内存，用一个单线程对外提供服务，单个节点在跑满一个CPU核心的情况下可以达到10w/s的超高QPS。&lt;/p&gt;
&lt;h2 id=&quot;RESP&quot;&gt;&lt;a href=&quot;#RESP&quot; class=&quot;headerlink&quot; title=&quot;RESP&quot;&gt;&lt;/a&gt;RESP&lt;/h2&gt;&lt;p&gt;RESP（Redis Serialization Protocol）是Redis序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简单，解析性能极好。&lt;/p&gt;
&lt;p&gt;Redis歇息将传输的数据结构分为5种最小单元类型，单元结束时统一加上回车换行符号\r\n。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单行字符以&lt;font color=&quot;red&quot;&gt;+&lt;/font&gt;符号开头&lt;/li&gt;
&lt;li&gt;多行字符以&lt;font color=&quot;red&quot;&gt;$&lt;/font&gt;符号开头，后跟字符串长度&lt;/li&gt;
&lt;li&gt;整数值以&lt;font color=&quot;red&quot;&gt;：&lt;/font&gt;符号开头，后跟整数的字符串形式&lt;/li&gt;
&lt;li&gt;错误消息以&lt;font color=&quot;red&quot;&gt;-&lt;/font&gt;符号开头&lt;/li&gt;
&lt;li&gt;数组以&lt;font color=&quot;red&quot;&gt;*&lt;/font&gt;符号开头，后跟数组的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单行字符&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;+hello world\r\n&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;多行字符串&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$11\r\n  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;hello world\r\n&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;整数&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;:1024\r\n&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;错误&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;-WRONGTYPE Operation ....&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;数组[1,2,3]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;*3\r\n  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;:1\r\n&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;:2\r\n  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;:3\r\n&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理----线程IO模型</title>
    <link href="http://yoursite.com/2018/10/20/Redis/Redis%E5%8E%9F%E7%90%86----%E7%BA%BF%E7%A8%8BIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/10/20/Redis/Redis原理----线程IO模型/</id>
    <published>2018-10-20T11:34:13.000Z</published>
    <updated>2018-10-20T15:45:50.396Z</updated>
    
    <content type="html"><![CDATA[<p><b>Redis是一个单线程程序</b></p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>当我们调用套接字的读写方法，默认他们是阻塞的，比如read方法要传递一个参数n，表示最多读取这门多字节后返回，如果一个字节都没有，那么线程就会卡在那里，直到新的数据到来或者连接关闭，read方法才可以返回，线程才能够继续处理。而write方法一般来说不会阻塞，除非内核为套接字分配的写缓冲区已经写满了，write方法才会阻塞，直到缓冲区有空闲空间。<img src="https://i.imgur.com/0sE9kXD.png" alt=""><br>非阻塞IO在套接字对象上提供了一个选项Non_Blocking,当这个选项打开时，读写方法不会阻塞。能读多少取决于内核为套接字分配的读缓冲区的空闲空间字节数，能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数。读方法和写方法都会通过返回值来告知程序实际读写了多少字节。</p><h2 id="事件轮询（多路复用）"><a href="#事件轮询（多路复用）" class="headerlink" title="事件轮询（多路复用）"></a>事件轮询（多路复用）</h2><p>非阻塞IO有个问题，就是线程要读数据，但是读了一部分就返回了，线程如何知道什么时候应该继续读，也就是当数据到来时，线程如何得到通知。写也是一样。<img src="https://i.imgur.com/bxF8jbN.png" alt=""><br>事件轮询API就是用来解决这个问题的，最简单的时间轮询API是select函数，它是操作系统提供给用户程序的API。输入时读写描述符列表read_fds &amp; write_fds，输出是与之对应的可读可写时间。同时还提供了一个timeout参数，如果没有任何事件的到来，那么最多等待timeout时间，线程处于阻塞状态。一旦期间有事件到来，就可以立即返回。线程就可以继续挨个处理相应的事件。处理完了继续过来轮询。于是线程就进入了一个死循环。我们把这个死循环称为事件轮询，一个循环为一个周期。<br><b>事件轮询API就是Java语言中的NIO技术</b></p><h2 id="指令队列"><a href="#指令队列" class="headerlink" title="指令队列"></a>指令队列</h2><p>Redis会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。</p><h2 id="响应队列"><a href="#响应队列" class="headerlink" title="响应队列"></a>响应队列</h2><p>Redis同样会为每个客户端套接字关联一个响应队列。<br>Redis服务器通过响应队列来将指令的返回结果回复给客户端。如果队列为空，那么以为这连接暂时处于空闲状态，不需要去获取写事件，也就是可以将当前的客户端描述符从write_fds里面移除。等到队列有数据了，再将描述符放进去。避免select系统调用立即返回写事件，结果发现没什么数据可以写。<b>出现这种情况的线程会飙高CPU</b></p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>服务器处理要响应的IO事件外，还要处理其他事情。比如定时任务。<br>如果线程阻塞在select系统调用上，定时任务将无法得到准时调度。那么Redis是如何解决这个问题的呢？  </p><p>Redis的定时任务会记录在一个最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是select系统调用的timeout参数。因为Redis知道未来timeout时间内，没有其他定时任务需要处理，所以可以安心睡眠timeout时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;b&gt;Redis是一个单线程程序&lt;/b&gt;&lt;/p&gt;
&lt;h2 id=&quot;非阻塞IO&quot;&gt;&lt;a href=&quot;#非阻塞IO&quot; class=&quot;headerlink&quot; title=&quot;非阻塞IO&quot;&gt;&lt;/a&gt;非阻塞IO&lt;/h2&gt;&lt;p&gt;当我们调用套接字的读写方法，默认他们是阻塞的，比如read方
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>reset master和reset slave</title>
    <link href="http://yoursite.com/2018/09/23/mysql/reset%20master%E5%92%8Crester%20slave/"/>
    <id>http://yoursite.com/2018/09/23/mysql/reset master和rester slave/</id>
    <published>2018-09-23T08:11:15.000Z</published>
    <updated>2018-10-30T12:11:26.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="reset-master"><a href="#reset-master" class="headerlink" title="reset master"></a>reset master</h3><p>删除index file中记录的所有binlog文件，将日志索引文件清空，创建一个新的日志文件，这个命令通常用于第一次搭建主从关系的主库。  </p><h4 id="reset-master和purge-binary-log的区别"><a href="#reset-master和purge-binary-log的区别" class="headerlink" title="reset master和purge binary log的区别"></a>reset master和purge binary log的区别</h4><ol><li>reset master 删除日志索引文件中记录的所有binlog文件，重新建立一个新的日志文件，起始值从000001开始，purge binary log 命令不会修改记录binlog顺序的数值</li><li>reset master 不能用于有任何slave正在运行的主从关系的主库。因为在slave运行时刻reset master命令不被支持。从库此时会报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">In MySQL 5.6.5 and later, RESET MASTER also clears the values of the gtid_purged system variable (known as gtid_lost in MySQL 5.6.8 and earlier) as well as the global value of the gtid_executed (gtid_done, prior to MySQL 5.6.9) system variable (but not its session value); that is, executing this statement sets each of these values to an empty string (&apos;&apos;)</div></pre></td></tr></table></figure></li></ol><h3 id="reset-slave"><a href="#reset-slave" class="headerlink" title="reset slave"></a>reset slave</h3><p>reset slave 将使slave忘记主从复制关系的位置信息。该语句用于干净的启动，它删除master.info文件和relay-log.info文件以及所有的relay log文件并重新启用一个新的relay-log文件。</p><h3 id="reset-slave-all"><a href="#reset-slave-all" class="headerlink" title="reset slave all"></a>reset slave all</h3><p>在 5.6 版本中 reset slave 并不会清理存储于内存中的复制信息比如  master host, master port, master user, or master password,也就是说如果没有使用change master 命令做重新定向，执行start slave 还是会指向旧的master 上面。<br>当从库执行reset slave之后,将mysqld shutdown 复制参数将被重置。<br>在5.6.3 版本以及以后 使用使用 RESET SLAVE ALL 来完全的清理复制连接参数信息。(Bug #11809016)<br>RESET SLAVE ALL does not clear the IGNORE_SERVER_IDS list set by CHANGE MASTER TO. This issue is fixed in MySQL 5.7. (Bug #18816897)<br>In MySQL 5.6.7 and later, RESET SLAVE causes an implicit commit of an ongoing transaction. See Section 13.3.3, “Statements That Cause an Implicit Commit”.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;reset-master&quot;&gt;&lt;a href=&quot;#reset-master&quot; class=&quot;headerlink&quot; title=&quot;reset master&quot;&gt;&lt;/a&gt;reset master&lt;/h3&gt;&lt;p&gt;删除index file中记录的所有binlog文件，将日志
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>python装饰器</title>
    <link href="http://yoursite.com/2018/08/19/python/python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2018/08/19/python/python装饰器/</id>
    <published>2018-08-19T13:40:56.000Z</published>
    <updated>2018-08-19T14:08:06.739Z</updated>
    
    <content type="html"><![CDATA[<p>python装饰器就是用于<font color="red">扩展原来函数功能的一种函数</font>，这个函数的特殊之处在于它的返回值也是一个函数。使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原函数</div><div class="line">def func():</div><div class="line">print(&quot;hello&quot;)</div></pre></td></tr></table></figure></p><p>要想扩展一个函数的功能，最简单的方法就是直接修改原函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def func():</div><div class="line">print(&quot;before&quot;)</div><div class="line">print(&quot;hello&quot;)</div><div class="line">print(&quot;after&quot;)</div></pre></td></tr></table></figure></p><p>如果不想修改原函数，还是想增强函数的功能时，可以另外定义一个函数调用原函数。（类似于设计模式中的装饰模式，有组合和代理两种方式）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def deco(func):</div><div class="line">print(&quot;before&quot;)</div><div class="line">func()</div><div class="line">print(&quot;after&quot;)</div><div class="line"></div><div class="line">def func():</div><div class="line">print(&quot;hello&quot;)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    f = func</div><div class="line">    deco(f)#只有把func()或者f()作为参数执行，新加入功能才会生效</div><div class="line">    print(&quot;f.__name__ is&quot;,f.__name__)#f的name就是func()</div><div class="line">    print()</div><div class="line">    #func()</div></pre></td></tr></table></figure></p><p>但是如果存在很多个类似于func的函数需要相同的扩展，那岂不是要执行deco函数许多次？<br>下面我们实现一个最简陋的装饰器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def deco(func):</div><div class="line">def wrapper(*args, **kwargs):</div><div class="line">print(&quot;before&quot;)</div><div class="line">func(*args, **kwargs)</div><div class="line">print(&quot;after&quot;)</div><div class="line">return wrapper</div><div class="line"></div><div class="line">@deco</div><div class="line">def func():</div><div class="line">print(&quot;hello&quot;)</div></pre></td></tr></table></figure></p><p>这里的deco函数就是最原始的装饰器，它的参数是一个函数，然后返回值也是一个函数。其中作为参数的这个函数func()就在返回函数wrapper()的内部执行。然后在函数func()前面加上@deco。<br>所以这里装饰器就像一个注入符号：有了它，拓展了原来函数的功能既不需要侵入函数内更改代码，也不需要重复执行原函数。<br>在func函数前还可以使用多个@的方式来执行多个装饰器，多个装饰器的执行顺序就是从最后一个装饰器开始执行到第一个装饰器，在执行函数本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">def dec1(func):  </div><div class="line">    print(&quot;1111&quot;)  </div><div class="line">    def one():  </div><div class="line">        print(&quot;2222&quot;)  </div><div class="line">        func()  </div><div class="line">        print(&quot;3333&quot;)  </div><div class="line">    return one  </div><div class="line"></div><div class="line">def dec2(func):  </div><div class="line">    print(&quot;aaaa&quot;)  </div><div class="line">    def two():  </div><div class="line">        print(&quot;bbbb&quot;)  </div><div class="line">        func()  </div><div class="line">        print(&quot;cccc&quot;)  </div><div class="line">    return two  </div><div class="line"></div><div class="line">@dec1  </div><div class="line">@dec2  </div><div class="line">def test():  </div><div class="line">    print(&quot;test test&quot;)  </div><div class="line"></div><div class="line">test()  </div><div class="line"></div><div class="line">aaaa  </div><div class="line">1111  </div><div class="line">2222  </div><div class="line">bbbb  </div><div class="line">test test  </div><div class="line">cccc  </div><div class="line">3333</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python装饰器就是用于&lt;font color=&quot;red&quot;&gt;扩展原来函数功能的一种函数&lt;/font&gt;，这个函数的特殊之处在于它的返回值也是一个函数。使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>innobackupex的备份和恢复</title>
    <link href="http://yoursite.com/2018/08/17/mysql/innobackupex%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2018/08/17/mysql/innobackupex的备份和恢复/</id>
    <published>2018-08-17T03:05:58.000Z</published>
    <updated>2018-08-19T14:09:58.649Z</updated>
    
    <content type="html"><![CDATA[<p>还原分为3个阶段：backup（备份）、prepare（预恢复）、restore（恢复）  </p><p>首先复制所有的innodb数据文件，这样复制出来的文件肯定是不一致的，然后对每个文件进行崩溃恢复处理，最终达到一致。  </p><p>XtraBackup在启动的时候会记录一个LSN（log sequence number)，然后就把所有的innodb数据文件复制出来，这样复制出来的数据文件是不一致的。但是XtraBackup会在后台运行一个进程把所有对redo log file的修改记录下来。</p><p>以上步骤完成后innobackupex就会去备份MyIsam表和.frm文件，这时要保证数据的一致性就会先锁表，通过FLUSH TABLES WITH READ LOCK命令锁表后把文件复制出来，再释放掉这个锁。</p><p>在恢复数据的时候，要经过prepare和restore两个步骤。在prepare结束以后，innodb的表恢复到了复制innodb文件结束的时间点，这个时间点也就是锁表复制MyIsam表的起点，所以最终数据是一致的。一般我们在恢复的时候执行了两次prepare，是因为第二次prepare会帮助我们生成redo log文件，从而加快MySQL数据库启动的速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还原分为3个阶段：backup（备份）、prepare（预恢复）、restore（恢复）  &lt;/p&gt;
&lt;p&gt;首先复制所有的innodb数据文件，这样复制出来的文件肯定是不一致的，然后对每个文件进行崩溃恢复处理，最终达到一致。  &lt;/p&gt;
&lt;p&gt;XtraBackup在启动的时
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysqldump和mysqlbinlog</title>
    <link href="http://yoursite.com/2018/08/16/mysql/mysqldump/"/>
    <id>http://yoursite.com/2018/08/16/mysql/mysqldump/</id>
    <published>2018-08-16T15:49:08.000Z</published>
    <updated>2018-08-16T16:19:53.493Z</updated>
    
    <content type="html"><![CDATA[<p>mysqldump常用于MySQL数据库逻辑备份</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>1、mysqldump -uroot -p [–all-databases] [database name] &gt; [dump file]<br>上述命令会将制定数据库备份到某dump文件（转储文件）中，生成的dump文件中包含建表语句（生成数据库结构）和插入数据的insert语句。<br>2、如果加上–opt参数  </p><ul><li>建表语句中包含drop table if exists tableName  </li><li>inert之前包含一个锁表语句lock tables tableName write,insert之后包含unlock tables<br>3、mysqldump –host=host1 –opt sourceDb|mysql –host=host2 -C targetDb<br>使用以上命令可以将host1上的sourceDb复制到host2的targetDb，前提是目标主机的targetDb已经创建。<br>4、使用–no-data将只备份表结构。<br>5、mysql [database name] &lt; [backup file name]从备份文件恢复到数据库  <a id="more"></a><h3 id="mysqldump全量备份-mysqlbinlog二进制日志增量备份"><a href="#mysqldump全量备份-mysqlbinlog二进制日志增量备份" class="headerlink" title="mysqldump全量备份+mysqlbinlog二进制日志增量备份"></a>mysqldump全量备份+mysqlbinlog二进制日志增量备份</h3>从mysqldump备份文件恢复数据会丢失掉从备份点开始的更新数据，所以还需要结合mysqlbinlog二进制日志增量备份。确保已启动二进制文件。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">log-bin = mysql-bin</div></pre></td></tr></table></figure></li></ul><p>mysqldump命令必须带上–flush-logs选项生成新的二进制文件<br>mysqldump –single-transaction –flush-logs –master-data &gt; backup.sql<br>那么在恢复时先导入mysqldump的全量备份后，再导入mysqlbinlog二进制日志的增量备份。<br>此外，mysqlbinlog还可以指定–start-data、–stop-date、–start-position和–stop-position参数，用于精确恢复数据到某个时刻之前或者跳过中间某个出问题时间段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">5.9.3.1. 指定恢复时间</div><div class="line">对于MySQL 4.1.4，可以在mysqlbinlog语句中通过--start-date和--stop-date选项指定DATETIME格式的起止时间。举例说明，假设在今天上午10:00(今天是2005年4月20日)，执行SQL语句来删除一个大表。要想恢复表和数据，你可以恢复前晚上的备份，并输入：</div><div class="line">mysqlbinlog --stop-date=&quot;2005-04-20 9:59:59&quot; /var/log/mysql/bin.123456 \</div><div class="line">     | mysql -u root -pmypwd</div><div class="line">该命令将恢复截止到在--stop-date选项中以DATETIME格式给出的日期和时间的所有数据。如果你没有检测到几个小时后输入的错误的SQL语句，可能你想要恢复后面发生的活动。根据这些，你可以用起使日期和时间再次运行mysqlbinlog：</div><div class="line"></div><div class="line">mysqlbinlog --start-date=&quot;2005-04-20 10:01:00&quot; /var/log/mysql/bin.123456 \</div><div class="line">     | mysql -u root -pmypwd \</div><div class="line">在该行中，从上午10:01登录的SQL语句将运行。组合执行前夜的转储文件和mysqlbinlog的两行可以将所有数据恢复到上午10:00前一秒钟。你应检查日志以确保时间确切。下一节介绍如何实现。</div><div class="line"></div><div class="line">5.9.3.2. 指定恢复位置</div><div class="line">也可以不指定日期和时间，而使用mysqlbinlog的选项--start-position和--stop-position来指定日志位置。它们的作用与起止日选项相同，不同的是给出了从日志起的位置号。使用日志位置是更准确的恢复方法，特别是当由于破坏性SQL语句同时发生许多事务的时候。要想确定位置号，可以运行mysqlbinlog寻找执行了不期望的事务的时间范围，但应将结果重新指向文本文件以便进行检查。操作方法为：</div><div class="line">mysqlbinlog --start-date=&quot;2005-04-20 9:55:00&quot; --stop-date=&quot;2005-04-20 10:05:00&quot; \</div><div class="line">      /var/log/mysql/bin.123456 &gt; /tmp/mysql_restore.sql</div><div class="line">该命令将在/tmp目录创建小的文本文件，将显示执行了错误的SQL语句时的SQL语句。你可以用文本编辑器打开该文件，寻找你不要想重复的语句。如果二进制日志中的位置号用于停止和继续恢复操作，应进行注释。用log_pos加一个数字来标记位置。使用位置号恢复了以前的备份文件后，你应从命令行输入下面内容：</div><div class="line"></div><div class="line">mysqlbinlog --stop-position=&quot;368312&quot; /var/log/mysql/bin.123456 \</div><div class="line">    | mysql -u root -pmypwd </div><div class="line"> </div><div class="line">mysqlbinlog --start-position=&quot;368315&quot; /var/log/mysql/bin.123456 \</div><div class="line">    | mysql -u root -pmypwd \ </div><div class="line">上面的第1行将恢复到停止位置为止的所有事务。下一行将恢复从给定的起始位置直到二进制日志结束的所有事务。因为mysqlbinlog的输出包括每个SQL语句记录之前的SET TIMESTAMP语句，恢复的数据和相关MySQL日志将反应事务执行的原时间。</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysqldump常用于MySQL数据库逻辑备份&lt;/p&gt;
&lt;h3 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h3&gt;&lt;p&gt;1、mysqldump -uroot -p [–all-databases] [database name] &amp;gt; [dump file]&lt;br&gt;上述命令会将制定数据库备份到某dump文件（转储文件）中，生成的dump文件中包含建表语句（生成数据库结构）和插入数据的insert语句。&lt;br&gt;2、如果加上–opt参数  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建表语句中包含drop table if exists tableName  &lt;/li&gt;
&lt;li&gt;inert之前包含一个锁表语句lock tables tableName write,insert之后包含unlock tables&lt;br&gt;3、mysqldump –host=host1 –opt sourceDb|mysql –host=host2 -C targetDb&lt;br&gt;使用以上命令可以将host1上的sourceDb复制到host2的targetDb，前提是目标主机的targetDb已经创建。&lt;br&gt;4、使用–no-data将只备份表结构。&lt;br&gt;5、mysql [database name] &amp;lt; [backup file name]从备份文件恢复到数据库
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制</title>
    <link href="http://yoursite.com/2018/08/16/mysql/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/16/mysql/MySQL主从复制/</id>
    <published>2018-08-16T07:11:15.000Z</published>
    <updated>2018-08-16T13:31:07.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h3><p>将主数据库中的DDL和DML操作通过二进制日志文件传输到从数据库上，然后将这些日志重新执行（重做）；从而使从数据库的数据和主数据库的数据保持一致。</p><h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ul><li>主数据库出现问题时，可以切换到从数据库</li><li>可以在数据库层面进行读写分离</li><li>可以在从数据库上进行备份操作</li></ul><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p><img src="http://ocx5m3vc3.bkt.clouddn.com/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt=""><br>Binary log：主数据库的二进制文件<br>Relay log：从服务器的中继日志<br><a id="more"></a></p><ol><li>master在每个事物更新数据完成之前，将该操作记录串行地写入binlog文件中。</li><li>salve开启一个I/O线程，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的时间。I/O线程最终的目的是将这些事件写入到中继日志中。</li><li>SQL线程会读取中继日志，并顺序执行该日志中的SQL时间，从而与主数据库中的数据保持一致。</li></ol><h3 id="配置主从"><a href="#配置主从" class="headerlink" title="配置主从"></a>配置主从</h3><p>一、主服务器</p><ul><li>开启二进制日志</li><li>配置唯一的server-id</li><li>创建一个用于slave和master通信的用户账号</li><li>获得master二进制日志文件名及位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">skip-name-resolve</div><div class="line">basedir = /home/huzb/mysql</div><div class="line">datadir = /home/huzb/mysql/data</div><div class="line">port = 23307</div><div class="line">server_id = 119961011</div><div class="line">socket = /home/huzb/mysql/mysql_23307.sock</div><div class="line">log-bin = master-bin</div><div class="line">log-bin-index = master-bin.index</div><div class="line"> </div><div class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</div><div class="line"> </div><div class="line">[client]</div><div class="line">port = 23307</div><div class="line">socket = /home/huzb/mysql/mysql_23307.sock</div></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#添加复制权限的用户</div><div class="line"></div><div class="line">mysql&gt; CREATE USER &apos;repl&apos;@&apos;100.73.41.62&apos; IDENTIFIED BY &apos;slavepass&apos;;</div><div class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;100.73.41.62&apos;;</div><div class="line"></div><div class="line">mysql&gt; flush privileges;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#查看master状态</div><div class="line"></div><div class="line">mysql&gt; show master status;</div></pre></td></tr></table></figure><p>二、从服务器：</p><ul><li>配置唯一的server-id</li><li>使用master分配的用户账号读取master二进制日志</li><li>启动slave服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">skip-name-resolve</div><div class="line">basedir = /home/huzb/mysql</div><div class="line">datadir = /home/huzb/mysql/data</div><div class="line">port = 23306</div><div class="line">server_id = 220180801</div><div class="line">socket = /home/huzb/mysql/mysql_23306.sock</div><div class="line">relay-log = slave-relay-bin</div><div class="line">relay-log-index = slave-relay-bin.index</div><div class="line"> </div><div class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</div><div class="line"> </div><div class="line">[client]</div><div class="line">port = 23306</div><div class="line">socket = /home/huzb/mysql/mysql_23306.sock</div></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#添加master信息</div><div class="line"></div><div class="line">mysql&gt; CHANGE MASTER TO</div><div class="line"></div><div class="line">MASTER_HOST=&apos;100.73.41.53&apos;,</div><div class="line">MASTER_PORT=23307,</div><div class="line">MASTER_USER=&apos;repl&apos;,</div><div class="line">MASTER_PASSWORD=&apos;slavepass&apos;,</div><div class="line">MASTER_LOG_FILE=&apos;master-bin.000001&apos;,</div><div class="line">MASTER_LOG_POS=629;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#启动slave进程</div><div class="line"></div><div class="line">mysql&gt; start slave;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#查看slave状态</div><div class="line"></div><div class="line">当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是主从复制&quot;&gt;&lt;a href=&quot;#什么是主从复制&quot; class=&quot;headerlink&quot; title=&quot;什么是主从复制&quot;&gt;&lt;/a&gt;什么是主从复制&lt;/h3&gt;&lt;p&gt;将主数据库中的DDL和DML操作通过二进制日志文件传输到从数据库上，然后将这些日志重新执行（重做）；从而使从数据库的数据和主数据库的数据保持一致。&lt;/p&gt;
&lt;h3 id=&quot;主从复制的作用&quot;&gt;&lt;a href=&quot;#主从复制的作用&quot; class=&quot;headerlink&quot; title=&quot;主从复制的作用&quot;&gt;&lt;/a&gt;主从复制的作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主数据库出现问题时，可以切换到从数据库&lt;/li&gt;
&lt;li&gt;可以在数据库层面进行读写分离&lt;/li&gt;
&lt;li&gt;可以在从数据库上进行备份操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;复制过程&quot;&gt;&lt;a href=&quot;#复制过程&quot; class=&quot;headerlink&quot; title=&quot;复制过程&quot;&gt;&lt;/a&gt;复制过程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ocx5m3vc3.bkt.clouddn.com/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Binary log：主数据库的二进制文件&lt;br&gt;Relay log：从服务器的中继日志&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之备份</title>
    <link href="http://yoursite.com/2018/08/11/mysql/MySQL%E4%B9%8B%E5%A4%87%E4%BB%BD/"/>
    <id>http://yoursite.com/2018/08/11/mysql/MySQL之备份/</id>
    <published>2018-08-11T08:11:15.000Z</published>
    <updated>2018-08-19T09:13:30.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备份的类型"><a href="#备份的类型" class="headerlink" title="备份的类型"></a>备份的类型</h2><h3 id="根据是否需要数据库离线"><a href="#根据是否需要数据库离线" class="headerlink" title="根据是否需要数据库离线"></a>根据是否需要数据库离线</h3><p>1、取决于业务的需求，而不是备份工具。<br>2、MyISAM不支持热备，INNODB支持热备，但是需要专门的工具。  </p><ul><li>冷备：需要关闭mysql服务，读写请求均不支持    状态下进行。</li><li>温备：服务在线，但仅支持读请求，不允许写请求。</li><li>热备：备份的同时，业务不受影响。</li></ul><h3 id="根据备份的数据集合的范围"><a href="#根据备份的数据集合的范围" class="headerlink" title="根据备份的数据集合的范围"></a>根据备份的数据集合的范围</h3><ul><li>完全备份：备份全部字符集。</li><li>增量备份：上一次完全备份或增量备份以来改变的数据。</li><li>差异备份：上一次完全备份以来改变的数。</li></ul><h3 id="根据备份数据或文件"><a href="#根据备份数据或文件" class="headerlink" title="根据备份数据或文件"></a>根据备份数据或文件</h3><ul><li>物理备份：直接备份数据文件。</li><li>逻辑备份：备份表中的数据和代码。<a id="more"></a></li></ul><h2 id="常用的备份工具"><a href="#常用的备份工具" class="headerlink" title="常用的备份工具"></a>常用的备份工具</h2><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>mysqldump是逻辑备份，所以使用这种备份方式数据的安全的。跨平台、版本都很容易。  </p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>mysqldump的优势是可以查看或者编辑十分方面，他可以灵活的恢复之前的数据。它也不关心底层的存储引擎，即适用于支持事务的，也适用于不支持事务的的表。  </p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>mysql的缺点是如果数据过大，即使备份步骤需要的时间不算太久，但有可能恢复数据的速度很慢，因为他涉及的SQL语句插入磁盘IO，创建索引等。</p><h3 id="mysqlhotcopy"><a href="#mysqlhotcopy" class="headerlink" title="mysqlhotcopy"></a>mysqlhotcopy</h3><p>mysqlhotcopy使用lock tables、flush tables、cp和scp来快速备份数据库。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>它是备份数据库或单个表最快的途径，完全属于物理备份。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>只能用于备份MyIsam和archive存储引擎；并且是一个服务器命令，只能运行在数据库目录所在的机器上。使用mysqlhotcopy命令之前需要安装相应的软件依赖包。</p><h3 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h3><p>Percona XtraBackup是一款基于MySQL的物理热备份的开源实用程序。xtrabackup基于innodb的crash-recovery（实例恢复）功能，先copy innodb的物理文件（这个时候数据的一致性是无法满足的），然后进行基于redo log进行恢复，达到数据的一致性。</p><h3 id="mysqlbackup"><a href="#mysqlbackup" class="headerlink" title="mysqlbackup"></a>mysqlbackup</h3><p>首先检测并应用全备事务日志文件，然后基于全备去应用增量的log。这个时候如果有多次增量备份也可以（基于LSN点向后应用）。所有的的应用完成之后就是一个可以直接cp的数据库了。</p><h2 id="备份和恢复的实现"><a href="#备份和恢复的实现" class="headerlink" title="备份和恢复的实现"></a>备份和恢复的实现</h2><ol><li>使用select into outfile实现数据的备份和还原。<br>1.1 把需要备份的数据备份出来<br>select * from test into outfile ‘/tmp/out.txt’;<br>1.2 导入<br>load data infile ‘/tmp/out.txt’ into table XXX;</li><li>利用mysqldump工具对数据进行备份和还原<br>mysqldump常用来做温备，所以需要对想备份的数据施加读锁。<br>2.1 施加读锁的方式：<br>2.1.1 直接在备份时添加选项<br>–lock-all-tables：对要备份的数据库的所有表施加读锁。<br>–lock-table：对单表施加读锁。<br>2.1.2 在服务端书写命令<br>mysql&gt;flush tables with read lock;施加锁，表示把内存上的表统统同步到磁盘上去后施加读锁。<br>mysql&gt;flush tables with read unlock;释放锁。<br>2.2 备份策略：完全备份+增量备份+二进制文件。</li></ol><ul><li>先给数据库做全量备份</li><li>回到mysql服务器更新数据</li><li>做增量备份</li><li>到处二进制文件</li><li>让mysql离线</li></ul><ol><li>利用lvm快照实现几乎热备的数据备份和恢复</li><li>基于Xtrabackup做备份恢复<br>优势：</li></ol><ul><li>快速可靠的进行完全备份</li><li>在备份过程中会影响事务</li><li>支持数据流、网络传输、压缩，所以它可以有效的节约磁盘资源和网络带宽。</li><li>可以自动备份校验数据的可用性。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;备份的类型&quot;&gt;&lt;a href=&quot;#备份的类型&quot; class=&quot;headerlink&quot; title=&quot;备份的类型&quot;&gt;&lt;/a&gt;备份的类型&lt;/h2&gt;&lt;h3 id=&quot;根据是否需要数据库离线&quot;&gt;&lt;a href=&quot;#根据是否需要数据库离线&quot; class=&quot;headerlink&quot; title=&quot;根据是否需要数据库离线&quot;&gt;&lt;/a&gt;根据是否需要数据库离线&lt;/h3&gt;&lt;p&gt;1、取决于业务的需求，而不是备份工具。&lt;br&gt;2、MyISAM不支持热备，INNODB支持热备，但是需要专门的工具。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冷备：需要关闭mysql服务，读写请求均不支持    状态下进行。&lt;/li&gt;
&lt;li&gt;温备：服务在线，但仅支持读请求，不允许写请求。&lt;/li&gt;
&lt;li&gt;热备：备份的同时，业务不受影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;根据备份的数据集合的范围&quot;&gt;&lt;a href=&quot;#根据备份的数据集合的范围&quot; class=&quot;headerlink&quot; title=&quot;根据备份的数据集合的范围&quot;&gt;&lt;/a&gt;根据备份的数据集合的范围&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;完全备份：备份全部字符集。&lt;/li&gt;
&lt;li&gt;增量备份：上一次完全备份或增量备份以来改变的数据。&lt;/li&gt;
&lt;li&gt;差异备份：上一次完全备份以来改变的数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;根据备份数据或文件&quot;&gt;&lt;a href=&quot;#根据备份数据或文件&quot; class=&quot;headerlink&quot; title=&quot;根据备份数据或文件&quot;&gt;&lt;/a&gt;根据备份数据或文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;物理备份：直接备份数据文件。&lt;/li&gt;
&lt;li&gt;逻辑备份：备份表中的数据和代码。
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之权限管理</title>
    <link href="http://yoursite.com/2018/08/11/mysql/Mysql%E4%B9%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/11/mysql/Mysql之权限管理/</id>
    <published>2018-08-11T07:11:15.000Z</published>
    <updated>2018-08-16T02:48:27.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、MySQL权限简介"><a href="#一、MySQL权限简介" class="headerlink" title="一、MySQL权限简介"></a>一、MySQL权限简介</h2><p>关于mysql的权限简单的理解就是mysql允许你做你权利以内的事情，不可以越界。</p><h3 id="mysql权限控制的实现"><a href="#mysql权限控制的实现" class="headerlink" title="mysql权限控制的实现"></a>mysql权限控制的实现</h3><p>第一阶段：服务器首先会检查你是否允许连接。因为创建用户的时候会加上主机限制，可以限制成本地、IP、网段、任何地方等。只允许你从配置的指定地方登陆。<br>第二阶段：Mysql会检查你发出的每个请求，看你是否有足够的权限实施它。</p><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">权限级别</th><th style="text-align:center">权限说明</th></tr></thead><tbody><tr><td style="text-align:center">CREATE</td><td style="text-align:center">数据库、表或索引</td><td style="text-align:center">创建</td></tr><tr><td style="text-align:center">DROP</td><td style="text-align:center">数据库或表</td><td style="text-align:center">删除</td></tr><tr><td style="text-align:center">GRANT OPTION</td><td style="text-align:center">数据库、表或保存的程序</td><td style="text-align:center">赋予权限</td></tr><tr><td style="text-align:center">REFERENCES</td><td style="text-align:center">数据库或表</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ALTER</td><td style="text-align:center">表</td><td style="text-align:center">修改表</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">表</td><td style="text-align:center">删除数据</td></tr><tr><td style="text-align:center">INDEX</td><td style="text-align:center">表</td><td style="text-align:center">索引权限</td></tr></tbody></table><a id="more"></a><h2 id="二、MySQL权限实战"><a href="#二、MySQL权限实战" class="headerlink" title="二、MySQL权限实战"></a>二、MySQL权限实战</h2><ol><li>GRANT命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; grant all privileges on *.* to jack@&apos;localhost&apos; identified by &quot;jack&quot; with grant option;</div><div class="line">Query OK, 0 rows affected (0.01 sec)</div></pre></td></tr></table></figure></li></ol><ul><li>grant:授予权限操作。</li><li>all:具体权限。(all代表所有权限，还可以为select、update、delete等单项权限选择)</li><li>on <em>.</em>:权限操作的数据库和表。(第一个<em>代表数据库，第二个</em>代表具体的表。<em>.</em>代表所有的库和表，可以指定具体库和表）</li><li>to user@ip:被授予权限的用户和ip。</li><li>identified by “passwd”:被授予用户的密码。</li><li>with grant option:是否拥有授予其他用户权限的权限。</li></ul><ol><li>刷新权限：flush privileges;</li><li><p>查看权限：show grants;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">查看当前用户的权限：</div><div class="line">mysql&gt; show grants;</div><div class="line">+---------------------------------------------------------------------+</div><div class="line">| Grants for root@localhost                                           |</div><div class="line">+---------------------------------------------------------------------+</div><div class="line">| GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION |</div><div class="line">| GRANT PROXY ON &apos;&apos;@&apos;&apos; TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION        |</div><div class="line">+---------------------------------------------------------------------+</div><div class="line">2 rows in set (0.00 sec)</div><div class="line"></div><div class="line">查看某个用户的权限：</div><div class="line">mysql&gt; show grants for &apos;jack&apos;@&apos;%&apos;;</div><div class="line">+-----------------------------------------------------------------------------------------------------+</div><div class="line">| Grants for jack@%                                                                                   |</div><div class="line">+-----------------------------------------------------------------------------------------------------+</div><div class="line">| GRANT USAGE ON *.* TO &apos;jack&apos;@&apos;%&apos; IDENTIFIED BY PASSWORD &apos;*9BCDC990E611B8D852EFAF1E3919AB6AC8C8A9F0&apos; |</div><div class="line">+-----------------------------------------------------------------------------------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>回收权限：revoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; revoke delete on *.* from &apos;jack&apos;@&apos;localhost&apos;;</div><div class="line">Query OK, 0 rows affected (0.01 sec)</div></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; drop user &apos;jack&apos;@&apos;localhost&apos;;</div><div class="line">Query OK, 0 rows affected (0.01 sec)</div></pre></td></tr></table></figure></li><li><p>对用户重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; rename user &apos;jack&apos;@&apos;%&apos; to &apos;jim&apos;@&apos;%&apos;;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div></pre></td></tr></table></figure></li><li><p>修改密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">1、用set password命令</div><div class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">2、用mysqladmin</div><div class="line">[root@rhel5 ~]# mysqladmin -uroot -p123456 password 1234abcd</div><div class="line">备注：</div><div class="line">格式：mysqladmin -u用户名 -p旧密码 password 新密码</div><div class="line">3、用update直接编辑user表</div><div class="line">mysql&gt; use mysql</div><div class="line">Reading table information for completion of table and column names</div><div class="line">You can turn off this feature to get a quicker startup with -A</div><div class="line"></div><div class="line">Database changed</div><div class="line">mysql&gt; update user set PASSWORD = PASSWORD(&apos;1234abcd&apos;) where user = &apos;root&apos;;</div><div class="line">Query OK, 1 row affected (0.01 sec)</div><div class="line">Rows matched: 1  Changed: 1  Warnings: 0</div><div class="line"></div><div class="line">mysql&gt; flush privileges;</div><div class="line">Query OK, 0 rows affected (0.00 sec)</div><div class="line">4、在丢失root密码的时候：</div><div class="line">[root@rhel5 ~]# mysqld_safe --skip-grant-tables &amp;</div><div class="line">[1] 15953</div><div class="line">[root@rhel5 ~]# 130911 09:35:33 mysqld_safe Logging to &apos;/mysql/mysql5.5/data/rhel5.4.err&apos;.</div><div class="line">130911 09:35:33 mysqld_safe Starting mysqld daemon with databases from /mysql/mysql5.5/data</div></pre></td></tr></table></figure></li></ol><h2 id="三、MySQL权限经验原则"><a href="#三、MySQL权限经验原则" class="headerlink" title="三、MySQL权限经验原则"></a>三、MySQL权限经验原则</h2><ul><li>只授予能满足需要的最小权限。</li><li>创建用户时限制用户的登录主机，一般是限制成指定IP或内网IP段。</li><li>初始化数据库时删除没有密码的用户。</li><li>为每个用户设置满足密码复杂度的密码。</li><li>定期清理不需要的用户，回收权限或者删除用户。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、MySQL权限简介&quot;&gt;&lt;a href=&quot;#一、MySQL权限简介&quot; class=&quot;headerlink&quot; title=&quot;一、MySQL权限简介&quot;&gt;&lt;/a&gt;一、MySQL权限简介&lt;/h2&gt;&lt;p&gt;关于mysql的权限简单的理解就是mysql允许你做你权利以内的事情，不可以越界。&lt;/p&gt;
&lt;h3 id=&quot;mysql权限控制的实现&quot;&gt;&lt;a href=&quot;#mysql权限控制的实现&quot; class=&quot;headerlink&quot; title=&quot;mysql权限控制的实现&quot;&gt;&lt;/a&gt;mysql权限控制的实现&lt;/h3&gt;&lt;p&gt;第一阶段：服务器首先会检查你是否允许连接。因为创建用户的时候会加上主机限制，可以限制成本地、IP、网段、任何地方等。只允许你从配置的指定地方登陆。&lt;br&gt;第二阶段：Mysql会检查你发出的每个请求，看你是否有足够的权限实施它。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;权限&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;权限级别&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;权限说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;CREATE&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据库、表或索引&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DROP&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据库或表&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;GRANT OPTION&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据库、表或保存的程序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;赋予权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;REFERENCES&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据库或表&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ALTER&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;表&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;修改表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DELETE&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;表&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;删除数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;INDEX&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;表&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;索引权限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>information_schema</title>
    <link href="http://yoursite.com/2018/08/11/mysql/information_schema/"/>
    <id>http://yoursite.com/2018/08/11/mysql/information_schema/</id>
    <published>2018-08-11T04:11:15.000Z</published>
    <updated>2018-08-16T02:20:18.367Z</updated>
    
    <content type="html"><![CDATA[<p>information_schema数据库是mysql系统自带的数据库，它提供了数据库元数据的访问方式。可以说information_schema就是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了解的信息，比如字符集、权限相关、数据库实体对象信息、外键等。<br><a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">mysql&gt;</span> show tables;</div><div class="line">+---------------------------------------+</div><div class="line">| Tables_in_information_schema          |</div><div class="line">+---------------------------------------+</div><div class="line">| CHARACTER_SETS                        |</div><div class="line">| COLLATIONS                            |</div><div class="line">| COLLATION_CHARACTER_SET_APPLICABILITY |</div><div class="line">| COLUMNS                               |</div><div class="line">| COLUMN_PRIVILEGES                     |</div><div class="line">| ENGINES                               |</div><div class="line">| EVENTS                                |</div><div class="line">| FILES                                 |</div><div class="line">| GLOBAL_STATUS                         |</div><div class="line">| GLOBAL_VARIABLES                      |</div><div class="line">| KEY_COLUMN_USAGE                      |</div><div class="line">| OPTIMIZER_TRACE                       |</div><div class="line">| PARAMETERS                            |</div><div class="line">| PARTITIONS                            |</div><div class="line">| PLUGINS                               |</div><div class="line">| PROCESSLIST                           |</div><div class="line">| PROFILING                             |</div><div class="line">| REFERENTIAL_CONSTRAINTS               |</div><div class="line">| ROUTINES                              |</div><div class="line">| SCHEMATA                              |</div><div class="line">| SCHEMA_PRIVILEGES                     |</div><div class="line">| SESSION_STATUS                        |</div><div class="line">| SESSION_VARIABLES                     |</div><div class="line">| STATISTICS                            |</div><div class="line">| TABLES                                |</div><div class="line">| TABLESPACES                           |</div><div class="line">| TABLE_CONSTRAINTS                     |</div><div class="line">| TABLE_PRIVILEGES                      |</div><div class="line">| TRIGGERS                              |</div><div class="line">| USER_PRIVILEGES                       |</div><div class="line">| VIEWS                                 |</div><div class="line">| INNODB_LOCKS                          |</div><div class="line">| INNODB_TRX                            |</div><div class="line">| INNODB_SYS_DATAFILES                  |</div><div class="line">| INNODB_LOCK_WAITS                     |</div><div class="line">| INNODB_SYS_TABLESTATS                 |</div><div class="line">| INNODB_CMP                            |</div><div class="line">| INNODB_METRICS                        |</div><div class="line">| INNODB_CMP_RESET                      |</div><div class="line">| INNODB_CMP_PER_INDEX                  |</div><div class="line">| INNODB_CMPMEM_RESET                   |</div><div class="line">| INNODB_FT_DELETED                     |</div><div class="line">| INNODB_BUFFER_PAGE_LRU                |</div><div class="line">| INNODB_SYS_FOREIGN                    |</div><div class="line">| INNODB_SYS_COLUMNS                    |</div><div class="line">| INNODB_SYS_INDEXES                    |</div><div class="line">| INNODB_FT_DEFAULT_STOPWORD            |</div><div class="line">| INNODB_SYS_FIELDS                     |</div><div class="line">| INNODB_CMP_PER_INDEX_RESET            |</div><div class="line">| INNODB_BUFFER_PAGE                    |</div><div class="line">| INNODB_CMPMEM                         |</div><div class="line">| INNODB_FT_INDEX_TABLE                 |</div><div class="line">| INNODB_FT_BEING_DELETED               |</div><div class="line">| INNODB_SYS_TABLESPACES                |</div><div class="line">| INNODB_FT_INDEX_CACHE                 |</div><div class="line">| INNODB_SYS_FOREIGN_COLS               |</div><div class="line">| INNODB_SYS_TABLES                     |</div><div class="line">| INNODB_BUFFER_POOL_STATS              |</div><div class="line">| INNODB_FT_CONFIG                      |</div><div class="line">+---------------------------------------+</div><div class="line">59 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p><h3 id="SCHEMATA"><a href="#SCHEMATA" class="headerlink" title="SCHEMATA"></a>SCHEMATA</h3><p>schemata提供了关于数据库的信息。show databases的结果就取自此表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc schemata;</div><div class="line">+----------------------------+--------------+------+-----+---------+-------+</div><div class="line">| Field                      | Type         | Null | Key | Default | Extra |</div><div class="line">+----------------------------+--------------+------+-----+---------+-------+</div><div class="line">| CATALOG_NAME               | varchar(512) | NO   |     |         |       |</div><div class="line">| SCHEMA_NAME                | varchar(64)  | NO   |     |         |    数据库名</div><div class="line">| DEFAULT_CHARACTER_SET_NAME | varchar(32)  | NO   |     |         |    默认表字符集编码</div><div class="line">| DEFAULT_COLLATION_NAME     | varchar(32)  | NO   |     |         |    默认字符集编码排序规则</div><div class="line">| SQL_PATH                   | varchar(512) | YES  |     | NULL    |       |</div><div class="line">+----------------------------+--------------+------+-----+---------+-------+</div><div class="line">5 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from schemata;</div><div class="line">+--------------+--------------------+----------------------------+------------------------+----------+</div><div class="line">| CATALOG_NAME | SCHEMA_NAME        | DEFAULT_CHARACTER_SET_NAME | DEFAULT_COLLATION_NAME | SQL_PATH |</div><div class="line">+--------------+--------------------+----------------------------+------------------------+----------+</div><div class="line">| def          | information_schema | utf8                       | utf8_general_ci        | NULL     |</div><div class="line">| def          | hoo                | utf8                       | utf8_general_ci        | NULL     |</div><div class="line">| def          | mysql              | utf8                       | utf8_general_ci        | NULL     |</div><div class="line">| def          | performance_schema | utf8                       | utf8_general_ci        | NULL     |</div><div class="line">| def          | test               | latin1                     | latin1_swedish_ci      | NULL     |</div><div class="line">+--------------+--------------------+----------------------------+------------------------+----------+</div><div class="line">5 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p><h3 id="TABLES"><a href="#TABLES" class="headerlink" title="TABLES"></a>TABLES</h3><p>存储了数据表的元数据信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc tables;</div><div class="line">+-----------------+---------------------+------+-----+---------+-------+</div><div class="line">| Field           | Type                | Null | Key | Default | Extra |</div><div class="line">+-----------------+---------------------+------+-----+---------+-------+</div><div class="line">| TABLE_CATALOG   | varchar(512)        | NO   |     |         |       |</div><div class="line">| TABLE_SCHEMA    | varchar(64)         | NO   |     |         |     数据库名  </div><div class="line">| TABLE_NAME      | varchar(64)         | NO   |     |         |     数据表名  |</div><div class="line">| TABLE_TYPE      | varchar(64)         | NO   |     |         |       |</div><div class="line">| ENGINE          | varchar(64)         | YES  |     | NULL    |     存储引擎  |</div><div class="line">| VERSION         | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| ROW_FORMAT      | varchar(10)         | YES  |     | NULL    |     是否被压缩过  |</div><div class="line">| TABLE_ROWS      | bigint(21) unsigned | YES  |     | NULL    |     表的粗略行估计  |</div><div class="line">| AVG_ROW_LENGTH  | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| DATA_LENGTH     | bigint(21) unsigned | YES  |     | NULL    |     表的大小  |</div><div class="line">| MAX_DATA_LENGTH | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| INDEX_LENGTH    | bigint(21) unsigned | YES  |     | NULL    |     索引的大小  |</div><div class="line">| DATA_FREE       | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| AUTO_INCREMENT  | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| CREATE_TIME     | datetime            | YES  |     | NULL    |       |</div><div class="line">| UPDATE_TIME     | datetime            | YES  |     | NULL    |       |</div><div class="line">| CHECK_TIME      | datetime            | YES  |     | NULL    |       |</div><div class="line">| TABLE_COLLATION | varchar(32)         | YES  |     | NULL    |       |</div><div class="line">| CHECKSUM        | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| CREATE_OPTIONS  | varchar(255)        | YES  |     | NULL    |       |</div><div class="line">| TABLE_COMMENT   | varchar(2048)       | NO   |     |         |       |</div><div class="line">+-----------------+---------------------+------+-----+---------+-------+</div><div class="line">21 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p><h3 id="ENGINES"><a href="#ENGINES" class="headerlink" title="ENGINES"></a>ENGINES</h3><p>引擎表，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc engines;</div><div class="line">+--------------+-------------+------+-----+---------+-------+</div><div class="line">| Field        | Type        | Null | Key | Default | Extra |</div><div class="line">+--------------+-------------+------+-----+---------+-------+</div><div class="line">| ENGINE       | varchar(64) | NO   |     |         |     引擎名  |</div><div class="line">| SUPPORT      | varchar(8)  | NO   |     |         |     是否支持  |</div><div class="line">| COMMENT      | varchar(80) | NO   |     |         |     描述  |</div><div class="line">| TRANSACTIONS | varchar(3)  | YES  |     | NULL    |     是否支持事务  |</div><div class="line">| XA           | varchar(3)  | YES  |     | NULL    |     是否支持分布式事务  |</div><div class="line">| SAVEPOINTS   | varchar(3)  | YES  |     | NULL    |     是否支持事务回滚点  |</div><div class="line">+--------------+-------------+------+-----+---------+-------+</div><div class="line">6 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from engines;</div><div class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</div><div class="line">| ENGINE             | SUPPORT | COMMENT                                                        | TRANSACTIONS | XA   | SAVEPOINTS |</div><div class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</div><div class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</div><div class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</div><div class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</div><div class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</div><div class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</div><div class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</div><div class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</div><div class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</div><div class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</div><div class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</div><div class="line">9 rows in set (0.01 sec)</div></pre></td></tr></table></figure></p><h3 id="COLUMNS"><a href="#COLUMNS" class="headerlink" title="COLUMNS"></a>COLUMNS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc columns;</div><div class="line">+--------------------------+---------------------+------+-----+---------+-------+</div><div class="line">| Field                    | Type                | Null | Key | Default | Extra |</div><div class="line">+--------------------------+---------------------+------+-----+---------+-------+</div><div class="line">| TABLE_CATALOG            | varchar(512)        | NO   |     |         |       |</div><div class="line">| TABLE_SCHEMA             | varchar(64)         | NO   |     |         |    数据库名   |</div><div class="line">| TABLE_NAME               | varchar(64)         | NO   |     |         |    表名   |</div><div class="line">| COLUMN_NAME              | varchar(64)         | NO   |     |         |    列名   |</div><div class="line">| ORDINAL_POSITION         | bigint(21) unsigned | NO   |     | 0       |    创建时排第几   |</div><div class="line">| COLUMN_DEFAULT           | longtext            | YES  |     | NULL    |    默认值   |</div><div class="line">| IS_NULLABLE              | varchar(3)          | NO   |     |         |    是否能为空   |</div><div class="line">| DATA_TYPE                | varchar(64)         | NO   |     |         |    字符数据类型   |</div><div class="line">| CHARACTER_MAXIMUM_LENGTH | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| CHARACTER_OCTET_LENGTH   | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| NUMERIC_PRECISION        | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| NUMERIC_SCALE            | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| DATETIME_PRECISION       | bigint(21) unsigned | YES  |     | NULL    |       |</div><div class="line">| CHARACTER_SET_NAME       | varchar(32)         | YES  |     | NULL    |    字符集   |</div><div class="line">| COLLATION_NAME           | varchar(32)         | YES  |     | NULL    |    字符集排序规则   |</div><div class="line">| COLUMN_TYPE              | longtext            | NO   |     | NULL    |    创表时列的类型定义   |</div><div class="line">| COLUMN_KEY               | varchar(3)          | NO   |     |         |       |</div><div class="line">| EXTRA                    | varchar(30)         | NO   |     |         |       |</div><div class="line">| PRIVILEGES               | varchar(80)         | NO   |     |         |    权限   |</div><div class="line">| COLUMN_COMMENT           | varchar(1024)       | NO   |     |         |       |</div><div class="line">+--------------------------+---------------------+------+-----+---------+-------+</div><div class="line">20 rows in set (0.00 sec)</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; select * from columns where table_schema = &apos;hoo&apos; and table_name =&apos;hoo_test&apos;\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">           TABLE_CATALOG: def</div><div class="line">            TABLE_SCHEMA: hoo</div><div class="line">              TABLE_NAME: hoo_test</div><div class="line">             COLUMN_NAME: name</div><div class="line">        ORDINAL_POSITION: 1</div><div class="line">          COLUMN_DEFAULT: NULL</div><div class="line">             IS_NULLABLE: YES</div><div class="line">               DATA_TYPE: varchar</div><div class="line">CHARACTER_MAXIMUM_LENGTH: 10</div><div class="line">  CHARACTER_OCTET_LENGTH: 30</div><div class="line">       NUMERIC_PRECISION: NULL</div><div class="line">           NUMERIC_SCALE: NULL</div><div class="line">      DATETIME_PRECISION: NULL</div><div class="line">      CHARACTER_SET_NAME: utf8</div><div class="line">          COLLATION_NAME: utf8_general_ci</div><div class="line">             COLUMN_TYPE: varchar(10)</div><div class="line">              COLUMN_KEY: </div><div class="line">                   EXTRA: </div><div class="line">              PRIVILEGES: select,insert,update,references</div><div class="line">          COLUMN_COMMENT: </div><div class="line">*************************** 2. row ***************************</div></pre></td></tr></table></figure><h3 id="KEY-COLUMN-USAGE"><a href="#KEY-COLUMN-USAGE" class="headerlink" title="KEY_COLUMN_USAGE"></a>KEY_COLUMN_USAGE</h3><p>索引列上的约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc key_column_usage;</div><div class="line">+-------------------------------+--------------+------+-----+---------+-------+</div><div class="line">| Field                         | Type         | Null | Key | Default | Extra |</div><div class="line">+-------------------------------+--------------+------+-----+---------+-------+</div><div class="line">| CONSTRAINT_CATALOG            | varchar(512) | NO   |     |         |       |</div><div class="line">| CONSTRAINT_SCHEMA             | varchar(64)  | NO   |     |         |       |</div><div class="line">| CONSTRAINT_NAME               | varchar(64)  | NO   |     |         |       |</div><div class="line">| TABLE_CATALOG                 | varchar(512) | NO   |     |         |       |</div><div class="line">| TABLE_SCHEMA                  | varchar(64)  | NO   |     |         |       |</div><div class="line">| TABLE_NAME                    | varchar(64)  | NO   |     |         |       |</div><div class="line">| COLUMN_NAME                   | varchar(64)  | NO   |     |         |       |</div><div class="line">| ORDINAL_POSITION              | bigint(10)   | NO   |     | 0       |       |</div><div class="line">| POSITION_IN_UNIQUE_CONSTRAINT | bigint(10)   | YES  |     | NULL    |       |</div><div class="line">| REFERENCED_TABLE_SCHEMA       | varchar(64)  | YES  |     | NULL    |       |</div><div class="line">| REFERENCED_TABLE_NAME         | varchar(64)  | YES  |     | NULL    |       |</div><div class="line">| REFERENCED_COLUMN_NAME        | varchar(64)  | YES  |     | NULL    |       |</div><div class="line">+-------------------------------+--------------+------+-----+---------+-------+</div><div class="line">12 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from key_column_usage where table_name = &apos;test_pri&apos;\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">           CONSTRAINT_CATALOG: def</div><div class="line">            CONSTRAINT_SCHEMA: hoo</div><div class="line">              CONSTRAINT_NAME: PRIMARY</div><div class="line">                TABLE_CATALOG: def</div><div class="line">                 TABLE_SCHEMA: hoo</div><div class="line">                   TABLE_NAME: test_pri</div><div class="line">                  COLUMN_NAME: id</div><div class="line">             ORDINAL_POSITION: 1</div><div class="line">POSITION_IN_UNIQUE_CONSTRAINT: NULL</div><div class="line">      REFERENCED_TABLE_SCHEMA: NULL</div><div class="line">        REFERENCED_TABLE_NAME: NULL</div><div class="line">       REFERENCED_COLUMN_NAME: NULL</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p><h3 id="PROCESSLIST"><a href="#PROCESSLIST" class="headerlink" title="PROCESSLIST"></a>PROCESSLIST</h3><p>processlist显示有哪些线程在运行，可以帮助识别出有问题的查询语句。<br>show processlist 和 select * from information_schema.processlist 效果一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">mysql&gt; desc PROCESSLIST;</div><div class="line">+---------+---------------------+------+-----+---------+-------+</div><div class="line">| Field   | Type                | Null | Key | Default | Extra |</div><div class="line">+---------+---------------------+------+-----+---------+-------+</div><div class="line">| ID      | bigint(21) unsigned | NO   |     | 0       |    会话ID   |</div><div class="line">| USER    | varchar(16)         | NO   |     |         |    运行用户   |</div><div class="line">| HOST    | varchar(64)         | NO   |     |         |    运行主机和端口   |</div><div class="line">| DB      | varchar(64)         | YES  |     | NULL    |    操作的数据库   |</div><div class="line">| COMMAND | varchar(16)         | NO   |     |         |    显示当前线程运行的命令类型   |</div><div class="line">| TIME    | int(7)              | NO   |     | 0       |    此状态持续时间   |</div><div class="line">| STATE   | varchar(64)         | YES  |     | NULL    |    显示使用当前连接的SQL语句   |</div><div class="line">| INFO    | longtext            | YES  |     | NULL    |    显示SQL语句   |</div><div class="line">+---------+---------------------+------+-----+---------+-------+</div><div class="line">8 rows in set (0.00 sec)</div><div class="line"></div><div class="line">mysql&gt; select * from processlist;</div><div class="line">+----+------+-----------+--------------------+---------+------+-----------+---------------------------+</div><div class="line">| ID | USER | HOST      | DB                 | COMMAND | TIME | STATE     | INFO                      |</div><div class="line">+----+------+-----------+--------------------+---------+------+-----------+---------------------------+</div><div class="line">| 25 | root | localhost | information_schema | Query   |    0 | executing | select * from processlist |</div><div class="line">+----+------+-----------+--------------------+---------+------+-----------+---------------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure></p><p>state列值：</p><ul><li>checking table：正在检查数据表。</li><li>closing tables：正在将表中修改的数据刷新到磁盘，同时关闭已用完的表。</li><li>connect out：复制从服务器正在连接主服务器。</li><li>copying to tmp table on disk：正在将临时表从内存存储转为磁盘存储以节省内存。</li><li>creating tmp table：正在创建临时表以存放部分查询结果。</li><li>deleting from main table：服务器正在执行多表删除的第一部分，刚删除第一个表。</li><li>deleting from reference tables：服务器正在执行多表删除的第二部分，正在删除其他表的记录。</li><li>flushing tables：正在执行flush tables，等待其他线程关闭数据表。</li><li>killed：发送了一个kill请求给某线程。</li><li>locked：被其他查询锁住了。</li><li>sending data：正在处理select查询的记录，同时正在把结果发送给客户端。</li><li>sorting for group：正在为group by做排序。</li><li>sorting for order：正在为order by做排序。</li><li>opening table：正在尝试打开一个表。</li><li>removing duplicates：正在执行一个select distinct方式的查询。</li><li>sleeping：正在等待客户端发送新请求</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;information_schema数据库是mysql系统自带的数据库，它提供了数据库元数据的访问方式。可以说information_schema就是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了解的信息，比如字符集、权限相关、数据库实体对象信息、外键等。&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务</title>
    <link href="http://yoursite.com/2018/08/11/mysql/mysql%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/08/11/mysql/mysql事务/</id>
    <published>2018-08-10T16:11:15.000Z</published>
    <updated>2018-08-15T08:47:10.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、事务的基本要素（ACID）"><a href="#一、事务的基本要素（ACID）" class="headerlink" title="一、事务的基本要素（ACID）"></a>一、事务的基本要素（ACID）</h2><ul><li>原子性（Atomicity):事务开始后所有的操作，要么全部做完，要么全部不做，不可能在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。</li><li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。</li><li>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同事务之间彼此没有任何干扰。</li><li>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。<a id="more"></a><h2 id="二、事务的并发问题"><a href="#二、事务的并发问题" class="headerlink" title="二、事务的并发问题"></a>二、事务的并发问题</h2></li><li>脏读：事务A读取了事务B未提交的数据。</li><li>不可重复读：事务A多次读取同一数据，事务B在事务A多次读取过程中，对数据进行了更新，导致事务A读取同一事务时结果不一致。</li><li>幻读：事务A在更新过程中，事务B对同数据库进行了操作并提交，事务A提交不成功。</li></ul><h2 id="三、Mysql事务隔离级别"><a href="#三、Mysql事务隔离级别" class="headerlink" title="三、Mysql事务隔离级别"></a>三、Mysql事务隔离级别</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>事务1对A进行操作还没提交，事务2就对A进行了读取，之后事务1对A进行再次操作或回滚，导致事务A读取的数据不对。（脏读）<br><img src="http://ocx5m3vc3.bkt.clouddn.com/%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4.png" alt="">  </p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>事务2多次读取同一数据，事务1在事务2读取过程中对数据进行了修改，导致事务1读取的数据不一致。（解决了脏读，不可重复读）<br><img src="http://ocx5m3vc3.bkt.clouddn.com/%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A42.png" alt=""><br>读已提交是大多数数据库的默认隔离级别。</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>事务与事务之间相互隔离，数据之间不相互影响。整个事务过程中多次执行同一个查询，查询得到的结果是不一样的，幻读针对的多笔记录。（解决了不可重复读，导致了幻读）</p><p>可重复读是mysql的默认隔离级别。 </p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>在事务进行操作时对表进行加锁操作，拒绝其他事务进行操作。保证了数据的安全性，但是效率大大降低。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、事务的基本要素（ACID）&quot;&gt;&lt;a href=&quot;#一、事务的基本要素（ACID）&quot; class=&quot;headerlink&quot; title=&quot;一、事务的基本要素（ACID）&quot;&gt;&lt;/a&gt;一、事务的基本要素（ACID）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原子性（Atomicity):事务开始后所有的操作，要么全部做完，要么全部不做，不可能在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同事务之间彼此没有任何干扰。&lt;/li&gt;
&lt;li&gt;持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>python获取本机IP</title>
    <link href="http://yoursite.com/2018/07/21/python/%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAIP/"/>
    <id>http://yoursite.com/2018/07/21/python/获取本机IP/</id>
    <published>2018-07-21T08:28:05.000Z</published>
    <updated>2018-07-21T15:27:47.365Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_ip</span><span class="params">()</span>:</span></div><div class="line">  <span class="keyword">try</span>:</div><div class="line">      s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</div><div class="line">      s.connect((<span class="string">'8.8.8.8'</span>, <span class="number">80</span>))</div><div class="line">      ip = s.getsockname()[<span class="number">0</span>]</div><div class="line">  <span class="keyword">finally</span>:</div><div class="line">      s.close()</div><div class="line">  <span class="keyword">return</span> ip</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/d
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>

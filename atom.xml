<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OMG_By</title>
  
  <subtitle>你走与不走，路就在那里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-13T10:08:32.280Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OMG_By</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac安装多版本JDK</title>
    <link href="http://yoursite.com/2019/07/13/mac%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACJDK/"/>
    <id>http://yoursite.com/2019/07/13/mac安装多版本JDK/</id>
    <published>2019-07-13T09:55:42.000Z</published>
    <updated>2019-07-13T10:08:32.280Z</updated>
    
    <content type="html"><![CDATA[<p>随着JDK版本的快速迭代，作为优秀(kubi)的Java用户者，为了跟随时代的潮流，也开始使用1.8版本。</p><p>但是，某一天。。。。苦逼的事情发生了，一个项目原本是好好的，突然报错起不来了。最终查到的原因是某个项目的Jar包使用的JDK为1.7….于是就有了这篇记录。</p><p>在终端下面使用<code>java -version</code>查看就可以查看使用的JDK版本了。<br>使用<code>/usr/libexec/java_home -V</code>可以查看本地已经安装的JDK</p><p>关于JDK1.x for mac的安装略过，网上有大把的教程。<br>我这里以安装3个版本1.6/1.7/1.8为例。</p><p>一、编辑.bash_profile<br><code>vim ~/.bash_profile</code></p><p>二、在.bash_profile中添加下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`</span><br><span class="line">export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7`</span><br><span class="line">export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`</span><br><span class="line"></span><br><span class="line">#默认设为JDK1.7</span><br><span class="line">export JAVA_HOME=$JAVA_7_HOME</span><br><span class="line"></span><br><span class="line">#alias命令动态切换JDK版本</span><br><span class="line">alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot;</span><br><span class="line">alias jdk7=&quot;export JAVA_HOME=$JAVA_7_HOME&quot;</span><br><span class="line">alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;</span><br></pre></td></tr></table></figure></p><p>三、刷新环境<br><code>source ~/.bash_profile</code></p><p>四、测试<br>执行：<code>jdk8</code>，再执行<code>java -version</code>，看看是不是1.8版本？<br>执行：<code>jdk6</code>，再执行<code>java -version</code>，看看是不是1.6版本？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着JDK版本的快速迭代，作为优秀(kubi)的Java用户者，为了跟随时代的潮流，也开始使用1.8版本。&lt;/p&gt;
&lt;p&gt;但是，某一天。。。。苦逼的事情发生了，一个项目原本是好好的，突然报错起不来了。最终查到的原因是某个项目的Jar包使用的JDK为1.7….于是就有了这篇记
      
    
    </summary>
    
      <category term="一些奇淫技巧" scheme="http://yoursite.com/categories/%E4%B8%80%E4%BA%9B%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Cloneable接口实现原理</title>
    <link href="http://yoursite.com/2019/06/04/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Cloneable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/06/04/面试准备/Cloneable实现原理/</id>
    <published>2019-06-04T14:41:31.000Z</published>
    <updated>2019-06-23T13:13:08.542Z</updated>
    
    <content type="html"><![CDATA[<p>Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例当中。</p><p>在开发过程中，如果一个类中的字段比较多，而我们如果采用在客户端中逐字段复制的方法来进行拷贝操作的话，将不可避免的造成客户端代码繁杂，而且也无法对类中的私有对象进行复制，而如果让需要具备拷贝功能的类实现<code>Cloneable</code>接口，并重写<code>clone()</code>方法的方式来简洁地实现实例拷贝功能。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><code>private class Demo implements Cloneable{}</code><br>我们创建一个Demo类，并让他实现Cloneable接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Cloneable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们发现<code>Cloneable</code>几口里面并没有定义任何接口方法。<br>这是因为在<code>Object</code>类中已经将<code>clone()</code>方法定义为所有类都应该具有的基本功能，只是将该方法声明为了<code>protected</code>类型。它是一个<code>native</code>本地方法。</p><p>如果一个类不实现该接口就直接调用<code>clone()</code>方法的话，就会抛出“不支持拷贝”异常。<br>所以如果要让一个类具有拷贝实例的功能，那么除了要重写<code>Object</code>类中<code>clone()</code>方法外，还必须实现Cloneable接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例当中。&lt;/p&gt;
&lt;p&gt;在开发过程中，如果一个类中的字段比较多，而我们如果采用在客户端中逐字段复制的方法来进行拷贝操作的话，将不可避免的造成客户端代码繁杂，而且也无法对
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2019/06/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/06/03/面试准备/单例模式/</id>
    <published>2019-06-03T14:41:31.000Z</published>
    <updated>2019-06-19T09:30:38.728Z</updated>
    
    <content type="html"><![CDATA[<p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h2 id="单例模式多种写法"><a href="#单例模式多种写法" class="headerlink" title="单例模式多种写法"></a>单例模式多种写法</h2><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>这种方式在类加载时就完成了初始化，所以类加载比较慢，但是获取对象的速度快。这种方式基于类加载机制避免了多线程的同步问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="懒汉模式（线程不安全）"><a href="#懒汉模式（线程不安全）" class="headerlink" title="懒汉模式（线程不安全）"></a>懒汉模式（线程不安全）</h3><p>懒汉模式声明了一个静态对象，在用户第一次调用时进行初始化，虽然节约了资源，但第一次加载时需要实例化，反应稍微慢一点，而且在多线程下不能工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="懒汉模式（线程安全）"><a href="#懒汉模式（线程安全）" class="headerlink" title="懒汉模式（线程安全）"></a>懒汉模式（线程安全）</h3><p>这种写法能够在多线程中很好的工作，但是每次调用getSingleton时都需要同步，造成不必要的同步开销，而且大部分时候我们都是用不到同步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双重检查模式（DCL）"><a href="#双重检查模式（DCL）" class="headerlink" title="双重检查模式（DCL）"></a>双重检查模式（DCL）</h3><p>这种写法对singleton进行了两次的判空操作，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。这里用到了volatile关键字，或多或少还是会影响性能，但是考虑到程序的正确性，牺牲这点性能还是值得的。</p><h4 id="PS：这里为什么要用volatile关键字？"><a href="#PS：这里为什么要用volatile关键字？" class="headerlink" title="PS：这里为什么要用volatile关键字？"></a>PS：这里为什么要用volatile关键字？</h4><p>这个地方使用volatile关键字是很有必要的，因为new一个新的对象其实是分了三步执行：</p><ol><li>为该对象分配内存空间</li><li>初始化对象</li><li>将对象指向分配的内存地址</li></ol><p>由于JVM指令重排的特性，执行顺序可能会变成1-&gt;3-&gt;2；在单线程环境下不会有问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。比如：</p><ol><li>线程1执行了1、3</li><li>线程2调用方法，发现该实例不为空，因此返回该实例。但此时实例还没被初始化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if(singleton == null)&#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton sInstance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，上述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。</p><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     public void doSomeThing() &#123;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用容器实现单例模式"><a href="#使用容器实现单例模式" class="headerlink" title="使用容器实现单例模式"></a>使用容器实现单例模式</h3><p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonManager &#123; </span><br><span class="line">　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();</span><br><span class="line">　　private Singleton() &#123; </span><br><span class="line">　　&#125;</span><br><span class="line">　　public static void registerService(String key, Objectinstance) &#123;</span><br><span class="line">　　　　if (!objMap.containsKey(key) ) &#123;</span><br><span class="line">　　　　　　objMap.put(key, instance) ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　public static ObjectgetService(String key) &#123;</span><br><span class="line">　　　　return objMap.get(key) ;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;h2 id=&quot;单例模式多种写法&quot;&gt;&lt;a href=&quot;#单例模式多种写法&quot; class=&quot;headerlink&quot; title=&quot;单例模式多种写法&quot;&gt;&lt;/a&gt;单例模式多种写法&lt;/h2&gt;&lt;h3 id=&quot;饿汉模式&quot;&gt;&lt;a href=&quot;#饿汉模式&quot; class=&quot;headerlink&quot; title=&quot;饿汉模式&quot;&gt;&lt;/a&gt;饿汉模式&lt;/h3&gt;&lt;p&gt;这种方式在类加载时就完成了初始化，所以类加载比较慢，但是获取对象的速度快。这种方式基于类加载机制避免了多线程的同步问题。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static Singleton singleton = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;懒汉模式（线程不安全）&quot;&gt;&lt;a href=&quot;#懒汉模式（线程不安全）&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式（线程不安全）&quot;&gt;&lt;/a&gt;懒汉模式（线程不安全）&lt;/h3&gt;&lt;p&gt;懒汉模式声明了一个静态对象，在用户第一次调用时进行初始化，虽然节约了资源，但第一次加载时需要实例化，反应稍微慢一点，而且在多线程下不能工作。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static Singleton singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Singleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(singleton == null)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            singleton = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程思想" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap详解</title>
    <link href="http://yoursite.com/2019/06/02/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/HashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/06/02/面试准备/HashMap详解/</id>
    <published>2019-06-02T14:41:31.000Z</published>
    <updated>2019-06-16T13:25:49.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是HashMap"><a href="#什么是HashMap" class="headerlink" title="什么是HashMap"></a>什么是HashMap</h2><p>HashMap一个用于存储Key-Value键值对的集合，每一个键值对称之为<code>Entry</code>分散存储在一个数组中。这个数组每一个元首初始值都是Null。</p><p>HashMap的常用操作就是<b>GET</b>和<b>PUT</b></p><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>我们在调用put方法的时候，会利用一个哈希函数来确定<code>Entry</code>的插入位置。为了解决哈希冲突的问题，HashMap采用<font color="red">链表法</font>来解决这个问题。<br><code>注意：位置0上存放的一定是Null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">modCount++;</span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line">return null;</span><br></pre></td></tr></table></figure></p><p>在遇到Hash冲突的时候，就将<code>Entry</code>以链表的形式给插入到相应的位置，这里需要注意的是：HashMap采用的是<font color="red">头插法</font>的形式。这是因为设计者认为最新加入的<code>Entry</code>更有可能被访问。<br>此时HashMap的结构为<b>数组加链表</b><br><img src="https://s2.ax1x.com/2019/06/16/V7M7nO.jpg" alt=""></p><a id="more"></a><p>当HashMap中有大量的元素都存放在同一个位置的时候，这个位置就有存在一条很长的链表；这个时候的HashMap相当于一个单链表。<br>于是在<b>JDK1.8</b>中引入了<font color="red">红黑树</font>来优化这个问题。当某一个位置上的<font color="red">链表长度大于等于8</font>的时就使用红黑树来进行存储。<br>在元素值小于6的时候就将红黑树又转换成链表形式。<br>此时HashMap的结构为<b>数组加链表加红黑树</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//一个桶的树化阈值</span><br><span class="line">//当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点</span><br><span class="line">//这个值必须为 8，要不然频繁转换效率也不高</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"> </span><br><span class="line">//一个树的链表还原阈值</span><br><span class="line">//当扩容时，桶中元素个数小于这个值，就会把树形的桶元素 还原（切分）为链表结构</span><br><span class="line">//这个值应该比上面那个小，至少为 6，避免频繁转换</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"> </span><br><span class="line">//哈希表的最小树形化容量</span><br><span class="line">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span><br><span class="line">//否则桶内元素太多时会扩容，而不是树形化</span><br><span class="line">//为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure></p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>在HashMap的GET函数中，首先会通过计算键值的哈希值获取到<code>Entry</code>所在的位置，然后通过遍历链表或红黑树中的<code>Entry</code>来确定是否是我们需要的值。</p><p>HashMap在遍历链表比较时使用的Java对象的equals()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != null;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>通过这段代码，我们也可以看出：HashMap是可以存放键为Null的对象</code></p><h4 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line">        while (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + next.getKey() + &quot; value=&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + key + &quot; value=&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>推荐使用第一种方式，第一种方式会将KV同时取出，而第二种方式还需要通过key取一次value，效率比较低。</p><h2 id="HashMap默认初始化长度"><a href="#HashMap默认初始化长度" class="headerlink" title="HashMap默认初始化长度"></a>HashMap默认初始化长度</h2><p>首先，我们要明确的一点就是：<font color="red">HashMap的默认初始化长度是16</font>，并且每次扩容和缩容后的长度大小都是2的幂。</p><p>为什么会有以上的限制呢？<br>这是因为需要实现尽可能分布均匀的Hash函数。HashMap中使用了<font color="red">位取模</font>的方式来计算哈希值。<br><code>index =  HashCode（Key） &amp;  （Length - 1）</code></p><p>这样做不但效果上等同于取模，而且大大提升了性能。<br>使用<code>位运算</code>的方式，相当于只取hash函数的后几位，分布情况取决于hash函数。<br>而使用其他方式，如<code>取模</code>，则可能会导致某些index结果出现的几率大大提升;此外，如果length不是2的幂的话，有些index的结果可能永远不会出现。</p><h2 id="Hash的Rehash"><a href="#Hash的Rehash" class="headerlink" title="Hash的Rehash"></a>Hash的Rehash</h2><p>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。<br>这个时候的HashMap会需要进行扩容行为了。</p><p>影响HashMap扩容的因素有两个：</p><ul><li>Capacity：当前长度</li><li>LoadFactor：负载因子，默认是0.75f</li></ul><p><code>HashMap.Size   &gt;=  Capacity * LoadFactor时就会进行扩容操作了</code></p><p>HashMap的扩容操作分两步：</p><ol><li>创建一个新的数组，大小是原来数组的2倍。</li><li>遍历原数组，将原数组的所有元素重新Hash到新数组。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Transfers all entries from current table to newTable.</span><br><span class="line"> */</span><br><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap每次扩容或缩容都是以2的倍数进行的。<br>这是因为在这样的流程中，HashMap中的<code>Entry</code>需要迁移的只有一半，大大的节省了扩缩容的消耗。</p><h2 id="高并发下的HashMap"><a href="#高并发下的HashMap" class="headerlink" title="高并发下的HashMap"></a>高并发下的HashMap</h2><p>HashMap并不是线程安全的，在多线程操作下可能会导致很多意想不到的情况发生。比如死循环。</p><p>比如在上一小节中讲的Rehash，如果有多个线程同时进行扩容操作就会出现问题。<br>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作：<br><img src="https://s2.ax1x.com/2019/06/16/V7MbHe.jpg" alt="-w564"><br><img src="https://s2.ax1x.com/2019/06/16/V7MONd.jpg" alt="-w496"><br>此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：<br><img src="https://s2.ax1x.com/2019/06/16/V7MLAH.jpg" alt="-w748"><br>这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：<br><img src="https://s2.ax1x.com/2019/06/16/V7MHBD.jpg" alt=""><br>假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：<br><img src="https://s2.ax1x.com/2019/06/16/V7MX4A.jpg" alt="-w778"><br>直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p><img src="https://s2.ax1x.com/2019/06/16/V7MzgP.jpg" alt=""><br>当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。<br><img src="https://s2.ax1x.com/2019/06/16/V7Mv9I.jpg" alt=""><br>我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且e指向了Entry2。此时e和next的指向如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry2</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QPHg.jpg" alt="-w702"><br>接着是新一轮循环，又执行到红框内的代码行：<br><img src="https://s2.ax1x.com/2019/06/16/V7Mx3t.jpg" alt=""><br>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QSjf.jpg" alt="-w762"><br>接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：<br><img src="https://s2.ax1x.com/2019/06/16/V7Q9u8.jpg" alt=""><br>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QCDS.jpg" alt="-w746"><br>第三次循环开始，又执行到红框的代码：<br><img src="https://s2.ax1x.com/2019/06/16/V7QkNj.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry3.next = null</span><br></pre></td></tr></table></figure></p><p>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：<br><img src="https://s2.ax1x.com/2019/06/16/V7QFEQ.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = Entry2</span><br><span class="line">e = Entry3</span><br><span class="line">Entry2.next = Entry3</span><br><span class="line">Entry3.next = Entry2</span><br></pre></td></tr></table></figure></p><p>链表出现了环形！</p><p>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QA4s.jpg" alt="-w751"><br>此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是HashMap&quot;&gt;&lt;a href=&quot;#什么是HashMap&quot; class=&quot;headerlink&quot; title=&quot;什么是HashMap&quot;&gt;&lt;/a&gt;什么是HashMap&lt;/h2&gt;&lt;p&gt;HashMap一个用于存储Key-Value键值对的集合，每一个键值对称之为&lt;code&gt;Entry&lt;/code&gt;分散存储在一个数组中。这个数组每一个元首初始值都是Null。&lt;/p&gt;
&lt;p&gt;HashMap的常用操作就是&lt;b&gt;GET&lt;/b&gt;和&lt;b&gt;PUT&lt;/b&gt;&lt;/p&gt;
&lt;h4 id=&quot;PUT&quot;&gt;&lt;a href=&quot;#PUT&quot; class=&quot;headerlink&quot; title=&quot;PUT&quot;&gt;&lt;/a&gt;PUT&lt;/h4&gt;&lt;p&gt;我们在调用put方法的时候，会利用一个哈希函数来确定&lt;code&gt;Entry&lt;/code&gt;的插入位置。为了解决哈希冲突的问题，HashMap采用&lt;font color=&quot;red&quot;&gt;链表法&lt;/font&gt;来解决这个问题。&lt;br&gt;&lt;code&gt;注意：位置0上存放的一定是Null&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Object k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                V oldValue = e.value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.recordAccess(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return oldValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addEntry(hash, key, value, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return null;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在遇到Hash冲突的时候，就将&lt;code&gt;Entry&lt;/code&gt;以链表的形式给插入到相应的位置，这里需要注意的是：HashMap采用的是&lt;font color=&quot;red&quot;&gt;头插法&lt;/font&gt;的形式。这是因为设计者认为最新加入的&lt;code&gt;Entry&lt;/code&gt;更有可能被访问。&lt;br&gt;此时HashMap的结构为&lt;b&gt;数组加链表&lt;/b&gt;&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/16/V7M7nO.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Object的常用方法</title>
    <link href="http://yoursite.com/2019/06/01/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Object%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/06/01/面试准备/Object的常用方法/</id>
    <published>2019-06-01T14:41:31.000Z</published>
    <updated>2019-06-16T13:11:41.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object类常见方法"><a href="#Object类常见方法" class="headerlink" title="Object类常见方法"></a>Object类常见方法</h1><p>Object是一个特殊的类，所有的类都会隐式的继承Object类。Object中主要有以下11个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">注：native方法：使用这个关键字说明这个方法是原生方法，底层使用C/C++实现，并且被编译成了DLL，由Java调用。函数实现在DLL中，JDK源码并不包含。</span><br><span class="line"></span><br><span class="line">public final native Class&lt;?&gt; getClass()</span><br><span class="line">用于返回当前运行时对象的Class对象，使用final关键字修饰，不允许子类重写。</span><br><span class="line"></span><br><span class="line">public native int hashCode()</span><br><span class="line">用于返回对象的哈希码，主要使用在哈希表中。</span><br><span class="line"></span><br><span class="line">public boolean equals(Object obj)</span><br><span class="line">用于比较2个对象的内存地址是否相等，String类对该方法进行了重写。</span><br><span class="line"></span><br><span class="line">protected native Object clone() throws CloneNotSupportedException</span><br><span class="line">用于创建当前对象的一份拷贝。Object本身并没有实现Cloneable接口，所以不重写clone方法并且进行调用就会发生CloneNotSupportedException异常。</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">默认返回类的名字@实例的哈希码的16进制的字符串，建议所有子类都重写该方法。</span><br><span class="line"></span><br><span class="line">public final native void notify()</span><br><span class="line">final方法，用于唤醒一个在此对象监视器上等待的线程。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="line"></span><br><span class="line">public final native void notifyAll()</span><br><span class="line">用于唤醒该对象上所有的等待线程。</span><br><span class="line"></span><br><span class="line">public final native void wait(long timeout) throws InterruptedException</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException</span><br><span class="line">public final void wait() throws InterruptedException</span><br><span class="line">暂停线程的执行，第二个超时时间需要增加nanos毫秒，第三个没有超时时间。</span><br><span class="line"></span><br><span class="line">protected void finalize() throws Throwable &#123; &#125;</span><br><span class="line">实例被垃圾回收器回收的时候触发的操作。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object类常见方法&quot;&gt;&lt;a href=&quot;#Object类常见方法&quot; class=&quot;headerlink&quot; title=&quot;Object类常见方法&quot;&gt;&lt;/a&gt;Object类常见方法&lt;/h1&gt;&lt;p&gt;Object是一个特殊的类，所有的类都会隐式的继承Object类。O
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Change Buffer</title>
    <link href="http://yoursite.com/2019/04/03/MySQL/Change%20Buffer/"/>
    <id>http://yoursite.com/2019/04/03/MySQL/Change Buffer/</id>
    <published>2019-04-03T08:11:15.000Z</published>
    <updated>2019-06-19T09:32:04.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的偷懒行为之Change-Buffer"><a href="#MySQL的偷懒行为之Change-Buffer" class="headerlink" title="MySQL的偷懒行为之Change Buffer"></a>MySQL的偷懒行为之Change Buffer</h1><p>在使用MySQL的时候，只要MySQL服务给你返回成功信息后，得到你需要的结果，你并不关注MySQL的行为；但是其实在MySQL内部，其实有很多的特性和机制来延迟真正的持久化等耗时耗资源行为。下面我将为你介绍其中的一个特性：change buffer</p><h2 id="简介-What"><a href="#简介-What" class="headerlink" title="简介(What)"></a>简介(What)</h2><p>The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool. The buffered changes, which may result from INSERT, UPDATE, or DELETE operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.</p><p>当需要改变<font color="red">二级索引</font>的数据，并且该<font color="red">数据页不在内存缓冲池中</font>；这个时候会直接向客户端返回修改成功的信息。MySQL并不实时的去更新磁盘数据，而是在之后一定条件下触发更新操作。这就是<font color="red">change buffer</font>在作祟。</p><p>change buffer在MySQL5.5版本之前，只支持insert操作，所以最初被称为insert buffer。在之后的版本中，支持了更多的修改操作，所以后面改称为change buffer。</p><a id="more"></a><h2 id="为什么需要change-buffer-Why"><a href="#为什么需要change-buffer-Why" class="headerlink" title="为什么需要change buffer(Why)"></a>为什么需要change buffer(Why)</h2><p>首先，你要明白<font color="red">二级索引的数据页在磁盘上存储得很散乱</font>，读取的时候需要消耗大量的资源去做寻址等操作。这里涉及到了操作系统知识，并不在本文的科普范围。</p><p>其次，一般情况下，二级索引的数据访问的并不是很频繁，作为冷数据的存在，<font color="red">即使读取到了内存当中，很快也会被挤出内存缓冲池</font>。如果每次更新操作都读取进来，那也是一笔很大的开销，所以MySQL会将多次更新给合并到一块去更新。（这里涉及到了LRU的淘汰知识，后续会有专门的文章讲解，这里你只需要知道有这个东西就行了）</p><p>所以，change buffer的主要作用有以下两点：</p><ol><li>减少了MySQL<font color="red">随机</font>读取磁盘的次数</li><li>将<font color="red">多次的随机写</font>磁盘操作，合并成了<font color="red">一次的顺序写</font>磁盘操作</li></ol><p>这里再介绍一下change buffer的限制条件：<font color="red">非唯一的辅助索引</font></p><p>前面我们说过二级索引的数据在磁盘上分布的很散乱，但是聚簇索引就不会这样；我们都知道Innodb的数据都存储在聚簇索引的叶子节点，Innodb为了保证能够更快的读取数据，会<font color="red">将聚簇索引的数据页尽可能在物理上顺序放在一起</font>。</p><p>此外，在修改聚簇索引和唯一辅助索引上的数据时，为了<font color="red">保证数据的唯一性</font>，总是会在进行修改操作前进行一次查询操作，这个时候已经将该数据页读取到内存缓存池中了。直接修改内存中数据页上的数据信息更快，完全没有必要使用change buffer。</p><h2 id="change-buffer干了什么-DO）"><a href="#change-buffer干了什么-DO）" class="headerlink" title="change buffer干了什么(DO）"></a>change buffer干了什么(DO）</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>下面我们来看change buffer的执行过程：</p><ol><li>如果需要修改的数据页在内存中，则直接修改内存数据并返回</li><li>如果需要修改的数据页不在内存中，则向change buffer中添加一条记录（修改数据页的记录)</li><li>在redo log中添加一条记录（change buffer页的修改记录）<br><a href="https://imgchr.com/i/V7JVC4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JVC4.jpg" alt="V7JVC4.jpg"></a></li></ol><p>从change buffer的执行过程中，我们可以看到，如果需要修改的数据页page 2不在内存中时，Innodb并不会去磁盘中读取，而是在change buffer中记录了page 2中的数据变更。</p><p>系统会周期性的将change buffer的数据写入到系统表空间中。所以不需要担心change buffer的数据丢失问题。</p><h3 id="什么时候进行合并操作"><a href="#什么时候进行合并操作" class="headerlink" title="什么时候进行合并操作"></a>什么时候进行合并操作</h3><ul><li>二级索引页被读取到buffer pool中，在页面可用之前，会先进行合并缓存操作</li><li>change buffer bitmap页追踪到该辅助索引页无可用空间时</li><li>Master Thread定时任务</li><li>在崩溃恢复时，索引页被读入到缓冲池时，会将存在系统表空间的change buffer应用到二级索引的叶子节点</li><li>当–innodb-fast-shutdown=0时，数据库实例关闭时会强制将change buffer合并到数据页中并刷盘。</li></ul><h3 id="change-buffer的存储"><a href="#change-buffer的存储" class="headerlink" title="change buffer的存储"></a>change buffer的存储</h3><p><a href="https://imgchr.com/i/V7J9uq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7J9uq.md.jpg" alt="V7J9uq.md.jpg"></a></p><p>change buffer在物理上是以一个普通的btree存储。根页是存储在系统表空间的固定页中（涉及innodb的数据存储结构，太高深了~还没到那个层次，就看个热闹)</p><p>上图是一条ibuf记录的存储格式，通过（space id, page no , counter）三列作为主键来唯一决定一条记录，其中counter是一个递增值，目的是为了维持不同操作的有序性。可以通过counter来保证merge时执行时的顺序和用户操作的顺序一致。</p><p>在插入时，会先将counter的值设置成0xFFFF；然后将定位到小于等于(space id, page no, 0xFFFF)的位置，再将counter为当前记录counter值加1。(这样做的原因是为了合并的时候能够更方便的找到同一数据页的缓存，并保证有序)</p><p><a href="https://imgchr.com/i/V7JSvn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JSvn.md.jpg" alt="V7JSvn.md.jpg"></a><br>因为ibuf缓存是针对具体的数据页的，因此在缓存操作的时候需要避免空页和满页的缓存操作。(满页：即将分裂的页，并不一定是所有空闲空间用完的页，一个数据页会有1/16的空隙)</p><ol><li>针对空页情况，在准备插入IBUF_OP_DELETE类型的操作缓存时，会预估执行完此操作后该page中还存在多少记录，如果只剩下一条记录，则走正常流程，将数据页读取到内存中。</li><li>针对满页情况，则是通过ibuf_bitmap页记录，该页存在于每个ibd的固定位置；ibuf_bitmap中记录了每个数据页的缓存状态和空闲空间大小。<br>在执行IBUF_OP_INSERT类型的操作前，会将该page的IBUF_BITMAP_BUFFERED设置为true。<br>通过IBUF_BITMAP_FREE来记录该page的空闲空间；在插入前，会去找到该page的空闲空间大小，如果本次操作超出限制，则会触发一次异步ibuf merge。</li></ol><h3 id="merge过程"><a href="#merge过程" class="headerlink" title="merge过程"></a>merge过程</h3><ol><li>一个磁盘上的数据页被读取到内存缓冲池中</li><li>到ibuf_bitmap中判断该数据页是否有缓存行为</li><li>如果存在缓存，则从ibuf的btree树中读取该数据页的缓存操作；并应用到该内存数据页上</li><li>只有当应用缓存完成，才能提供给用户查询等操作行为</li><li>在一定情况下执行刷盘操作，持久化到磁盘</li></ol><h3 id="merge触发情况"><a href="#merge触发情况" class="headerlink" title="merge触发情况"></a>merge触发情况</h3><ol><li>二级索引页被读入到内存中</li><li>插入ibuf操作时，遇到满页，会造成页分裂操作时，触发一次异步的merge</li><li>当前ibuf tree size&gt;max_size + 10时，会执行一次同步的merge</li><li>本次插入ibuf操作可能会导致ibuf tree索引分裂时，根据ibuf size的大小情况会触发不同情况的merge</li><li>master定时任务会合并相应数量的buffer</li><li>对某个表执行flush table时，会强制对该表的page进行merge</li><li>数据库关闭时，根据innodb_fast_shutdown来决定是否进行merge</li></ol><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><ol><li><p>innodb_change_buffering<br>innodb_change_buffering参数可以控制什么操作会使用change buffer。默认是all</p><p> |||<br> | — | — |<br> | all | The default value: buffer inserts, delete-marking operations, and purges. |<br> | none | Do not buffer any operations. |<br> | inserts | Buffer insert operations. |<br> | deletes | Buffer delete-marking operations. |<br> | changes | Buffer both inserts and delete-marking operations. |<br> | purges | Buffer physical deletion operations that happen in the background. |</p></li><li><p>innodb_change_buffer_max_size<br>innodb_change_buffer_max_size参数控制change buffer占buffer pool的百分比。默认25%，最大50%</p></li><li><p>查看change buffer的使用情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SHOW ENGINE INNODB STATUS \G</span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">56</span>, seg <span class="keyword">size</span> <span class="number">58</span>, <span class="number">517693</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">560451</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ol><p>Ibuf表示当前缓冲区中change buffer的页使用情况<br>size表示已使用的页数，free list len表示空闲的页，seg size表示总共的页数（等于size + free list len + 1)，merges合并数<br>merged operations表示change buffer中每个操作的次数。<br>insert表示Insert Buffer，delete mark表示Delete Buffer，delete表示Purge Buffer。<br>discarded operations表示当change buffer发生merge操作时，表已经被删除，此时不再需要将记录合并到辅助索引中去。</p><p>从上面的信息可以看出这个数据库实例的change buffer效果并不明显（通过insert/merges计算)。change buffer适用于存在大量修改二级索引页的DML活动中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>change buffer将随机IO转换成顺序IO，避免了IO带来的性能损耗，减少了随机读磁盘的次数，提高了数据库的写性能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html</a><br><a href="https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html</a><br><a href="http://mysql.taobao.org/monthly/2015/07/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2015/07/01/</a><br><a href="https://blog.csdn.net/bohu83/article/details/81837872" target="_blank" rel="noopener">https://blog.csdn.net/bohu83/article/details/81837872</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL的偷懒行为之Change-Buffer&quot;&gt;&lt;a href=&quot;#MySQL的偷懒行为之Change-Buffer&quot; class=&quot;headerlink&quot; title=&quot;MySQL的偷懒行为之Change Buffer&quot;&gt;&lt;/a&gt;MySQL的偷懒行为之Change Buffer&lt;/h1&gt;&lt;p&gt;在使用MySQL的时候，只要MySQL服务给你返回成功信息后，得到你需要的结果，你并不关注MySQL的行为；但是其实在MySQL内部，其实有很多的特性和机制来延迟真正的持久化等耗时耗资源行为。下面我将为你介绍其中的一个特性：change buffer&lt;/p&gt;
&lt;h2 id=&quot;简介-What&quot;&gt;&lt;a href=&quot;#简介-What&quot; class=&quot;headerlink&quot; title=&quot;简介(What)&quot;&gt;&lt;/a&gt;简介(What)&lt;/h2&gt;&lt;p&gt;The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool. The buffered changes, which may result from INSERT, UPDATE, or DELETE operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.&lt;/p&gt;
&lt;p&gt;当需要改变&lt;font color=&quot;red&quot;&gt;二级索引&lt;/font&gt;的数据，并且该&lt;font color=&quot;red&quot;&gt;数据页不在内存缓冲池中&lt;/font&gt;；这个时候会直接向客户端返回修改成功的信息。MySQL并不实时的去更新磁盘数据，而是在之后一定条件下触发更新操作。这就是&lt;font color=&quot;red&quot;&gt;change buffer&lt;/font&gt;在作祟。&lt;/p&gt;
&lt;p&gt;change buffer在MySQL5.5版本之前，只支持insert操作，所以最初被称为insert buffer。在之后的版本中，支持了更多的修改操作，所以后面改称为change buffer。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL忘记密码怎么办</title>
    <link href="http://yoursite.com/2019/04/02/MySQL/MySQL%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://yoursite.com/2019/04/02/MySQL/MySQL忘记密码怎么办/</id>
    <published>2019-04-02T12:14:16.000Z</published>
    <updated>2019-07-13T05:53:16.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL忘记密码怎么办？"><a href="#MySQL忘记密码怎么办？" class="headerlink" title="MySQL忘记密码怎么办？"></a>MySQL忘记密码怎么办？</h1><p>有的时候搭建MySQL后，由于密码没有保存好、忘记密码、密码过期等原因，导致登录不上数据库。这个时候该怎么办？</p><p>如果数据库使用人员，那还是乖乖的找数据库管理人员修改密码吧！<br>如果是数据库管理人员，能够登录到MySQL实例所在服务器的话。下面将介绍两种方式进行修改密码操作。</p><h2 id="skip-grant-tables"><a href="#skip-grant-tables" class="headerlink" title="skip-grant-tables"></a>skip-grant-tables</h2><p>第一种方式就是网上介绍最多的通过配置skip-grant-tables参数来跳过MySQL登录校验后，进行修改密码。</p><p>步骤就是：</p><ol><li>需要关闭MySQL实例。</li><li>配置参数。这里有两种方式：第一种就是在启动的使用，启动命令添加–skip-grant-tables；第二种就是通过修改配置文件，在[mysqld]下添加skip-grant-tables。</li><li>启动数据库</li><li>通过alter mysql.user set authentication_string=password(‘newpass’) where XXX@XXX;</li><li>去掉skip-grant-tables配置后重新启动。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">MySQL5.6的密码参数列为：password</span><br><span class="line">MySQL5.7的密码参数列为：authentication_string</span><br><span class="line"></span><br><span class="line">MySQL的账号是以`用户名`@`主机地址`计算的。同一用户名不同主机地址视为不同账号。</span><br></pre></td></tr></table></figure><p>这种方法的缺点很明显：</p><ol><li>数据库必须有一段时间不能提供服务。</li><li>开启跳过权限检查的参数后，安全性无法得到保障。所有人都能登录，即使没有改账号也能登录成功。<a id="more"></a></li></ol><h2 id="利用MyISAM表的特性"><a href="#利用MyISAM表的特性" class="headerlink" title="利用MyISAM表的特性"></a>利用MyISAM表的特性</h2><p>在MySQL8.0之前，mysql.user表都是MyISAM表，可以利用MyISAM表的特性进行修改密码操作。MySQL8.0后，放弃了MyISAM表，所以这个方法对8.0后的版本没有用。</p><p>这个方法需要有一个临时的数据库。<br>假设我们当前有两个数据库，一个3307，一个3309；3307实例的密码忘记了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vdb_172_16_123_101 /root]# ps aux | grep mysql</span><br><span class="line">mysql     2792  0.3 10.3 1067856 184220 pts/0  Sl   19:46   0:00 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3307/my.cnf</span><br><span class="line">mysql     2822  0.4 10.5 1067856 186072 pts/0  Sl   19:46   0:00 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3309/my.cnf</span><br><span class="line">root      2869  0.0  0.0 112648   960 pts/0    R+   19:47   0:00 grep --color=auto mysql</span><br></pre></td></tr></table></figure></p><p>第一步：我们首先登录3309实例，并创建一个临时库testdb(库名可以指定定)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; create database testdb;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>第二步：将3307实例下的mysql库下的user*文件都拷贝到第一步创建的3309实例的testdb库下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# cp -a /data/mysql/mysql_3307/data/mysql/user.* /data/mysql/mysql_3309/data/testdb/</span><br><span class="line">[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3309.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 6</span><br><span class="line">Server version: 5.7.17-log MySQL Community Server (GPL)</span><br><span class="line"> </span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> </span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"> </span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; use testdb;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"> </span><br><span class="line">Database changed</span><br><span class="line">root@localhost:mysql_3309.sock [testdb]&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_testdb |</span><br><span class="line">+------------------+</span><br><span class="line">| user             |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>第三步：在3309实例下修改testdb库下user表的密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3309.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 7</span><br><span class="line">Server version: 5.7.17-log MySQL Community Server (GPL)</span><br><span class="line"> </span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> </span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"> </span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; select user,host,authentication_string from testdb.user;</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">| user      | host      | authentication_string                     |</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">| root      | localhost | *527F89C205EA0A51A7537FFA7B6090D91A7D77AE |</span><br><span class="line">| mysql.sys | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; update testdb.user set authentication_string=password(&apos;newpass&apos;) where user=&apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 1</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; exit</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure></p><p>第四步：将user*文件拷贝回3307的mysql库下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# cp -a /data/mysql/mysql_3309/data/testdb/user.* /data/mysql/mysql_3307/data/mysql</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.frm’? y</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.MYD’? y</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.MYI’? y</span><br></pre></td></tr></table></figure></p><p>第五步：给一个HUP信号给3307，重新加载配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# ps aux | grep mysqld</span><br><span class="line">mysql     2792  0.0 10.7 1067856 189960 pts/0  Sl   19:46   0:01 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3307/my.cnf</span><br><span class="line">mysql     2822  0.0 11.6 1067856 206352 pts/0  Sl   19:46   0:01 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3309/my.cnf</span><br><span class="line">root      2912  0.0  0.0 112648   964 pts/0    S+   20:07   0:00 grep --color=auto mysqld</span><br><span class="line">[root@vdb_172_16_123_101 /root]# kill -HUP 2792</span><br></pre></td></tr></table></figure></p><p>第六步：用新密码登录3307实例</p><pre><code>[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3307.sock -p&apos;newpass&apos;mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.7.17-log MySQL Community Server (GPL)Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.root@localhost:mysql_3307.sock [(none)]&gt; </code></pre><p>这种方法是利用MyISAM表拷贝即可使用的特性，在一个临时实例中修改后替换。可以不用重启数据库，不会对业务造成影响。<br>为了安全起见，在操作前还是需要对原文件进行备份。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL忘记密码怎么办？&quot;&gt;&lt;a href=&quot;#MySQL忘记密码怎么办？&quot; class=&quot;headerlink&quot; title=&quot;MySQL忘记密码怎么办？&quot;&gt;&lt;/a&gt;MySQL忘记密码怎么办？&lt;/h1&gt;&lt;p&gt;有的时候搭建MySQL后，由于密码没有保存好、忘记密码、密码过期等原因，导致登录不上数据库。这个时候该怎么办？&lt;/p&gt;
&lt;p&gt;如果数据库使用人员，那还是乖乖的找数据库管理人员修改密码吧！&lt;br&gt;如果是数据库管理人员，能够登录到MySQL实例所在服务器的话。下面将介绍两种方式进行修改密码操作。&lt;/p&gt;
&lt;h2 id=&quot;skip-grant-tables&quot;&gt;&lt;a href=&quot;#skip-grant-tables&quot; class=&quot;headerlink&quot; title=&quot;skip-grant-tables&quot;&gt;&lt;/a&gt;skip-grant-tables&lt;/h2&gt;&lt;p&gt;第一种方式就是网上介绍最多的通过配置skip-grant-tables参数来跳过MySQL登录校验后，进行修改密码。&lt;/p&gt;
&lt;p&gt;步骤就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要关闭MySQL实例。&lt;/li&gt;
&lt;li&gt;配置参数。这里有两种方式：第一种就是在启动的使用，启动命令添加–skip-grant-tables；第二种就是通过修改配置文件，在[mysqld]下添加skip-grant-tables。&lt;/li&gt;
&lt;li&gt;启动数据库&lt;/li&gt;
&lt;li&gt;通过alter mysql.user set authentication_string=password(‘newpass’) where XXX@XXX;&lt;/li&gt;
&lt;li&gt;去掉skip-grant-tables配置后重新启动。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;注：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL5.6的密码参数列为：password&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL5.7的密码参数列为：authentication_string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL的账号是以`用户名`@`主机地址`计算的。同一用户名不同主机地址视为不同账号。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方法的缺点很明显：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库必须有一段时间不能提供服务。&lt;/li&gt;
&lt;li&gt;开启跳过权限检查的参数后，安全性无法得到保障。所有人都能登录，即使没有改账号也能登录成功。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB整体架构</title>
    <link href="http://yoursite.com/2019/03/03/MySQL/InnoDB%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/03/MySQL/InnoDB整体架构/</id>
    <published>2019-03-03T12:14:16.000Z</published>
    <updated>2019-07-13T06:09:15.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InnoDB整体架构"><a href="#InnoDB整体架构" class="headerlink" title="InnoDB整体架构"></a>InnoDB整体架构</h1><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><ul><li>Master Thread<br>Master Thread具有最高的线程优先级别，内部由多个循环（每秒/每10秒）组成。<ol><li>每秒的操作<ul><li>刷新日志缓冲到磁盘（总是）</li><li>合并插入缓冲</li><li>刷新脏页到磁盘（至多100个）</li><li>切换到后台进程</li></ul></li><li>每10秒的操作<ul><li>删除无用的undo页（总是）</li><li>合并20个插入缓冲（总是）</li><li>调回主循环（总是）</li></ul></li></ol></li><li>IO Thread</li><li>purge Thread</li><li>Page cleaner Thread</li></ul><a id="more"></a><h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><ul><li><p>Change buffer（Insert buffer、Delete buffer、Purge buffer）<br>在对非唯一索引的插入和更新操作过程中，如果该数据页在内存中，则直接对数据页进行修改。如果该数据页不在内存中，Innodb并不会马上到磁盘上将该数据页读入内存中，而是先将修改存入到Change buffer中，再按照一定的频率将修改合并到数据页中。</p><ol><li>为什么是需要在非唯一索引的<br>如果是对唯一索引上的数据进行修改，那么在修改前需要进行唯一性校验，这个时候会对该数据页进行查询操作，此时已经将该数据页读取到了内存当中，所以Change buffer的优化对唯一索引并没有什么效果。</li><li>如果宕机是否会导致数据的丢失？<br>Change buffer中数据，不仅会保存在内存当中，还会持久化到磁盘（系统表空间）当中。（持久化机制？）</li><li>什么情况下会合并？<ul><li>当对该数据页进行查询操作时，会将该数据页读取到内存当中。此时，会进行Change buffer的合并操作，将Change buffer中对该数据页的修改应用到该数据页。</li><li>Insert buffer Bitmap页追踪到该辅助索引页中已无可用空间</li><li>Master Thread</li></ul></li><li>合并流程怎样？<ul><li>从磁盘中读取数据页到内存（老版本）</li><li>从Change buffer中读取这个数据页的修改引用到内存中的数据页</li><li>写redo log。记录了内存也和Change buffer的变更。（此时内存中的数据页属于脏页）<br><a href="https://imgchr.com/i/Zhzndf" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/Zhzndf.md.jpg" alt="Zhzndf.md.jpg"></a></li></ul></li></ol></li><li><p>redo buffer<br>redo log中记录的是数据页的物理修改。在事务执行过程中不断的写入到redo buffer中。<br>redo buffer在以下情况会持久化到磁盘。</p><ul><li>Master Thread每秒的定时任务</li><li>每个事务提交时</li><li>写入量过大，导致redo buffer不足是<br>由innodb_flush_log_at_trx_commit控制刷盘策略</li><li>0代表当事务提交时刷盘，只由Master Thread每秒定时任务执行刷盘</li><li>1代表在执行commit时将重做日志缓冲同步到写到磁盘</li><li>2异步刷盘，直接写到文件系统的缓存中，不保证commit执行时肯定会刷盘</li></ul></li><li>数据页和索引页<br>数据都是存储在磁盘上的，当需要访问时才会从磁盘中将该数据所在的页读取到内存当中，并以一定的策略进行淘汰策略和刷盘策略。</li><li>哈希信息页</li><li>元数据信息页</li></ul><h3 id="Innodb机制"><a href="#Innodb机制" class="headerlink" title="Innodb机制"></a>Innodb机制</h3><ul><li>checkpoint<br>在一定条件下，将内存中的脏页持久化到磁盘，并记录数据页刷新的位点信息(LSN)的一种机制。<ol><li>缩短数据库的恢复时间（数据库关闭时将所有的脏页刷新到磁盘/Sharp Checkpoint）</li><li>缓冲池不够用时，刷新部分脏页（为了保证缓冲池中有足够可用的数据页，Innodb会强制进行Checkpoint/Dirty Page too much Checkpoint)</li><li>重做日志不可用时，刷新部分脏页（redo log是一个循环文件，如果redo log的写入量特别大，导致此时redo log几乎写满，Innodb会先将部分脏页先刷新到磁盘，释放redo log空间，此时会触发Checkpoint。/Async/Sync Flush Checkpoint）</li><li>Master Thread每秒任务，刷新部分脏页</li><li>LRU列表空闲页不足时，刷新部分脏页（Innodb会保证LRU列表中有一定数量空闲页可使用，如果LRU列表中没有这么多空闲页，那么Innodb会将LRU列表尾端的页移除，如果其中存在脏页，那么此时会进行Checkpoint操作/FLUSH_LRU_LIST Checkpoint）</li></ol></li><li><p>两次写（Double write）<br>在写数据之前，先把这个数据页写到一块独立物理位置后，再写到数据页中。<br>由两部分组成，一部分是Innodb内存中的double write buffer；另一部分是物理磁盘上的ibdata系统表空间的大小为2M，共128个连续的page。<br>在对缓冲池中的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer分两次，每次1M顺序地写入到共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘。<br><a href="https://imgchr.com/i/ZhzmeP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhzmeP.md.jpg" alt="ZhzmeP.md.jpg"></a></p></li><li><p>WAL（write ahead log)</p><pre><code>1. 先记录undo/redo log,确保日志刷到磁盘上持久存储。2. 更新内存数据页，并&lt;font color=&quot;red&quot;&gt;异步刷盘&lt;/font&gt;。3. 事务日志持久化到binlog，&lt;font color=&quot;red&quot;&gt;此时返回给客户端事务已提交&lt;/font&gt;。4. 提交事务，在redo log中写入到commit记录。</code></pre></li><li><p>两阶段提交<br>我们可以看到对于更新数据的操作，MySQL的处理逻辑是先将内存中的数据页更新，然后写入redolog(prepare阶段），写入binglog，redo log(commit阶段)<br><a href="https://imgchr.com/i/ZhzEQA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhzEQA.md.jpg" alt="ZhzEQA.md.jpg"></a></p><p>在两阶段不同时刻宕机，会发生什么情况？<br>innodb发现redolog中没有commit，就会拿着XA号去binlog中寻找是否存在</p><ul><li>在时刻A宕机，此时是不存在的，所以事务回滚。</li><li>在时刻B宕机，此时Binlog中存在该XA号，所以会恢复该事务。</li></ul></li><li><p>MVCC(多版本并发控制）<br>事务在开启的时候会获取一个一致性快照，每个事务都有一个唯一的事务ID，叫做transaction ID。<br>每行数据也有多个版本，每次事务更新数据的时候都会生成一个新的数据版本，并且将transaction ID赋值给这个数据版本的事务ID。<br>图中的虚线代表的就是undo log,V1、V2、V3并不物理真实存在，需要获取V2则需要从V4依次应用U3、U2。<br>一个数据版本，对于一个事务视图来说，除了自己更新的总是可见以外：</p><ol><li>版本未提交，不可见</li><li>版本已提交，但是是在视图创建后提交的，不可见</li><li>版本已提交，而且是在视图创建前提交的，可见<br><a href="https://imgchr.com/i/Zhzuo8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/Zhzuo8.md.jpg" alt="Zhzuo8.md.jpg"></a></li></ol></li><li><p>自适应哈希</p></li><li>异步IO</li><li>刷新临近页</li><li>组提交<h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;InnoDB整体架构&quot;&gt;&lt;a href=&quot;#InnoDB整体架构&quot; class=&quot;headerlink&quot; title=&quot;InnoDB整体架构&quot;&gt;&lt;/a&gt;InnoDB整体架构&lt;/h1&gt;&lt;h3 id=&quot;后台线程&quot;&gt;&lt;a href=&quot;#后台线程&quot; class=&quot;headerlink&quot; title=&quot;后台线程&quot;&gt;&lt;/a&gt;后台线程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Master Thread&lt;br&gt;Master Thread具有最高的线程优先级别，内部由多个循环（每秒/每10秒）组成。&lt;ol&gt;
&lt;li&gt;每秒的操作&lt;ul&gt;
&lt;li&gt;刷新日志缓冲到磁盘（总是）&lt;/li&gt;
&lt;li&gt;合并插入缓冲&lt;/li&gt;
&lt;li&gt;刷新脏页到磁盘（至多100个）&lt;/li&gt;
&lt;li&gt;切换到后台进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每10秒的操作&lt;ul&gt;
&lt;li&gt;删除无用的undo页（总是）&lt;/li&gt;
&lt;li&gt;合并20个插入缓冲（总是）&lt;/li&gt;
&lt;li&gt;调回主循环（总是）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;IO Thread&lt;/li&gt;
&lt;li&gt;purge Thread&lt;/li&gt;
&lt;li&gt;Page cleaner Thread&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL体系结构</title>
    <link href="http://yoursite.com/2019/03/02/MySQL/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/02/MySQL/MySQL体系结构/</id>
    <published>2019-03-02T12:14:16.000Z</published>
    <updated>2019-07-13T05:56:52.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h1><p><a href="https://imgchr.com/i/ZhxoZV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhxoZV.md.jpg" alt="ZhxoZV.md.jpg"></a></p><ul><li>连接器<br>连接器负责跟客户端建立连接、获取权限、维持和管理连接。<br>在这个阶段，连接器会对用户输入的账号密码进行判断。并判断用户连接和数据库连接是否都到了最大限制。以及后续对超时连接进行清理操作。<ol><li>在连接之前，不管用户名密码是够正确，权限如何，连接器会先对连接数进行检查。</li><li>权限会存在两份，一份在数据库中持久化存储，一份保存在内存当中。flush privileges操作就是将内存中的信息给清空，并从数据库中重新加载到内存中。</li><li>在执行grant和revoke操作时，会先将磁盘中的信息修改，然后同步到内存中。但是如果是直接修改的mysql.user表，此时不会主动去更新内存。</li><li>连接器只会到内存中读取用户信息以及权限。连接器只会在进行连接的时候才对用户账号密码进行校验，这意味着，如果一个用户已经连接上，修改密码并不会影响此连接。</li><li>对于全局权限是实时从内存中获取，这代表如果进行权限修改会马上生效。但是对库的权限修改稍微有点区别，虽然也是实时同步到内存，但是如果该连接已经使用了use database进入某库，那么该连接会将该库的权限保存到当前会话变量中，对该库操作权限仍是进入时的状态。</li></ol></li><li>缓存器<br>缓存器会将之前执行过的语句以key-value的形式缓存在内存当中，key是执行的语句,value是该语句执行的结果。如果能够直接获取到，那么会将结果直接返回。（返回结果前还会进行一次权限校验）<br>但是，如果对该表存在更新等数据修改操作，那么这个表上所有的缓存将会清空以保证读取数据的一致性。</li><li>分析器<br>对sql进行词法和语法分析，此时会生成一颗解析树。此时会将sql语句转化成数据库能够看懂的形式，如将字符串’T’识别成’表名T’。此时会去读取库表结构，判断该表是否存在，该字段是够存在。</li><li>优化器<br>根据自身的信息采集、以往执行计划分析等选择自认为最优的执行计划、选择相应的索引。<br>MySQL有一整套规则来判断SQL语句的最优方案，但是该方案不一定是最快的。<br>可以人为的对优化器进行控制，使其选择相应的方案。如force index/ignore index/STRAIGHT_JOIN等。</li><li>执行器<br>根据优化器生成的执行计划来调用存储引擎的接口获取数据并对数据进行处理返回给客户端。</li><li>存储引擎</li></ul><h1 id="MySQL内存结构"><a href="#MySQL内存结构" class="headerlink" title="MySQL内存结构"></a>MySQL内存结构</h1><p><a href="https://imgchr.com/i/ZhxTaT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhxTaT.md.jpg" alt="ZhxTaT.md.jpg"></a></p><h2 id="全局内存"><a href="#全局内存" class="headerlink" title="全局内存"></a>全局内存</h2><ul><li>innodb_buffer_pool_size  innodb缓冲池大小</li><li>innodb_log_buffer_size   redo日志缓冲</li><li>key_buffer_size          MyISAM索引缓冲</li><li>table_definition_cache   表定义文件描述缓存</li><li>table_open_cache         表空间文件描述缓存</li><li>max_heap_table_size      memory、heap表的最大容量</li></ul><h2 id="线程内存"><a href="#线程内存" class="headerlink" title="线程内存"></a>线程内存</h2><ul><li>read_buffer_size</li><li>read_rnd_buffer_size</li><li>sort_buffer_size</li><li>join_buffer_size</li><li>binlog_cache_size</li><li>tmp_table_size</li><li>thread_stack</li><li>thread_chche_size</li><li>net_buffer_length</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL体系结构&quot;&gt;&lt;a href=&quot;#MySQL体系结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL体系结构&quot;&gt;&lt;/a&gt;MySQL体系结构&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/ZhxoZV&quot; targ
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis的内存管理和优化</title>
    <link href="http://yoursite.com/2019/01/25/Redis/Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/25/Redis/Redis的内存管理和优化/</id>
    <published>2019-01-25T13:34:13.000Z</published>
    <updated>2019-06-19T09:32:34.189Z</updated>
    
    <content type="html"><![CDATA[<p>Redis中的内存使用主要是数据使用内存+客户端连接使用内存+内存碎片。<br>其中数据内存占用的最多，优化的常用手段是合理的控制对象的生命周期以及正确的使用数据结构。客户端使用内存主要包含输出缓冲区等一些数据传输缓存。</p><h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><p>只有熟悉的了解数据结构的组成、特性、性能、边界条件等因素后，我们还能更好的分析该数据结构的使用场景和资源消耗情况。</p><p>在Redis当中，所有的对象都是通过（redisObject+具体的对象）形式存在的，所有的对象都被封装在redisObject中，redisObject有五个成员：对象类型（type）、底层编码（encoding)、lru（最近访问时间）、refcount（引用数）、*ptr（指向具体对象的指针）。该结构一共会占用16字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><p>Redis一共有五种基本类型（其他的特殊类型都是此基础上形成的）string、list、hash、set、zset。<br><a href="https://imgchr.com/i/V7Jart" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7Jart.md.jpg" alt="V7Jart.md.jpg"></a></p><p>每一种数据类型在底层的存储实现存在多种选择，根据实际情况选择合适的编码类型。在效率和资源之间做出合适的权衡。<br><a href="https://imgchr.com/i/V7JtxA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JtxA.md.jpg" alt="V7JtxA.md.jpg"></a></p><a id="more"></a><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>String类型是redis中使用最为广泛的一个类型，所有的key都是字符串类型；它使用的是redis自己设计的SDS结构：包含len、free以及字符串数组。可以O(1)获取字符串长度和空闲空间。<br>通过buf数组存储数据可以保证二进制安全，以及SDS的预分配机制可以避免频繁的进行数组扩容行为。<br>在创建的字符串长度小于等于39（3.2版本后为44）的时候，Redis会使用embstr编码来存储字符串；在这种编码下，只会进行一次内存分配，会把redisObject和sds一起分配；所以embstr编码的字符串是不能改变的，如果对该字符串进行修改，则该编码会直接变成raw。<br>此外，如果是整型字符串的话，String会使用int格式，直接将整数的值赋值给指针对象。这样就省去了sds的开销。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    int len;</span><br><span class="line">    int free;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><a href="https://imgchr.com/i/V7JY2d" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JY2d.md.jpg" alt="V7JY2d.md.jpg"></a></p><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>压缩列表是将所有的元素紧凑的连接在一起，相当于把所有的成员都叠在一起，没有额外的数据结构，空间占用比较小。缺点就是在读写的时候需要修改整个压缩列表，所以在数据量比较小的时候才使用，一般能够达到5-10倍的压缩比。</p><ul><li>ziplist：记录了整个压缩列表所占用的内存直接数</li><li>ziplist：记录压缩表尾节点举例压缩列表起始地址的字节偏移量，通过这个偏移量可以直接确定表尾节点的地址</li><li>zllen：记录了压缩列表包含的节点数量</li><li>entryX：节点列表，压缩列表包含的各个节点，里面记录了前一个节点的长度、本节点的长度、编码等信息。可以方便的实现逆序遍历。</li><li>zlend：特殊值，用于标记压缩列表的末尾。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zlentry &#123;</span><br><span class="line">    unsigned int prevrawlensize, prevrawlen;</span><br><span class="line">    unsigned int lensize, len;</span><br><span class="line">    unsigned int headersize;</span><br><span class="line">    unsigned char encoding;</span><br><span class="line">    unsigned char *p;</span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://imgchr.com/i/V7JJ8H" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JJ8H.md.jpg" alt="V7JJ8H.md.jpg"></a></p><h2 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h2><p>在Redis启动的时候，就直接创建了10000个redisObject，代表1-10000的整型，这些整型会一直保存在内存当中，当其他对象需要用到时，就会共享使用这些整型。这也意味着这些整型LRU成员没有用，后续不会有其他的一些开销。</p><h2 id="键值对管理"><a href="#键值对管理" class="headerlink" title="键值对管理"></a>键值对管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    dict *dict;                 /* The keyspace for this DB */</span><br><span class="line">    dict *expires;              /* Timeout of keys with a timeout set */</span><br><span class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */</span><br><span class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</span><br><span class="line">    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */</span><br><span class="line">    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */</span><br><span class="line">    int id;                     /* Database ID */</span><br><span class="line">    long long avg_ttl;          /* Average TTL, just for stats */</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>在redis当中使用redisDb表示一个数据库结构，单个redis可以设置16个这样的DB；通过select命令进行选择，不同DB之间互不影响。</p><h3 id="过期Key清理"><a href="#过期Key清理" class="headerlink" title="过期Key清理"></a>过期Key清理</h3><p>通过一个dict结构(dict)来存储具体键值对对象；一个dict结构(expires)来记录redis中设置了过期时间的键值对，这个结构会复用dict中的Key、Value对象，所以并不会造成额外的内存开销。</p><p>在Key过期的时候，redis会自动执行一个del操作对过期的Key进行清理操作。这个行为并不是立即去执行的，而是会在几个条件下触发。一般只会在必要或者CPU空闲的时候做过期清理动作；如访问Key的时候、事件循环结束进入事件侦听前、后台定期任务。</p><p>Redis后台清理任务默认1s执行10次，也就是100ms一次。相当于如果没有其他操作，全部用来做后台任务的话，一次后台任务可以执行100ms；其中最高25%的时间用来删除过期Key的操作，即100ms中有25ms可以用来做Key清理。其他时间用来做Redis管理的任务。</p><p>过期Key清理算法：</p><ol><li>依次遍历所有的DB</li><li>从DB中随机取20个键值对，判断是否过期，如果过期，则删除。</li><li>如果取出的键值对中有大于5个过期，则重复上一步；否则遍历下一个DB</li><li>在清理过程中，如果达到了时间限制，退出清理过程。</li></ol><p>//TODO<br>redis的过期Key清理是在redis.c/activeExpireCycle()函数实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">void activeExpireCycle(int type) &#123;</span><br><span class="line">    /* This function has some global state in order to continue the work</span><br><span class="line">     * incrementally across calls. */</span><br><span class="line">    // 静态变量，用来累积函数连续执行时的数据</span><br><span class="line">    static unsigned int current_db = 0; /* Last DB tested. */</span><br><span class="line">    static int timelimit_exit = 0;      /* Time limit hit in previous call? */</span><br><span class="line">    static long long last_fast_cycle = 0; /* When last fast cycle ran. */</span><br><span class="line"></span><br><span class="line">    unsigned int j, iteration = 0;</span><br><span class="line">    // 默认每次处理的数据库数量</span><br><span class="line">    unsigned int dbs_per_call = REDIS_DBCRON_DBS_PER_CALL;</span><br><span class="line">    // 函数开始的时间</span><br><span class="line">    long long start = ustime(), timelimit;</span><br><span class="line"></span><br><span class="line">    // 快速模式</span><br><span class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        /* Don&apos;t start a fast cycle if the previous cycle did not exited</span><br><span class="line">         * for time limt. Also don&apos;t repeat a fast cycle for the same period</span><br><span class="line">         * as the fast cycle total duration itself. */</span><br><span class="line">        // 如果上次函数没有触发 timelimit_exit ，那么不执行处理</span><br><span class="line">        if (!timelimit_exit) return;</span><br><span class="line">        // 如果距离上次执行未够一定时间，那么不执行处理</span><br><span class="line">        if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;</span><br><span class="line">        // 运行到这里，说明执行快速处理，记录当前时间</span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We usually should test REDIS_DBCRON_DBS_PER_CALL per iteration, with</span><br><span class="line">     * two exceptions:</span><br><span class="line">     *</span><br><span class="line">     * 一般情况下，函数只处理 REDIS_DBCRON_DBS_PER_CALL 个数据库，</span><br><span class="line">     * 除非：</span><br><span class="line">     *</span><br><span class="line">     * 1) Don&apos;t test more DBs than we have.</span><br><span class="line">     *    当前数据库的数量小于 REDIS_DBCRON_DBS_PER_CALL</span><br><span class="line">     * 2) If last time we hit the time limit, we want to scan all DBs</span><br><span class="line">     * in this iteration, as there is work to do in some DB and we don&apos;t want</span><br><span class="line">     * expired keys to use memory for too much time. </span><br><span class="line">     *     如果上次处理遇到了时间上限，那么这次需要对所有数据库进行扫描，</span><br><span class="line">     *     这可以避免过多的过期键占用空间</span><br><span class="line">     */</span><br><span class="line">    if (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line"></span><br><span class="line">    /* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time</span><br><span class="line">     * per iteration. Since this function gets called with a frequency of</span><br><span class="line">     * server.hz times per second, the following is the max amount of</span><br><span class="line">     * microseconds we can spend in this function. */</span><br><span class="line">    // 函数处理的微秒时间上限</span><br><span class="line">    // ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 默认为 25 ，也即是 25 % 的 CPU 时间</span><br><span class="line">    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;</span><br><span class="line">    timelimit_exit = 0;</span><br><span class="line">    if (timelimit &lt;= 0) timelimit = 1;</span><br><span class="line"></span><br><span class="line">    // 如果是运行在快速模式之下</span><br><span class="line">    // 那么最多只能运行 FAST_DURATION 微秒 </span><br><span class="line">    // 默认值为 1000 （微秒）</span><br><span class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */</span><br><span class="line"></span><br><span class="line">    // 遍历数据库</span><br><span class="line">    for (j = 0; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">        int expired;</span><br><span class="line">        // 指向要处理的数据库</span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"></span><br><span class="line">        /* Increment the DB now so we are sure if we run out of time</span><br><span class="line">         * in the current DB we&apos;ll restart from the next. This allows to</span><br><span class="line">         * distribute the time evenly across DBs. */</span><br><span class="line">        // 为 DB 计数器加一，如果进入 do 循环之后因为超时而跳出</span><br><span class="line">        // 那么下次会直接从下个 DB 开始处理</span><br><span class="line">        current_db++;</span><br><span class="line"></span><br><span class="line">        /* Continue to expire if at the end of the cycle more than 25%</span><br><span class="line">         * of the keys were expired. */</span><br><span class="line">        do &#123;</span><br><span class="line">            unsigned long num, slots;</span><br><span class="line">            long long now, ttl_sum;</span><br><span class="line">            int ttl_samples;</span><br><span class="line"></span><br><span class="line">            /* If there is nothing to expire try next DB ASAP. */</span><br><span class="line">            // 获取数据库中带过期时间的键的数量</span><br><span class="line">            // 如果该数量为 0 ，直接跳过这个数据库</span><br><span class="line">            if ((num = dictSize(db-&gt;expires)) == 0) &#123;</span><br><span class="line">                db-&gt;avg_ttl = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取数据库中键值对的数量</span><br><span class="line">            slots = dictSlots(db-&gt;expires);</span><br><span class="line">            // 当前时间</span><br><span class="line">            now = mstime();</span><br><span class="line"></span><br><span class="line">            /* When there are less than 1% filled slots getting random</span><br><span class="line">             * keys is expensive, so stop here waiting for better times...</span><br><span class="line">             * The dictionary will be resized asap. */</span><br><span class="line">            // 这个数据库的使用率低于 1% ，扫描起来太费力了（大部分都会 MISS）</span><br><span class="line">            // 跳过，等待字典收缩程序运行</span><br><span class="line">            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*100/slots &lt; 1)) break;</span><br><span class="line"></span><br><span class="line">            /* The main collection cycle. Sample random keys among keys</span><br><span class="line">             * with an expire set, checking for expired ones. </span><br><span class="line">             *</span><br><span class="line">             * 样本计数器</span><br><span class="line">             */</span><br><span class="line">            // 已处理过期键计数器</span><br><span class="line">            expired = 0;</span><br><span class="line">            // 键的总 TTL 计数器</span><br><span class="line">            ttl_sum = 0;</span><br><span class="line">            // 总共处理的键计数器</span><br><span class="line">            ttl_samples = 0;</span><br><span class="line"></span><br><span class="line">            // 每次最多只能检查 LOOKUPS_PER_LOOP 个键</span><br><span class="line">            if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line"></span><br><span class="line">            // 开始遍历数据库</span><br><span class="line">            while (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                long long ttl;</span><br><span class="line"></span><br><span class="line">                // 从 expires 中随机取出一个带过期时间的键</span><br><span class="line">                if ((de = dictGetRandomKey(db-&gt;expires)) == NULL) break;</span><br><span class="line">                // 计算 TTL</span><br><span class="line">                ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                // 如果键已经过期，那么删除它，并将 expired 计数器增一</span><br><span class="line">                if (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                if (ttl &lt; 0) ttl = 0;</span><br><span class="line">                // 累积键的 TTL</span><br><span class="line">                ttl_sum += ttl;</span><br><span class="line">                // 累积处理键的个数</span><br><span class="line">                ttl_samples++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* Update the average TTL stats for this database. */</span><br><span class="line">            // 为这个数据库更新平均 TTL 统计数据</span><br><span class="line">            if (ttl_samples) &#123;</span><br><span class="line">                // 计算当前平均值</span><br><span class="line">                long long avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line">                </span><br><span class="line">                // 如果这是第一次设置数据库平均 TTL ，那么进行初始化</span><br><span class="line">                if (db-&gt;avg_ttl == 0) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                /* Smooth the value averaging with the previous one. */</span><br><span class="line">                // 取数据库的上次平均 TTL 和今次平均 TTL 的平均值</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl+avg_ttl)/2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* We can&apos;t block forever here even if there are many keys to</span><br><span class="line">             * expire. So after a given amount of milliseconds return to the</span><br><span class="line">             * caller waiting for the other active expire cycle. */</span><br><span class="line">            // 我们不能用太长时间处理过期键，</span><br><span class="line">            // 所以这个函数执行一定时间之后就要返回</span><br><span class="line"></span><br><span class="line">            // 更新遍历次数</span><br><span class="line">            iteration++;</span><br><span class="line"></span><br><span class="line">            // 每遍历 16 次执行一次</span><br><span class="line">            if ((iteration &amp; 0xf) == 0 &amp;&amp; /* check once every 16 iterations. */</span><br><span class="line">                (ustime()-start) &gt; timelimit)</span><br><span class="line">            &#123;</span><br><span class="line">                // 如果遍历次数正好是 16 的倍数</span><br><span class="line">                // 并且遍历的时间超过了 timelimit</span><br><span class="line">                // 那么断开 timelimit_exit</span><br><span class="line">                timelimit_exit = 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 已经超时了，返回</span><br><span class="line">            if (timelimit_exit) return;</span><br><span class="line"></span><br><span class="line">            /* We don&apos;t repeat the cycle if there are less than 25% of keys</span><br><span class="line">             * found expired in the current DB. */</span><br><span class="line">            // 如果已删除的过期键占当前总数据库带过期时间的键数量的 25 %</span><br><span class="line">            // 那么不再遍历</span><br><span class="line">        &#125; while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设想在一个大型的Redis实例中所有的Key在同一时间过期了会出现什么样的结果？</p><p>答案就是：会导致线上读写请求出现明显的卡顿现象。<br>首先，Redis会持续扫描过期字典（多次循环），直到过期字典中的Key变得稀疏才会减缓清理的节奏。另外一个原因就是内存管理器需要频繁的回收内存页，会产生一定的CPU消耗。</p><p>当客户端请求到来时，服务器如果正好过期扫描，客户端的请求将会等待至少25ms后才会进行处理，如果客户端将超时时间设置的比较短，比如10ms，那么就会出现大量的链接因为超时而关闭，业务端就会出现很多异常。<br>并且这时还无法从Redis的slowlog中看到慢查询记录，因为慢查询指的是逻辑处理过程慢，不包含等待时间。</p><p>所以业务开发人员一定要注意过期时间，如果有大批量的key过期，要给过期时间设置一个随机范围，分散过期处理的压力。</p><p>##淘汰机制<br>实例的内存是有上限的，当使用的内存超过了允许的最大内存时，Redis会按照设定的淘汰策略清理内存，以保证实例的正常运行。</p><ul><li>volatile-lru：从<strong>已设置过期时间</strong>的数据中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从<strong>已设置过期时间</strong>的数据中挑选将要过期的数据淘汰</li><li>volatile-random：从<strong>已设置过期时间</strong>的数据集中任意选择数据淘汰</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集中任意选择数据淘汰</li><li>no-enviction：禁止淘汰数据</li></ul><p>淘汰算法：</p><ol><li>遍历所有DB</li><li>按照设置的淘汰策略挑选一个Key进行淘汰</li><li>若策略是lru或ttl，采用近似算法随机取n个样本(默认为5，可配置)，从中挑选出最佳值进行淘汰</li><li>计算内存是否超过允许值，若是，重复1~3</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>最佳实践就是平时遇到的一些好案例，或者从前面的原理导出的一些结论。首先，最重要的就是选择正确的数据类型，主要以满足业务，性能和场景为优先考虑。一般数据量不大的业务，没必要花太大的精力；但是对于一些主要业务，就需要做比较细致的优化。如String类型对象可以考虑使用整数，浮点型可以改成整数。对于数据量比较大，比较重要的业务，可以深入优化，根据业务场景对字符串类型进行合理的拆分，以符合使用压缩列表的(可以适当的对压缩列表的转换条件进行放宽)。</p><p><a href="https://imgchr.com/i/V7JUKI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JUKI.md.jpg" alt="V7JUKI.md.jpg"></a><br>这是官网上的一个例子，在4存Key-Value的时候，以object后面加一个整数作为ID，整个数据库可能都是这种类型，数据量又特别大，想对它优化的时候，比较通用的优化方法就是取模，相同前缀的Key单独做hash。整个db空间相当于一个大的哈希表，这样就把本来分配给整个db空间的Key，按照不同的前缀分成小的哈希表，每个哈希表里面保证数据比较小，那这个哈希表就会用压缩列表来保存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis中的内存使用主要是数据使用内存+客户端连接使用内存+内存碎片。&lt;br&gt;其中数据内存占用的最多，优化的常用手段是合理的控制对象的生命周期以及正确的使用数据结构。客户端使用内存主要包含输出缓冲区等一些数据传输缓存。&lt;/p&gt;
&lt;h2 id=&quot;Redis的数据结构&quot;&gt;&lt;a href=&quot;#Redis的数据结构&quot; class=&quot;headerlink&quot; title=&quot;Redis的数据结构&quot;&gt;&lt;/a&gt;Redis的数据结构&lt;/h2&gt;&lt;p&gt;只有熟悉的了解数据结构的组成、特性、性能、边界条件等因素后，我们还能更好的分析该数据结构的使用场景和资源消耗情况。&lt;/p&gt;
&lt;p&gt;在Redis当中，所有的对象都是通过（redisObject+具体的对象）形式存在的，所有的对象都被封装在redisObject中，redisObject有五个成员：对象类型（type）、底层编码（encoding)、lru（最近访问时间）、refcount（引用数）、*ptr（指向具体对象的指针）。该结构一共会占用16字节。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct redisObject &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned type:4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned encoding:4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int refcount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *ptr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; robj;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Redis一共有五种基本类型（其他的特殊类型都是此基础上形成的）string、list、hash、set、zset。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/V7Jart&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/16/V7Jart.md.jpg&quot; alt=&quot;V7Jart.md.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每一种数据类型在底层的存储实现存在多种选择，根据实际情况选择合适的编码类型。在效率和资源之间做出合适的权衡。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/V7JtxA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/16/V7JtxA.md.jpg&quot; alt=&quot;V7JtxA.md.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Binlog格式</title>
    <link href="http://yoursite.com/2019/01/23/MySQL/Binlog%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/01/23/MySQL/Binlog格式/</id>
    <published>2019-01-23T12:14:16.000Z</published>
    <updated>2019-06-16T14:42:53.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binlog日志格式"><a href="#Binlog日志格式" class="headerlink" title="Binlog日志格式"></a>Binlog日志格式</h1><p>binlog_format是规定binlog日志文件记录语句方式的参数，可以动态修改，支持session和global级别，可选项有row、statement、mixed。</p><ul><li>row：以修改前后的数据信息，能够清晰的展现出数据变更，便于解析binlog文件后开发闪回功能。缺点是会产生大量的日志，在某些情况下会占用大量的IO资源。</li><li>statement：语句格式；仅记录执行的语句，在特定情况下会可能会导致数据的不一致；优点很明显，减少了binlog日志量，减少IO。</li><li>mixed：以上两种模式的混合使用，一般情况下使用statement保存，在可能会导致数据不一致的情况使用row保存</li></ul><a id="more"></a><h2 id="row格式"><a href="#row格式" class="headerlink" title="row格式"></a>row格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># at 860</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 925 CRC32 0x1fcb13d6  GTID    last_committed=2        sequence_number=3</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;a81311dd-448f-11e9-be56-06d4d400045d:113&apos;/*!*/;</span><br><span class="line"># at 925</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 996 CRC32 0x106b145e  Query   thread_id=210   exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1555398441/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 996</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1055 CRC32 0x2920f8d2         Rows_query</span><br><span class="line"># update t set age = 24 where id = 15</span><br><span class="line"># at 1055</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1102 CRC32 0x07a1009c         Table_map: `hoo`.`t` mapped to number 223</span><br><span class="line"># at 1102</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1162 CRC32 0xef28b2a8         Update_rows: table id 223 flags: STMT_END_F</span><br><span class="line">### UPDATE `hoo`.`t`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=15 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&apos;xx&apos; /* VARSTRING(40) meta=40 nullable=1 is_null=0 */</span><br><span class="line">###   @3=22 /* INT meta=0 nullable=1 is_null=0 */</span><br><span class="line">### SET</span><br><span class="line">###   @1=15 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&apos;xx&apos; /* VARSTRING(40) meta=40 nullable=1 is_null=0 */</span><br><span class="line">###   @3=24 /* INT meta=0 nullable=1 is_null=0 */</span><br><span class="line"># at 1162</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1193 CRC32 0x90bc6f89         Xid = 2975</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;AUTOMATIC&apos; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure><p>在执行正式的SQL语句前会先去执行SET @@SESSION.GTID_NEXT和SET TIMESTAMP两个命令。这意味着即使事务回滚，他所申请的gtid也不会再被复用。</p><p>我们可以看到binlog文件中专门有一段(Update_rows)用来记录受影响的行在修改前后的记录。</p><p>此外，row格式的binlog记录还会受另一个参数的影响：binlog_row_image；<br>binlog_row_image是5.6版本出现的参数，控制在binlog_format=row情况下的binlog日志记录格式；可选项有full、minimal、noblob，默认值是full，可以动态修改，支持session和global级别。</p><ul><li>full：记录所有列的信息</li><li>minimal：仅仅记录被更改以及能够唯一识别数据行的列值（如：主键列）</li><li>noblob：记录所有的列值信息，但是BLOB和TEXT列除外（如未修改）</li></ul><h2 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># at 1193</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1258 CRC32 0x518fd71a         GTID    last_committed=3        sequence_number=4</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;a81311dd-448f-11e9-be56-06d4d400045d:114&apos;/*!*/;</span><br><span class="line"># at 1258</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1335 CRC32 0xc276a08b         Query   thread_id=210   exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1555398636/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 1335</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1442 CRC32 0xf4c40dce         Query   thread_id=210   exec_time=0     error_code=0</span><br><span class="line">use `hoo`/*!*/;</span><br><span class="line">SET TIMESTAMP=1555398636/*!*/;</span><br><span class="line">update t set age = 24 where id = 14</span><br><span class="line">/*!*/;</span><br><span class="line"># at 1442</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1473 CRC32 0xdf3eeac5         Xid = 2978</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;AUTOMATIC&apos; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>我们看到在statement格式下，binlog记录了库名、事务开启时的时间戳、具体执行的语句。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binlog日志格式&quot;&gt;&lt;a href=&quot;#Binlog日志格式&quot; class=&quot;headerlink&quot; title=&quot;Binlog日志格式&quot;&gt;&lt;/a&gt;Binlog日志格式&lt;/h1&gt;&lt;p&gt;binlog_format是规定binlog日志文件记录语句方式的参数，可以动态修改，支持session和global级别，可选项有row、statement、mixed。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;row：以修改前后的数据信息，能够清晰的展现出数据变更，便于解析binlog文件后开发闪回功能。缺点是会产生大量的日志，在某些情况下会占用大量的IO资源。&lt;/li&gt;
&lt;li&gt;statement：语句格式；仅记录执行的语句，在特定情况下会可能会导致数据的不一致；优点很明显，减少了binlog日志量，减少IO。&lt;/li&gt;
&lt;li&gt;mixed：以上两种模式的混合使用，一般情况下使用statement保存，在可能会导致数据不一致的情况使用row保存&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>当执行-single-transaction做逻辑备份时，遇到DDL</title>
    <link href="http://yoursite.com/2019/01/22/MySQL/mysqldump%E9%81%87%E5%88%B0DDL/"/>
    <id>http://yoursite.com/2019/01/22/MySQL/mysqldump遇到DDL/</id>
    <published>2019-01-22T12:54:48.000Z</published>
    <updated>2019-01-22T15:18:49.766Z</updated>
    
    <content type="html"><![CDATA[<p>当使用-single-transaction做逻辑备份的时候，遇到一个DDL语句会怎样？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；</span><br><span class="line">/* other tables */</span><br><span class="line">Q3:SAVEPOINT sp;</span><br><span class="line">/* 时刻 1 */</span><br><span class="line">Q4:show create table `t1`;</span><br><span class="line">/* 时刻 2 */</span><br><span class="line">Q5:SELECT * FROM `t1`;</span><br><span class="line">/* 时刻 3 */</span><br><span class="line">Q6:ROLLBACK TO SAVEPOINT sp;</span><br><span class="line">/* 时刻 4 */</span><br><span class="line">/* other tables */</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在备份开始的时候，为了确保RR隔离级别，再设置一次RR隔离级别（Q1）</p><p>启动事务，使用WITH CONSISTENT SNAPSHOP确保语句执行完得到一个一致性视图（Q2）</p><p>设置一个保存点，这个很重要（Q3）</p><p>show create是为了拿到表结构（Q4），然后正式导数据（Q5），回滚到SAVEPOINT sp，作用是释放t1的MDL锁。</p><p>按照DDL执行的时间不同，效果不同。</p><ol><li>如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。</li><li>如果在“时刻2”到达，则表结构被改过，Q5执行的时候，报Table definition has changed，please retry transaction，现象：mysqldump终止。</li><li>如果在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，现象：主从延迟，知道Q6执行完成。</li><li>从“时刻4”开始，mysqldump释放MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当使用-single-transaction做逻辑备份的时候，遇到一个DDL语句会怎样？&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* other tables */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q3:SAVEPOINT sp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 时刻 1 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q4:show create table `t1`;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 时刻 2 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q5:SELECT * FROM `t1`;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 时刻 3 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q6:ROLLBACK TO SAVEPOINT sp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 时刻 4 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* other tables */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="MYSQL45讲" scheme="http://yoursite.com/tags/MYSQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="http://yoursite.com/2019/01/21/MySQL/%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/01/21/MySQL/索引/</id>
    <published>2019-01-21T14:21:45.000Z</published>
    <updated>2019-01-22T02:20:42.787Z</updated>
    
    <content type="html"><![CDATA[<font color="red">索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</font><h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>索引的出现时为了提高查询效率，但是实现索引的方式有很多种，所以这里也就引入了索引模型的概念。可以用来提高读写操作的数据结构有很多，这里先介绍比较简单的数据结构：哈希表和搜索树。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表是一种以K-V存储的数据结构，我们只要输入待查找的值，就可以找到其对应的值。哈希的思路很简单，把值放在数组里，用一个哈希函数把Key换算成一个确认的位置，然后把value放在数组的这个位置。遇到同一个位置上有很多value时，就用一个链表串起来。</p><p>哈希链表适用于只有等值查询的场景</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。查询的平均复杂度是O(log(N))。<br><a id="more"></a></p><h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>在InnoDB中，表都是根据主键的顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB使用B+树索引模型。每一个索引再InnoDB里面对应一颗B+树。</p><p>假设我们有一个主键列为ID的表，表中有字段k，并且k上有索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure></p><p>表中R1~R5的（ID、k）值分别为（100，1）、（200，2）、（300，3）、（500，5）、（600、6）<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/Ei9YpCJeczWr9VO8*BgWLIHjUz30q5UyxUldf8Sp*g4!/b/dL4AAAAAAAAA&amp;bo=WgXyAwAAAAADB4w!&amp;rf=viewer_4" alt=""><br>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。<br>主键索引的叶子节点存的是整行数据。非主键索引的叶子节点的内容是主键的值。<br>1、如果语句是select <em> from T where ID=500，即主键查询方式，则只需要搜索ID这颗B+树；<br>2、如果语句是select </em> from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID值为500，再到ID索引树搜索一次。这个过程称为回表。</p><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+树为了维护索引的有序性，在插入新值得时候需要做必要的维护。<br>插入：</p><ul><li>当叶子节点未满时，将记录插入对应的叶子节点。</li><li>当叶子节点已满，索引页未满时；拆分中间的节点放入索引页，小于中间节点的放在左边节点，大于等于中间节点的放右边</li><li>当叶子页已满，索引页已满时；逐层拆分，直到所有节点都满足</li><li>当叶子节点的兄弟页未满，索引页已满时；不急于拆分节点，而是做旋转操作，减少页的拆分。<br>删除：<br>B+树使用填充因子来控制树的删除变化，填充因子是指数据填充的百分比。</li><li>当删除节点后，对应的叶子页大于填充因子时；直接删除节点，不做合并页操作。</li><li>当删除节点后，对应的叶子页大于填充因子，但是该节点也是索引节点；直接删除节点，将右边节点更新到对应的索引页。</li><li>当删除节点后，对应的叶子页小于填充因子时；合并页节点及其兄弟页节点。</li><li>当删除节点后，对应的叶子页小于填充因子，该节点也是索引节点；合并页节点及其兄弟页节点，更新索引页。</li><li>当删除节点后，该节点也是索引节点，并且删除该节点索引页也小于填充因子。逐层合并，直到满足条件。</li></ul><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果需要查询的值已经在非主键索引中可以完全获取，那么就可以不需要再去主键索引中进行回表操作了。<br><b>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</b></p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>B+树这种索引结构，可以利用索引的”最左前缀”来定位记录。<br>为了直观的说明这个概念，我们用（name，age）这个联合索引来分析。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/jMYONpHYjMYo6BaqToUtBg8my7ZjOad9c32kC9kHzN4!/b/dLgAAAAAAAAA&amp;bo=VAW6AwAAAAADB8o!&amp;rf=viewer_4" alt=""><br>可以看到，索引项是按照索引里面定义出现的先后顺序排序的。<br>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p><p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>]]></content>
    
    <summary type="html">
    
      &lt;font color=&quot;red&quot;&gt;索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。&lt;/font&gt;

&lt;h3 id=&quot;索引的常见模型&quot;&gt;&lt;a href=&quot;#索引的常见模型&quot; class=&quot;headerlink&quot; title=&quot;索引的常见模型&quot;&gt;&lt;/a&gt;索引的常见模型&lt;/h3&gt;&lt;p&gt;索引的出现时为了提高查询效率，但是实现索引的方式有很多种，所以这里也就引入了索引模型的概念。可以用来提高读写操作的数据结构有很多，这里先介绍比较简单的数据结构：哈希表和搜索树。&lt;/p&gt;
&lt;h4 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h4&gt;&lt;p&gt;哈希表是一种以K-V存储的数据结构，我们只要输入待查找的值，就可以找到其对应的值。哈希的思路很简单，把值放在数组里，用一个哈希函数把Key换算成一个确认的位置，然后把value放在数组的这个位置。遇到同一个位置上有很多value时，就用一个链表串起来。&lt;/p&gt;
&lt;p&gt;哈希链表适用于只有等值查询的场景&lt;/p&gt;
&lt;h4 id=&quot;二叉搜索树&quot;&gt;&lt;a href=&quot;#二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树&quot;&gt;&lt;/a&gt;二叉搜索树&lt;/h4&gt;&lt;p&gt;二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。查询的平均复杂度是O(log(N))。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="MySQL45讲" scheme="http://yoursite.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>事务隔离</title>
    <link href="http://yoursite.com/2019/01/16/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>http://yoursite.com/2019/01/16/MySQL/事务隔离/</id>
    <published>2019-01-16T14:32:26.000Z</published>
    <updated>2019-06-16T14:27:36.239Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说：事务就是保证一组数据库操作，要么全部成功，要么全部是失败。在MySQL中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务。</p><h3 id="隔离性和隔离级别"><a href="#隔离性和隔离级别" class="headerlink" title="隔离性和隔离级别"></a>隔离性和隔离级别</h3><p>提到事务，肯定会想到ACID（即原子性、一致性、隔离性、持久性），这里就讨论一下隔离性。<br>当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><ul><li>读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读已提交：一个事务提交后，它做的变更才会被其他事务看到</li><li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li><li>串行化：后访问的事务必须等前一个事务完成后，才能继续执行。</li></ul><p>假设数据表T中只有一列，其中一行的值为1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure></p><p><img src="https://m.qpic.cn/psb?/V140pON30woojR/N34*jAP61rjm0uHLDCigAi2GlkgbvdMqoW4J9gqGBok!/b/dL8AAAAAAAAA&amp;bo=OAT.BAAAAAADB.Q!&amp;rf=viewer_4" alt=""><br><a id="more"></a><br>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图中的V1、V2、V3的返回值分别是什么。</p><ul><li>若隔离级别是“读未提交”，这V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此V2、V3也都是2。</li><li>若隔离级别是“读提交”，这V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以，V3的值也是2。</li><li>若隔离级别是“可重复读”，则V1、V2是1，V3是2.之所以V2是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”。则在事务B执行将1改成2的时候，就会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看，V1、V2、V3的值是2。</li></ul><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个事务是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接使用加锁的方式来避免并行访问。</p><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。</p><h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面都会有类似下面的记录：<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/pyWktvOA4ggEJYuVgTtFYnCH.Id5ReNQfprJmpwT1.8!/b/dMIAAAAAAAAA&amp;bo=TAVIAwAAAAADByA!&amp;rf=viewer_4" alt=""><br>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-riew。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作等到。</p><p>回滚日志不可能一直保留；在不需要的时候就会被删除，也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志就会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p><p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在MySQL5.5以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何避免长事务的出现？<br><b>从开发端来看：</b></p><ol><li>确认是否使用了set autocommit=0。建议将这个值设置成1</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit框起来。</li><li>业务连接数据库的时候，根据业务本身的预估，通过set max_execution_time命令来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li></ol><p><b>从数据库端看：</b></p><ol><li>监控Information_schema.innodb_trx表，设置长事务阈值，超过就报警。</li><li>在业务功能测试阶段要求输出所欲的general_log，分析日志行为提前发现问题。</li><li>如果使用的是MySQL5.6或更新版本，把innodb_undo_tablespaces设置为2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说：事务就是保证一组数据库操作，要么全部成功，要么全部是失败。在MySQL中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务。&lt;/p&gt;
&lt;h3 id=&quot;隔离性和隔离级别&quot;&gt;&lt;a href=&quot;#隔离性和隔离级别&quot; class=&quot;headerlink&quot; title=&quot;隔离性和隔离级别&quot;&gt;&lt;/a&gt;隔离性和隔离级别&lt;/h3&gt;&lt;p&gt;提到事务，肯定会想到ACID（即原子性、一致性、隔离性、持久性），这里就讨论一下隔离性。&lt;br&gt;当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了“隔离级别”的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。&lt;/li&gt;
&lt;li&gt;读已提交：一个事务提交后，它做的变更才会被其他事务看到&lt;/li&gt;
&lt;li&gt;可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。&lt;/li&gt;
&lt;li&gt;串行化：后访问的事务必须等前一个事务完成后，才能继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设数据表T中只有一列，其中一行的值为1。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; create table T(c int) engine=InnoDB;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;insert into T(c) values(1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://m.qpic.cn/psb?/V140pON30woojR/N34*jAP61rjm0uHLDCigAi2GlkgbvdMqoW4J9gqGBok!/b/dL8AAAAAAAAA&amp;amp;bo=OAT.BAAAAAADB.Q!&amp;amp;rf=viewer_4&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="MySQL实战45讲" scheme="http://yoursite.com/tags/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>一条更新语句的执行过程</title>
    <link href="http://yoursite.com/2019/01/14/MySQL/%E4%B8%80%E4%B8%AA%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/01/14/MySQL/一个更新语句的执行过程/</id>
    <published>2019-01-14T14:32:26.000Z</published>
    <updated>2019-01-17T15:26:12.485Z</updated>
    
    <content type="html"><![CDATA[<p>下面我们以下面这个表和更新语句来进行分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table T(ID int primary key, c int);</span><br><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p><p>对于更新语句，查询语句的那一套流程，更新语句同样是会走一遍。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>如果每一次更新操作都要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新；整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL采用了WAL技术来提升更新效率。WAL的全称是write-Ahead Logging。它的关键点在于<font color="red">先写日志，再写磁盘</font>。</p><p>具体来说，就是当有一条记录需要更新的时候，innodb引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，innodb引擎会在适当的时候，将这个操作记录更新到次磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p>innodb的redo log是固定大小的，比如可以配置为一组4个文件，每个文件大小是1GB，那么redo log总共就可以记录4GB的操作，从头开始写，写到末尾就又回到开头循环写。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/cO8DivjlNOs4*4J.jc9sWkTtPIM5APzdpDE8aPjQews!/b/dLYAAAAAAAAA&amp;bo=hAUyAwAAAAADB5I!&amp;rf=viewer_4" alt=""><br><a id="more"></a><br>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的部分是用来记录新的操作。如果write pos追上checkpoint，那么表示redo log写满了，得先停下来擦掉一些记录，把checkpoint推进一点后才能够继续写入。</p><p>有了redo log，innodb就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称作crash-safe。</p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>MySQL从整体来说，其实有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。redo log是innodb引擎特有的日志，Server层也有自己的日志，称为binlog（归档日志）<br>最开始MySQL里并没有innodb引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而innodb是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力，所以innodb使用另一套日志系统（redo log）来实现crash-safe能力。</p><p>redo log 和 binlog主要有以下三点不同:</p><ol><li>redo log是innodb引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。</li></ol><p>我们回过头来看执行器和innodb引擎在执行这个简单的update语句时的内部流程。</p><ol><li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎的给的行数据，把这个值加上1，等到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/7vc6Wi5rjgpfIRIhIttNcrFLh7FmB1heWy5NCCPr8to!/b/dFIBAAAAAAAA&amp;bo=OASgBQAAAAADB7s!&amp;rf=viewer_4" alt=""><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3>binlog会记录所有的逻辑操作，并且采用的是“追加写”的形式。当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，可以这样做：</li></ol><ul><li>首先找到最近一次的全年备份</li><li>然后从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li><li>将表数据从临时库中取出来，按需要恢复到线上库去。</li></ul><p>说完数据恢复过程，我们来说说为什么日志需要“两阶段提交”。<br>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，那么就是先写完redo log再写binlog或者放过来。</p><ol><li><b>先写redo log后写binlog</b>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过，redo log写完后，系统及时崩溃，仍然能够将数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写就crash了，这时候binlog是没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要这个binlog恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0。造成了数据不一致。（主从情况也是一样的）</li><li><b>先写binlog后写 redo log</b>。如果binlog写完后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binglog里面已经记录了“把c从0改成1”这个日子。所以binlog恢复后就多了一个事务。</li></ol><p>可以看到，如果不使用两阶段提交，那么数据库的状态与应用它日子的其他数据库数据不一致。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>redo log用来宝成crash-safe能力，innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都会直接持久化到磁盘。<br>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面我们以下面这个表和更新语句来进行分析：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;create table T(ID int primary key, c int);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;update T set c=c+1 where ID=2;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于更新语句，查询语句的那一套流程，更新语句同样是会走一遍。&lt;/p&gt;
&lt;h3 id=&quot;redo-log&quot;&gt;&lt;a href=&quot;#redo-log&quot; class=&quot;headerlink&quot; title=&quot;redo log&quot;&gt;&lt;/a&gt;redo log&lt;/h3&gt;&lt;p&gt;如果每一次更新操作都要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新；整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL采用了WAL技术来提升更新效率。WAL的全称是write-Ahead Logging。它的关键点在于&lt;font color=&quot;red&quot;&gt;先写日志，再写磁盘&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;具体来说，就是当有一条记录需要更新的时候，innodb引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，innodb引擎会在适当的时候，将这个操作记录更新到次磁盘里面，而这个更新往往是在系统比较空闲的时候做。&lt;/p&gt;
&lt;p&gt;innodb的redo log是固定大小的，比如可以配置为一组4个文件，每个文件大小是1GB，那么redo log总共就可以记录4GB的操作，从头开始写，写到末尾就又回到开头循环写。&lt;br&gt;&lt;img src=&quot;https://m.qpic.cn/psb?/V140pON30woojR/cO8DivjlNOs4*4J.jc9sWkTtPIM5APzdpDE8aPjQews!/b/dLYAAAAAAAAA&amp;amp;bo=hAUyAwAAAAADB5I!&amp;amp;rf=viewer_4&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="MySQL实战45讲" scheme="http://yoursite.com/tags/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>一条查询语句的执行过程</title>
    <link href="http://yoursite.com/2019/01/13/MySQL/MySQL%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/01/13/MySQL/MySQL基本架构/</id>
    <published>2019-01-13T14:32:26.000Z</published>
    <updated>2019-01-14T14:34:11.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL基本架构"><a href="#MySQL基本架构" class="headerlink" title="MySQL基本架构"></a>MySQL基本架构</h2><p><img src="https://m.qpic.cn/psb?/V140pON30woojR/ussYTDB3vJmBbUYn8*kQP.aOU4fUXs6XhkExUtrBwWA!/b/dMMAAAAAAAAA&amp;bo=oAU4BAAAAAARB6k!&amp;rf=viewer_4" alt=""><br>MySQL基本架构可以分为Server层和存储引擎层两部分。</p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，覆盖MySQL大多数核心服务功能，以及<font color="red">所有的内置函数</font>（如日期、时间、数学等），所有的跨存储引擎的功能都在这一层实现，如存储过程、触发器、视图等。<br><a id="more"></a><br>下面以select * from T where ID=10；这条语句做讲解。</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器负责和客户端建立连接、获取权限、维持和管理连接。<br>使用mysql客户端工具来跟服务端进行建立连接。在完成经典的TCP握手后，连接器就要验证用户身份。</p><ul><li>如果用户名或密码不对，会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认真通过，连接器会到权限表里面查出你拥有的权限。在此连接后续过程中进行的权限判断逻辑都依赖于此时读取到的权限。</li></ul><p>这意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限进行了修改，也不会影响到已经存在连接的权限。</p><p>连接完成后，如果没有后续动作，这个连接就处于空闲状态；如果处于空闲状态太久没有进行操作，连接器就会自动将它断开。如果在连接端口后，客户端再发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query。这时候会进行重连才能够执行请求了。</p><p>有时候会发现MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。但是由于长连接积累一直不释放，导致内存占用太大，被系统强行杀掉（OOM），从现象来看就是MySQL异常重启了。<br>怎么解决这个问题呢？</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果使用的是MySQL5.7以上版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接建立完成后，就可以开始执行命令了。那么在进行查询语句时，会先到缓存中去查询缓存，之前是不是执行过这条语句。之前执行过的语句和结果可能会以键值对的形式被直接缓存在内存中。key是查询的语句，value是查询的结果。如果能够在缓存中找到查询的语句，那么就会直接返回value值给客户端。</p><p><b>但是大多数情况下，建议是不要使用查询缓存</b><br>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存就会被清空。对于更新压力大的数据库来说，查询缓存的命中率非常低。出给你的业务就是一张静态表，很长时间才更新一次。<br>你可以将参数query_cache_type设置为DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select SQL_CACHE * from T where ID=10;</span><br></pre></td></tr></table></figure></p><p>MySQL8.0版本直接将查询缓存的整块功能给删掉了。</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果没有命中缓存，就要开始真正执行语句了。首先MySQL需要知道你要做什么，所以需要对SQL语句进行解析。</p><p>分析器先会做“词法解析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。<br>MySQL从输入的“select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。<br>做完识别后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，将会收到“you hava an error in your SQL syntax”的错处提醒。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL就知道你要做什么了。在正式开始执行前，还要经过优化器的处理。<br>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联的时候，决定各个表的连接顺序。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL知道了你要做什么，该怎么做后就开始执行了。<br>开始执行的时候，要先判断一下你对这个表T有没有执行权限，如果没有，就会返回没有权限的错误。<br>如果有权限，就打开表继续执行。打开表的时候，执行器会根据表的引擎定义，去使用这个引擎提供的接口。<br>比如我们例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><pre><code>1. 调用InnodDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中。2. 调用引擎接口取“下一行”，重复相同的判断逻辑，知道取到这个表的最后一行。3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</code></pre><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口。<br>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。<br>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描函数跟rows_examined并不是完全相同的。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果表中没有字段k，而执行select * from T where k=1;肯定会报“不存在列”错误，这个错误是在哪个阶段报出来的？<br>答案：分析器，MySQL设计受Oracle影响，会在分析判断语句是否正确，表是否存在，列是否存在。<br>《高性能MySQL》里提到解析器处理语法和解析查询，会生成一颗对应的解析树</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL基本架构&quot;&gt;&lt;a href=&quot;#MySQL基本架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL基本架构&quot;&gt;&lt;/a&gt;MySQL基本架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://m.qpic.cn/psb?/V140pON30woojR/ussYTDB3vJmBbUYn8*kQP.aOU4fUXs6XhkExUtrBwWA!/b/dMMAAAAAAAAA&amp;amp;bo=oAU4BAAAAAARB6k!&amp;amp;rf=viewer_4&quot; alt=&quot;&quot;&gt;&lt;br&gt;MySQL基本架构可以分为Server层和存储引擎层两部分。&lt;/p&gt;
&lt;p&gt;Server层包括连接器、查询缓存、分析器、优化器、执行器等，覆盖MySQL大多数核心服务功能，以及&lt;font color=&quot;red&quot;&gt;所有的内置函数&lt;/font&gt;（如日期、时间、数学等），所有的跨存储引擎的功能都在这一层实现，如存储过程、触发器、视图等。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="MySQL实战45讲" scheme="http://yoursite.com/tags/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>记一次磁盘空间不足</title>
    <link href="http://yoursite.com/2018/12/29/Linux/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%EF%BC%8C%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/29/Linux/记一次磁盘空间不足，找不到什么文件导致的解决方法/</id>
    <published>2018-12-29T03:06:28.000Z</published>
    <updated>2018-12-29T03:42:05.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>在一台虚拟机机器上发现磁盘空间不足的情况，通过登录上去查看，发现是挂载盘占用磁盘资源太多，通过df命令查看，但是并找不到具体是哪个文件占用过多。<br>通过以下查找大文件命令也没有找到相应的大文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size +100M</span><br></pre></td></tr></table></figure></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>文件被删除后，并没有及时的释放磁盘资源，导致磁盘空间不足的情况。<br>通过以下命令，查看已经标记为删除但是没有释放的文件。对相应程序进行重启后解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof|grep -i delete|less</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h3&gt;&lt;p&gt;在一台虚拟机机器上发现磁盘空间不足的情况，通过登录上去查看，发现是挂载盘占用磁盘资源太多，通过df命令查看，但是并找
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL问答</title>
    <link href="http://yoursite.com/2018/11/29/MySQL/MySQL%E9%97%AE%E7%AD%94/"/>
    <id>http://yoursite.com/2018/11/29/MySQL/MySQL问答/</id>
    <published>2018-11-29T11:51:25.000Z</published>
    <updated>2019-01-20T15:24:52.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导致主从不一致的原因"><a href="#导致主从不一致的原因" class="headerlink" title="导致主从不一致的原因"></a>导致主从不一致的原因</h2><ol><li>人为原因（从库写入）</li><li>主库异常宕机</li><li>设置了ignore/do/rewrite等replication等规则</li><li>binlog使用了非row格式</li><li>从库中断</li><li>从库启用了存储过程</li><li>主从数据库版本不一致</li><li>重做时，mysqldump备份没有指定参数</li><li>主从sql_mode不一致</li><li>采用5.6的after_commit方式半同步，主库宕机可能会引起主从不一致。</li><li>启用了增强半同步，但是从库延迟超时自动切换成了异步复制</li></ol><h3 id="预防和解决的方案"><a href="#预防和解决的方案" class="headerlink" title="预防和解决的方案"></a>预防和解决的方案</h3><ol><li>master:innodb_flush_log_at_trx_commit=1&amp;sync_binlog=1</li><li>slave:master_info_repository=”TABLE”&amp;relay_log_info_repository=”TABLE”&amp;relay_log_recovery=1</li><li>设置从库库为只读模式</li><li>可以使用5.7增强半同步避免数据丢失等</li><li>binlog row格式</li><li>必须引定期的数据校验机制</li><li>当使用延迟复制的时候，此时主从数据也是不一致的（计划内），但在切换中，不要把延迟从提升为主库哦~</li><li>mha在主从切换的过程中，因主库系统宕机，可能造成主从不一致（mha本身机制导致这个问题）</li></ol><a id="more"></a><h2 id="为什么决定使用分库分表"><a href="#为什么决定使用分库分表" class="headerlink" title="为什么决定使用分库分表"></a>为什么决定使用分库分表</h2><ol><li>根据业务类型和业务容量评估</li><li>当前数据库本身具有的能力、压力评估</li><li>数据库的物理隔离，如：减少锁的争夺，资源的消耗和隔离</li><li>热点表较多，并且数据量大，可能会引起锁增强，性能下降</li><li>数据库的高并发，数据库读写压力大，可能会导致数据库或启动宕机</li><li>数据库（5.7以下）连接数过高，会增加系统压力</li><li>单表数据量大，如SQL使用不当，导致IO随机读写比例高；查询慢</li><li>备份和恢复时间比较长</li></ol><h3 id="会有什么问题"><a href="#会有什么问题" class="headerlink" title="会有什么问题"></a>会有什么问题</h3><ol><li>全局pk（主键和唯一索引）的冲突检测不准确，全局的自增主键支持不够好</li><li>分片键的选择</li><li>分布式事务</li><li>开发方面：需要进行业务的拆分。部分SQL不兼容。跨库查询、join。</li></ol><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ol><li>使用全局分号器。或者使用全局唯一id。</li><li>应用层来判断唯一索引</li><li>配合应用选择合适的分片键，并加上索引</li><li>配合应用，配合开发，对不兼容SQL进行整改</li></ol><h2 id="MySQL高可用架构应该考虑什么？"><a href="#MySQL高可用架构应该考虑什么？" class="headerlink" title="MySQL高可用架构应该考虑什么？"></a>MySQL高可用架构应该考虑什么？</h2><ol><li>对业务有一定了解，需要考虑业务对数据库一致性要求的敏感程度，切换过程中是否有事务丢失。</li><li>对于基础设施有一定了解，需要了解基础设施的高可用架构。</li><li>对于数据库故障时间掌握，业务方最多能容忍时间范围</li><li>需要了解主流的高可用的优缺点</li><li>考虑多机房多副本分布<h3 id="如何设计？"><a href="#如何设计？" class="headerlink" title="如何设计？"></a>如何设计？</h3></li><li>基础层和基础运维部门配合，了解和避免网络/硬盘/电源等是否会出现单点故障</li><li>应用层和开发配合，在关键日志中记录SQL日志，可以做到即使切换出现丢事务的情况，也可以通过手工补的方式保证数据一致性。</li><li>根据不同的应用制定合理的高可用策略</li><li>单机多实例</li><li>在数据库不可用，可以把已提交的事务先存储到队列或者其他位置，等数据库恢复，重新应用。</li></ol><h2 id="xtrabackup和mysqldump备份造成的锁等待"><a href="#xtrabackup和mysqldump备份造成的锁等待" class="headerlink" title="xtrabackup和mysqldump备份造成的锁等待"></a>xtrabackup和mysqldump备份造成的锁等待</h2><ol><li>xtrabackup在备份非innodb表时会有短暂的全局读锁FTWL</li><li>mysqldump获取一致性快照时会进行锁表</li><li>xtrabackup在备份时会在/tmp目录下生成一个临时文件，如果在备份过程中修改了/tmp的权限，这会造成xtrabackup hang住，正在备份的表不能正常释放锁，会造成锁等待。</li></ol><h2 id="为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？"><a href="#为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？" class="headerlink" title="为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？"></a>为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？</h2><ol><li>若复制中binlog使用row格式，对大表使用ps-osc把数据从旧表拷贝到临时表，期间会产生大量的binlog，从而导致延时</li><li>pt-osc在搬数据过程中insert..select是有行锁的，会降低事务并行度；且pt-osc搬数据过程中生成的binlog不是并行的，所以在slave不能并行回放。</li><li>可以通过设定参数–chunk-size、–chunk-time控制每次拷贝数据大小，也可以设定–max-log、check-interval、check-slave-lag等参数控制主从复制延迟程度（但这样可能会造成pt-osc工作耗时太久，需要执行权衡）</li></ol><h2 id="哪些原因会造成MySQL异步复制延迟"><a href="#哪些原因会造成MySQL异步复制延迟" class="headerlink" title="哪些原因会造成MySQL异步复制延迟"></a>哪些原因会造成MySQL异步复制延迟</h2><ol><li>master上多为并发事务，slave上则多为单线程回放（5.7起，支持真正的并行回放）</li><li>异步复制，本身就是有一定的延迟</li><li>有时为了节省机器资源，会在slave上运行多个实例</li><li>表结构设计不合理</li><li>slave上运行了大量只读低效率的SQL</li><li>大量大事务，也会造成slave无法并行回放</li><li>业务设计缺陷，或网络延迟等</li></ol><h2 id="MySQL每天产生了多大容量的binlog，可以查到吗"><a href="#MySQL每天产生了多大容量的binlog，可以查到吗" class="headerlink" title="MySQL每天产生了多大容量的binlog，可以查到吗"></a>MySQL每天产生了多大容量的binlog，可以查到吗</h2><p>binlog并不会自动的每天切分统计，所以需要人为这执行flush binlog logs再结合系统层命令完成。</p><h2 id="明明有索引，但是执行的时候没有选中是什么原因？"><a href="#明明有索引，但是执行的时候没有选中是什么原因？" class="headerlink" title="明明有索引，但是执行的时候没有选中是什么原因？"></a>明明有索引，但是执行的时候没有选中是什么原因？</h2><ol><li>隐式转换</li><li>表碎片，表碎片率过高</li><li>根据索引读取到的数据在整个表中的数据占比超过30%</li><li>统计信息没有及时更新</li></ol><h2 id="主从复制正常，但是主从延迟过高是什么原因"><a href="#主从复制正常，但是主从延迟过高是什么原因" class="headerlink" title="主从复制正常，但是主从延迟过高是什么原因"></a>主从复制正常，但是主从延迟过高是什么原因</h2><ol><li>sync_relay_log值过低，导致slave频繁刷新relay_log文件，使slave硬盘资源消耗过高。</li><li>Master/Slave压力过大</li><li>网络丢包严重</li><li>Master和Slave网络链接已经断开，但是slave_net_timeout值等于0（表示完全禁用心跳）或者slave_net_timeout和Slave_heart_period非常大（表示检测主从心跳的时间）</li><li>Master的binlog非常大，io线程的file很长时间在读同一个。</li></ol><h2 id="MySQL-hang的原因有哪些？"><a href="#MySQL-hang的原因有哪些？" class="headerlink" title="MySQL hang的原因有哪些？"></a>MySQL hang的原因有哪些？</h2><ol><li>MySQL使用资源过高导致服务器太累扛不住。</li><li>磁盘无可用空间</li><li>MySQL频繁的创建和销毁连接。</li><li>MySQL使用的最大文件打开数和连接数，超过了操作系统的限制。</li><li>MySQL的锁不能有效的释放。例如持有行锁或者表锁，造成MDL等待。</li><li>MySQL的bug导致的</li></ol><h2 id="MySQL中如果发现乱码该怎么处理？"><a href="#MySQL中如果发现乱码该怎么处理？" class="headerlink" title="MySQL中如果发现乱码该怎么处理？"></a>MySQL中如果发现乱码该怎么处理？</h2><ol><li>直接修改法，alter或者pt-osc等工具直接对工具进行修改。</li><li>备份修改法，利用mysqldump等其他逻辑备份进行备份，备份的结果集再利用iconv进行转换。</li><li>跳过字符集备份，–skip-set-charset</li></ol><h2 id="MySQL的表中有唯一索引，设置unique-check为0时，能否写入重复值"><a href="#MySQL的表中有唯一索引，设置unique-check为0时，能否写入重复值" class="headerlink" title="MySQL的表中有唯一索引，设置unique_check为0时，能否写入重复值"></a>MySQL的表中有唯一索引，设置unique_check为0时，能否写入重复值</h2><p>首先，即便设置unique_checks=0，也无法往唯一索引中写入重复值。</p><p>其次，设置unique_checks=0的作用在于，批量导入数据（例如load data）时，在确保导入数据中无重复值时，无需再次检查其唯一性，加快导入速度。</p><p>所以，unique_checks=0并不是允许唯一约束失效，而是再批量导数据时不再逐行检查唯一性。</p><h2 id="在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗-？"><a href="#在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗-？" class="headerlink" title="在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗 ？"></a>在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗 ？</h2><p>前提说明：MySQL5.7.23、innodb表、“双1” </p><p>1、添加/删除列，采用copy的方式 </p><p>1.1、ctrl+c。在当前session中，手动执行ctrl+c。无影响，并且会自动删除产生的临时文件。 </p><p>1.2、kill -9。在执行ddl的时候，服务器发生意外宕机或者手动执行kill -9。待MySQL启动后，则会自动执行InnoDB Recovered流程。并且不会删除产生的临时文件，需要手工处理。 </p><p>2、添加/删除索引，采用INPLACE方式 </p><p>2.1、ctrl+c，同1.1 </p><p>2.2、kill -9。不会删除临时文件，也不会执行InnoDB Recovered流程并且报错 Operating system error number 2 in a file operation ….OS error: 71 </p><p>在开始执行alter table的过程中，在没有结束的时候，并不会写入到binglog文件中。</p><h2 id="MySQL线上实例insert慢常见原因有哪些？"><a href="#MySQL线上实例insert慢常见原因有哪些？" class="headerlink" title="MySQL线上实例insert慢常见原因有哪些？"></a>MySQL线上实例insert慢常见原因有哪些？</h2><ol><li>锁等待：SQL产生的间隙锁、自增锁、死锁、MDL锁、外键检查锁，锁等待时间</li><li>iops达到瓶颈：例如备份任务、高频binlog redolog等文件写入</li><li>semi-sync：因为网络抖动，MySQL半同步、增强半同步导致语句卡住</li><li>高并发：高并发场景下，导致系统资源达到瓶颈，从而SQL执行慢</li><li>大字段：当前表索引过多，或者写入大量的text类型数据</li><li>硬件故障：因为磁盘、raid卡、内存等物理硬件故障导致写入慢</li><li>磁盘资源耗尽：操作系统的磁盘、inode资源耗尽</li><li>文件系统故障：MySQL data目录的所在挂在的不可写、或者被设置为只读</li><li>binlog group commit等待 </li><li>参数配置：innodb_buffer、redo_buffer过小 </li><li>autocommit：事物非自动提交，等待程序提交。</li></ol><h2 id="虽然命中索引，但SQL效率仍然慢，可能有哪些原因？"><a href="#虽然命中索引，但SQL效率仍然慢，可能有哪些原因？" class="headerlink" title="虽然命中索引，但SQL效率仍然慢，可能有哪些原因？"></a>虽然命中索引，但SQL效率仍然慢，可能有哪些原因？</h2><ol><li>索引字段重复值或者空值太多。 </li><li>查询条件范围太广返回结果数太多，全索引扫描 </li><li>没有利用到覆盖索引，造成大量回表 </li><li>查询字段过多，并且包含大字段</li><li>索引字段数据分布太随机，回表不多也会引起大量随机io </li><li>统计信息不准 </li><li>表的单行数据值很大，需要较多io </li><li>表中包含多个索引， 命中的索引不是最优的索引。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导致主从不一致的原因&quot;&gt;&lt;a href=&quot;#导致主从不一致的原因&quot; class=&quot;headerlink&quot; title=&quot;导致主从不一致的原因&quot;&gt;&lt;/a&gt;导致主从不一致的原因&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;人为原因（从库写入）&lt;/li&gt;
&lt;li&gt;主库异常宕机&lt;/li&gt;
&lt;li&gt;设置了ignore/do/rewrite等replication等规则&lt;/li&gt;
&lt;li&gt;binlog使用了非row格式&lt;/li&gt;
&lt;li&gt;从库中断&lt;/li&gt;
&lt;li&gt;从库启用了存储过程&lt;/li&gt;
&lt;li&gt;主从数据库版本不一致&lt;/li&gt;
&lt;li&gt;重做时，mysqldump备份没有指定参数&lt;/li&gt;
&lt;li&gt;主从sql_mode不一致&lt;/li&gt;
&lt;li&gt;采用5.6的after_commit方式半同步，主库宕机可能会引起主从不一致。&lt;/li&gt;
&lt;li&gt;启用了增强半同步，但是从库延迟超时自动切换成了异步复制&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;预防和解决的方案&quot;&gt;&lt;a href=&quot;#预防和解决的方案&quot; class=&quot;headerlink&quot; title=&quot;预防和解决的方案&quot;&gt;&lt;/a&gt;预防和解决的方案&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;master:innodb_flush_log_at_trx_commit=1&amp;amp;sync_binlog=1&lt;/li&gt;
&lt;li&gt;slave:master_info_repository=”TABLE”&amp;amp;relay_log_info_repository=”TABLE”&amp;amp;relay_log_recovery=1&lt;/li&gt;
&lt;li&gt;设置从库库为只读模式&lt;/li&gt;
&lt;li&gt;可以使用5.7增强半同步避免数据丢失等&lt;/li&gt;
&lt;li&gt;binlog row格式&lt;/li&gt;
&lt;li&gt;必须引定期的数据校验机制&lt;/li&gt;
&lt;li&gt;当使用延迟复制的时候，此时主从数据也是不一致的（计划内），但在切换中，不要把延迟从提升为主库哦~&lt;/li&gt;
&lt;li&gt;mha在主从切换的过程中，因主库系统宕机，可能造成主从不一致（mha本身机制导致这个问题）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码阅读(启动过程)</title>
    <link href="http://yoursite.com/2018/11/15/Redis/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B)/"/>
    <id>http://yoursite.com/2018/11/15/Redis/Redis源码阅读(启动过程)/</id>
    <published>2018-11-15T06:12:13.000Z</published>
    <updated>2018-11-23T07:16:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的启动函数main()在redis.c文件中。 </p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>在启动时会使用initServerConfig()函数进行初始化服务器配置工作，redisServer(redis.h)作为保存服务器配置的结构。 redisServer包含以下的一些Redis服务器的信息：  </p><ul><li>一般服务器状态。</li><li>一些服务器统计信息。</li><li>各种链表结构，如保存客户端的链表等。</li><li>配置文件及启动参数中的配置。</li><li>主从复制的状态。</li><li>持久化文件的参数和状态。</li></ul><p><img src="https://i.imgur.com/IXG8CwE.png" alt=""><br><a id="more"></a></p><h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><p>在initServer中会进行初始化服务器所需要的一些数据结构信息</p><ul><li>共享对象</li><li>事件循环</li><li>数据库结构</li><li>TCP套接字</li><li>服务器cron</li><li>事件循环</li><li>打开AOF</li></ul><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>如果开启了AOF持久化，那么加载AOF文件；否则加载RDB文件。   </p><p><font color="red">如果开启AOF，但是没有AOF文件的话也不会去读取RDB文件，这样会造成数据的丢失！！！</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void loadDataFromDisk(void) &#123;</span><br><span class="line">    // 记录开始时间</span><br><span class="line">    long long start = ustime();</span><br><span class="line"></span><br><span class="line">    // AOF 持久化已打开？</span><br><span class="line">    if (server.aof_state == REDIS_AOF_ON) &#123;</span><br><span class="line">        // 尝试载入 AOF 文件</span><br><span class="line">        if (loadAppendOnlyFile(server.aof_filename) == REDIS_OK)</span><br><span class="line">            // 打印载入信息，并计算载入耗时长度</span><br><span class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from append only file: %.3f seconds&quot;,(float)(ustime()-start)/1000000);</span><br><span class="line">    // AOF 持久化未打开</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 尝试载入 RDB 文件</span><br><span class="line">        if (rdbLoad(server.rdb_filename) == REDIS_OK) &#123;</span><br><span class="line">            // 打印载入信息，并计算载入耗时长度</span><br><span class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from disk: %.3f seconds&quot;,</span><br><span class="line">                (float)(ustime()-start)/1000000);</span><br><span class="line">        &#125; else if (errno != ENOENT) &#123;</span><br><span class="line">            redisLog(REDIS_WARNING,&quot;Fatal error loading the DB: %s. Exiting.&quot;,strerror(errno));</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="运行事件处理器"><a href="#运行事件处理器" class="headerlink" title="运行事件处理器"></a>运行事件处理器</h3><p>Redis在每次进入事件循环时都会想调用函数beforeSleep()。<br>beforeSleep()会做两件事：  </p><ol><li>如果启用了虚拟内存系统，将会去刷新AOF到磁盘，由flushAppendOnlyFile()函数处理。  </li><li>该函数封装了关于刷新缓冲区的一些复杂的逻辑，该缓冲区保存了AOF的写入缓存。  </li></ol><h4 id="进入事件循环"><a href="#进入事件循环" class="headerlink" title="进入事件循环"></a>进入事件循环</h4><p>Redis通过aeMain()进入主事件循环server.el。通过aeProcessEvents()处理所有已到达的时间事件和所有已就绪的文件事件。</p><h3 id="处理请求并返回响应"><a href="#处理请求并返回响应" class="headerlink" title="处理请求并返回响应"></a>处理请求并返回响应</h3><p>经过上面的启动过程后，Redis已经处于主事件轮询循环中，监听端口并等待客户端连接。<br><img src="https://i.imgur.com/J2YEVoo.png" alt=""></p><h4 id="处理新连接"><a href="#处理新连接" class="headerlink" title="处理新连接"></a>处理新连接</h4><p>在initServer()中，Redis注册acceptHandler()，当IO事件发生时被调用。acceptHandler()会创建一个客户端对象RedisClient。</p><h4 id="从客户端读取命令"><a href="#从客户端读取命令" class="headerlink" title="从客户端读取命令"></a>从客户端读取命令</h4><p>当客户端发送命令请求时，主事件循环调用readQueryFromClient()函数，它会尽可能多的读取（最多1024个字节）到临时缓冲区。<br>然后调用processInputBuffer()函数将客户端对象作为参数传递。processInputBuffer()将客户端的原始查询解析为执行Redis命令的参数，并解析每个参数的Redis字符串对象，并将它存储在客户端对象的数组中。然后调用processCommand()客户端对象来实际执行客户端发送的命令。<br>processCommand()从客户端获取命令的参数并执行。在执行前会进行许多的检查，如果检查失败，会向客户端对象附加一个错误消息并返回。</p><h4 id="执行命令并响应"><a href="#执行命令并响应" class="headerlink" title="执行命令并响应"></a>执行命令并响应</h4><p>call()函数，从客户端对象中获取具体执行命令的指针所指向的函数对象，并调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void call(redisClient *c, struct redisCommand *cmd) &#123;</span><br><span class="line">    long long dirty;</span><br><span class="line"></span><br><span class="line">    dirty = server.dirty;</span><br><span class="line">    cmd-&gt;proc(c);</span><br><span class="line">    dirty = server.dirty-dirty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的启动函数main()在redis.c文件中。 &lt;/p&gt;
&lt;h3 id=&quot;初始化配置&quot;&gt;&lt;a href=&quot;#初始化配置&quot; class=&quot;headerlink&quot; title=&quot;初始化配置&quot;&gt;&lt;/a&gt;初始化配置&lt;/h3&gt;&lt;p&gt;在启动时会使用initServerConfig()函数进行初始化服务器配置工作，redisServer(redis.h)作为保存服务器配置的结构。 redisServer包含以下的一些Redis服务器的信息：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般服务器状态。&lt;/li&gt;
&lt;li&gt;一些服务器统计信息。&lt;/li&gt;
&lt;li&gt;各种链表结构，如保存客户端的链表等。&lt;/li&gt;
&lt;li&gt;配置文件及启动参数中的配置。&lt;/li&gt;
&lt;li&gt;主从复制的状态。&lt;/li&gt;
&lt;li&gt;持久化文件的参数和状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/IXG8CwE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis对象结构</title>
    <link href="http://yoursite.com/2018/11/10/Redis/Redis%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/10/Redis/Redis对象/</id>
    <published>2018-11-10T13:34:13.000Z</published>
    <updated>2019-06-16T13:58:11.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="object-c"><a href="#object-c" class="headerlink" title="object.c"></a>object.c</h1><p>object.c文件主要记录了Redis对象的创建和释放方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">robj *createEmbeddedStringObject(char *ptr, size_t len) &#123;</span><br><span class="line">    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr)+len+1);</span><br><span class="line">    struct sdshdr *sh = (void*)(o+1);</span><br><span class="line"></span><br><span class="line">    o-&gt;type = REDIS_STRING;</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh+1;</span><br><span class="line">    o-&gt;refcount = 1;</span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;free = 0;</span><br><span class="line">    if (ptr) &#123;</span><br><span class="line">        memcpy(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = &apos;\0&apos;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        memset(sh-&gt;buf,0,len+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这个函数中，我们可以看出Redis在创建一个REDIS_ENCODING_EMBSTR编码的字符串对象时，是SDS连同redisObject一同创建的。也就是说这个字符串是不可以修改的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">robj *createStringObjectFromLongLong(long long value) &#123;</span><br><span class="line"></span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    // value 的大小符合 REDIS 共享整数的范围</span><br><span class="line">    // 那么返回一个共享对象</span><br><span class="line">    if (value &gt;= 0 &amp;&amp; value &lt; REDIS_SHARED_INTEGERS) &#123;</span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        o = shared.integers[value];</span><br><span class="line"></span><br><span class="line">    // 不符合共享范围，创建一个新的整数对象</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 值可以用 long 类型保存，</span><br><span class="line">        // 创建一个 REDIS_ENCODING_INT 编码的字符串对象</span><br><span class="line">        if (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</span><br><span class="line">            o = createObject(REDIS_STRING, NULL);</span><br><span class="line">            o-&gt;encoding = REDIS_ENCODING_INT;</span><br><span class="line">            o-&gt;ptr = (void*)((long)value);</span><br><span class="line"></span><br><span class="line">        // 值不能用 long 类型保存（long long 类型），将值转换为字符串，</span><br><span class="line">        // 并创建一个 REDIS_ENCODING_RAW 的字符串对象来保存值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            o = createObject(REDIS_STRING,sdsfromlonglong(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是根据传入的整数值来创建一个字符串对象。从这里可以看到主要有三个判断：</p><ol><li>如果设置的值符合Redis共享整数对象的范围时，是直接复用共享对象，并不会去创建一个新的对象。</li><li>如果传入的值是long类型的，这创建一个REDIS_ENCODING_INT编码类型的字符串对象。</li><li>如果传入的值为long long类型的，则创建REDIS_ENCODING_RAW编码类型的字符串对象。</li></ol><p>debug命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* Object command allows to inspect the internals of an Redis Object.</span><br><span class="line"> * Usage: OBJECT &lt;verb&gt; ... arguments ... */</span><br><span class="line">void objectCommand(redisClient *c) &#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    // 返回对戏哪个的引用计数</span><br><span class="line">    if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;refcount&quot;) &amp;&amp; c-&gt;argc == 3) &#123;</span><br><span class="line">        if ((o = objectCommandLookupOrReply(c,c-&gt;argv[2],shared.nullbulk))</span><br><span class="line">                == NULL) return;</span><br><span class="line">        addReplyLongLong(c,o-&gt;refcount);</span><br><span class="line"></span><br><span class="line">    // 返回对象的编码</span><br><span class="line">    &#125; else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;encoding&quot;) &amp;&amp; c-&gt;argc == 3) &#123;</span><br><span class="line">        if ((o = objectCommandLookupOrReply(c,c-&gt;argv[2],shared.nullbulk))</span><br><span class="line">                == NULL) return;</span><br><span class="line">        addReplyBulkCString(c,strEncoding(o-&gt;encoding));</span><br><span class="line">    </span><br><span class="line">    // 返回对象的空闲时间</span><br><span class="line">    &#125; else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;idletime&quot;) &amp;&amp; c-&gt;argc == 3) &#123;</span><br><span class="line">        if ((o = objectCommandLookupOrReply(c,c-&gt;argv[2],shared.nullbulk))</span><br><span class="line">                == NULL) return;</span><br><span class="line">        addReplyLongLong(c,estimateObjectIdleTime(o)/1000);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addReplyError(c,&quot;Syntax error. Try OBJECT (refcount|encoding|idletime)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;object-c&quot;&gt;&lt;a href=&quot;#object-c&quot; class=&quot;headerlink&quot; title=&quot;object.c&quot;&gt;&lt;/a&gt;object.c&lt;/h1&gt;&lt;p&gt;object.c文件主要记录了Redis对象的创建和释放方法&lt;br&gt;&lt;figure clas
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
</feed>

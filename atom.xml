<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OMG_By</title>
  
  <subtitle>你走与不走，路就在那里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-17T05:20:10.808Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OMG_By</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java类加载机制</title>
    <link href="http://yoursite.com/2019/07/16/Java/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/16/Java/Java类加载机制/</id>
    <published>2019-07-16T14:59:41.000Z</published>
    <updated>2019-07-17T05:20:10.808Z</updated>
    
    <content type="html"><![CDATA[<p>类的加载是指将类的<code>.class</code>文件中的<strong>二进制数据读入到内存</strong>中，将其放在运行时数据区的方法区，然后在Java堆中创建一个java.lang.Class对象(类也是对象)，用来封装类在方法区内的数据结构。<br>类加载的最终产物是位于堆中的Class对象，该Class对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。<br><a href="https://imgchr.com/i/ZqjkUs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjkUs.jpg" alt="ZqjkUs.jpg"></a></p><p>类加载器不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用的时候就预先加载，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器必须在程序<font color="red">首次主动使用该类</font>时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p><a href="https://imgchr.com/i/ZqjPbQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjPbQ.jpg" alt="ZqjPbQ.jpg"></a></p><p>类的生命周期主要包含<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>、<code>使用</code>、<code>卸载</code>。<br>在加载过程中的五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>初始化</code>发生的顺序是一定的，而<code>解析</code>在某些情况下可以在<code>初始化</code>阶段之后执行。这是为了支持Java语言的运行时绑定。<br>另外需要注意的是：这几个阶段是按照顺序开始，而不是按照顺序进行或完成，因为这些阶段通常是相互交叉混合进行的，通常在一个阶段执行的过程中需要调用或激活另一个阶段。<br><a id="more"></a></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>查找并加载类的二进制数据是类加载过程的第一个阶段，在这个阶段，虚拟机需要完成以下事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流代表的静态存储结构转化成方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，连接阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。</p><p>在验证阶段，主要是完成以下的校验动作：</p><h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>验证字节流是否符合Class文件格式的规范。例如：是否以<code>OxCAFEBASE</code>开头、主版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p><h3 id="元数据校验"><a href="#元数据校验" class="headerlink" title="元数据校验"></a>元数据校验</h3><p>对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求；列如：这个类是否有父类，除了<code>java.lang.Object</code></p><h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>确保解析动作能正确执行</p><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为类的<code>静态变量</code>分配内存，并将其初始化为默认值</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区分配。</p><ul><li>这个阶段进行内存分配的<font color="red">仅包括类变量(static)</font>，不包括实例变量；实例变量会在对象实例化时随着实例一块分配在Java堆中。</li><li>这个阶段设置的初始值通常是数据类型的默认值，而不是在Java程序中被显式赋予的值。</li><li>如果是同时被final和static修饰的属性，这在准备阶段会被初始化为定义的值。</li></ul><blockquote><p>假设有一个变量public static int value = 3<br>那么变量value在准备阶段过后的初始值是0，而不是3，因为这个时候还没开始执行任何Java方法，把value赋值为3的public static指令是在程序编译后，存放在类构造器<clinit>()方法中，所以value赋值为3的动作在初始化阶段才会执行。</clinit></p></blockquote><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。<br>解析动作主要是针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号类型进行，</p><ul><li>符号引用：用一组符号描述目标，可以是任何字面量</li><li>直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><h3 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h3><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><h3 id="类初始化情况"><a href="#类初始化情况" class="headerlink" title="类初始化情况"></a>类初始化情况</h3><ul><li>使用new创建类的实例</li><li>第一次访问某个类或接口的静态变量，或者对静态变量赋值</li><li>第一次调用类的静态方法</li><li>使用反射加载类(Class.forName(“xxx.xxx”))</li><li>初始化某个类的子类，其父类也会被初始化</li><li>Java虚拟机启动的时候标明启动的类(Java Test)，直接使用<code>java.exe</code>运行某个主类。</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>JVM预定义了三种类加载器，当一个JVM启动的时候，Java会默认使用类加载器进行类加载。</p><ul><li>启动类加载器:负责加载存放在<code>JDK\jre\lib</code>下或被<code>-Xbootclasspath</code>指定路径中的类库。</li><li>扩展类加载器:负责加载<code>JDK\jre\lib\ext</code>或由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库。</li><li>引用类加载器:负责加载用户类路径（ClassPath）所指定的类。程序默认的类加载器。<br><a href="https://imgchr.com/i/ZqjFEj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjFEj.jpg" alt="ZqjFEj.jpg"></a></li></ul><blockquote><p>注：父类加载器并不是通过继承关系实现的，而是采用组合的方式<br>启动类加载器是C++实现，属于虚拟机的一部分；其他类加载器都是由启动类加载器加载到内存中的。</p></blockquote><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><ul><li>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>双亲委派：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h2 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h2><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类的加载是指将类的&lt;code&gt;.class&lt;/code&gt;文件中的&lt;strong&gt;二进制数据读入到内存&lt;/strong&gt;中，将其放在运行时数据区的方法区，然后在Java堆中创建一个java.lang.Class对象(类也是对象)，用来封装类在方法区内的数据结构。&lt;br&gt;类加载的最终产物是位于堆中的Class对象，该Class对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/ZqjkUs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/17/ZqjkUs.jpg&quot; alt=&quot;ZqjkUs.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类加载器不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用的时候就预先加载，如果在预先加载的过程中遇到了&lt;code&gt;.class&lt;/code&gt;文件缺失或存在错误，类加载器必须在程序&lt;font color=&quot;red&quot;&gt;首次主动使用该类&lt;/font&gt;时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。&lt;/p&gt;
&lt;h1 id=&quot;类加载过程&quot;&gt;&lt;a href=&quot;#类加载过程&quot; class=&quot;headerlink&quot; title=&quot;类加载过程&quot;&gt;&lt;/a&gt;类加载过程&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/ZqjPbQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/17/ZqjPbQ.jpg&quot; alt=&quot;ZqjPbQ.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类的生命周期主要包含&lt;code&gt;加载&lt;/code&gt;、&lt;code&gt;验证&lt;/code&gt;、&lt;code&gt;准备&lt;/code&gt;、&lt;code&gt;解析&lt;/code&gt;、&lt;code&gt;初始化&lt;/code&gt;、&lt;code&gt;使用&lt;/code&gt;、&lt;code&gt;卸载&lt;/code&gt;。&lt;br&gt;在加载过程中的五个阶段中，&lt;code&gt;加载&lt;/code&gt;、&lt;code&gt;验证&lt;/code&gt;、&lt;code&gt;准备&lt;/code&gt;、&lt;code&gt;初始化&lt;/code&gt;发生的顺序是一定的，而&lt;code&gt;解析&lt;/code&gt;在某些情况下可以在&lt;code&gt;初始化&lt;/code&gt;阶段之后执行。这是为了支持Java语言的运行时绑定。&lt;br&gt;另外需要注意的是：这几个阶段是按照顺序开始，而不是按照顺序进行或完成，因为这些阶段通常是相互交叉混合进行的，通常在一个阶段执行的过程中需要调用或激活另一个阶段。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Arrays.sort和Collections.sort实现原理</title>
    <link href="http://yoursite.com/2019/07/16/Java/Arrays-sort%E5%92%8CCollections-sort%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/16/Java/Arrays-sort和Collections-sort实现原理/</id>
    <published>2019-07-16T14:51:54.000Z</published>
    <updated>2019-07-16T14:54:32.017Z</updated>
    
    <content type="html"><![CDATA[<p>事实上，在使用<code>Collections.sort(list)</code>的时候，就调用list.sort()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;</span><br><span class="line">        list.sort(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在深入进去后，发现其实调用的就是Array.sort()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">    default void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">        Object[] a = this.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = this.listIterator();</span><br><span class="line">        for (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>而在Array.sort中，会根据该对象是否能够通过归并排序来选择不同的排序方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            else</span><br><span class="line">                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>legacyMergeSort：归并排序</li><li><a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">TimSort</a><br>：结合归并排序和插入排序的一种排序算法</li></ul><blockquote><p>TimSort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。排序的输入的单位不是一个个单独的数字，而是一个个的块-分区。其中每一个分区叫一个run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run合并到只剩一个 run 为止。这时这个仅剩的 run 便是排好序的结果。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事实上，在使用&lt;code&gt;Collections.sort(list)&lt;/code&gt;的时候，就调用list.sort()&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池解析</title>
    <link href="http://yoursite.com/2019/07/15/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/15/面试准备/Java线程池解析/</id>
    <published>2019-07-15T14:02:22.000Z</published>
    <updated>2019-07-15T14:59:24.827Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线程池</strong>：可以根据字面意思简单的理解，一个管理线程的池子。</p><ul><li>帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。</li><li>提高响应速度。</li><li>重复利用。</li></ul><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize：线程池核心线程数最大值</li><li>maximumPoolSize： 线程池最大线程数大小</li><li>keepAliveTime： 线程池中非核心线程空闲的存活时间大小</li><li>unit： 线程空闲存活时间单位</li><li>workQueue： 存放任务的阻塞队列</li><li>threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li><li>handler：  线城池的饱和策略事件，主要有四种类型。</li></ul><h1 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h1><p>线程池执行流程，对应<code>execute()</code>方法。<br><a href="https://imgchr.com/i/Z7iOzt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7iOzt.md.jpg" alt="Z7iOzt.md.jpg"></a><br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        /*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">         * start a new thread with the given command as its first</span><br><span class="line">         * task.  The call to addWorker atomically checks runState and</span><br><span class="line">         * workerCount, and so prevents false alarms that would add</span><br><span class="line">         * threads when it shouldn&apos;t, by returning false.</span><br><span class="line">         *</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need</span><br><span class="line">         * to double-check whether we should have added a thread</span><br><span class="line">         * (because existing ones died since last checking) or that</span><br><span class="line">         * the pool shut down since entry into this method. So we</span><br><span class="line">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">         * stopped, or start a new thread if there are none.</span><br><span class="line">         *</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">         * and so reject the task.</span><br><span class="line">         */</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            else if (workerCountOf(recheck) == 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从execute代码注释中可以看出，任务执行流程主要是以下几步：</p><ul><li>提交任务，如果线程池里存活的核心线程数小于线程数<code>corePoolSize</code>时，线程池就会创建一个核心线程去处理提交的任务</li><li>如果线程池核心线程数满了，那么新提交的任务就会被放进任务队列<code>workQueue</code>中排队等待执行。</li><li>当线程池里面存活的线程数已经等于<code>corePoolSize</code>，并且任务队列<code>workQueue</code>也满了，判断线程数是否达到<code>maximumPoolSize</code>，如果没有达到，创建一个非核心线程执行提交的任务。</li><li>如果当前线程数达到了<code>maximumPoolSize</code>，那么直接采取拒绝策略处理。</li></ul><h1 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h1><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li></ul><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue(有界队列)是一个用数组实现的有界阻塞队列，按照FIFO排序。</p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue(可设置容量队列)基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，就是一个没有边界的阻塞队列，最大长度为Integer.MAX_VALUE。</p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue(延迟队列)是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后顺序排序。</p><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlockingQueue(优先阻塞队列)具有优先级的无界阻塞队列。</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue(同步队列)一个不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移除操作，否则插入操作一直处于阻塞状态。</p><h1 id="几种常用的线程池"><a href="#几种常用的线程池" class="headerlink" title="几种常用的线程池"></a>几种常用的线程池</h1><h2 id="newSingleThreadPool"><a href="#newSingleThreadPool" class="headerlink" title="newSingleThreadPool"></a>newSingleThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>这个线程池只有一个核心线程在工作，也就是相当于单线程串化执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。阻塞队列使用的是<code>LinkedBlockingQueue</code><br><a href="https://imgchr.com/i/Z7i4sK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7i4sK.jpg" alt="Z7i4sK.jpg"></a></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于串行执行任务的场景，一个任务一个任务地执行。</p><!-- more --><p>##newFixedThreadPool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>这个线程池的大小(核心线程)是固定的。每次提交一个任务就创建一个线程，直到线程数达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，会将后面的任务加入到阻塞队列。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。使用的阻塞队列是<code>LinkedBlockingQueue</code><br><a href="https://imgchr.com/i/Z7ihM6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7ihM6.md.jpg" alt="Z7ihM6.md.jpg"></a></p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于处理CPU密集型任务，确保CPU在长期被工作线程使用的情况下，尽可能少的分配线程，适用于执行长期的任务。</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">     return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                   60L, TimeUnit.SECONDS,</span><br><span class="line">                                   new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>创建一个可缓存的线程池(即核心线程数为0)，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲(60s不执行任务)的线程，当任务数增加时，此线程池又可以智能的添加新的线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统能够创建的最大线程大小。阻塞队列使用的是<code>SynchronousQueue</code><br><a href="https://imgchr.com/i/Z7iWxx" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7iWxx.md.jpg" alt="Z7iWxx.md.jpg"></a></p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>用于并发执行大量短期的小任务</p><h2 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>创建一个大小为<code>Integer.MAX_VALUE</code>的线程池，此线程池支持定时以及周期性执行任务的需求。阻塞队列使用的是<code>DelayedWorkQueue</code></p><ol><li>添加一个任务</li><li>线程池中的线程从DelayQueue中取任务</li><li>线程从DelayQueue中获取time大于等于当前时间的task</li><li>执行完后修改这个task的time为下一次被执行的时间</li><li>这个task返回到DelayQueue队列中</li></ol><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要周期性执行任务的场景，需要限制线程数量的场景</p><blockquote><p><a href="https://juejin.im/post/5d1882b1f265da1ba84aa676?utm_source=gold_browser_extension#heading-37" target="_blank" rel="noopener">https://juejin.im/post/5d1882b1f265da1ba84aa676?utm_source=gold_browser_extension#heading-37</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;线程池&lt;/strong&gt;：可以根据字面意思简单的理解，一个管理线程的池子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。&lt;/li&gt;
&lt;li&gt;提高响应速度。&lt;/li&gt;
&lt;li&gt;重复利用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public ThreadPoolExecutor(int corePoolSize,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              int maximumPoolSize,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              long keepAliveTime,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              TimeUnit unit,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             Executors.defaultThreadFactory(), defaultHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;corePoolSize：线程池核心线程数最大值&lt;/li&gt;
&lt;li&gt;maximumPoolSize： 线程池最大线程数大小&lt;/li&gt;
&lt;li&gt;keepAliveTime： 线程池中非核心线程空闲的存活时间大小&lt;/li&gt;
&lt;li&gt;unit： 线程空闲存活时间单位&lt;/li&gt;
&lt;li&gt;workQueue： 存放任务的阻塞队列&lt;/li&gt;
&lt;li&gt;threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。&lt;/li&gt;
&lt;li&gt;handler：  线城池的饱和策略事件，主要有四种类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;任务执行流程&quot;&gt;&lt;a href=&quot;#任务执行流程&quot; class=&quot;headerlink&quot; title=&quot;任务执行流程&quot;&gt;&lt;/a&gt;任务执行流程&lt;/h1&gt;&lt;p&gt;线程池执行流程，对应&lt;code&gt;execute()&lt;/code&gt;方法。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/Z7iOzt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/15/Z7iOzt.md.jpg&quot; alt=&quot;Z7iOzt.md.jpg&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Bitmap、Bloom Filter、Cuckoo Filter</title>
    <link href="http://yoursite.com/2019/07/15/Bitmap%E3%80%81Bloom-Filter%E3%80%81Cuckoo-Filter/"/>
    <id>http://yoursite.com/2019/07/15/Bitmap、Bloom-Filter、Cuckoo-Filter/</id>
    <published>2019-07-15T04:11:26.000Z</published>
    <updated>2019-07-15T04:16:44.081Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，在跟同学&amp;同事谈人生谈理想的时候。他告诉我他学长面试头条，其中一道题是如何判断一个整数在不在40亿整数集中；他说他学长竟然不知道<code>bitmap</code>(<a href="https://mp.weixin.qq.com/s/pUq213AJDpTGdGw4ywIS7g" target="_blank" rel="noopener">原题链接</a>)!!!然后我又给他科普了一下<code>布隆过滤器</code>和<code>布谷鸟过滤器</code>。<br>所以借此文章来记录一下这些知识，并巩固一下。</p><h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><p>Bitmap，直译就叫位图。可以理解为通过一个bit数组存储特定数据的一种数据结构；由于bit是数据的最小单位，所以这种数据结构往往是非常节省存储空间的。在Java和Redis中都存在同名实现结构。<br>在一个记录只有两种状态，是或不是的场景下，如果使用其他数据结构存储则会存在大量空间空间的浪费。即使存在海量的数据，我们也只需要为每个数据分配<code>1byte</code>的空间就可以记录了。比如：用户画像<br>Bitmap可以<font color="red">节省大量的存储空间</font>，所以可以很容易的倍一次性加载到内存中。Bitmap结构还有一个很重要的特点:<font color="red">可以很方便的进行位运算</font><br>比如我们需要统计用户满足以下条件的用户：程序员、带眼镜、长头发。。。。那么我们可以将对相应条件的用户画像的<code>Bitmap</code>结构做<code>AND</code>操作，就可以方便的过滤出满足条件的对象了。</p><h2 id="Bitmap的优化"><a href="#Bitmap的优化" class="headerlink" title="Bitmap的优化"></a>Bitmap的优化</h2><a id="more"></a><p>假如一个Bitmap中只有稀疏的那个几个1，那么其他空间是不是就被浪费了呢？</p><p>谷歌开发的EWAHComressedBitmap对Bitmap存储空间做了一定的优化操作。</p><p>EWAH把Bitmap存储在一个long数组中，long数组的每一个元素都可以当做64位的二进制数，也就是整个Bitmap的子集，称为<code>Word</code>。<br>当创建一个空的Bitmap时，只有4个<code>Word</code>，也就是只有4个long数组，随着数据的不断插入，<code>Word</code>数组会随着进行扩容。<br><code>Word</code>节点分为两种，直接存储数据的叫做<code>Literal Word</code>，简称LW。存储跨度信息的叫<code>Running Length Word</code>，简称RLW。<br>每一个RLW分为两部分，低32位表示当前Word横跨了多少个空Word，高32位表示当前RLW后面又多少个连续的LW。这样即使存在很多个0的位置，也能进行合并，减少浪费。<br><a href="https://imgchr.com/i/ZoGNon" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGNon.md.jpg" alt="ZoGNon.md.jpg"></a></p><h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><p>Bitmap适合处理<font color="red">按顺序字段映射</font>，如ID。但是当遇到其他情况时就无能为力了，比如判断一个单词是否存在于单词集中，这个时候如果需要映射的话，只能够对该单词进行相应的<code>hash</code>计算后映射到Bitmap上，But！绝大情况下会存在hash冲突，无法确认是不是。</p><p>于是便引入了<font color="red">布隆过滤器</font>。布隆过滤器也不能完全的消除误差。只能说大大的减少了误差率。</p><p>布隆过滤器的原理就是<font color="red">将需要判断的对象进行多次不同的hash计算后，同时判断那几位是否都为1</font>，由此可见，布隆过滤器的误差率取决于hash函数的选取。<br><a href="https://imgchr.com/i/ZoGYZj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGYZj.md.jpg" alt="ZoGYZj.md.jpg"></a></p><h1 id="Cuckoo-Filter"><a href="#Cuckoo-Filter" class="headerlink" title="Cuckoo Filter"></a>Cuckoo Filter</h1><p>布隆过滤器存在一个致命的缺点，那就是已经置为1的位不能再重置为0。这是因为你并不能判断该位具体被多少个对象映射了。只能在你认为误差率已经不能接受时进行重建。</p><p>我也是最近才了解到有<code>布谷鸟过滤器</code>的存在。</p><h2 id="布谷鸟哈希"><a href="#布谷鸟哈希" class="headerlink" title="布谷鸟哈希"></a>布谷鸟哈希</h2><p>最简单的布谷鸟哈希结构时一维数组结构，会有两个hash算法将新来的元素映射到数组的两个位置。如果两个位置中有一个位置为空，那么就可以把元素放进去；但是如果这两个位置都满了，那么会随机踢走一个，然后自己霸占这个位置。<br>被踢走的那个元素会寻找其他位置，重复上面的行为。知道所有的元素都找到了对应的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = hash1(x) % l</span><br><span class="line">p2 = hash2(x) % l</span><br></pre></td></tr></table></figure></p><p>布谷鸟算法为了避免重复踢的这个过程执行次数过多，会设置一个阈值，如果执行次数超过这个值，那么就会进行扩容操作，重新放置所有的元素。<br><a href="https://imgchr.com/i/ZoGGLQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGGLQ.md.jpg" alt="ZoGGLQ.md.jpg"></a><br><a href="https://imgchr.com/i/ZoG8sg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoG8sg.md.jpg" alt="ZoG8sg.md.jpg"></a></p><h2 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h2><p>布谷鸟过滤器和布谷鸟哈希结构一样，也是一维数组，但是不同于布谷鸟哈希的是，布谷鸟哈希会存储整个元素，而布谷鸟过滤器只会储存元素的指纹信息（只有几个bit，类似于布隆过滤器）。</p><p>首先布谷鸟过滤器还是只会选用两个 hash 函数，但是每个位置可以放置多个座位。这两个 hash 函数选择的比较特殊，因为过滤器中只能存储指纹信息。当这个位置上的指纹被挤兑之后，它需要计算出另一个对偶位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fp = fingerprint(x)</span><br><span class="line">p1 = hash(x)</span><br><span class="line">p2 = p1 ^ hash(fp)  // 异或</span><br></pre></td></tr></table></figure></p><p>我们可以看出p1和p2具有<code>对偶性</code>。所以我们根本不需要知道当前的位置是 p1 还是 p2，只需要将当前的位置和 hash(fp) 进行异或计算就可以得到对偶位置。而且只需要确保 hash(fp) != 0 就可以确保 p1 != p2，如此就不会出现自己踢自己导致死循环的问题。</p><p>由于布谷鸟过滤器保证了一个byte只被一个元素映射，所以允许删除操作，但是会存在误删的情况。</p><blockquote><p><a href="http://blog.talkingdata.net/?p=2493" target="_blank" rel="noopener">http://blog.talkingdata.net/?p=2493</a><br><a href="https://juejin.im/post/5c4fd2af51882525da267385" target="_blank" rel="noopener">https://juejin.im/post/5c4fd2af51882525da267385</a><br><a href="https://cloud.tencent.com/developer/article/1447177" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1447177</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天，在跟同学&amp;amp;同事谈人生谈理想的时候。他告诉我他学长面试头条，其中一道题是如何判断一个整数在不在40亿整数集中；他说他学长竟然不知道&lt;code&gt;bitmap&lt;/code&gt;(&lt;a href=&quot;https://mp.weixin.qq.com/s/pUq213AJDpTGdGw4ywIS7g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原题链接&lt;/a&gt;)!!!然后我又给他科普了一下&lt;code&gt;布隆过滤器&lt;/code&gt;和&lt;code&gt;布谷鸟过滤器&lt;/code&gt;。&lt;br&gt;所以借此文章来记录一下这些知识，并巩固一下。&lt;/p&gt;
&lt;h1 id=&quot;Bitmap&quot;&gt;&lt;a href=&quot;#Bitmap&quot; class=&quot;headerlink&quot; title=&quot;Bitmap&quot;&gt;&lt;/a&gt;Bitmap&lt;/h1&gt;&lt;p&gt;Bitmap，直译就叫位图。可以理解为通过一个bit数组存储特定数据的一种数据结构；由于bit是数据的最小单位，所以这种数据结构往往是非常节省存储空间的。在Java和Redis中都存在同名实现结构。&lt;br&gt;在一个记录只有两种状态，是或不是的场景下，如果使用其他数据结构存储则会存在大量空间空间的浪费。即使存在海量的数据，我们也只需要为每个数据分配&lt;code&gt;1byte&lt;/code&gt;的空间就可以记录了。比如：用户画像&lt;br&gt;Bitmap可以&lt;font color=&quot;red&quot;&gt;节省大量的存储空间&lt;/font&gt;，所以可以很容易的倍一次性加载到内存中。Bitmap结构还有一个很重要的特点:&lt;font color=&quot;red&quot;&gt;可以很方便的进行位运算&lt;/font&gt;&lt;br&gt;比如我们需要统计用户满足以下条件的用户：程序员、带眼镜、长头发。。。。那么我们可以将对相应条件的用户画像的&lt;code&gt;Bitmap&lt;/code&gt;结构做&lt;code&gt;AND&lt;/code&gt;操作，就可以方便的过滤出满足条件的对象了。&lt;/p&gt;
&lt;h2 id=&quot;Bitmap的优化&quot;&gt;&lt;a href=&quot;#Bitmap的优化&quot; class=&quot;headerlink&quot; title=&quot;Bitmap的优化&quot;&gt;&lt;/a&gt;Bitmap的优化&lt;/h2&gt;
    
    </summary>
    
      <category term="一些奇淫技巧" scheme="http://yoursite.com/categories/%E4%B8%80%E4%BA%9B%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>mac安装多版本JDK</title>
    <link href="http://yoursite.com/2019/07/13/mac%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACJDK/"/>
    <id>http://yoursite.com/2019/07/13/mac安装多版本JDK/</id>
    <published>2019-07-13T09:55:42.000Z</published>
    <updated>2019-07-14T10:04:25.341Z</updated>
    
    <content type="html"><![CDATA[<p>随着JDK版本的快速迭代，作为优秀(kubi)的Java拥护者，为了跟随时代的潮流，也开始使用1.8版本。</p><p>但是，某一天。。。。苦逼的事情发生了，一个项目原本是好好的，突然报错起不来了。最终查到的原因是某个项目的Jar包使用的JDK为1.7….于是就有了这篇记录。</p><p>在终端下面使用<code>java -version</code>查看就可以查看使用的JDK版本了。<br>使用<code>/usr/libexec/java_home -V</code>可以查看本地已经安装的JDK</p><p>关于JDK1.x for mac的安装略过，网上有大把的教程。<br>我这里以安装3个版本1.6/1.7/1.8为例。</p><p>一、编辑.bash_profile<br><code>vim ~/.bash_profile</code></p><p>二、在.bash_profile中添加下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`</span><br><span class="line">export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7`</span><br><span class="line">export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`</span><br><span class="line"></span><br><span class="line">#默认设为JDK1.7</span><br><span class="line">export JAVA_HOME=$JAVA_7_HOME</span><br><span class="line"></span><br><span class="line">#alias命令动态切换JDK版本</span><br><span class="line">alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot;</span><br><span class="line">alias jdk7=&quot;export JAVA_HOME=$JAVA_7_HOME&quot;</span><br><span class="line">alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;</span><br></pre></td></tr></table></figure></p><p>三、刷新环境<br><code>source ~/.bash_profile</code></p><p>四、测试<br>执行：<code>jdk8</code>，再执行<code>java -version</code>，看看是不是1.8版本？<br>执行：<code>jdk6</code>，再执行<code>java -version</code>，看看是不是1.6版本？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着JDK版本的快速迭代，作为优秀(kubi)的Java拥护者，为了跟随时代的潮流，也开始使用1.8版本。&lt;/p&gt;
&lt;p&gt;但是，某一天。。。。苦逼的事情发生了，一个项目原本是好好的，突然报错起不来了。最终查到的原因是某个项目的Jar包使用的JDK为1.7….于是就有了这篇记
      
    
    </summary>
    
      <category term="一些奇淫技巧" scheme="http://yoursite.com/categories/%E4%B8%80%E4%BA%9B%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="小技巧" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Cloneable接口实现原理</title>
    <link href="http://yoursite.com/2019/06/04/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Cloneable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/06/04/面试准备/Cloneable实现原理/</id>
    <published>2019-06-04T14:41:31.000Z</published>
    <updated>2019-06-23T13:13:08.542Z</updated>
    
    <content type="html"><![CDATA[<p>Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例当中。</p><p>在开发过程中，如果一个类中的字段比较多，而我们如果采用在客户端中逐字段复制的方法来进行拷贝操作的话，将不可避免的造成客户端代码繁杂，而且也无法对类中的私有对象进行复制，而如果让需要具备拷贝功能的类实现<code>Cloneable</code>接口，并重写<code>clone()</code>方法的方式来简洁地实现实例拷贝功能。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><code>private class Demo implements Cloneable{}</code><br>我们创建一个Demo类，并让他实现Cloneable接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Cloneable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们发现<code>Cloneable</code>几口里面并没有定义任何接口方法。<br>这是因为在<code>Object</code>类中已经将<code>clone()</code>方法定义为所有类都应该具有的基本功能，只是将该方法声明为了<code>protected</code>类型。它是一个<code>native</code>本地方法。</p><p>如果一个类不实现该接口就直接调用<code>clone()</code>方法的话，就会抛出“不支持拷贝”异常。<br>所以如果要让一个类具有拷贝实例的功能，那么除了要重写<code>Object</code>类中<code>clone()</code>方法外，还必须实现Cloneable接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例当中。&lt;/p&gt;
&lt;p&gt;在开发过程中，如果一个类中的字段比较多，而我们如果采用在客户端中逐字段复制的方法来进行拷贝操作的话，将不可避免的造成客户端代码繁杂，而且也无法对
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2019/06/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/06/03/面试准备/单例模式/</id>
    <published>2019-06-03T14:41:31.000Z</published>
    <updated>2019-06-19T09:30:38.728Z</updated>
    
    <content type="html"><![CDATA[<p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h2 id="单例模式多种写法"><a href="#单例模式多种写法" class="headerlink" title="单例模式多种写法"></a>单例模式多种写法</h2><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>这种方式在类加载时就完成了初始化，所以类加载比较慢，但是获取对象的速度快。这种方式基于类加载机制避免了多线程的同步问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="懒汉模式（线程不安全）"><a href="#懒汉模式（线程不安全）" class="headerlink" title="懒汉模式（线程不安全）"></a>懒汉模式（线程不安全）</h3><p>懒汉模式声明了一个静态对象，在用户第一次调用时进行初始化，虽然节约了资源，但第一次加载时需要实例化，反应稍微慢一点，而且在多线程下不能工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="懒汉模式（线程安全）"><a href="#懒汉模式（线程安全）" class="headerlink" title="懒汉模式（线程安全）"></a>懒汉模式（线程安全）</h3><p>这种写法能够在多线程中很好的工作，但是每次调用getSingleton时都需要同步，造成不必要的同步开销，而且大部分时候我们都是用不到同步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双重检查模式（DCL）"><a href="#双重检查模式（DCL）" class="headerlink" title="双重检查模式（DCL）"></a>双重检查模式（DCL）</h3><p>这种写法对singleton进行了两次的判空操作，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。这里用到了volatile关键字，或多或少还是会影响性能，但是考虑到程序的正确性，牺牲这点性能还是值得的。</p><h4 id="PS：这里为什么要用volatile关键字？"><a href="#PS：这里为什么要用volatile关键字？" class="headerlink" title="PS：这里为什么要用volatile关键字？"></a>PS：这里为什么要用volatile关键字？</h4><p>这个地方使用volatile关键字是很有必要的，因为new一个新的对象其实是分了三步执行：</p><ol><li>为该对象分配内存空间</li><li>初始化对象</li><li>将对象指向分配的内存地址</li></ol><p>由于JVM指令重排的特性，执行顺序可能会变成1-&gt;3-&gt;2；在单线程环境下不会有问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。比如：</p><ol><li>线程1执行了1、3</li><li>线程2调用方法，发现该实例不为空，因此返回该实例。但此时实例还没被初始化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if(singleton == null)&#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton sInstance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，上述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。</p><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     public void doSomeThing() &#123;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用容器实现单例模式"><a href="#使用容器实现单例模式" class="headerlink" title="使用容器实现单例模式"></a>使用容器实现单例模式</h3><p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonManager &#123; </span><br><span class="line">　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();</span><br><span class="line">　　private Singleton() &#123; </span><br><span class="line">　　&#125;</span><br><span class="line">　　public static void registerService(String key, Objectinstance) &#123;</span><br><span class="line">　　　　if (!objMap.containsKey(key) ) &#123;</span><br><span class="line">　　　　　　objMap.put(key, instance) ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　public static ObjectgetService(String key) &#123;</span><br><span class="line">　　　　return objMap.get(key) ;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;h2 id=&quot;单例模式多种写法&quot;&gt;&lt;a href=&quot;#单例模式多种写法&quot; class=&quot;headerlink&quot; title=&quot;单例模式多种写法&quot;&gt;&lt;/a&gt;单例模式多种写法&lt;/h2&gt;&lt;h3 id=&quot;饿汉模式&quot;&gt;&lt;a href=&quot;#饿汉模式&quot; class=&quot;headerlink&quot; title=&quot;饿汉模式&quot;&gt;&lt;/a&gt;饿汉模式&lt;/h3&gt;&lt;p&gt;这种方式在类加载时就完成了初始化，所以类加载比较慢，但是获取对象的速度快。这种方式基于类加载机制避免了多线程的同步问题。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static Singleton singleton = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;懒汉模式（线程不安全）&quot;&gt;&lt;a href=&quot;#懒汉模式（线程不安全）&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式（线程不安全）&quot;&gt;&lt;/a&gt;懒汉模式（线程不安全）&lt;/h3&gt;&lt;p&gt;懒汉模式声明了一个静态对象，在用户第一次调用时进行初始化，虽然节约了资源，但第一次加载时需要实例化，反应稍微慢一点，而且在多线程下不能工作。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static Singleton singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Singleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(singleton == null)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            singleton = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return singleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程思想" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap详解</title>
    <link href="http://yoursite.com/2019/06/02/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/HashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/06/02/面试准备/HashMap详解/</id>
    <published>2019-06-02T14:41:31.000Z</published>
    <updated>2019-06-16T13:25:49.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是HashMap"><a href="#什么是HashMap" class="headerlink" title="什么是HashMap"></a>什么是HashMap</h2><p>HashMap一个用于存储Key-Value键值对的集合，每一个键值对称之为<code>Entry</code>分散存储在一个数组中。这个数组每一个元首初始值都是Null。</p><p>HashMap的常用操作就是<b>GET</b>和<b>PUT</b></p><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>我们在调用put方法的时候，会利用一个哈希函数来确定<code>Entry</code>的插入位置。为了解决哈希冲突的问题，HashMap采用<font color="red">链表法</font>来解决这个问题。<br><code>注意：位置0上存放的一定是Null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">modCount++;</span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line">return null;</span><br></pre></td></tr></table></figure></p><p>在遇到Hash冲突的时候，就将<code>Entry</code>以链表的形式给插入到相应的位置，这里需要注意的是：HashMap采用的是<font color="red">头插法</font>的形式。这是因为设计者认为最新加入的<code>Entry</code>更有可能被访问。<br>此时HashMap的结构为<b>数组加链表</b><br><img src="https://s2.ax1x.com/2019/06/16/V7M7nO.jpg" alt=""></p><a id="more"></a><p>当HashMap中有大量的元素都存放在同一个位置的时候，这个位置就有存在一条很长的链表；这个时候的HashMap相当于一个单链表。<br>于是在<b>JDK1.8</b>中引入了<font color="red">红黑树</font>来优化这个问题。当某一个位置上的<font color="red">链表长度大于等于8</font>的时就使用红黑树来进行存储。<br>在元素值小于6的时候就将红黑树又转换成链表形式。<br>此时HashMap的结构为<b>数组加链表加红黑树</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//一个桶的树化阈值</span><br><span class="line">//当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点</span><br><span class="line">//这个值必须为 8，要不然频繁转换效率也不高</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"> </span><br><span class="line">//一个树的链表还原阈值</span><br><span class="line">//当扩容时，桶中元素个数小于这个值，就会把树形的桶元素 还原（切分）为链表结构</span><br><span class="line">//这个值应该比上面那个小，至少为 6，避免频繁转换</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"> </span><br><span class="line">//哈希表的最小树形化容量</span><br><span class="line">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span><br><span class="line">//否则桶内元素太多时会扩容，而不是树形化</span><br><span class="line">//为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure></p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>在HashMap的GET函数中，首先会通过计算键值的哈希值获取到<code>Entry</code>所在的位置，然后通过遍历链表或红黑树中的<code>Entry</code>来确定是否是我们需要的值。</p><p>HashMap在遍历链表比较时使用的Java对象的equals()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != null;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>通过这段代码，我们也可以看出：HashMap是可以存放键为Null的对象</code></p><h4 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line">        while (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + next.getKey() + &quot; value=&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + key + &quot; value=&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>推荐使用第一种方式，第一种方式会将KV同时取出，而第二种方式还需要通过key取一次value，效率比较低。</p><h2 id="HashMap默认初始化长度"><a href="#HashMap默认初始化长度" class="headerlink" title="HashMap默认初始化长度"></a>HashMap默认初始化长度</h2><p>首先，我们要明确的一点就是：<font color="red">HashMap的默认初始化长度是16</font>，并且每次扩容和缩容后的长度大小都是2的幂。</p><p>为什么会有以上的限制呢？<br>这是因为需要实现尽可能分布均匀的Hash函数。HashMap中使用了<font color="red">位取模</font>的方式来计算哈希值。<br><code>index =  HashCode（Key） &amp;  （Length - 1）</code></p><p>这样做不但效果上等同于取模，而且大大提升了性能。<br>使用<code>位运算</code>的方式，相当于只取hash函数的后几位，分布情况取决于hash函数。<br>而使用其他方式，如<code>取模</code>，则可能会导致某些index结果出现的几率大大提升;此外，如果length不是2的幂的话，有些index的结果可能永远不会出现。</p><h2 id="Hash的Rehash"><a href="#Hash的Rehash" class="headerlink" title="Hash的Rehash"></a>Hash的Rehash</h2><p>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。<br>这个时候的HashMap会需要进行扩容行为了。</p><p>影响HashMap扩容的因素有两个：</p><ul><li>Capacity：当前长度</li><li>LoadFactor：负载因子，默认是0.75f</li></ul><p><code>HashMap.Size   &gt;=  Capacity * LoadFactor时就会进行扩容操作了</code></p><p>HashMap的扩容操作分两步：</p><ol><li>创建一个新的数组，大小是原来数组的2倍。</li><li>遍历原数组，将原数组的所有元素重新Hash到新数组。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Transfers all entries from current table to newTable.</span><br><span class="line"> */</span><br><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap每次扩容或缩容都是以2的倍数进行的。<br>这是因为在这样的流程中，HashMap中的<code>Entry</code>需要迁移的只有一半，大大的节省了扩缩容的消耗。</p><h2 id="高并发下的HashMap"><a href="#高并发下的HashMap" class="headerlink" title="高并发下的HashMap"></a>高并发下的HashMap</h2><p>HashMap并不是线程安全的，在多线程操作下可能会导致很多意想不到的情况发生。比如死循环。</p><p>比如在上一小节中讲的Rehash，如果有多个线程同时进行扩容操作就会出现问题。<br>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作：<br><img src="https://s2.ax1x.com/2019/06/16/V7MbHe.jpg" alt="-w564"><br><img src="https://s2.ax1x.com/2019/06/16/V7MONd.jpg" alt="-w496"><br>此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：<br><img src="https://s2.ax1x.com/2019/06/16/V7MLAH.jpg" alt="-w748"><br>这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：<br><img src="https://s2.ax1x.com/2019/06/16/V7MHBD.jpg" alt=""><br>假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：<br><img src="https://s2.ax1x.com/2019/06/16/V7MX4A.jpg" alt="-w778"><br>直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p><img src="https://s2.ax1x.com/2019/06/16/V7MzgP.jpg" alt=""><br>当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。<br><img src="https://s2.ax1x.com/2019/06/16/V7Mv9I.jpg" alt=""><br>我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且e指向了Entry2。此时e和next的指向如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry2</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p><p>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QPHg.jpg" alt="-w702"><br>接着是新一轮循环，又执行到红框内的代码行：<br><img src="https://s2.ax1x.com/2019/06/16/V7Mx3t.jpg" alt=""><br>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QSjf.jpg" alt="-w762"><br>接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：<br><img src="https://s2.ax1x.com/2019/06/16/V7Q9u8.jpg" alt=""><br>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QCDS.jpg" alt="-w746"><br>第三次循环开始，又执行到红框的代码：<br><img src="https://s2.ax1x.com/2019/06/16/V7QkNj.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry3.next = null</span><br></pre></td></tr></table></figure></p><p>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：<br><img src="https://s2.ax1x.com/2019/06/16/V7QFEQ.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = Entry2</span><br><span class="line">e = Entry3</span><br><span class="line">Entry2.next = Entry3</span><br><span class="line">Entry3.next = Entry2</span><br></pre></td></tr></table></figure></p><p>链表出现了环形！</p><p>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QA4s.jpg" alt="-w751"><br>此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是HashMap&quot;&gt;&lt;a href=&quot;#什么是HashMap&quot; class=&quot;headerlink&quot; title=&quot;什么是HashMap&quot;&gt;&lt;/a&gt;什么是HashMap&lt;/h2&gt;&lt;p&gt;HashMap一个用于存储Key-Value键值对的集合，每一个键值对称之为&lt;code&gt;Entry&lt;/code&gt;分散存储在一个数组中。这个数组每一个元首初始值都是Null。&lt;/p&gt;
&lt;p&gt;HashMap的常用操作就是&lt;b&gt;GET&lt;/b&gt;和&lt;b&gt;PUT&lt;/b&gt;&lt;/p&gt;
&lt;h4 id=&quot;PUT&quot;&gt;&lt;a href=&quot;#PUT&quot; class=&quot;headerlink&quot; title=&quot;PUT&quot;&gt;&lt;/a&gt;PUT&lt;/h4&gt;&lt;p&gt;我们在调用put方法的时候，会利用一个哈希函数来确定&lt;code&gt;Entry&lt;/code&gt;的插入位置。为了解决哈希冲突的问题，HashMap采用&lt;font color=&quot;red&quot;&gt;链表法&lt;/font&gt;来解决这个问题。&lt;br&gt;&lt;code&gt;注意：位置0上存放的一定是Null&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Object k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                V oldValue = e.value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.recordAccess(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return oldValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addEntry(hash, key, value, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return null;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在遇到Hash冲突的时候，就将&lt;code&gt;Entry&lt;/code&gt;以链表的形式给插入到相应的位置，这里需要注意的是：HashMap采用的是&lt;font color=&quot;red&quot;&gt;头插法&lt;/font&gt;的形式。这是因为设计者认为最新加入的&lt;code&gt;Entry&lt;/code&gt;更有可能被访问。&lt;br&gt;此时HashMap的结构为&lt;b&gt;数组加链表&lt;/b&gt;&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/16/V7M7nO.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Object的常用方法</title>
    <link href="http://yoursite.com/2019/06/01/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Object%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/06/01/面试准备/Object的常用方法/</id>
    <published>2019-06-01T14:41:31.000Z</published>
    <updated>2019-06-16T13:11:41.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object类常见方法"><a href="#Object类常见方法" class="headerlink" title="Object类常见方法"></a>Object类常见方法</h1><p>Object是一个特殊的类，所有的类都会隐式的继承Object类。Object中主要有以下11个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">注：native方法：使用这个关键字说明这个方法是原生方法，底层使用C/C++实现，并且被编译成了DLL，由Java调用。函数实现在DLL中，JDK源码并不包含。</span><br><span class="line"></span><br><span class="line">public final native Class&lt;?&gt; getClass()</span><br><span class="line">用于返回当前运行时对象的Class对象，使用final关键字修饰，不允许子类重写。</span><br><span class="line"></span><br><span class="line">public native int hashCode()</span><br><span class="line">用于返回对象的哈希码，主要使用在哈希表中。</span><br><span class="line"></span><br><span class="line">public boolean equals(Object obj)</span><br><span class="line">用于比较2个对象的内存地址是否相等，String类对该方法进行了重写。</span><br><span class="line"></span><br><span class="line">protected native Object clone() throws CloneNotSupportedException</span><br><span class="line">用于创建当前对象的一份拷贝。Object本身并没有实现Cloneable接口，所以不重写clone方法并且进行调用就会发生CloneNotSupportedException异常。</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">默认返回类的名字@实例的哈希码的16进制的字符串，建议所有子类都重写该方法。</span><br><span class="line"></span><br><span class="line">public final native void notify()</span><br><span class="line">final方法，用于唤醒一个在此对象监视器上等待的线程。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="line"></span><br><span class="line">public final native void notifyAll()</span><br><span class="line">用于唤醒该对象上所有的等待线程。</span><br><span class="line"></span><br><span class="line">public final native void wait(long timeout) throws InterruptedException</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException</span><br><span class="line">public final void wait() throws InterruptedException</span><br><span class="line">暂停线程的执行，第二个超时时间需要增加nanos毫秒，第三个没有超时时间。</span><br><span class="line"></span><br><span class="line">protected void finalize() throws Throwable &#123; &#125;</span><br><span class="line">实例被垃圾回收器回收的时候触发的操作。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object类常见方法&quot;&gt;&lt;a href=&quot;#Object类常见方法&quot; class=&quot;headerlink&quot; title=&quot;Object类常见方法&quot;&gt;&lt;/a&gt;Object类常见方法&lt;/h1&gt;&lt;p&gt;Object是一个特殊的类，所有的类都会隐式的继承Object类。O
      
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="http://yoursite.com/2019/04/04/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2019/04/04/面试准备/三次握手和四次挥手/</id>
    <published>2019-04-04T15:03:37.000Z</published>
    <updated>2019-07-15T15:06:44.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">客户端-&gt;服务端: SYNC=1,seq=x</span><br><span class="line">Note left of 客户端: SYCN_SEND</span><br><span class="line">服务端--&gt;客户端: SYNC=1,ACK=1,seq=y,ack=x+1</span><br><span class="line">Note right of 服务端: SYNC_RECV</span><br><span class="line">客户端-&gt;服务端: ACK=1,seq=x+1,ack=y+1</span><br><span class="line">Note left of 客户端: ESTAB-LISHED</span><br><span class="line">Note right of 服务端: ESTAB-LISHED</span><br></pre></td></tr></table></figure><p>第一次握手：建立连接时，客户端发送sync包(syn=x)到服务器，并进入SYN_SENT状态，等待服务器确认；</p><p>第二次握手：服务器收到syn包，发送确认号(ack=x+1)，同时自己也发送一个syn包(syn=y)，即ACK+SYN包；服务器进入SYN_RECV状态。</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)；发送完毕后，客户端和服务端都进入ESTABLISHED状态完成三次握手。</p><a id="more"></a><h2 id="四次挥手流程"><a href="#四次挥手流程" class="headerlink" title="四次挥手流程"></a>四次挥手流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端-&gt;服务端: FIN=1,seq=u</span><br><span class="line">Note left of 客户端: FIN_WAIT_1</span><br><span class="line">服务端--&gt;客户端: ACK=1,seq=v,ack=u+1</span><br><span class="line">Note right of 服务端: CLOSE_WAIT</span><br><span class="line">服务端--&gt;客户端: FIN=1,ACK=1,seq=w,ack=u+1</span><br><span class="line">Note right of 服务端: LAST_ACK</span><br><span class="line">客户端-&gt;服务端: ACK=1,seq=u+1,ack=w+1</span><br><span class="line">Note right of 服务端: CLOSED</span><br><span class="line">Note left of 客户端: 等待2MSL后，进入CLOSED</span><br></pre></td></tr></table></figure><p>1、 客户端进程发送连接释放报文，并且停止发送数据。报文中带<code>FIN=1</code>标记。并且其序列号<code>seq=u</code>（等于前面已经传送过来的数据的最后一个字节的序号+1）。客户端进入<code>FIN-WAIT=1</code>状态。</p><p>2、服务器接收到连接释放报文后，发送确认报文<code>ACK=1，ack=u+1</code>，并带上自己的序列号<code>seq=v</code>，此时，服务端进入<code>CLOSE-WAIT</code>状态。这个时候处于半关闭状态；表示客户端不再发送数据，服务端不再接收数据；服务端若要发送数据，客户端依然要接收。</p><p>3、 客户端手抖服务端的确认请求后，进入<code>FIN-WAIT-2</code>状态，等待服务器发送连接释放报文。</p><p>4、 服务器将数据发送完毕后，就向客户端发送连接释放报文，<code>FIN=1,ack=u+1,seq=w</code>。此时服务端进入<code>LAST-ACK</code>状态，等待客户端的确认。</p><p>5、 客户端收到服务端的连接释放报文后，必须发出确认。<code>ACK=1,ack=w+1，seq=u+1</code>，客户端进入<code>TIME-WAIT</code>状态。此时TCP连接还没有释放，必须经过2*MSL的时间后，才进入<code>CLOSED</code>状态。</p><p>6、 服务端接收到客户端发出的确认后，立即进入<code>CLOSED</code>状态。</p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol><li><p>为什么连接的时候是三次握手，关闭的时候却是四次挥手？<br> 当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p><p> 在关闭连接的时候，服务端接收到FIN报文后，很可能不会立即关闭SOCKET，所以先回复一个ACK报文，告诉客户端“你的FIN报文我收到了”。只有当服务端的报文都发送完，才发送FIN报文给客户端。</p></li><li><p>为什么TIME_WAIT状态需要经过2MSL才进入CLOSED状态？<br> 虽然按道理，四个报文都发送完毕后，就可以直接进入CLOSED状态了，但是我们必须假设网络是不可靠的，有可能最后一个ACK丢失。</p><p> 由于网络原因，导致服务端没有收到客户端的ACK报文，不断的发送FIN给客户端。所以需要留下一段时间来处理这种情况，发送ACK报文给服务端。如果知道2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被服务端成功接收，结束TCP连接。</p></li><li><p>为什么不能只用两次握手进行连接？<br> 三次握手主要是完成两个重要功能：</p><ul><li>双方都已经做好了发送数据的准备工作</li><li><p>协商算法初始序列号，这个序列号在握手过程中发送和确认。</p><p>我们假设只进行两次握手；客户端发送连接请求给客户端，客户端收到后返回确认给客户端。<br>按照两次握手的约定，这个时候服务端已经认为成功的建立了连接，一直处于等待客户端发送消息的状态。<br>而客户端再丢失了服务端发送过来的确认报文，不知道是否建立成功，以及不知道服务端的序号状态。在这种情况下，客户端将认为连接没有建立成功，忽略客户端发送过来的任何数据报文，只等待应答报文。而服务端在发出数据报文超时后，不断的重复发送同样的数据。</p></li></ul></li><li><p>如果已经建立连接后，客户端发生了故障怎么办？<br> TCP设有一个计时器，服务器每收到一个客户端请求后都会重新复位这个计时器，如果在规定时间内还没有收到客户端的任何数据，服务器就会发送一个探测报文，每隔75s发送一次。如果连续10次都没有反应，服务端就认为客户端发生了故障，关闭连接。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;三次握手流程&quot;&gt;&lt;a href=&quot;#三次握手流程&quot; class=&quot;headerlink&quot; title=&quot;三次握手流程&quot;&gt;&lt;/a&gt;三次握手流程&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;客户端-&amp;gt;服务端: SYNC=1,seq=x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note left of 客户端: SYCN_SEND&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;服务端--&amp;gt;客户端: SYNC=1,ACK=1,seq=y,ack=x+1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note right of 服务端: SYNC_RECV&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;客户端-&amp;gt;服务端: ACK=1,seq=x+1,ack=y+1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note left of 客户端: ESTAB-LISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note right of 服务端: ESTAB-LISHED&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一次握手：建立连接时，客户端发送sync包(syn=x)到服务器，并进入SYN_SENT状态，等待服务器确认；&lt;/p&gt;
&lt;p&gt;第二次握手：服务器收到syn包，发送确认号(ack=x+1)，同时自己也发送一个syn包(syn=y)，即ACK+SYN包；服务器进入SYN_RECV状态。&lt;/p&gt;
&lt;p&gt;第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)；发送完毕后，客户端和服务端都进入ESTABLISHED状态完成三次握手。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Change Buffer</title>
    <link href="http://yoursite.com/2019/04/03/MySQL/Change%20Buffer/"/>
    <id>http://yoursite.com/2019/04/03/MySQL/Change Buffer/</id>
    <published>2019-04-03T08:11:15.000Z</published>
    <updated>2019-06-19T09:32:04.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的偷懒行为之Change-Buffer"><a href="#MySQL的偷懒行为之Change-Buffer" class="headerlink" title="MySQL的偷懒行为之Change Buffer"></a>MySQL的偷懒行为之Change Buffer</h1><p>在使用MySQL的时候，只要MySQL服务给你返回成功信息后，得到你需要的结果，你并不关注MySQL的行为；但是其实在MySQL内部，其实有很多的特性和机制来延迟真正的持久化等耗时耗资源行为。下面我将为你介绍其中的一个特性：change buffer</p><h2 id="简介-What"><a href="#简介-What" class="headerlink" title="简介(What)"></a>简介(What)</h2><p>The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool. The buffered changes, which may result from INSERT, UPDATE, or DELETE operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.</p><p>当需要改变<font color="red">二级索引</font>的数据，并且该<font color="red">数据页不在内存缓冲池中</font>；这个时候会直接向客户端返回修改成功的信息。MySQL并不实时的去更新磁盘数据，而是在之后一定条件下触发更新操作。这就是<font color="red">change buffer</font>在作祟。</p><p>change buffer在MySQL5.5版本之前，只支持insert操作，所以最初被称为insert buffer。在之后的版本中，支持了更多的修改操作，所以后面改称为change buffer。</p><a id="more"></a><h2 id="为什么需要change-buffer-Why"><a href="#为什么需要change-buffer-Why" class="headerlink" title="为什么需要change buffer(Why)"></a>为什么需要change buffer(Why)</h2><p>首先，你要明白<font color="red">二级索引的数据页在磁盘上存储得很散乱</font>，读取的时候需要消耗大量的资源去做寻址等操作。这里涉及到了操作系统知识，并不在本文的科普范围。</p><p>其次，一般情况下，二级索引的数据访问的并不是很频繁，作为冷数据的存在，<font color="red">即使读取到了内存当中，很快也会被挤出内存缓冲池</font>。如果每次更新操作都读取进来，那也是一笔很大的开销，所以MySQL会将多次更新给合并到一块去更新。（这里涉及到了LRU的淘汰知识，后续会有专门的文章讲解，这里你只需要知道有这个东西就行了）</p><p>所以，change buffer的主要作用有以下两点：</p><ol><li>减少了MySQL<font color="red">随机</font>读取磁盘的次数</li><li>将<font color="red">多次的随机写</font>磁盘操作，合并成了<font color="red">一次的顺序写</font>磁盘操作</li></ol><p>这里再介绍一下change buffer的限制条件：<font color="red">非唯一的辅助索引</font></p><p>前面我们说过二级索引的数据在磁盘上分布的很散乱，但是聚簇索引就不会这样；我们都知道Innodb的数据都存储在聚簇索引的叶子节点，Innodb为了保证能够更快的读取数据，会<font color="red">将聚簇索引的数据页尽可能在物理上顺序放在一起</font>。</p><p>此外，在修改聚簇索引和唯一辅助索引上的数据时，为了<font color="red">保证数据的唯一性</font>，总是会在进行修改操作前进行一次查询操作，这个时候已经将该数据页读取到内存缓存池中了。直接修改内存中数据页上的数据信息更快，完全没有必要使用change buffer。</p><h2 id="change-buffer干了什么-DO）"><a href="#change-buffer干了什么-DO）" class="headerlink" title="change buffer干了什么(DO）"></a>change buffer干了什么(DO）</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>下面我们来看change buffer的执行过程：</p><ol><li>如果需要修改的数据页在内存中，则直接修改内存数据并返回</li><li>如果需要修改的数据页不在内存中，则向change buffer中添加一条记录（修改数据页的记录)</li><li>在redo log中添加一条记录（change buffer页的修改记录）<br><a href="https://imgchr.com/i/V7JVC4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JVC4.jpg" alt="V7JVC4.jpg"></a></li></ol><p>从change buffer的执行过程中，我们可以看到，如果需要修改的数据页page 2不在内存中时，Innodb并不会去磁盘中读取，而是在change buffer中记录了page 2中的数据变更。</p><p>系统会周期性的将change buffer的数据写入到系统表空间中。所以不需要担心change buffer的数据丢失问题。</p><h3 id="什么时候进行合并操作"><a href="#什么时候进行合并操作" class="headerlink" title="什么时候进行合并操作"></a>什么时候进行合并操作</h3><ul><li>二级索引页被读取到buffer pool中，在页面可用之前，会先进行合并缓存操作</li><li>change buffer bitmap页追踪到该辅助索引页无可用空间时</li><li>Master Thread定时任务</li><li>在崩溃恢复时，索引页被读入到缓冲池时，会将存在系统表空间的change buffer应用到二级索引的叶子节点</li><li>当–innodb-fast-shutdown=0时，数据库实例关闭时会强制将change buffer合并到数据页中并刷盘。</li></ul><h3 id="change-buffer的存储"><a href="#change-buffer的存储" class="headerlink" title="change buffer的存储"></a>change buffer的存储</h3><p><a href="https://imgchr.com/i/V7J9uq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7J9uq.md.jpg" alt="V7J9uq.md.jpg"></a></p><p>change buffer在物理上是以一个普通的btree存储。根页是存储在系统表空间的固定页中（涉及innodb的数据存储结构，太高深了~还没到那个层次，就看个热闹)</p><p>上图是一条ibuf记录的存储格式，通过（space id, page no , counter）三列作为主键来唯一决定一条记录，其中counter是一个递增值，目的是为了维持不同操作的有序性。可以通过counter来保证merge时执行时的顺序和用户操作的顺序一致。</p><p>在插入时，会先将counter的值设置成0xFFFF；然后将定位到小于等于(space id, page no, 0xFFFF)的位置，再将counter为当前记录counter值加1。(这样做的原因是为了合并的时候能够更方便的找到同一数据页的缓存，并保证有序)</p><p><a href="https://imgchr.com/i/V7JSvn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JSvn.md.jpg" alt="V7JSvn.md.jpg"></a><br>因为ibuf缓存是针对具体的数据页的，因此在缓存操作的时候需要避免空页和满页的缓存操作。(满页：即将分裂的页，并不一定是所有空闲空间用完的页，一个数据页会有1/16的空隙)</p><ol><li>针对空页情况，在准备插入IBUF_OP_DELETE类型的操作缓存时，会预估执行完此操作后该page中还存在多少记录，如果只剩下一条记录，则走正常流程，将数据页读取到内存中。</li><li>针对满页情况，则是通过ibuf_bitmap页记录，该页存在于每个ibd的固定位置；ibuf_bitmap中记录了每个数据页的缓存状态和空闲空间大小。<br>在执行IBUF_OP_INSERT类型的操作前，会将该page的IBUF_BITMAP_BUFFERED设置为true。<br>通过IBUF_BITMAP_FREE来记录该page的空闲空间；在插入前，会去找到该page的空闲空间大小，如果本次操作超出限制，则会触发一次异步ibuf merge。</li></ol><h3 id="merge过程"><a href="#merge过程" class="headerlink" title="merge过程"></a>merge过程</h3><ol><li>一个磁盘上的数据页被读取到内存缓冲池中</li><li>到ibuf_bitmap中判断该数据页是否有缓存行为</li><li>如果存在缓存，则从ibuf的btree树中读取该数据页的缓存操作；并应用到该内存数据页上</li><li>只有当应用缓存完成，才能提供给用户查询等操作行为</li><li>在一定情况下执行刷盘操作，持久化到磁盘</li></ol><h3 id="merge触发情况"><a href="#merge触发情况" class="headerlink" title="merge触发情况"></a>merge触发情况</h3><ol><li>二级索引页被读入到内存中</li><li>插入ibuf操作时，遇到满页，会造成页分裂操作时，触发一次异步的merge</li><li>当前ibuf tree size&gt;max_size + 10时，会执行一次同步的merge</li><li>本次插入ibuf操作可能会导致ibuf tree索引分裂时，根据ibuf size的大小情况会触发不同情况的merge</li><li>master定时任务会合并相应数量的buffer</li><li>对某个表执行flush table时，会强制对该表的page进行merge</li><li>数据库关闭时，根据innodb_fast_shutdown来决定是否进行merge</li></ol><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><ol><li><p>innodb_change_buffering<br>innodb_change_buffering参数可以控制什么操作会使用change buffer。默认是all</p><p> |||<br> | — | — |<br> | all | The default value: buffer inserts, delete-marking operations, and purges. |<br> | none | Do not buffer any operations. |<br> | inserts | Buffer insert operations. |<br> | deletes | Buffer delete-marking operations. |<br> | changes | Buffer both inserts and delete-marking operations. |<br> | purges | Buffer physical deletion operations that happen in the background. |</p></li><li><p>innodb_change_buffer_max_size<br>innodb_change_buffer_max_size参数控制change buffer占buffer pool的百分比。默认25%，最大50%</p></li><li><p>查看change buffer的使用情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SHOW ENGINE INNODB STATUS \G</span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">56</span>, seg <span class="keyword">size</span> <span class="number">58</span>, <span class="number">517693</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">560451</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ol><p>Ibuf表示当前缓冲区中change buffer的页使用情况<br>size表示已使用的页数，free list len表示空闲的页，seg size表示总共的页数（等于size + free list len + 1)，merges合并数<br>merged operations表示change buffer中每个操作的次数。<br>insert表示Insert Buffer，delete mark表示Delete Buffer，delete表示Purge Buffer。<br>discarded operations表示当change buffer发生merge操作时，表已经被删除，此时不再需要将记录合并到辅助索引中去。</p><p>从上面的信息可以看出这个数据库实例的change buffer效果并不明显（通过insert/merges计算)。change buffer适用于存在大量修改二级索引页的DML活动中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>change buffer将随机IO转换成顺序IO，避免了IO带来的性能损耗，减少了随机读磁盘的次数，提高了数据库的写性能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html</a><br><a href="https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html</a><br><a href="http://mysql.taobao.org/monthly/2015/07/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2015/07/01/</a><br><a href="https://blog.csdn.net/bohu83/article/details/81837872" target="_blank" rel="noopener">https://blog.csdn.net/bohu83/article/details/81837872</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL的偷懒行为之Change-Buffer&quot;&gt;&lt;a href=&quot;#MySQL的偷懒行为之Change-Buffer&quot; class=&quot;headerlink&quot; title=&quot;MySQL的偷懒行为之Change Buffer&quot;&gt;&lt;/a&gt;MySQL的偷懒行为之Change Buffer&lt;/h1&gt;&lt;p&gt;在使用MySQL的时候，只要MySQL服务给你返回成功信息后，得到你需要的结果，你并不关注MySQL的行为；但是其实在MySQL内部，其实有很多的特性和机制来延迟真正的持久化等耗时耗资源行为。下面我将为你介绍其中的一个特性：change buffer&lt;/p&gt;
&lt;h2 id=&quot;简介-What&quot;&gt;&lt;a href=&quot;#简介-What&quot; class=&quot;headerlink&quot; title=&quot;简介(What)&quot;&gt;&lt;/a&gt;简介(What)&lt;/h2&gt;&lt;p&gt;The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool. The buffered changes, which may result from INSERT, UPDATE, or DELETE operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.&lt;/p&gt;
&lt;p&gt;当需要改变&lt;font color=&quot;red&quot;&gt;二级索引&lt;/font&gt;的数据，并且该&lt;font color=&quot;red&quot;&gt;数据页不在内存缓冲池中&lt;/font&gt;；这个时候会直接向客户端返回修改成功的信息。MySQL并不实时的去更新磁盘数据，而是在之后一定条件下触发更新操作。这就是&lt;font color=&quot;red&quot;&gt;change buffer&lt;/font&gt;在作祟。&lt;/p&gt;
&lt;p&gt;change buffer在MySQL5.5版本之前，只支持insert操作，所以最初被称为insert buffer。在之后的版本中，支持了更多的修改操作，所以后面改称为change buffer。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL忘记密码怎么办</title>
    <link href="http://yoursite.com/2019/04/02/MySQL/MySQL%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://yoursite.com/2019/04/02/MySQL/MySQL忘记密码怎么办/</id>
    <published>2019-04-02T12:14:16.000Z</published>
    <updated>2019-07-13T05:53:16.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL忘记密码怎么办？"><a href="#MySQL忘记密码怎么办？" class="headerlink" title="MySQL忘记密码怎么办？"></a>MySQL忘记密码怎么办？</h1><p>有的时候搭建MySQL后，由于密码没有保存好、忘记密码、密码过期等原因，导致登录不上数据库。这个时候该怎么办？</p><p>如果数据库使用人员，那还是乖乖的找数据库管理人员修改密码吧！<br>如果是数据库管理人员，能够登录到MySQL实例所在服务器的话。下面将介绍两种方式进行修改密码操作。</p><h2 id="skip-grant-tables"><a href="#skip-grant-tables" class="headerlink" title="skip-grant-tables"></a>skip-grant-tables</h2><p>第一种方式就是网上介绍最多的通过配置skip-grant-tables参数来跳过MySQL登录校验后，进行修改密码。</p><p>步骤就是：</p><ol><li>需要关闭MySQL实例。</li><li>配置参数。这里有两种方式：第一种就是在启动的使用，启动命令添加–skip-grant-tables；第二种就是通过修改配置文件，在[mysqld]下添加skip-grant-tables。</li><li>启动数据库</li><li>通过alter mysql.user set authentication_string=password(‘newpass’) where XXX@XXX;</li><li>去掉skip-grant-tables配置后重新启动。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">MySQL5.6的密码参数列为：password</span><br><span class="line">MySQL5.7的密码参数列为：authentication_string</span><br><span class="line"></span><br><span class="line">MySQL的账号是以`用户名`@`主机地址`计算的。同一用户名不同主机地址视为不同账号。</span><br></pre></td></tr></table></figure><p>这种方法的缺点很明显：</p><ol><li>数据库必须有一段时间不能提供服务。</li><li>开启跳过权限检查的参数后，安全性无法得到保障。所有人都能登录，即使没有改账号也能登录成功。<a id="more"></a></li></ol><h2 id="利用MyISAM表的特性"><a href="#利用MyISAM表的特性" class="headerlink" title="利用MyISAM表的特性"></a>利用MyISAM表的特性</h2><p>在MySQL8.0之前，mysql.user表都是MyISAM表，可以利用MyISAM表的特性进行修改密码操作。MySQL8.0后，放弃了MyISAM表，所以这个方法对8.0后的版本没有用。</p><p>这个方法需要有一个临时的数据库。<br>假设我们当前有两个数据库，一个3307，一个3309；3307实例的密码忘记了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vdb_172_16_123_101 /root]# ps aux | grep mysql</span><br><span class="line">mysql     2792  0.3 10.3 1067856 184220 pts/0  Sl   19:46   0:00 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3307/my.cnf</span><br><span class="line">mysql     2822  0.4 10.5 1067856 186072 pts/0  Sl   19:46   0:00 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3309/my.cnf</span><br><span class="line">root      2869  0.0  0.0 112648   960 pts/0    R+   19:47   0:00 grep --color=auto mysql</span><br></pre></td></tr></table></figure></p><p>第一步：我们首先登录3309实例，并创建一个临时库testdb(库名可以指定定)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; create database testdb;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>第二步：将3307实例下的mysql库下的user*文件都拷贝到第一步创建的3309实例的testdb库下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# cp -a /data/mysql/mysql_3307/data/mysql/user.* /data/mysql/mysql_3309/data/testdb/</span><br><span class="line">[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3309.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 6</span><br><span class="line">Server version: 5.7.17-log MySQL Community Server (GPL)</span><br><span class="line"> </span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> </span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"> </span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; use testdb;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"> </span><br><span class="line">Database changed</span><br><span class="line">root@localhost:mysql_3309.sock [testdb]&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_testdb |</span><br><span class="line">+------------------+</span><br><span class="line">| user             |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>第三步：在3309实例下修改testdb库下user表的密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3309.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 7</span><br><span class="line">Server version: 5.7.17-log MySQL Community Server (GPL)</span><br><span class="line"> </span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> </span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"> </span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; select user,host,authentication_string from testdb.user;</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">| user      | host      | authentication_string                     |</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">| root      | localhost | *527F89C205EA0A51A7537FFA7B6090D91A7D77AE |</span><br><span class="line">| mysql.sys | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; update testdb.user set authentication_string=password(&apos;newpass&apos;) where user=&apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 1</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; exit</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure></p><p>第四步：将user*文件拷贝回3307的mysql库下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# cp -a /data/mysql/mysql_3309/data/testdb/user.* /data/mysql/mysql_3307/data/mysql</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.frm’? y</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.MYD’? y</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.MYI’? y</span><br></pre></td></tr></table></figure></p><p>第五步：给一个HUP信号给3307，重新加载配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# ps aux | grep mysqld</span><br><span class="line">mysql     2792  0.0 10.7 1067856 189960 pts/0  Sl   19:46   0:01 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3307/my.cnf</span><br><span class="line">mysql     2822  0.0 11.6 1067856 206352 pts/0  Sl   19:46   0:01 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3309/my.cnf</span><br><span class="line">root      2912  0.0  0.0 112648   964 pts/0    S+   20:07   0:00 grep --color=auto mysqld</span><br><span class="line">[root@vdb_172_16_123_101 /root]# kill -HUP 2792</span><br></pre></td></tr></table></figure></p><p>第六步：用新密码登录3307实例</p><pre><code>[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3307.sock -p&apos;newpass&apos;mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 5Server version: 5.7.17-log MySQL Community Server (GPL)Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.root@localhost:mysql_3307.sock [(none)]&gt; </code></pre><p>这种方法是利用MyISAM表拷贝即可使用的特性，在一个临时实例中修改后替换。可以不用重启数据库，不会对业务造成影响。<br>为了安全起见，在操作前还是需要对原文件进行备份。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL忘记密码怎么办？&quot;&gt;&lt;a href=&quot;#MySQL忘记密码怎么办？&quot; class=&quot;headerlink&quot; title=&quot;MySQL忘记密码怎么办？&quot;&gt;&lt;/a&gt;MySQL忘记密码怎么办？&lt;/h1&gt;&lt;p&gt;有的时候搭建MySQL后，由于密码没有保存好、忘记密码、密码过期等原因，导致登录不上数据库。这个时候该怎么办？&lt;/p&gt;
&lt;p&gt;如果数据库使用人员，那还是乖乖的找数据库管理人员修改密码吧！&lt;br&gt;如果是数据库管理人员，能够登录到MySQL实例所在服务器的话。下面将介绍两种方式进行修改密码操作。&lt;/p&gt;
&lt;h2 id=&quot;skip-grant-tables&quot;&gt;&lt;a href=&quot;#skip-grant-tables&quot; class=&quot;headerlink&quot; title=&quot;skip-grant-tables&quot;&gt;&lt;/a&gt;skip-grant-tables&lt;/h2&gt;&lt;p&gt;第一种方式就是网上介绍最多的通过配置skip-grant-tables参数来跳过MySQL登录校验后，进行修改密码。&lt;/p&gt;
&lt;p&gt;步骤就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要关闭MySQL实例。&lt;/li&gt;
&lt;li&gt;配置参数。这里有两种方式：第一种就是在启动的使用，启动命令添加–skip-grant-tables；第二种就是通过修改配置文件，在[mysqld]下添加skip-grant-tables。&lt;/li&gt;
&lt;li&gt;启动数据库&lt;/li&gt;
&lt;li&gt;通过alter mysql.user set authentication_string=password(‘newpass’) where XXX@XXX;&lt;/li&gt;
&lt;li&gt;去掉skip-grant-tables配置后重新启动。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;注：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL5.6的密码参数列为：password&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL5.7的密码参数列为：authentication_string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MySQL的账号是以`用户名`@`主机地址`计算的。同一用户名不同主机地址视为不同账号。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方法的缺点很明显：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库必须有一段时间不能提供服务。&lt;/li&gt;
&lt;li&gt;开启跳过权限检查的参数后，安全性无法得到保障。所有人都能登录，即使没有改账号也能登录成功。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB整体架构</title>
    <link href="http://yoursite.com/2019/03/03/MySQL/InnoDB%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/03/MySQL/InnoDB整体架构/</id>
    <published>2019-03-03T12:14:16.000Z</published>
    <updated>2019-07-13T06:09:15.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InnoDB整体架构"><a href="#InnoDB整体架构" class="headerlink" title="InnoDB整体架构"></a>InnoDB整体架构</h1><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><ul><li>Master Thread<br>Master Thread具有最高的线程优先级别，内部由多个循环（每秒/每10秒）组成。<ol><li>每秒的操作<ul><li>刷新日志缓冲到磁盘（总是）</li><li>合并插入缓冲</li><li>刷新脏页到磁盘（至多100个）</li><li>切换到后台进程</li></ul></li><li>每10秒的操作<ul><li>删除无用的undo页（总是）</li><li>合并20个插入缓冲（总是）</li><li>调回主循环（总是）</li></ul></li></ol></li><li>IO Thread</li><li>purge Thread</li><li>Page cleaner Thread</li></ul><a id="more"></a><h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><ul><li><p>Change buffer（Insert buffer、Delete buffer、Purge buffer）<br>在对非唯一索引的插入和更新操作过程中，如果该数据页在内存中，则直接对数据页进行修改。如果该数据页不在内存中，Innodb并不会马上到磁盘上将该数据页读入内存中，而是先将修改存入到Change buffer中，再按照一定的频率将修改合并到数据页中。</p><ol><li>为什么是需要在非唯一索引的<br>如果是对唯一索引上的数据进行修改，那么在修改前需要进行唯一性校验，这个时候会对该数据页进行查询操作，此时已经将该数据页读取到了内存当中，所以Change buffer的优化对唯一索引并没有什么效果。</li><li>如果宕机是否会导致数据的丢失？<br>Change buffer中数据，不仅会保存在内存当中，还会持久化到磁盘（系统表空间）当中。（持久化机制？）</li><li>什么情况下会合并？<ul><li>当对该数据页进行查询操作时，会将该数据页读取到内存当中。此时，会进行Change buffer的合并操作，将Change buffer中对该数据页的修改应用到该数据页。</li><li>Insert buffer Bitmap页追踪到该辅助索引页中已无可用空间</li><li>Master Thread</li></ul></li><li>合并流程怎样？<ul><li>从磁盘中读取数据页到内存（老版本）</li><li>从Change buffer中读取这个数据页的修改引用到内存中的数据页</li><li>写redo log。记录了内存也和Change buffer的变更。（此时内存中的数据页属于脏页）<br><a href="https://imgchr.com/i/Zhzndf" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/Zhzndf.md.jpg" alt="Zhzndf.md.jpg"></a></li></ul></li></ol></li><li><p>redo buffer<br>redo log中记录的是数据页的物理修改。在事务执行过程中不断的写入到redo buffer中。<br>redo buffer在以下情况会持久化到磁盘。</p><ul><li>Master Thread每秒的定时任务</li><li>每个事务提交时</li><li>写入量过大，导致redo buffer不足是<br>由innodb_flush_log_at_trx_commit控制刷盘策略</li><li>0代表当事务提交时刷盘，只由Master Thread每秒定时任务执行刷盘</li><li>1代表在执行commit时将重做日志缓冲同步到写到磁盘</li><li>2异步刷盘，直接写到文件系统的缓存中，不保证commit执行时肯定会刷盘</li></ul></li><li>数据页和索引页<br>数据都是存储在磁盘上的，当需要访问时才会从磁盘中将该数据所在的页读取到内存当中，并以一定的策略进行淘汰策略和刷盘策略。</li><li>哈希信息页</li><li>元数据信息页</li></ul><h3 id="Innodb机制"><a href="#Innodb机制" class="headerlink" title="Innodb机制"></a>Innodb机制</h3><ul><li>checkpoint<br>在一定条件下，将内存中的脏页持久化到磁盘，并记录数据页刷新的位点信息(LSN)的一种机制。<ol><li>缩短数据库的恢复时间（数据库关闭时将所有的脏页刷新到磁盘/Sharp Checkpoint）</li><li>缓冲池不够用时，刷新部分脏页（为了保证缓冲池中有足够可用的数据页，Innodb会强制进行Checkpoint/Dirty Page too much Checkpoint)</li><li>重做日志不可用时，刷新部分脏页（redo log是一个循环文件，如果redo log的写入量特别大，导致此时redo log几乎写满，Innodb会先将部分脏页先刷新到磁盘，释放redo log空间，此时会触发Checkpoint。/Async/Sync Flush Checkpoint）</li><li>Master Thread每秒任务，刷新部分脏页</li><li>LRU列表空闲页不足时，刷新部分脏页（Innodb会保证LRU列表中有一定数量空闲页可使用，如果LRU列表中没有这么多空闲页，那么Innodb会将LRU列表尾端的页移除，如果其中存在脏页，那么此时会进行Checkpoint操作/FLUSH_LRU_LIST Checkpoint）</li></ol></li><li><p>两次写（Double write）<br>在写数据之前，先把这个数据页写到一块独立物理位置后，再写到数据页中。<br>由两部分组成，一部分是Innodb内存中的double write buffer；另一部分是物理磁盘上的ibdata系统表空间的大小为2M，共128个连续的page。<br>在对缓冲池中的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer分两次，每次1M顺序地写入到共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘。<br><a href="https://imgchr.com/i/ZhzmeP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhzmeP.md.jpg" alt="ZhzmeP.md.jpg"></a></p></li><li><p>WAL（write ahead log)</p><pre><code>1. 先记录undo/redo log,确保日志刷到磁盘上持久存储。2. 更新内存数据页，并&lt;font color=&quot;red&quot;&gt;异步刷盘&lt;/font&gt;。3. 事务日志持久化到binlog，&lt;font color=&quot;red&quot;&gt;此时返回给客户端事务已提交&lt;/font&gt;。4. 提交事务，在redo log中写入到commit记录。</code></pre></li><li><p>两阶段提交<br>我们可以看到对于更新数据的操作，MySQL的处理逻辑是先将内存中的数据页更新，然后写入redolog(prepare阶段），写入binglog，redo log(commit阶段)<br><a href="https://imgchr.com/i/ZhzEQA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhzEQA.md.jpg" alt="ZhzEQA.md.jpg"></a></p><p>在两阶段不同时刻宕机，会发生什么情况？<br>innodb发现redolog中没有commit，就会拿着XA号去binlog中寻找是否存在</p><ul><li>在时刻A宕机，此时是不存在的，所以事务回滚。</li><li>在时刻B宕机，此时Binlog中存在该XA号，所以会恢复该事务。</li></ul></li><li><p>MVCC(多版本并发控制）<br>事务在开启的时候会获取一个一致性快照，每个事务都有一个唯一的事务ID，叫做transaction ID。<br>每行数据也有多个版本，每次事务更新数据的时候都会生成一个新的数据版本，并且将transaction ID赋值给这个数据版本的事务ID。<br>图中的虚线代表的就是undo log,V1、V2、V3并不物理真实存在，需要获取V2则需要从V4依次应用U3、U2。<br>一个数据版本，对于一个事务视图来说，除了自己更新的总是可见以外：</p><ol><li>版本未提交，不可见</li><li>版本已提交，但是是在视图创建后提交的，不可见</li><li>版本已提交，而且是在视图创建前提交的，可见<br><a href="https://imgchr.com/i/Zhzuo8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/Zhzuo8.md.jpg" alt="Zhzuo8.md.jpg"></a></li></ol></li><li><p>自适应哈希</p></li><li>异步IO</li><li>刷新临近页</li><li>组提交<h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;InnoDB整体架构&quot;&gt;&lt;a href=&quot;#InnoDB整体架构&quot; class=&quot;headerlink&quot; title=&quot;InnoDB整体架构&quot;&gt;&lt;/a&gt;InnoDB整体架构&lt;/h1&gt;&lt;h3 id=&quot;后台线程&quot;&gt;&lt;a href=&quot;#后台线程&quot; class=&quot;headerlink&quot; title=&quot;后台线程&quot;&gt;&lt;/a&gt;后台线程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Master Thread&lt;br&gt;Master Thread具有最高的线程优先级别，内部由多个循环（每秒/每10秒）组成。&lt;ol&gt;
&lt;li&gt;每秒的操作&lt;ul&gt;
&lt;li&gt;刷新日志缓冲到磁盘（总是）&lt;/li&gt;
&lt;li&gt;合并插入缓冲&lt;/li&gt;
&lt;li&gt;刷新脏页到磁盘（至多100个）&lt;/li&gt;
&lt;li&gt;切换到后台进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每10秒的操作&lt;ul&gt;
&lt;li&gt;删除无用的undo页（总是）&lt;/li&gt;
&lt;li&gt;合并20个插入缓冲（总是）&lt;/li&gt;
&lt;li&gt;调回主循环（总是）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;IO Thread&lt;/li&gt;
&lt;li&gt;purge Thread&lt;/li&gt;
&lt;li&gt;Page cleaner Thread&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL体系结构</title>
    <link href="http://yoursite.com/2019/03/02/MySQL/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/03/02/MySQL/MySQL体系结构/</id>
    <published>2019-03-02T12:14:16.000Z</published>
    <updated>2019-07-13T05:56:52.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h1><p><a href="https://imgchr.com/i/ZhxoZV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhxoZV.md.jpg" alt="ZhxoZV.md.jpg"></a></p><ul><li>连接器<br>连接器负责跟客户端建立连接、获取权限、维持和管理连接。<br>在这个阶段，连接器会对用户输入的账号密码进行判断。并判断用户连接和数据库连接是否都到了最大限制。以及后续对超时连接进行清理操作。<ol><li>在连接之前，不管用户名密码是够正确，权限如何，连接器会先对连接数进行检查。</li><li>权限会存在两份，一份在数据库中持久化存储，一份保存在内存当中。flush privileges操作就是将内存中的信息给清空，并从数据库中重新加载到内存中。</li><li>在执行grant和revoke操作时，会先将磁盘中的信息修改，然后同步到内存中。但是如果是直接修改的mysql.user表，此时不会主动去更新内存。</li><li>连接器只会到内存中读取用户信息以及权限。连接器只会在进行连接的时候才对用户账号密码进行校验，这意味着，如果一个用户已经连接上，修改密码并不会影响此连接。</li><li>对于全局权限是实时从内存中获取，这代表如果进行权限修改会马上生效。但是对库的权限修改稍微有点区别，虽然也是实时同步到内存，但是如果该连接已经使用了use database进入某库，那么该连接会将该库的权限保存到当前会话变量中，对该库操作权限仍是进入时的状态。</li></ol></li><li>缓存器<br>缓存器会将之前执行过的语句以key-value的形式缓存在内存当中，key是执行的语句,value是该语句执行的结果。如果能够直接获取到，那么会将结果直接返回。（返回结果前还会进行一次权限校验）<br>但是，如果对该表存在更新等数据修改操作，那么这个表上所有的缓存将会清空以保证读取数据的一致性。</li><li>分析器<br>对sql进行词法和语法分析，此时会生成一颗解析树。此时会将sql语句转化成数据库能够看懂的形式，如将字符串’T’识别成’表名T’。此时会去读取库表结构，判断该表是否存在，该字段是够存在。</li><li>优化器<br>根据自身的信息采集、以往执行计划分析等选择自认为最优的执行计划、选择相应的索引。<br>MySQL有一整套规则来判断SQL语句的最优方案，但是该方案不一定是最快的。<br>可以人为的对优化器进行控制，使其选择相应的方案。如force index/ignore index/STRAIGHT_JOIN等。</li><li>执行器<br>根据优化器生成的执行计划来调用存储引擎的接口获取数据并对数据进行处理返回给客户端。</li><li>存储引擎</li></ul><h1 id="MySQL内存结构"><a href="#MySQL内存结构" class="headerlink" title="MySQL内存结构"></a>MySQL内存结构</h1><p><a href="https://imgchr.com/i/ZhxTaT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhxTaT.md.jpg" alt="ZhxTaT.md.jpg"></a></p><h2 id="全局内存"><a href="#全局内存" class="headerlink" title="全局内存"></a>全局内存</h2><ul><li>innodb_buffer_pool_size  innodb缓冲池大小</li><li>innodb_log_buffer_size   redo日志缓冲</li><li>key_buffer_size          MyISAM索引缓冲</li><li>table_definition_cache   表定义文件描述缓存</li><li>table_open_cache         表空间文件描述缓存</li><li>max_heap_table_size      memory、heap表的最大容量</li></ul><h2 id="线程内存"><a href="#线程内存" class="headerlink" title="线程内存"></a>线程内存</h2><ul><li>read_buffer_size</li><li>read_rnd_buffer_size</li><li>sort_buffer_size</li><li>join_buffer_size</li><li>binlog_cache_size</li><li>tmp_table_size</li><li>thread_stack</li><li>thread_chche_size</li><li>net_buffer_length</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL体系结构&quot;&gt;&lt;a href=&quot;#MySQL体系结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL体系结构&quot;&gt;&lt;/a&gt;MySQL体系结构&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/ZhxoZV&quot; targ
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis的内存管理和优化</title>
    <link href="http://yoursite.com/2019/01/25/Redis/Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/25/Redis/Redis的内存管理和优化/</id>
    <published>2019-01-25T13:34:13.000Z</published>
    <updated>2019-06-19T09:32:34.189Z</updated>
    
    <content type="html"><![CDATA[<p>Redis中的内存使用主要是数据使用内存+客户端连接使用内存+内存碎片。<br>其中数据内存占用的最多，优化的常用手段是合理的控制对象的生命周期以及正确的使用数据结构。客户端使用内存主要包含输出缓冲区等一些数据传输缓存。</p><h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><p>只有熟悉的了解数据结构的组成、特性、性能、边界条件等因素后，我们还能更好的分析该数据结构的使用场景和资源消耗情况。</p><p>在Redis当中，所有的对象都是通过（redisObject+具体的对象）形式存在的，所有的对象都被封装在redisObject中，redisObject有五个成员：对象类型（type）、底层编码（encoding)、lru（最近访问时间）、refcount（引用数）、*ptr（指向具体对象的指针）。该结构一共会占用16字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p><p>Redis一共有五种基本类型（其他的特殊类型都是此基础上形成的）string、list、hash、set、zset。<br><a href="https://imgchr.com/i/V7Jart" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7Jart.md.jpg" alt="V7Jart.md.jpg"></a></p><p>每一种数据类型在底层的存储实现存在多种选择，根据实际情况选择合适的编码类型。在效率和资源之间做出合适的权衡。<br><a href="https://imgchr.com/i/V7JtxA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JtxA.md.jpg" alt="V7JtxA.md.jpg"></a></p><a id="more"></a><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>String类型是redis中使用最为广泛的一个类型，所有的key都是字符串类型；它使用的是redis自己设计的SDS结构：包含len、free以及字符串数组。可以O(1)获取字符串长度和空闲空间。<br>通过buf数组存储数据可以保证二进制安全，以及SDS的预分配机制可以避免频繁的进行数组扩容行为。<br>在创建的字符串长度小于等于39（3.2版本后为44）的时候，Redis会使用embstr编码来存储字符串；在这种编码下，只会进行一次内存分配，会把redisObject和sds一起分配；所以embstr编码的字符串是不能改变的，如果对该字符串进行修改，则该编码会直接变成raw。<br>此外，如果是整型字符串的话，String会使用int格式，直接将整数的值赋值给指针对象。这样就省去了sds的开销。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    int len;</span><br><span class="line">    int free;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><a href="https://imgchr.com/i/V7JY2d" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JY2d.md.jpg" alt="V7JY2d.md.jpg"></a></p><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>压缩列表是将所有的元素紧凑的连接在一起，相当于把所有的成员都叠在一起，没有额外的数据结构，空间占用比较小。缺点就是在读写的时候需要修改整个压缩列表，所以在数据量比较小的时候才使用，一般能够达到5-10倍的压缩比。</p><ul><li>ziplist：记录了整个压缩列表所占用的内存直接数</li><li>ziplist：记录压缩表尾节点举例压缩列表起始地址的字节偏移量，通过这个偏移量可以直接确定表尾节点的地址</li><li>zllen：记录了压缩列表包含的节点数量</li><li>entryX：节点列表，压缩列表包含的各个节点，里面记录了前一个节点的长度、本节点的长度、编码等信息。可以方便的实现逆序遍历。</li><li>zlend：特殊值，用于标记压缩列表的末尾。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zlentry &#123;</span><br><span class="line">    unsigned int prevrawlensize, prevrawlen;</span><br><span class="line">    unsigned int lensize, len;</span><br><span class="line">    unsigned int headersize;</span><br><span class="line">    unsigned char encoding;</span><br><span class="line">    unsigned char *p;</span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://imgchr.com/i/V7JJ8H" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JJ8H.md.jpg" alt="V7JJ8H.md.jpg"></a></p><h2 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h2><p>在Redis启动的时候，就直接创建了10000个redisObject，代表1-10000的整型，这些整型会一直保存在内存当中，当其他对象需要用到时，就会共享使用这些整型。这也意味着这些整型LRU成员没有用，后续不会有其他的一些开销。</p><h2 id="键值对管理"><a href="#键值对管理" class="headerlink" title="键值对管理"></a>键值对管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    dict *dict;                 /* The keyspace for this DB */</span><br><span class="line">    dict *expires;              /* Timeout of keys with a timeout set */</span><br><span class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */</span><br><span class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</span><br><span class="line">    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */</span><br><span class="line">    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */</span><br><span class="line">    int id;                     /* Database ID */</span><br><span class="line">    long long avg_ttl;          /* Average TTL, just for stats */</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>在redis当中使用redisDb表示一个数据库结构，单个redis可以设置16个这样的DB；通过select命令进行选择，不同DB之间互不影响。</p><h3 id="过期Key清理"><a href="#过期Key清理" class="headerlink" title="过期Key清理"></a>过期Key清理</h3><p>通过一个dict结构(dict)来存储具体键值对对象；一个dict结构(expires)来记录redis中设置了过期时间的键值对，这个结构会复用dict中的Key、Value对象，所以并不会造成额外的内存开销。</p><p>在Key过期的时候，redis会自动执行一个del操作对过期的Key进行清理操作。这个行为并不是立即去执行的，而是会在几个条件下触发。一般只会在必要或者CPU空闲的时候做过期清理动作；如访问Key的时候、事件循环结束进入事件侦听前、后台定期任务。</p><p>Redis后台清理任务默认1s执行10次，也就是100ms一次。相当于如果没有其他操作，全部用来做后台任务的话，一次后台任务可以执行100ms；其中最高25%的时间用来删除过期Key的操作，即100ms中有25ms可以用来做Key清理。其他时间用来做Redis管理的任务。</p><p>过期Key清理算法：</p><ol><li>依次遍历所有的DB</li><li>从DB中随机取20个键值对，判断是否过期，如果过期，则删除。</li><li>如果取出的键值对中有大于5个过期，则重复上一步；否则遍历下一个DB</li><li>在清理过程中，如果达到了时间限制，退出清理过程。</li></ol><p>//TODO<br>redis的过期Key清理是在redis.c/activeExpireCycle()函数实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">void activeExpireCycle(int type) &#123;</span><br><span class="line">    /* This function has some global state in order to continue the work</span><br><span class="line">     * incrementally across calls. */</span><br><span class="line">    // 静态变量，用来累积函数连续执行时的数据</span><br><span class="line">    static unsigned int current_db = 0; /* Last DB tested. */</span><br><span class="line">    static int timelimit_exit = 0;      /* Time limit hit in previous call? */</span><br><span class="line">    static long long last_fast_cycle = 0; /* When last fast cycle ran. */</span><br><span class="line"></span><br><span class="line">    unsigned int j, iteration = 0;</span><br><span class="line">    // 默认每次处理的数据库数量</span><br><span class="line">    unsigned int dbs_per_call = REDIS_DBCRON_DBS_PER_CALL;</span><br><span class="line">    // 函数开始的时间</span><br><span class="line">    long long start = ustime(), timelimit;</span><br><span class="line"></span><br><span class="line">    // 快速模式</span><br><span class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        /* Don&apos;t start a fast cycle if the previous cycle did not exited</span><br><span class="line">         * for time limt. Also don&apos;t repeat a fast cycle for the same period</span><br><span class="line">         * as the fast cycle total duration itself. */</span><br><span class="line">        // 如果上次函数没有触发 timelimit_exit ，那么不执行处理</span><br><span class="line">        if (!timelimit_exit) return;</span><br><span class="line">        // 如果距离上次执行未够一定时间，那么不执行处理</span><br><span class="line">        if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;</span><br><span class="line">        // 运行到这里，说明执行快速处理，记录当前时间</span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We usually should test REDIS_DBCRON_DBS_PER_CALL per iteration, with</span><br><span class="line">     * two exceptions:</span><br><span class="line">     *</span><br><span class="line">     * 一般情况下，函数只处理 REDIS_DBCRON_DBS_PER_CALL 个数据库，</span><br><span class="line">     * 除非：</span><br><span class="line">     *</span><br><span class="line">     * 1) Don&apos;t test more DBs than we have.</span><br><span class="line">     *    当前数据库的数量小于 REDIS_DBCRON_DBS_PER_CALL</span><br><span class="line">     * 2) If last time we hit the time limit, we want to scan all DBs</span><br><span class="line">     * in this iteration, as there is work to do in some DB and we don&apos;t want</span><br><span class="line">     * expired keys to use memory for too much time. </span><br><span class="line">     *     如果上次处理遇到了时间上限，那么这次需要对所有数据库进行扫描，</span><br><span class="line">     *     这可以避免过多的过期键占用空间</span><br><span class="line">     */</span><br><span class="line">    if (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line"></span><br><span class="line">    /* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time</span><br><span class="line">     * per iteration. Since this function gets called with a frequency of</span><br><span class="line">     * server.hz times per second, the following is the max amount of</span><br><span class="line">     * microseconds we can spend in this function. */</span><br><span class="line">    // 函数处理的微秒时间上限</span><br><span class="line">    // ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 默认为 25 ，也即是 25 % 的 CPU 时间</span><br><span class="line">    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;</span><br><span class="line">    timelimit_exit = 0;</span><br><span class="line">    if (timelimit &lt;= 0) timelimit = 1;</span><br><span class="line"></span><br><span class="line">    // 如果是运行在快速模式之下</span><br><span class="line">    // 那么最多只能运行 FAST_DURATION 微秒 </span><br><span class="line">    // 默认值为 1000 （微秒）</span><br><span class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */</span><br><span class="line"></span><br><span class="line">    // 遍历数据库</span><br><span class="line">    for (j = 0; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">        int expired;</span><br><span class="line">        // 指向要处理的数据库</span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"></span><br><span class="line">        /* Increment the DB now so we are sure if we run out of time</span><br><span class="line">         * in the current DB we&apos;ll restart from the next. This allows to</span><br><span class="line">         * distribute the time evenly across DBs. */</span><br><span class="line">        // 为 DB 计数器加一，如果进入 do 循环之后因为超时而跳出</span><br><span class="line">        // 那么下次会直接从下个 DB 开始处理</span><br><span class="line">        current_db++;</span><br><span class="line"></span><br><span class="line">        /* Continue to expire if at the end of the cycle more than 25%</span><br><span class="line">         * of the keys were expired. */</span><br><span class="line">        do &#123;</span><br><span class="line">            unsigned long num, slots;</span><br><span class="line">            long long now, ttl_sum;</span><br><span class="line">            int ttl_samples;</span><br><span class="line"></span><br><span class="line">            /* If there is nothing to expire try next DB ASAP. */</span><br><span class="line">            // 获取数据库中带过期时间的键的数量</span><br><span class="line">            // 如果该数量为 0 ，直接跳过这个数据库</span><br><span class="line">            if ((num = dictSize(db-&gt;expires)) == 0) &#123;</span><br><span class="line">                db-&gt;avg_ttl = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取数据库中键值对的数量</span><br><span class="line">            slots = dictSlots(db-&gt;expires);</span><br><span class="line">            // 当前时间</span><br><span class="line">            now = mstime();</span><br><span class="line"></span><br><span class="line">            /* When there are less than 1% filled slots getting random</span><br><span class="line">             * keys is expensive, so stop here waiting for better times...</span><br><span class="line">             * The dictionary will be resized asap. */</span><br><span class="line">            // 这个数据库的使用率低于 1% ，扫描起来太费力了（大部分都会 MISS）</span><br><span class="line">            // 跳过，等待字典收缩程序运行</span><br><span class="line">            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*100/slots &lt; 1)) break;</span><br><span class="line"></span><br><span class="line">            /* The main collection cycle. Sample random keys among keys</span><br><span class="line">             * with an expire set, checking for expired ones. </span><br><span class="line">             *</span><br><span class="line">             * 样本计数器</span><br><span class="line">             */</span><br><span class="line">            // 已处理过期键计数器</span><br><span class="line">            expired = 0;</span><br><span class="line">            // 键的总 TTL 计数器</span><br><span class="line">            ttl_sum = 0;</span><br><span class="line">            // 总共处理的键计数器</span><br><span class="line">            ttl_samples = 0;</span><br><span class="line"></span><br><span class="line">            // 每次最多只能检查 LOOKUPS_PER_LOOP 个键</span><br><span class="line">            if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line"></span><br><span class="line">            // 开始遍历数据库</span><br><span class="line">            while (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                long long ttl;</span><br><span class="line"></span><br><span class="line">                // 从 expires 中随机取出一个带过期时间的键</span><br><span class="line">                if ((de = dictGetRandomKey(db-&gt;expires)) == NULL) break;</span><br><span class="line">                // 计算 TTL</span><br><span class="line">                ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                // 如果键已经过期，那么删除它，并将 expired 计数器增一</span><br><span class="line">                if (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                if (ttl &lt; 0) ttl = 0;</span><br><span class="line">                // 累积键的 TTL</span><br><span class="line">                ttl_sum += ttl;</span><br><span class="line">                // 累积处理键的个数</span><br><span class="line">                ttl_samples++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* Update the average TTL stats for this database. */</span><br><span class="line">            // 为这个数据库更新平均 TTL 统计数据</span><br><span class="line">            if (ttl_samples) &#123;</span><br><span class="line">                // 计算当前平均值</span><br><span class="line">                long long avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line">                </span><br><span class="line">                // 如果这是第一次设置数据库平均 TTL ，那么进行初始化</span><br><span class="line">                if (db-&gt;avg_ttl == 0) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                /* Smooth the value averaging with the previous one. */</span><br><span class="line">                // 取数据库的上次平均 TTL 和今次平均 TTL 的平均值</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl+avg_ttl)/2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* We can&apos;t block forever here even if there are many keys to</span><br><span class="line">             * expire. So after a given amount of milliseconds return to the</span><br><span class="line">             * caller waiting for the other active expire cycle. */</span><br><span class="line">            // 我们不能用太长时间处理过期键，</span><br><span class="line">            // 所以这个函数执行一定时间之后就要返回</span><br><span class="line"></span><br><span class="line">            // 更新遍历次数</span><br><span class="line">            iteration++;</span><br><span class="line"></span><br><span class="line">            // 每遍历 16 次执行一次</span><br><span class="line">            if ((iteration &amp; 0xf) == 0 &amp;&amp; /* check once every 16 iterations. */</span><br><span class="line">                (ustime()-start) &gt; timelimit)</span><br><span class="line">            &#123;</span><br><span class="line">                // 如果遍历次数正好是 16 的倍数</span><br><span class="line">                // 并且遍历的时间超过了 timelimit</span><br><span class="line">                // 那么断开 timelimit_exit</span><br><span class="line">                timelimit_exit = 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 已经超时了，返回</span><br><span class="line">            if (timelimit_exit) return;</span><br><span class="line"></span><br><span class="line">            /* We don&apos;t repeat the cycle if there are less than 25% of keys</span><br><span class="line">             * found expired in the current DB. */</span><br><span class="line">            // 如果已删除的过期键占当前总数据库带过期时间的键数量的 25 %</span><br><span class="line">            // 那么不再遍历</span><br><span class="line">        &#125; while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设想在一个大型的Redis实例中所有的Key在同一时间过期了会出现什么样的结果？</p><p>答案就是：会导致线上读写请求出现明显的卡顿现象。<br>首先，Redis会持续扫描过期字典（多次循环），直到过期字典中的Key变得稀疏才会减缓清理的节奏。另外一个原因就是内存管理器需要频繁的回收内存页，会产生一定的CPU消耗。</p><p>当客户端请求到来时，服务器如果正好过期扫描，客户端的请求将会等待至少25ms后才会进行处理，如果客户端将超时时间设置的比较短，比如10ms，那么就会出现大量的链接因为超时而关闭，业务端就会出现很多异常。<br>并且这时还无法从Redis的slowlog中看到慢查询记录，因为慢查询指的是逻辑处理过程慢，不包含等待时间。</p><p>所以业务开发人员一定要注意过期时间，如果有大批量的key过期，要给过期时间设置一个随机范围，分散过期处理的压力。</p><p>##淘汰机制<br>实例的内存是有上限的，当使用的内存超过了允许的最大内存时，Redis会按照设定的淘汰策略清理内存，以保证实例的正常运行。</p><ul><li>volatile-lru：从<strong>已设置过期时间</strong>的数据中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从<strong>已设置过期时间</strong>的数据中挑选将要过期的数据淘汰</li><li>volatile-random：从<strong>已设置过期时间</strong>的数据集中任意选择数据淘汰</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集中任意选择数据淘汰</li><li>no-enviction：禁止淘汰数据</li></ul><p>淘汰算法：</p><ol><li>遍历所有DB</li><li>按照设置的淘汰策略挑选一个Key进行淘汰</li><li>若策略是lru或ttl，采用近似算法随机取n个样本(默认为5，可配置)，从中挑选出最佳值进行淘汰</li><li>计算内存是否超过允许值，若是，重复1~3</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>最佳实践就是平时遇到的一些好案例，或者从前面的原理导出的一些结论。首先，最重要的就是选择正确的数据类型，主要以满足业务，性能和场景为优先考虑。一般数据量不大的业务，没必要花太大的精力；但是对于一些主要业务，就需要做比较细致的优化。如String类型对象可以考虑使用整数，浮点型可以改成整数。对于数据量比较大，比较重要的业务，可以深入优化，根据业务场景对字符串类型进行合理的拆分，以符合使用压缩列表的(可以适当的对压缩列表的转换条件进行放宽)。</p><p><a href="https://imgchr.com/i/V7JUKI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JUKI.md.jpg" alt="V7JUKI.md.jpg"></a><br>这是官网上的一个例子，在4存Key-Value的时候，以object后面加一个整数作为ID，整个数据库可能都是这种类型，数据量又特别大，想对它优化的时候，比较通用的优化方法就是取模，相同前缀的Key单独做hash。整个db空间相当于一个大的哈希表，这样就把本来分配给整个db空间的Key，按照不同的前缀分成小的哈希表，每个哈希表里面保证数据比较小，那这个哈希表就会用压缩列表来保存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis中的内存使用主要是数据使用内存+客户端连接使用内存+内存碎片。&lt;br&gt;其中数据内存占用的最多，优化的常用手段是合理的控制对象的生命周期以及正确的使用数据结构。客户端使用内存主要包含输出缓冲区等一些数据传输缓存。&lt;/p&gt;
&lt;h2 id=&quot;Redis的数据结构&quot;&gt;&lt;a href=&quot;#Redis的数据结构&quot; class=&quot;headerlink&quot; title=&quot;Redis的数据结构&quot;&gt;&lt;/a&gt;Redis的数据结构&lt;/h2&gt;&lt;p&gt;只有熟悉的了解数据结构的组成、特性、性能、边界条件等因素后，我们还能更好的分析该数据结构的使用场景和资源消耗情况。&lt;/p&gt;
&lt;p&gt;在Redis当中，所有的对象都是通过（redisObject+具体的对象）形式存在的，所有的对象都被封装在redisObject中，redisObject有五个成员：对象类型（type）、底层编码（encoding)、lru（最近访问时间）、refcount（引用数）、*ptr（指向具体对象的指针）。该结构一共会占用16字节。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct redisObject &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned type:4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned encoding:4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int refcount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void *ptr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; robj;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Redis一共有五种基本类型（其他的特殊类型都是此基础上形成的）string、list、hash、set、zset。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/V7Jart&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/16/V7Jart.md.jpg&quot; alt=&quot;V7Jart.md.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每一种数据类型在底层的存储实现存在多种选择，根据实际情况选择合适的编码类型。在效率和资源之间做出合适的权衡。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/V7JtxA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/16/V7JtxA.md.jpg&quot; alt=&quot;V7JtxA.md.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Binlog格式</title>
    <link href="http://yoursite.com/2019/01/23/MySQL/Binlog%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/01/23/MySQL/Binlog格式/</id>
    <published>2019-01-23T12:14:16.000Z</published>
    <updated>2019-06-16T14:42:53.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binlog日志格式"><a href="#Binlog日志格式" class="headerlink" title="Binlog日志格式"></a>Binlog日志格式</h1><p>binlog_format是规定binlog日志文件记录语句方式的参数，可以动态修改，支持session和global级别，可选项有row、statement、mixed。</p><ul><li>row：以修改前后的数据信息，能够清晰的展现出数据变更，便于解析binlog文件后开发闪回功能。缺点是会产生大量的日志，在某些情况下会占用大量的IO资源。</li><li>statement：语句格式；仅记录执行的语句，在特定情况下会可能会导致数据的不一致；优点很明显，减少了binlog日志量，减少IO。</li><li>mixed：以上两种模式的混合使用，一般情况下使用statement保存，在可能会导致数据不一致的情况使用row保存</li></ul><a id="more"></a><h2 id="row格式"><a href="#row格式" class="headerlink" title="row格式"></a>row格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># at 860</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 925 CRC32 0x1fcb13d6  GTID    last_committed=2        sequence_number=3</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;a81311dd-448f-11e9-be56-06d4d400045d:113&apos;/*!*/;</span><br><span class="line"># at 925</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 996 CRC32 0x106b145e  Query   thread_id=210   exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1555398441/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 996</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1055 CRC32 0x2920f8d2         Rows_query</span><br><span class="line"># update t set age = 24 where id = 15</span><br><span class="line"># at 1055</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1102 CRC32 0x07a1009c         Table_map: `hoo`.`t` mapped to number 223</span><br><span class="line"># at 1102</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1162 CRC32 0xef28b2a8         Update_rows: table id 223 flags: STMT_END_F</span><br><span class="line">### UPDATE `hoo`.`t`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=15 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&apos;xx&apos; /* VARSTRING(40) meta=40 nullable=1 is_null=0 */</span><br><span class="line">###   @3=22 /* INT meta=0 nullable=1 is_null=0 */</span><br><span class="line">### SET</span><br><span class="line">###   @1=15 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&apos;xx&apos; /* VARSTRING(40) meta=40 nullable=1 is_null=0 */</span><br><span class="line">###   @3=24 /* INT meta=0 nullable=1 is_null=0 */</span><br><span class="line"># at 1162</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1193 CRC32 0x90bc6f89         Xid = 2975</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;AUTOMATIC&apos; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure><p>在执行正式的SQL语句前会先去执行SET @@SESSION.GTID_NEXT和SET TIMESTAMP两个命令。这意味着即使事务回滚，他所申请的gtid也不会再被复用。</p><p>我们可以看到binlog文件中专门有一段(Update_rows)用来记录受影响的行在修改前后的记录。</p><p>此外，row格式的binlog记录还会受另一个参数的影响：binlog_row_image；<br>binlog_row_image是5.6版本出现的参数，控制在binlog_format=row情况下的binlog日志记录格式；可选项有full、minimal、noblob，默认值是full，可以动态修改，支持session和global级别。</p><ul><li>full：记录所有列的信息</li><li>minimal：仅仅记录被更改以及能够唯一识别数据行的列值（如：主键列）</li><li>noblob：记录所有的列值信息，但是BLOB和TEXT列除外（如未修改）</li></ul><h2 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># at 1193</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1258 CRC32 0x518fd71a         GTID    last_committed=3        sequence_number=4</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;a81311dd-448f-11e9-be56-06d4d400045d:114&apos;/*!*/;</span><br><span class="line"># at 1258</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1335 CRC32 0xc276a08b         Query   thread_id=210   exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1555398636/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 1335</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1442 CRC32 0xf4c40dce         Query   thread_id=210   exec_time=0     error_code=0</span><br><span class="line">use `hoo`/*!*/;</span><br><span class="line">SET TIMESTAMP=1555398636/*!*/;</span><br><span class="line">update t set age = 24 where id = 14</span><br><span class="line">/*!*/;</span><br><span class="line"># at 1442</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1473 CRC32 0xdf3eeac5         Xid = 2978</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;AUTOMATIC&apos; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>我们看到在statement格式下，binlog记录了库名、事务开启时的时间戳、具体执行的语句。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binlog日志格式&quot;&gt;&lt;a href=&quot;#Binlog日志格式&quot; class=&quot;headerlink&quot; title=&quot;Binlog日志格式&quot;&gt;&lt;/a&gt;Binlog日志格式&lt;/h1&gt;&lt;p&gt;binlog_format是规定binlog日志文件记录语句方式的参数，可以动态修改，支持session和global级别，可选项有row、statement、mixed。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;row：以修改前后的数据信息，能够清晰的展现出数据变更，便于解析binlog文件后开发闪回功能。缺点是会产生大量的日志，在某些情况下会占用大量的IO资源。&lt;/li&gt;
&lt;li&gt;statement：语句格式；仅记录执行的语句，在特定情况下会可能会导致数据的不一致；优点很明显，减少了binlog日志量，减少IO。&lt;/li&gt;
&lt;li&gt;mixed：以上两种模式的混合使用，一般情况下使用statement保存，在可能会导致数据不一致的情况使用row保存&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>当执行-single-transaction做逻辑备份时，遇到DDL</title>
    <link href="http://yoursite.com/2019/01/22/MySQL/mysqldump%E9%81%87%E5%88%B0DDL/"/>
    <id>http://yoursite.com/2019/01/22/MySQL/mysqldump遇到DDL/</id>
    <published>2019-01-22T12:54:48.000Z</published>
    <updated>2019-01-22T15:18:49.766Z</updated>
    
    <content type="html"><![CDATA[<p>当使用-single-transaction做逻辑备份的时候，遇到一个DDL语句会怎样？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；</span><br><span class="line">/* other tables */</span><br><span class="line">Q3:SAVEPOINT sp;</span><br><span class="line">/* 时刻 1 */</span><br><span class="line">Q4:show create table `t1`;</span><br><span class="line">/* 时刻 2 */</span><br><span class="line">Q5:SELECT * FROM `t1`;</span><br><span class="line">/* 时刻 3 */</span><br><span class="line">Q6:ROLLBACK TO SAVEPOINT sp;</span><br><span class="line">/* 时刻 4 */</span><br><span class="line">/* other tables */</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在备份开始的时候，为了确保RR隔离级别，再设置一次RR隔离级别（Q1）</p><p>启动事务，使用WITH CONSISTENT SNAPSHOP确保语句执行完得到一个一致性视图（Q2）</p><p>设置一个保存点，这个很重要（Q3）</p><p>show create是为了拿到表结构（Q4），然后正式导数据（Q5），回滚到SAVEPOINT sp，作用是释放t1的MDL锁。</p><p>按照DDL执行的时间不同，效果不同。</p><ol><li>如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。</li><li>如果在“时刻2”到达，则表结构被改过，Q5执行的时候，报Table definition has changed，please retry transaction，现象：mysqldump终止。</li><li>如果在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，现象：主从延迟，知道Q6执行完成。</li><li>从“时刻4”开始，mysqldump释放MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当使用-single-transaction做逻辑备份的时候，遇到一个DDL语句会怎样？&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* other tables */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q3:SAVEPOINT sp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 时刻 1 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q4:show create table `t1`;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 时刻 2 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q5:SELECT * FROM `t1`;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 时刻 3 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q6:ROLLBACK TO SAVEPOINT sp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 时刻 4 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* other tables */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="MYSQL45讲" scheme="http://yoursite.com/tags/MYSQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="http://yoursite.com/2019/01/21/MySQL/%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/01/21/MySQL/索引/</id>
    <published>2019-01-21T14:21:45.000Z</published>
    <updated>2019-01-22T02:20:42.787Z</updated>
    
    <content type="html"><![CDATA[<font color="red">索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</font><h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>索引的出现时为了提高查询效率，但是实现索引的方式有很多种，所以这里也就引入了索引模型的概念。可以用来提高读写操作的数据结构有很多，这里先介绍比较简单的数据结构：哈希表和搜索树。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表是一种以K-V存储的数据结构，我们只要输入待查找的值，就可以找到其对应的值。哈希的思路很简单，把值放在数组里，用一个哈希函数把Key换算成一个确认的位置，然后把value放在数组的这个位置。遇到同一个位置上有很多value时，就用一个链表串起来。</p><p>哈希链表适用于只有等值查询的场景</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。查询的平均复杂度是O(log(N))。<br><a id="more"></a></p><h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>在InnoDB中，表都是根据主键的顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB使用B+树索引模型。每一个索引再InnoDB里面对应一颗B+树。</p><p>假设我们有一个主键列为ID的表，表中有字段k，并且k上有索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure></p><p>表中R1~R5的（ID、k）值分别为（100，1）、（200，2）、（300，3）、（500，5）、（600、6）<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/Ei9YpCJeczWr9VO8*BgWLIHjUz30q5UyxUldf8Sp*g4!/b/dL4AAAAAAAAA&amp;bo=WgXyAwAAAAADB4w!&amp;rf=viewer_4" alt=""><br>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。<br>主键索引的叶子节点存的是整行数据。非主键索引的叶子节点的内容是主键的值。<br>1、如果语句是select <em> from T where ID=500，即主键查询方式，则只需要搜索ID这颗B+树；<br>2、如果语句是select </em> from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID值为500，再到ID索引树搜索一次。这个过程称为回表。</p><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+树为了维护索引的有序性，在插入新值得时候需要做必要的维护。<br>插入：</p><ul><li>当叶子节点未满时，将记录插入对应的叶子节点。</li><li>当叶子节点已满，索引页未满时；拆分中间的节点放入索引页，小于中间节点的放在左边节点，大于等于中间节点的放右边</li><li>当叶子页已满，索引页已满时；逐层拆分，直到所有节点都满足</li><li>当叶子节点的兄弟页未满，索引页已满时；不急于拆分节点，而是做旋转操作，减少页的拆分。<br>删除：<br>B+树使用填充因子来控制树的删除变化，填充因子是指数据填充的百分比。</li><li>当删除节点后，对应的叶子页大于填充因子时；直接删除节点，不做合并页操作。</li><li>当删除节点后，对应的叶子页大于填充因子，但是该节点也是索引节点；直接删除节点，将右边节点更新到对应的索引页。</li><li>当删除节点后，对应的叶子页小于填充因子时；合并页节点及其兄弟页节点。</li><li>当删除节点后，对应的叶子页小于填充因子，该节点也是索引节点；合并页节点及其兄弟页节点，更新索引页。</li><li>当删除节点后，该节点也是索引节点，并且删除该节点索引页也小于填充因子。逐层合并，直到满足条件。</li></ul><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果需要查询的值已经在非主键索引中可以完全获取，那么就可以不需要再去主键索引中进行回表操作了。<br><b>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</b></p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>B+树这种索引结构，可以利用索引的”最左前缀”来定位记录。<br>为了直观的说明这个概念，我们用（name，age）这个联合索引来分析。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/jMYONpHYjMYo6BaqToUtBg8my7ZjOad9c32kC9kHzN4!/b/dLgAAAAAAAAA&amp;bo=VAW6AwAAAAADB8o!&amp;rf=viewer_4" alt=""><br>可以看到，索引项是按照索引里面定义出现的先后顺序排序的。<br>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p><p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>]]></content>
    
    <summary type="html">
    
      &lt;font color=&quot;red&quot;&gt;索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。&lt;/font&gt;

&lt;h3 id=&quot;索引的常见模型&quot;&gt;&lt;a href=&quot;#索引的常见模型&quot; class=&quot;headerlink&quot; title=&quot;索引的常见模型&quot;&gt;&lt;/a&gt;索引的常见模型&lt;/h3&gt;&lt;p&gt;索引的出现时为了提高查询效率，但是实现索引的方式有很多种，所以这里也就引入了索引模型的概念。可以用来提高读写操作的数据结构有很多，这里先介绍比较简单的数据结构：哈希表和搜索树。&lt;/p&gt;
&lt;h4 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h4&gt;&lt;p&gt;哈希表是一种以K-V存储的数据结构，我们只要输入待查找的值，就可以找到其对应的值。哈希的思路很简单，把值放在数组里，用一个哈希函数把Key换算成一个确认的位置，然后把value放在数组的这个位置。遇到同一个位置上有很多value时，就用一个链表串起来。&lt;/p&gt;
&lt;p&gt;哈希链表适用于只有等值查询的场景&lt;/p&gt;
&lt;h4 id=&quot;二叉搜索树&quot;&gt;&lt;a href=&quot;#二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树&quot;&gt;&lt;/a&gt;二叉搜索树&lt;/h4&gt;&lt;p&gt;二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。查询的平均复杂度是O(log(N))。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="MySQL45讲" scheme="http://yoursite.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>事务隔离</title>
    <link href="http://yoursite.com/2019/01/16/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>http://yoursite.com/2019/01/16/MySQL/事务隔离/</id>
    <published>2019-01-16T14:32:26.000Z</published>
    <updated>2019-06-16T14:27:36.239Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说：事务就是保证一组数据库操作，要么全部成功，要么全部是失败。在MySQL中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务。</p><h3 id="隔离性和隔离级别"><a href="#隔离性和隔离级别" class="headerlink" title="隔离性和隔离级别"></a>隔离性和隔离级别</h3><p>提到事务，肯定会想到ACID（即原子性、一致性、隔离性、持久性），这里就讨论一下隔离性。<br>当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><ul><li>读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读已提交：一个事务提交后，它做的变更才会被其他事务看到</li><li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li><li>串行化：后访问的事务必须等前一个事务完成后，才能继续执行。</li></ul><p>假设数据表T中只有一列，其中一行的值为1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure></p><p><img src="https://m.qpic.cn/psb?/V140pON30woojR/N34*jAP61rjm0uHLDCigAi2GlkgbvdMqoW4J9gqGBok!/b/dL8AAAAAAAAA&amp;bo=OAT.BAAAAAADB.Q!&amp;rf=viewer_4" alt=""><br><a id="more"></a><br>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图中的V1、V2、V3的返回值分别是什么。</p><ul><li>若隔离级别是“读未提交”，这V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此V2、V3也都是2。</li><li>若隔离级别是“读提交”，这V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以，V3的值也是2。</li><li>若隔离级别是“可重复读”，则V1、V2是1，V3是2.之所以V2是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”。则在事务B执行将1改成2的时候，就会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看，V1、V2、V3的值是2。</li></ul><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个事务是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接使用加锁的方式来避免并行访问。</p><p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。</p><h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面都会有类似下面的记录：<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/pyWktvOA4ggEJYuVgTtFYnCH.Id5ReNQfprJmpwT1.8!/b/dMIAAAAAAAAA&amp;bo=TAVIAwAAAAADByA!&amp;rf=viewer_4" alt=""><br>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-riew。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作等到。</p><p>回滚日志不可能一直保留；在不需要的时候就会被删除，也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志就会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p><p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>在MySQL5.5以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何避免长事务的出现？<br><b>从开发端来看：</b></p><ol><li>确认是否使用了set autocommit=0。建议将这个值设置成1</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit框起来。</li><li>业务连接数据库的时候，根据业务本身的预估，通过set max_execution_time命令来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li></ol><p><b>从数据库端看：</b></p><ol><li>监控Information_schema.innodb_trx表，设置长事务阈值，超过就报警。</li><li>在业务功能测试阶段要求输出所欲的general_log，分析日志行为提前发现问题。</li><li>如果使用的是MySQL5.6或更新版本，把innodb_undo_tablespaces设置为2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说：事务就是保证一组数据库操作，要么全部成功，要么全部是失败。在MySQL中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务。&lt;/p&gt;
&lt;h3 id=&quot;隔离性和隔离级别&quot;&gt;&lt;a href=&quot;#隔离性和隔离级别&quot; class=&quot;headerlink&quot; title=&quot;隔离性和隔离级别&quot;&gt;&lt;/a&gt;隔离性和隔离级别&lt;/h3&gt;&lt;p&gt;提到事务，肯定会想到ACID（即原子性、一致性、隔离性、持久性），这里就讨论一下隔离性。&lt;br&gt;当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了“隔离级别”的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。&lt;/li&gt;
&lt;li&gt;读已提交：一个事务提交后，它做的变更才会被其他事务看到&lt;/li&gt;
&lt;li&gt;可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。&lt;/li&gt;
&lt;li&gt;串行化：后访问的事务必须等前一个事务完成后，才能继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设数据表T中只有一列，其中一行的值为1。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; create table T(c int) engine=InnoDB;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;insert into T(c) values(1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://m.qpic.cn/psb?/V140pON30woojR/N34*jAP61rjm0uHLDCigAi2GlkgbvdMqoW4J9gqGBok!/b/dL8AAAAAAAAA&amp;amp;bo=OAT.BAAAAAADB.Q!&amp;amp;rf=viewer_4&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="MySQL实战45讲" scheme="http://yoursite.com/tags/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>一条更新语句的执行过程</title>
    <link href="http://yoursite.com/2019/01/14/MySQL/%E4%B8%80%E4%B8%AA%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/01/14/MySQL/一个更新语句的执行过程/</id>
    <published>2019-01-14T14:32:26.000Z</published>
    <updated>2019-01-17T15:26:12.485Z</updated>
    
    <content type="html"><![CDATA[<p>下面我们以下面这个表和更新语句来进行分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table T(ID int primary key, c int);</span><br><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p><p>对于更新语句，查询语句的那一套流程，更新语句同样是会走一遍。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>如果每一次更新操作都要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新；整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL采用了WAL技术来提升更新效率。WAL的全称是write-Ahead Logging。它的关键点在于<font color="red">先写日志，再写磁盘</font>。</p><p>具体来说，就是当有一条记录需要更新的时候，innodb引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，innodb引擎会在适当的时候，将这个操作记录更新到次磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p>innodb的redo log是固定大小的，比如可以配置为一组4个文件，每个文件大小是1GB，那么redo log总共就可以记录4GB的操作，从头开始写，写到末尾就又回到开头循环写。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/cO8DivjlNOs4*4J.jc9sWkTtPIM5APzdpDE8aPjQews!/b/dLYAAAAAAAAA&amp;bo=hAUyAwAAAAADB5I!&amp;rf=viewer_4" alt=""><br><a id="more"></a><br>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间的部分是用来记录新的操作。如果write pos追上checkpoint，那么表示redo log写满了，得先停下来擦掉一些记录，把checkpoint推进一点后才能够继续写入。</p><p>有了redo log，innodb就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称作crash-safe。</p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>MySQL从整体来说，其实有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。redo log是innodb引擎特有的日志，Server层也有自己的日志，称为binlog（归档日志）<br>最开始MySQL里并没有innodb引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而innodb是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力，所以innodb使用另一套日志系统（redo log）来实现crash-safe能力。</p><p>redo log 和 binlog主要有以下三点不同:</p><ol><li>redo log是innodb引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。</li></ol><p>我们回过头来看执行器和innodb引擎在执行这个简单的update语句时的内部流程。</p><ol><li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎的给的行数据，把这个值加上1，等到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/7vc6Wi5rjgpfIRIhIttNcrFLh7FmB1heWy5NCCPr8to!/b/dFIBAAAAAAAA&amp;bo=OASgBQAAAAADB7s!&amp;rf=viewer_4" alt=""><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3>binlog会记录所有的逻辑操作，并且采用的是“追加写”的形式。当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，可以这样做：</li></ol><ul><li>首先找到最近一次的全年备份</li><li>然后从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li><li>将表数据从临时库中取出来，按需要恢复到线上库去。</li></ul><p>说完数据恢复过程，我们来说说为什么日志需要“两阶段提交”。<br>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，那么就是先写完redo log再写binlog或者放过来。</p><ol><li><b>先写redo log后写binlog</b>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过，redo log写完后，系统及时崩溃，仍然能够将数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写就crash了，这时候binlog是没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要这个binlog恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0。造成了数据不一致。（主从情况也是一样的）</li><li><b>先写binlog后写 redo log</b>。如果binlog写完后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binglog里面已经记录了“把c从0改成1”这个日子。所以binlog恢复后就多了一个事务。</li></ol><p>可以看到，如果不使用两阶段提交，那么数据库的状态与应用它日子的其他数据库数据不一致。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>redo log用来宝成crash-safe能力，innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都会直接持久化到磁盘。<br>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面我们以下面这个表和更新语句来进行分析：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;create table T(ID int primary key, c int);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;update T set c=c+1 where ID=2;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于更新语句，查询语句的那一套流程，更新语句同样是会走一遍。&lt;/p&gt;
&lt;h3 id=&quot;redo-log&quot;&gt;&lt;a href=&quot;#redo-log&quot; class=&quot;headerlink&quot; title=&quot;redo log&quot;&gt;&lt;/a&gt;redo log&lt;/h3&gt;&lt;p&gt;如果每一次更新操作都要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新；整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL采用了WAL技术来提升更新效率。WAL的全称是write-Ahead Logging。它的关键点在于&lt;font color=&quot;red&quot;&gt;先写日志，再写磁盘&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;具体来说，就是当有一条记录需要更新的时候，innodb引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，innodb引擎会在适当的时候，将这个操作记录更新到次磁盘里面，而这个更新往往是在系统比较空闲的时候做。&lt;/p&gt;
&lt;p&gt;innodb的redo log是固定大小的，比如可以配置为一组4个文件，每个文件大小是1GB，那么redo log总共就可以记录4GB的操作，从头开始写，写到末尾就又回到开头循环写。&lt;br&gt;&lt;img src=&quot;https://m.qpic.cn/psb?/V140pON30woojR/cO8DivjlNOs4*4J.jc9sWkTtPIM5APzdpDE8aPjQews!/b/dLYAAAAAAAAA&amp;amp;bo=hAUyAwAAAAADB5I!&amp;amp;rf=viewer_4&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="MySQL实战45讲" scheme="http://yoursite.com/tags/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/"/>
    
  </entry>
  
</feed>

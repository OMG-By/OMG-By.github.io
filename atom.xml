<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OMG_By</title>
  
  <subtitle>你走与不走，路就在那里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-14T12:54:31.143Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OMG_By</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis RDB文件存储格式</title>
    <link href="http://yoursite.com/2020/01/14/new/Redis-RDB%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/01/14/new/Redis-RDB文件存储格式/</id>
    <published>2020-01-14T12:13:30.000Z</published>
    <updated>2020-01-14T12:54:31.143Z</updated>
    
    <content type="html"><![CDATA[<p>Redis存在两种数据文件：RDB和AOF。<br>AOF文件的结构比较简单，就不做说明。主要是简介RDB数据文件的结构</p><p>*.rdb文件是表示Redis瞬间快照的一个二进制文件。根据这个快照文件，可以将Redis恢复到Redis当时的状态。<br>rdb文件针对读写进行了优化操作。尽可能的会使用LZF压缩算法来减少文件的大小。</p><p>在命令行下我们可以通过<code>od -x rdb.rdb | less</code>和<code>od -c rdb.rdb | less</code>命令查看16进制和字符模式下的rdb文件。<br>注意：使用<code>od -x</code>命令查出来的16进制是逆序的。</p><h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gan46keebgj30r806z3z8.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">----------------------------# RDB文件是二进制的，所以并不存在回车换行来分隔一行一行.</span><br><span class="line">52 45 44 49 53              # 以字符串 &quot;REDIS&quot; 开头</span><br><span class="line">30 30 30 36                 # RDB 的版本号，大端存储，比如左边这个表示版本号为0006</span><br><span class="line">----------------------------</span><br><span class="line">FE 00                       # FE = FE表示数据库编号，Redis支持多个库，以数字编号，这里00表示第0个数据库</span><br><span class="line">----------------------------# Key-Value 对存储开始了</span><br><span class="line">FD $length-encoding         # FD 表示过期时间，过期时间是用 length encoding 编码存储的，后面会讲到</span><br><span class="line">$value-type                 # 1 个字节用于表示value的类型，比如set,hash,list,zset等</span><br><span class="line">$string-encoded-key         # Key 值，通过string encoding 编码，同样后面会讲到</span><br><span class="line">$encoded-value              # Value值，根据不同的Value类型采用不同的编码方式</span><br><span class="line">----------------------------</span><br><span class="line">FC $length-encoding         # FC 表示毫秒级的过期时间，后面的具体时间用length encoding编码存储</span><br><span class="line">$value-type                 # 同上，也是一个字节的value类型</span><br><span class="line">$string-encoded-key         # 同样是以 string encoding 编码的 Key值</span><br><span class="line">$encoded-value              # 同样是以对应的数据类型编码的 Value 值</span><br><span class="line">----------------------------</span><br><span class="line">$value-type                 # 下面是没有过期时间设置的 Key-Value对，为防止冲突，数据类型不会以 FD, FC, FE, FF 开头</span><br><span class="line">$string-encoded-key</span><br><span class="line">$encoded-value</span><br><span class="line">----------------------------</span><br><span class="line">FE $length-encoding         # 下一个库开始，库的编号用 length encoding 编码</span><br><span class="line">----------------------------</span><br><span class="line">...                         # 继续存储这个数据库的 Key-Value 对</span><br><span class="line">FF                          ## FF：RDB文件结束的标志</span><br><span class="line">8 byte checksum             ## 8位校验码                  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">od -x rdb.rdb | head -n 10</span><br><span class="line">0000000 4552 4944 3053 3030 fe36 fc1e ae47 2160</span><br><span class="line">0000020 016e 0000 2800 6c65 7361 6974 5f63 3036</span><br><span class="line">0000040 3930 3562 6432 3139 3962 3233 3134 3138</span><br><span class="line">0000060 6338 3031 3338 6166 6233 3163 6264 5d4e</span><br><span class="line">0000100 8b1f 0008 0000 0000 ff00 9bcc 535b 595a</span><br><span class="line">0000120 c79b 66fb e7ae a42b 1db8 7585 7bde dea7</span><br><span class="line">0000140 a779 eb62 7264 3500 e931 2a1c 2165 116c</span><br><span class="line">0000160 6082 1838 27b5 1855 8b4d fb67 d18d 6344</span><br><span class="line">0000200 3a62 6231 51b7 6dd3 6247 bb50 9aac b9ab</span><br><span class="line">0000220 8f9c d610 7366 af95 b530 cd01 d906 8104</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">od -c rdb.rdb | head -n 10</span><br><span class="line">0000000   R   E   D   I   S   0   0   0   6 376 036 374   G 256   `   !</span><br><span class="line">0000020   n 001  \0  \0  \0   (   e   l   a   s   t   i   c   _   6   0</span><br><span class="line">0000040   0   9   b   5   2   d   9   1   b   9   3   2   4   1   8   1</span><br><span class="line">0000060   8   c   1   0   8   3   f   a   3   b   c   1   d   b   N   ]</span><br><span class="line">0000100 037 213  \b  \0  \0  \0  \0  \0  \0 377 314 233   [   S   Z   Y</span><br><span class="line">0000120 233 307 373   f 256 347   + 244 270 035 205   u 336   &#123; 247 336</span><br><span class="line">0000140   y 247   b 353   d   r  \0   5   1 351 034   *   e   !   l 021</span><br><span class="line">0000160 202   `   8 030 265   &apos;   U 030   M 213   g 373 215 321   D   c</span><br><span class="line">0000200   b   :   1   b 267   Q 323   m   G   b   P 273 254 232 253 271</span><br><span class="line">0000220 234 217 020 326   f   s 225 257   0 265 001 315 006 331 004 201</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>rdb文件固定以魔术字符串”REDIS”开头，表示这个rdb文件时Redis数据文件。<br><code>52 45 44 49 53 # &quot;REDIS&quot;</code></p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>接下来固定4个字节保存rdb格式的的版本号。<br><code>30 30 30 36 # Version = 6</code></p><h3 id="数据库编号"><a href="#数据库编号" class="headerlink" title="数据库编号"></a>数据库编号</h3><p>一个字节<code>0xfe</code>表示开始选择数据库；在这个字节之后，一个可变长度字段表示数据库编号。具体部分参考<b>长度编码</b>部分<br><code>1e</code>表示十进制的30，代表是30数据库</p><h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><p>在选择数据库后，就是具体的一些键值对记录。每个键值对包含4个部分</p><table><thead><tr><th>名称</th><th>大小</th><th>说明</th></tr></thead><tbody><tr><td>RDB_OPCODE_EXPIRETIME_MS</td><td>1byte</td><td>0xfc/0xfd(252/253)，说明是带过期时间的键值对</td></tr><tr><td>ms</td><td>8bytes</td><td>时间戳</td></tr><tr><td>TYPE</td><td>1byte</td><td>键值对类型</td></tr><tr><td>key</td><td>—-</td><td>键</td></tr><tr><td>value</td><td>—-</td><td>值</td></tr></tbody></table><h4 id="过期标记和过期时间戳"><a href="#过期标记和过期时间戳" class="headerlink" title="过期标记和过期时间戳"></a>过期标记和过期时间戳</h4><p>一个字节。<code>0xFD</code>表示过期时间戳以秒为单位，<code>0xFC</code>表示过期时间戳以毫秒为单位。<br>后面接下来使用<b>长度编码</b>的方式来表示一个时间戳</p><p>如果设置了过期时间，那么接下来的8个字节就表示具体的过期时间。<br>在导入RDB文件的时候，会将已经过期的key进行丢弃。</p><p>如果没有设置过期时间，则没有这两个字段。</p><h4 id="key类型"><a href="#key类型" class="headerlink" title="key类型"></a>key类型</h4><p>一个字节，表示保存键值对value的具体编码。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gan531wxo8j30ly0dqt9u.jpg" alt=""></p><ul><li>0表示是一个简单字符串</li><li>当值为9-13时，该值被包装到字符串中，读取字符串后，会对其进行进一步解析。</li><li>当值为1-4时，该值是一个字符串序列，此字符串序列用于构造列表、集合、集合或哈希表等复杂数据类型。</li></ul><h4 id="键值对-1"><a href="#键值对-1" class="headerlink" title="键值对"></a>键值对</h4><p>key固定为字符串编码保存。<br>value取决于编码，不同的编码有不同的保存格式。<br>后面会有详细介绍。</p><h2 id="长度编码"><a href="#长度编码" class="headerlink" title="长度编码"></a>长度编码</h2><p>长度编码用于存储下一个对象的长度，长度编码是一种可变长字节编码，目的在于使用更少的字节来表示内容。<br>从数据流中取出一个字节，可能存在以下几种情况：</p><ul><li>00：接下来6位表示长度</li><li>01：取出下一个字节，组合的14位表示长度</li><li>10：剩余6位舍弃，取出4个字节表示长度</li><li>11：表示下一个对象以特殊格式编码。其余6位表示格式。</li></ul><p>好处：<br>63的数字只需要一个字节进行存储<br>64 – 16383 的数字只需要两个字节进行存储<br>16383 - 2^32 -1 的数字只需要用5个字节（1个字节的标识加4个字节的值）进行存储</p><h2 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h2><p>Redis字符串是二进制安全的，这意味着可以在其中存储任何内容。它没有任何特殊的字符串结尾标记。最好将Redis字符串视为字节数组。</p><p>在RDB文件中有三种类型的字符串：</p><ol><li>简单字符串</li><li>8、16、32位的整数</li><li>一个经过LZF压缩的支付串</li></ol><h3 id="简单字符串"><a href="#简单字符串" class="headerlink" title="简单字符串"></a>简单字符串</h3><p>简单字符串编码非常简单，就是 字符串长度+具体的字符串<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ganb8w8bbzj31is03g74g.jpg" alt=""></p><h3 id="整数字符串"><a href="#整数字符串" class="headerlink" title="整数字符串"></a>整数字符串</h3><p>在长度编码为<code>11</code>的时候，读取后续的6位。如果后续的6位为：</p><ul><li>0表示跟随的是8位整数</li><li>1表示跟随的是16位整数</li><li>2表示跟随的是32位整数</li></ul><h3 id="压缩字符串"><a href="#压缩字符串" class="headerlink" title="压缩字符串"></a>压缩字符串</h3><p>TODO 疑问一：到底是3还是4<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ganbdubpn0j31i603mwey.jpg" alt=""><br>在长度编码为<code>11</code>的时候，读取后续的6位。如果后续的6位为<code>4</code>表示后面跟随着的是压缩字符串。具体步骤为下：</p><ol><li>使用长度编码方式从c_len中读取出压缩的长度</li><li>使用长度编码方式从o_len中读取出压缩前的长度</li><li>读取出压缩后的字符串</li><li>使用LZF算法解压缩</li></ol><h2 id="CRC校验和"><a href="#CRC校验和" class="headerlink" title="CRC校验和"></a>CRC校验和</h2><p>从Redis5开始启动参数控制是否将8字节的校验和添加到文件末尾，可以通过修改参数关闭该功能。<br>当禁用校验和的时候，此字段为0</p><blockquote><p><a href="https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_File_Format.textile" target="_blank" rel="noopener">https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_File_Format.textile</a><br><a href="https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_Version_History.textile" target="_blank" rel="noopener">https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_Version_History.textile</a><br><a href="https://blog.csdn.net/guiqulaxi920/article/details/51177307" target="_blank" rel="noopener">https://blog.csdn.net/guiqulaxi920/article/details/51177307</a><br><a href="http://ascii.911cha.com/" target="_blank" rel="noopener">http://ascii.911cha.com/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis存在两种数据文件：RDB和AOF。&lt;br&gt;AOF文件的结构比较简单，就不做说明。主要是简介RDB数据文件的结构&lt;/p&gt;
&lt;p&gt;*.rdb文件是表示Redis瞬间快照的一个二进制文件。根据这个快照文件，可以将Redis恢复到Redis当时的状态。&lt;br&gt;rdb文件针对读写进行了优化操作。尽可能的会使用LZF压缩算法来减少文件的大小。&lt;/p&gt;
&lt;p&gt;在命令行下我们可以通过&lt;code&gt;od -x rdb.rdb | less&lt;/code&gt;和&lt;code&gt;od -c rdb.rdb | less&lt;/code&gt;命令查看16进制和字符模式下的rdb文件。&lt;br&gt;注意：使用&lt;code&gt;od -x&lt;/code&gt;命令查出来的16进制是逆序的。&lt;/p&gt;
&lt;h2 id=&quot;RDB文件结构&quot;&gt;&lt;a href=&quot;#RDB文件结构&quot; class=&quot;headerlink&quot; title=&quot;RDB文件结构&quot;&gt;&lt;/a&gt;RDB文件结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gan46keebgj30r806z3z8.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;----------------------------# RDB文件是二进制的，所以并不存在回车换行来分隔一行一行.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52 45 44 49 53              # 以字符串 &amp;quot;REDIS&amp;quot; 开头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30 30 30 36                 # RDB 的版本号，大端存储，比如左边这个表示版本号为0006&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FE 00                       # FE = FE表示数据库编号，Redis支持多个库，以数字编号，这里00表示第0个数据库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------# Key-Value 对存储开始了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FD $length-encoding         # FD 表示过期时间，过期时间是用 length encoding 编码存储的，后面会讲到&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$value-type                 # 1 个字节用于表示value的类型，比如set,hash,list,zset等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$string-encoded-key         # Key 值，通过string encoding 编码，同样后面会讲到&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$encoded-value              # Value值，根据不同的Value类型采用不同的编码方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FC $length-encoding         # FC 表示毫秒级的过期时间，后面的具体时间用length encoding编码存储&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$value-type                 # 同上，也是一个字节的value类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$string-encoded-key         # 同样是以 string encoding 编码的 Key值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$encoded-value              # 同样是以对应的数据类型编码的 Value 值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$value-type                 # 下面是没有过期时间设置的 Key-Value对，为防止冲突，数据类型不会以 FD, FC, FE, FF 开头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$string-encoded-key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$encoded-value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FE $length-encoding         # 下一个库开始，库的编号用 length encoding 编码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...                         # 继续存储这个数据库的 Key-Value 对&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FF                          ## FF：RDB文件结束的标志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8 byte checksum             ## 8位校验码                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;od -x rdb.rdb | head -n 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000000 4552 4944 3053 3030 fe36 fc1e ae47 2160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000020 016e 0000 2800 6c65 7361 6974 5f63 3036&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000040 3930 3562 6432 3139 3962 3233 3134 3138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000060 6338 3031 3338 6166 6233 3163 6264 5d4e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000100 8b1f 0008 0000 0000 ff00 9bcc 535b 595a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000120 c79b 66fb e7ae a42b 1db8 7585 7bde dea7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000140 a779 eb62 7264 3500 e931 2a1c 2165 116c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000160 6082 1838 27b5 1855 8b4d fb67 d18d 6344&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000200 3a62 6231 51b7 6dd3 6247 bb50 9aac b9ab&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000220 8f9c d610 7366 af95 b530 cd01 d906 8104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;od -c rdb.rdb | head -n 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000000   R   E   D   I   S   0   0   0   6 376 036 374   G 256   `   !&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000020   n 001  \0  \0  \0   (   e   l   a   s   t   i   c   _   6   0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000040   0   9   b   5   2   d   9   1   b   9   3   2   4   1   8   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000060   8   c   1   0   8   3   f   a   3   b   c   1   d   b   N   ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000100 037 213  \b  \0  \0  \0  \0  \0  \0 377 314 233   [   S   Z   Y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000120 233 307 373   f 256 347   + 244 270 035 205   u 336   &amp;#123; 247 336&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000140   y 247   b 353   d   r  \0   5   1 351 034   *   e   !   l 021&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000160 202   `   8 030 265   &amp;apos;   U 030   M 213   g 373 215 321   D   c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000200   b   :   1   b 267   Q 323   m   G   b   P 273 254 232 253 271&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0000220 234 217 020 326   f   s 225 257   0 265 001 315 006 331 004 201&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>pika学习之同步篇</title>
    <link href="http://yoursite.com/2020/01/05/new/pika/pika%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/01/05/new/pika/pika复制模块/</id>
    <published>2020-01-05T14:08:29.000Z</published>
    <updated>2020-01-05T14:11:12.720Z</updated>
    
    <content type="html"><![CDATA[<ul><li>pika支持m-s的复制方式，跟redis主从复制命令一样，通过slave执行slaveof命令来触发。</li><li>slave的trysync线程向master发起trysync，同时将同步位点信息发送给master</li><li>master处理trysync命令，发起对slave的同步过程，从同步点开始顺序发送binlog或进行全同步</li></ul><h1 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h1><p>pika在需要进行全量同步的时候，会将数据文件进行dump后通过rsync的deamon模式发送给slave。</p><h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><ol><li>slave在trysnc前启动rsync进程启动rsync服务</li><li>master发现需要全同步时，判断是否有备份文件可用，如果没有先dump一份</li><li>master通过rsync向slave发送dump出的文件</li><li>slave用收到的文件替换自己的db</li><li>slave用最新的偏移量再次发起trysnc</li><li>完成同步 </li></ol><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0g8e1iij30oq09q0th.jpg" alt=""></p><center>slave同步流程</center><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0gae0huj30me08qt99.jpg" alt=""></p><center>master同步流程</center><a id="more"></a><p>slave连接状态：</p><ul><li>No Connect：不尝试成为任何其他节点的slave</li><li>Connect：Slaveof后尝试成为某个节点的slave，发送trysnc命令和同步点</li><li>Connecting：收到master回复可以slaveof，尝试跟master建立心跳</li><li>Connected: 心跳建立成功</li><li>WaitSync：不断检测是否DBSync完成，完成后更新DB并发起新的slaveof<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0h9q8ulj30hn0dr0tm.jpg" alt=""></li></ul><h1 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h1><p>Pika的主从同步是通过Binlog来完成的，在一主多从的结构中，master节点也可以给多个slave复用一个Binlog，不同的slave拥有不同的偏移量。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><ol><li>当WorkerThread接收到客户端的命令，按照执行顺序，添加到Binlog里</li><li>BinglogSenderThread判断它所负责的从节点在主节点的Binlog里是否有需要同步的命令，若有则发送给从节点</li><li>BinglogReceiverModule模块则做以下三件事情：接收主节点的BinlogSenderThread发送过来的同步命令；把接收到的命令应用到本地的数据上；把接收到的命令添加到本地Binlog里 至此，一条命令从主节点到从节点的同步过程完成<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0spmbugj30i20en75l.jpg" alt=""></li></ol><ul><li>WorkerThread：接受和处理用户的命令</li><li>BinlogSenderThread：负责顺序地向对应的从节点发送在需要同步的命令</li><li>BinlogReceiverModule: 负责接受主节点发送过来的同步命令</li><li>Binglog：用于顺序的记录需要同步的命令</li></ul><p>上图中的<code>BinLogReceiverModule</code>是为了更好的说明方便而抽象出来的一个对象，从图中可以看出<code>BinLogReceiverModule</code>是由一个<code>BinlogReceiverThread</code>和多个<code>BinlogBGWorker</code>组成。</p><ul><li>BinlogReceiverThread: 负责接受由主节点传送过来的命令，并分发给各个BinlogBGWorker，若当前的节点是只读状态（不能接受客户端的同步命令），则在这个阶段写Binlog</li><li>BinlogBGWorker：负责执行同步命令；若该节点不是只读状态（还能接受客户端的同步命令），则在这个阶段写Binlog（在命令执行之前写）</li></ul><p>BinlogReceiverThread接收到一个同步命令后，它会给这个命令赋予一个唯一的序列号（这个序列号是递增的），并把它分发给一个BinlogBGWorker；而各个BinlogBGWorker则会根据各个命令的所对应的序列号的顺序来执行各个命令，这样也就保证了命令执行的顺序和主节点执行的顺序一致了 之所以这么设计主要原因是：</p><ol><li>配备多个BinlogBGWorker是可以提高主从同步的效率，减少主从同步的滞后延迟</li><li>BinlogBGWorker在执行执行之前写Binlog可以提高命令执行的并行度</li><li>在当前节点是非只读状态，让BinglogReceiverThread来写Binlog，是为了让Binglog里保存的命令顺序和命令的执行顺序保持一致</li></ol><h2 id="Binlog结构"><a href="#Binlog结构" class="headerlink" title="Binlog结构"></a>Binlog结构</h2><p>由于主从偏移量一样，所以一旦发生网络或节点故障需要重连主从时，slave只需要将当前的偏移量发送给master，master找到后从该偏移量开始同步后续命令。<br>理论上命令不做处理一条一条追加到Binlog文件中，这也就意味着如果文件写错一个字节就会导致整个文件不可用，所以pika采用了类似leveldb log的格式来进行存储。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0rxhp2rj30i20att9m.jpg" alt=""></p><h3 id="leveldb-log"><a href="#leveldb-log" class="headerlink" title="leveldb log"></a>leveldb log</h3><p>在leveldb中，所有的写操作都必须先成功的append到操作日志中，然后再更新内存memtable</p><ol><li>可以将随机的写IO变成append，极大的提高写磁盘速度</li><li>防止在节点down机导致内存数据丢失，造成数据丢失<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">The log file contents are a sequence of 32KB blocks.  The only</span><br><span class="line">exception is that the tail of the file may contain a partial block.</span><br><span class="line"></span><br><span class="line">Each block consists of a sequence of records:</span><br><span class="line">   block := record* trailer?</span><br><span class="line">   record :=</span><br><span class="line">    checksum: uint32    // crc32c of type and data[] ; little-endian</span><br><span class="line">    length: uint16      // little-endian</span><br><span class="line">    type: uint8     // One of FULL, FIRST, MIDDLE, LAST</span><br><span class="line">    data: uint8[length]</span><br><span class="line"></span><br><span class="line">A record never starts within the last six bytes of a block (since it</span><br><span class="line">won&apos;t fit).  Any leftover bytes here form the trailer, which must</span><br><span class="line">consist entirely of zero bytes and must be skipped by readers.</span><br></pre></td></tr></table></figure></li></ol><p>日志文件由连续的大小为32KB的block组成，block又由连续的record组成，record的格式为 | CRC(4 byte) | Length(2 byte) | type(1 byte) | data |</p><blockquote><p><a href="https://www.jianshu.com/p/223f0c73ddc2" target="_blank" rel="noopener">LevelDB 功能与架构</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;pika支持m-s的复制方式，跟redis主从复制命令一样，通过slave执行slaveof命令来触发。&lt;/li&gt;
&lt;li&gt;slave的trysync线程向master发起trysync，同时将同步位点信息发送给master&lt;/li&gt;
&lt;li&gt;master处理trysync命令，发起对slave的同步过程，从同步点开始顺序发送binlog或进行全同步&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;全量同步&quot;&gt;&lt;a href=&quot;#全量同步&quot; class=&quot;headerlink&quot; title=&quot;全量同步&quot;&gt;&lt;/a&gt;全量同步&lt;/h1&gt;&lt;p&gt;pika在需要进行全量同步的时候，会将数据文件进行dump后通过rsync的deamon模式发送给slave。&lt;/p&gt;
&lt;h2 id=&quot;实现逻辑&quot;&gt;&lt;a href=&quot;#实现逻辑&quot; class=&quot;headerlink&quot; title=&quot;实现逻辑&quot;&gt;&lt;/a&gt;实现逻辑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;slave在trysnc前启动rsync进程启动rsync服务&lt;/li&gt;
&lt;li&gt;master发现需要全同步时，判断是否有备份文件可用，如果没有先dump一份&lt;/li&gt;
&lt;li&gt;master通过rsync向slave发送dump出的文件&lt;/li&gt;
&lt;li&gt;slave用收到的文件替换自己的db&lt;/li&gt;
&lt;li&gt;slave用最新的偏移量再次发起trysnc&lt;/li&gt;
&lt;li&gt;完成同步 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gam0g8e1iij30oq09q0th.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;slave同步流程&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gam0gae0huj30me08qt99.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;master同步流程&lt;/center&gt;
    
    </summary>
    
      <category term="Pika" scheme="http://yoursite.com/categories/Pika/"/>
    
    
      <category term="Pika" scheme="http://yoursite.com/tags/Pika/"/>
    
  </entry>
  
  <entry>
    <title>何为IO多路复用</title>
    <link href="http://yoursite.com/2020/01/05/new/%E4%BD%95%E4%B8%BAIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://yoursite.com/2020/01/05/new/何为IO多路复用/</id>
    <published>2020-01-05T08:29:22.000Z</published>
    <updated>2020-01-05T08:32:32.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络编程概念"><a href="#网络编程概念" class="headerlink" title="网络编程概念"></a>网络编程概念</h2><p>在网络当中，数据的传输是基于HTTP/TCP协议簇来实现的。TCP协议仅仅是把这些数据看做是一串二进制流来进行处理。<br>所以：<b>客户端和服务器是通过在建立的连接上发送字节流来进行通信</b></p><p>一个连接由它两端的套接字地址唯一确定，结构为<code>(客户端地址:客户端端口号，服务端地址:服务端端口号)</code>。有了通信双方的连接地址信息后，就可以进行数据传输了。</p><p>在Unix系统中，实现了一套套接字接口来描述和规范双方通信的整个过程。<br>创建-&gt;连接-&gt;绑定-&gt;监听-&gt;响应<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1galrpl667mj30hs0dzwfp.jpg" alt=""></p><blockquote><ul><li>socket()：创建一个套接字描述符</li><li>connect()：客户端通过调用connect函数来建立和服务器的连接</li><li>bind()：告诉内核将socket()创建的套接字与某个服务端地址与端口连接起来，后续会对这个地址和端口进行监听</li><li>listen()：告诉内核，将这个套接字当成服务器这种被动实体来看待(服务器是等待客户端连接的被动实体，而内核认为socket()创建的套接字默认是主动实体，所以才需要listen()函数，告诉内核进行主动到被动实体的转换)</li><li>accept()：等待客户端的连接请求并返回一个新的已连接描述符</li></ul></blockquote><a id="more"></a><h2 id="最简单的单进程服务器"><a href="#最简单的单进程服务器" class="headerlink" title="最简单的单进程服务器"></a>最简单的单进程服务器</h2><p>由于Unix的历史遗留问题，原始的套接字接口对地址和端口等数据封装并不简洁。<br>在最初的服务器中，一个服务器进程只能同时处理一个客户端连接与相关的读写操作。<br>在读写的过程中，整个进程被该客户端独占，当前服务器进程只能处理该客户端连接的读写操作，无法对其他客户端连接请求进行处理。</p><h2 id="IO并发提升"><a href="#IO并发提升" class="headerlink" title="IO并发提升"></a>IO并发提升</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>如果去优化单进程？<br>一个进程不行，那就搞多个进程来同时处理不就得了。</p><p>由于一个客户端的connect对应着一个服务端的accept，那么每次客户端过来时，都使用fork()来进行accept的系统调用。</p><p>缺点：</p><ul><li>进程创建的数量随连接请求的增加而增加。</li><li>fork等系统调用会使得进程的上下文进行切换，效率很低。</li><li>进程与进程之间的地址空间私有。使得进程之间的数据共享比较困难。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>线程是运行在进程上下文的逻辑流。一个进程可以包含多个线程，多个线程运行在单一的进程上下文中，因此共享这个进程的地址空间的所有内容，解决了进程与进程之间通信难的问题。同时，由于一个线程的上下文要比一个进程的上下文小得多，所以线程的上下文切换，要比进程的上下文切换效率高得多。线程是轻量级的进程，解决了进程上下文切换效率低的问题。</p><h3 id="基于单进程的IO多路复用"><a href="#基于单进程的IO多路复用" class="headerlink" title="基于单进程的IO多路复用"></a>基于单进程的IO多路复用</h3><p>前面谈到的都是通过增加进程和线程的数量来同时处理多个套接字。而IO多路复用只需要一个进程就能够处理多个套接字。</p><p>其本质是：<b>一个服务端进程可以同时处理多个套接字描述符</b></p><p>在之前的讲述中，一个服务端进程，只能同时处理一个连接。如果想同时处理多个客户端连接，需要多进程或者多线程的帮助，免不了上下文切换的开销。IO多路复用技术就解决了上下文切换的问题。IO多路复用技术的发展可以分为select-&gt;poll-&gt;epoll三个阶段。</p><p>IO多路复用的核心就是添加了一个<b>套接字集合管理员</b>，它可以同时监听多个套接字。由于客户端连接以及读写事件到来的随机性，我们需要这个管理员在单进程内部对多个套接字的事件进行合理的调度。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select()函数会在某个或某些套接字的状态从不可读变为可读、或不可写变为可写的时候通知服务器主进程。所以select()本身的调用是阻塞的。但是具体哪一个套接字或哪些套接字变为可读或可写我们是不知道的，所以我们需要遍历所有select()返回的套接字来判断哪些套接字可以进行处理了。</p><p>但是，select()函数本身的调用阻塞的。因为select()需要一直等到有状态变化的套接字之后（比如监听套接字或者连接套接字的状态由不可读变为可读），才能解除select()本身的阻塞，继续对读写就绪的套接字进行处理。虽然这里是阻塞的，但是它能够同时返回多个就绪的套接字，而不是之前单进程中只能够处理一个套接字，大大提升了效率</p><p>优点：</p><ul><li>实现了对多个套接字的同时、集中管理</li><li>通过遍历所有的套接字集合，能够获取所有已就绪的套接字，对这些就绪的套接字进行操作不会阻塞</li></ul><p>缺点：</p><ul><li>select管理的套接字描述符们存在数量限制。在Unix中，一个进程最多同时监听1024个套接字描述符</li><li>select返回的时候，并不知道具体是哪个套接字描述符已经就绪，所以需要遍历所有套接字来判断哪个已经就绪，可以继续进行读写</li></ul><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><b>poll解决了select带来的套接字描述符的最大数量限制问题</b></p><p>poll的fds参数集合了select的read、write和exception套接字数组，合三为一。poll中的fds没有了1024个的数量限制。当有些描述符状态发生变化并就绪之后，poll同select一样会返回。但是遗憾的是，我们同样不知道具体是哪个或哪些套接字已经就绪，我们仍需要遍历套接字集合去判断究竟是哪个套接字已经就绪，这一点并没有解决刚才提到select的第二个问题。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是最先进的套接字管理员，解决了上述select和poll中所存在的问题。它将一个阻塞的select、poll系统调用拆分成了三个步骤。一次select或poll可以看作是由一次 epoll_create、若干次 epoll_ctl、若干次 epoll_wait构成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure></p><ul><li>epoll_create()：创建一个epoll实例。后续操作会使用</li><li>epoll_ctl()：对套接字描述符集合进行增删改操作，并告诉内核需要监听套接字描述符的什么事件</li><li>epoll_wait()：等待监听列表中的连接事件（监听套接字描述符才会发生）或读写事件（连接套接字描述符才会发生）。如果有某个或某些套接字事件已经准备就绪，就会返回这些已就绪的套接字们</li></ul><p>我们调用epoll_wait()等待连接或读写等事件，在某个套接字描述符上准备就绪。当有事件准备就绪之后，会存到第二个参数epoll_event结构体中。通过访问这个结构体就可以得到所有已经准备好事件的套接字描述符。这里就不用再像之前select和poll那样，遍历所有的套接字描述符之后才能知道究竟是哪个描述符已经准备就绪了，这样减少了一次O(n)的遍历，大大提高了效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;网络编程概念&quot;&gt;&lt;a href=&quot;#网络编程概念&quot; class=&quot;headerlink&quot; title=&quot;网络编程概念&quot;&gt;&lt;/a&gt;网络编程概念&lt;/h2&gt;&lt;p&gt;在网络当中，数据的传输是基于HTTP/TCP协议簇来实现的。TCP协议仅仅是把这些数据看做是一串二进制流来进行处理。&lt;br&gt;所以：&lt;b&gt;客户端和服务器是通过在建立的连接上发送字节流来进行通信&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;一个连接由它两端的套接字地址唯一确定，结构为&lt;code&gt;(客户端地址:客户端端口号，服务端地址:服务端端口号)&lt;/code&gt;。有了通信双方的连接地址信息后，就可以进行数据传输了。&lt;/p&gt;
&lt;p&gt;在Unix系统中，实现了一套套接字接口来描述和规范双方通信的整个过程。&lt;br&gt;创建-&amp;gt;连接-&amp;gt;绑定-&amp;gt;监听-&amp;gt;响应&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1galrpl667mj30hs0dzwfp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;socket()：创建一个套接字描述符&lt;/li&gt;
&lt;li&gt;connect()：客户端通过调用connect函数来建立和服务器的连接&lt;/li&gt;
&lt;li&gt;bind()：告诉内核将socket()创建的套接字与某个服务端地址与端口连接起来，后续会对这个地址和端口进行监听&lt;/li&gt;
&lt;li&gt;listen()：告诉内核，将这个套接字当成服务器这种被动实体来看待(服务器是等待客户端连接的被动实体，而内核认为socket()创建的套接字默认是主动实体，所以才需要listen()函数，告诉内核进行主动到被动实体的转换)&lt;/li&gt;
&lt;li&gt;accept()：等待客户端的连接请求并返回一个新的已连接描述符&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>提问的智慧</title>
    <link href="http://yoursite.com/2020/01/05/new/other/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/"/>
    <id>http://yoursite.com/2020/01/05/new/other/提问的智慧/</id>
    <published>2020-01-05T05:40:58.000Z</published>
    <updated>2020-01-05T05:46:49.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在你提问之前"><a href="#在你提问之前" class="headerlink" title="在你提问之前"></a>在你提问之前</h1><ul><li>尝试在你准备提问的论坛的旧文章中搜索答案</li><li>尝试上网搜索以找到答案</li><li>尝试阅读手册以找到答案</li><li>尝试阅读常见问题文件（FAQ）以找到答案</li><li>尝试自己检查或试验以找到答案</li><li>向你身边的强者朋友打听以找到答案</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案</li></ul><h1 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h1><ul><li>慎选提问的论坛</li><li>Stack Overflow</li><li>网站和 IRC 论坛</li><li>第二步，使用项目邮件列表</li><li>使用有意义且描述明确的标题</li><li>使问题容易回复</li><li>用清晰、正确、精准并合法语法的语句</li><li>使用易于读取且标准的文件格式发送问题</li><li>精确地描述问题并言之有物</li><li>话不在多而在精</li><li>别动辄声称找到 Bug</li><li>低声下气不能代替你的功课</li><li>描述问题症状而非你的猜测</li><li>按发生时间先后列出问题症状</li><li>描述目标而不是过程</li><li>别要求使用私人电邮回复</li><li>清楚明确的表达你的问题以及需求</li><li>询问有关代码的问题时</li><li>别把自己家庭作业的问题贴上来</li><li>去掉无意义的提问句</li><li>即使你很急也不要在标题写紧急</li><li>礼多人不怪，而且有时还很有帮助</li><li>问题解决后，加个简短的补充说明</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1galmxel3nqj30u00vk43j.jpg" alt=""></p><blockquote><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener">原文地址</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在你提问之前&quot;&gt;&lt;a href=&quot;#在你提问之前&quot; class=&quot;headerlink&quot; title=&quot;在你提问之前&quot;&gt;&lt;/a&gt;在你提问之前&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;尝试在你准备提问的论坛的旧文章中搜索答案&lt;/li&gt;
&lt;li&gt;尝试上网搜索以找到答案&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="生活杂记" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>听《工作三年我学到了什么》总结</title>
    <link href="http://yoursite.com/2020/01/05/new/other/%E5%90%AC%E3%80%8A%E5%B7%A5%E4%BD%9C%E4%B8%89%E5%B9%B4%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E3%80%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/05/new/other/听《工作三年我学到了什么》总结/</id>
    <published>2020-01-04T16:53:03.000Z</published>
    <updated>2020-01-04T16:54:59.543Z</updated>
    
    <content type="html"><![CDATA[<p>最近听到一篇文章，觉得其中很多的点给了我很多收获。所以反复听了很多遍，并做了大概的总结。关键词：沟通、尝试、上升、思考、落地。</p><ul><li>不要把自己局限于某一个位置，试着多尝试不同的东西，“管理”好自己,“管理”好身边的人。</li><li>你的技术能力决定了你能多快去完成目标。而你的非技术能力决定了你在朝哪个方向努力。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakzw4xmkcj30u00ubn5h.jpg" alt=""></p><a id="more"></a><p>总的来说，就是站在不同角色的角度来看待事情，思他人之所思。(领导、依赖人、客户、被求助者、被依赖人)</p><h2 id="向上管理"><a href="#向上管理" class="headerlink" title="向上管理"></a>向上管理</h2><p>在工作当中，我们经常都是领导分配什么任务，我们就去努力完成任务。<br>而没有去思考这个任务到底能不能胜任，有没有更适合去做这个任务的人，以及更适合自己的任务却被分配给了其他的人。<br><b>领导是一个统筹管理的角色</b>，他大多时候只会关注总体任务是否完成。而没在意谁完成，怎么完成。</p><p><font color="red">我们应该站在领导的角度上去思考整个项目任务</font>当我们遇到不合理任务时，及时表达自己的想法和看法，看是否存在更好解决方案。<br>一个适合自己的任务，不仅能够节省大量完成任务的时间，还能保证完成的质量。</p><p>当然，在更多时候人手并不是很充足，所以并不是说一味的去拒绝任务；完成任务仍然是第一优先级，只有在完成任务的基础上，才能去发表和实现自己的想法。</p><h2 id="沟通先行"><a href="#沟通先行" class="headerlink" title="沟通先行"></a>沟通先行</h2><p>在整个项目流程当中，我们会遇到很多依赖别人的点。我们尽量在到达这个点之间就提前跟相关依赖人沟通，确定资源，而不是在需要的时候才去申请资源。</p><h2 id="高效会议"><a href="#高效会议" class="headerlink" title="高效会议"></a>高效会议</h2><p>在参加会议前，我们需要明确自己在其中的角色、需要了解、表达的东西。明确需要沟通的相关人员及其负责部分。<br>在会议当中，我们需要准确的提出自己的问题以及看法，避免形成沟通黑洞。<br>会议之后，需要及时记录会议记录，避免忘记。不同紧急程度的任务可以采用不同的方式去联系相关人员。</p><h2 id="上升意识"><a href="#上升意识" class="headerlink" title="上升意识"></a>上升意识</h2><p>不要将自己的角色给限制死，需要时常的跳出去，从不同的维度发展自己。不断的去尝试边界，并尝试突破。<br>主动的去发现项目的风险点、改进点。多从其他人手中争取锻炼自己的机会。</p><blockquote><p><a href="https://pythonhunter.org/episodes/sp02" target="_blank" rel="noopener">原文：https://pythonhunter.org/episodes/sp02</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近听到一篇文章，觉得其中很多的点给了我很多收获。所以反复听了很多遍，并做了大概的总结。关键词：沟通、尝试、上升、思考、落地。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要把自己局限于某一个位置，试着多尝试不同的东西，“管理”好自己,“管理”好身边的人。&lt;/li&gt;
&lt;li&gt;你的技术能力决定了你能多快去完成目标。而你的非技术能力决定了你在朝哪个方向努力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gakzw4xmkcj30u00ubn5h.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活杂记" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JB全家桶激活教程</title>
    <link href="http://yoursite.com/2020/01/04/new/other/JB%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/01/04/new/other/JB全家桶激活教程/</id>
    <published>2020-01-04T04:31:38.000Z</published>
    <updated>2020-01-04T04:32:26.238Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本教程适用于jetbrains全家桶开发工具（Pycharm、Idea、WebStorm、phpstorm、CLion、RubyMine、AppCode、DataGrid）</li><li>本教程适用于所有版本</li><li>软件直接从官网下载即可</li><li>不需要修改host</li></ul><h2 id="激活教程"><a href="#激活教程" class="headerlink" title="激活教程"></a>激活教程</h2><h3 id="1-下载破解补丁"><a href="#1-下载破解补丁" class="headerlink" title="1. 下载破解补丁"></a>1. 下载破解补丁</h3><p>下载补丁文件：<a href="https://pan.baidu.com/s/1Kc-byjcH_pvrN4CTgfKSFA" target="_blank" rel="noopener">jetbrains-agent.jar</a><br>文件保存位置可以任意，建议放置到软件安装路径的bin目录下。避免误删文件。</p><a id="more"></a><h3 id="2-点击试用"><a href="#2-点击试用" class="headerlink" title="2. 点击试用"></a>2. 点击试用</h3><p>如果你是刚下载的IDEA，则需要点击激活窗口的“Evaluate for free”免费试用，然后再创建一个空项目，这样就可以进入到IDEA的工作页面<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaketkrmc0j30su0aigmp.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeuydlulj30zw0u0ahk.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakev1f4tcj314a0qojty.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakev6d8cxj314a0qo0ux.jpg" alt=""></p><h3 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3. 修改配置文件"></a>3. 修改配置文件</h3><p><font color="red"> 配置文件修改已经不在bin目录下直接修改，而是通过IDEA修改</font><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakexpa10mj31100qs0uc.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakextkszmj31c60u0jvx.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakexxczvlj31c60u076b.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeyew4ilj31c60u0tb5.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeyicahmj31hc0sktcn.jpg" alt=""></p><p>进入到项目界面后，点击IDEA最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options …”<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeyw6muqj31gf0u0n2b.jpg" alt=""></p><p>如果提示是否要创建文件，请点”Yes”。</p><p>在打开的vmoptions编辑窗口末行添加：<font color="red"> -javaagent:你IDEA的安装目录\jetbrains-agent.jar</font> 请仔细检查补丁路径是否正确，如果错误则会出现IDEA打不开的情况。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakezxp1tij31hc0tsq8e.jpg" alt=""><br><b>修改完配置文件之后切记重启IDEA软件</b></p><p>如果修改完打不开软件，或者提示没有jdk等问题，这时候可以删除用户目录下的IDEA文件夹，注意这个文件夹是隐藏目录！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windwos：C:\Users\用户名\</span><br><span class="line">macos：~/Library/Preferences/</span><br><span class="line">ubuntu：~/.</span><br></pre></td></tr></table></figure></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf0tyctij31gd0u046p.jpg" alt=""></p><h3 id="4-输入激活码"><a href="#4-输入激活码" class="headerlink" title="4. 输入激活码"></a>4. 输入激活码</h3><p>修改完配置文件之后重启IDEA，点击菜单栏中的 “Help” -&gt; “Register …”<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf1mhjaaj31ga0u0jyg.jpg" alt=""></p><p>选择最后一种License server激活方式，地址填入：<a href="http://jetbrains-license-server" target="_blank" rel="noopener">http://jetbrains-license-server</a> （应该会自动填上），或者点击按钮：”Discover Server”来自动填充地址，完成激活。</p><p>注意：服务器激活需要联网！<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf2mn7tdj31hc0tr438.jpg" alt=""></p><p>如果服务器激活方式无法激活，还可以选择Activation code方式激活，复制下面激活码即可<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf3hatfwj314a0qogrb.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JQE11SV0BR-eyJsaWNlbnNlSWQiOiJKUUUxMVNWMEJSIiwibGljZW5zZWVOYW1lIjoicGlnNiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-khgsQrnDiglknF0m+yyoYGJXX4vFE3IIVaoMd0bkpfAlMiYM4FUK1JM7uMnVSN0NBC7qtZjYlNzPscEyKE8634uGuY/uToFQnIOCtyUfBxB6j0wF/DcCjhKMNDbnJ1RKZ2VaALuC9B6d6lhtEKm9+urXWTBq7h2VfIBv5wk1Ul9T/m9Dwkz/LccTqnxO0PP288fF13ZbmcLI1/D0dqp/QxYshW6CLR+2Tvk6QCPoaOTKDU/eL1AssD7/mO1g2ZJA+k//8qfRMLgdLmLrMdyiaIhrsM/jJk2qDfTaMcCNylkWXLgKwSvEQG95IhitLN9+GQ4pBW3gOTNl82Gem7jEkA==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure></p><h3 id="5-查看有效期"><a href="#5-查看有效期" class="headerlink" title="5. 查看有效期"></a>5. 查看有效期</h3><p>当你激活完毕后，IDEA右下角会有个Registration小长条提示框，大致的内容为：You copy is Licensed to XXX意思就会告诉你：兄弟，你已经激活成功了，激活码的许可来源是：XXX。<br>查看有效期的步骤为点击：Help-&gt;About这里可以看到你的IDEA的版本号、许可来源、有效期、以及一些环境<br>服务器激活是没有期限的，即为永久有效<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf4dn7abj31hc0th44m.jpg" alt=""></p><blockquote><p>资源来源：<br><a href="https://zhile.io/" target="_blank" rel="noopener">https://zhile.io/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本教程适用于jetbrains全家桶开发工具（Pycharm、Idea、WebStorm、phpstorm、CLion、RubyMine、AppCode、DataGrid）&lt;/li&gt;
&lt;li&gt;本教程适用于所有版本&lt;/li&gt;
&lt;li&gt;软件直接从官网下载即可&lt;/li&gt;
&lt;li&gt;不需要修改host&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;激活教程&quot;&gt;&lt;a href=&quot;#激活教程&quot; class=&quot;headerlink&quot; title=&quot;激活教程&quot;&gt;&lt;/a&gt;激活教程&lt;/h2&gt;&lt;h3 id=&quot;1-下载破解补丁&quot;&gt;&lt;a href=&quot;#1-下载破解补丁&quot; class=&quot;headerlink&quot; title=&quot;1. 下载破解补丁&quot;&gt;&lt;/a&gt;1. 下载破解补丁&lt;/h3&gt;&lt;p&gt;下载补丁文件：&lt;a href=&quot;https://pan.baidu.com/s/1Kc-byjcH_pvrN4CTgfKSFA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jetbrains-agent.jar&lt;/a&gt;&lt;br&gt;文件保存位置可以任意，建议放置到软件安装路径的bin目录下。避免误删文件。&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="破解教程" scheme="http://yoursite.com/tags/%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>pika学习之数据结构篇</title>
    <link href="http://yoursite.com/2019/12/29/new/pika/pika%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    <id>http://yoursite.com/2019/12/29/new/pika/pika学习之数据结构篇/</id>
    <published>2019-12-29T15:58:59.000Z</published>
    <updated>2019-12-29T16:00:07.049Z</updated>
    
    <content type="html"><![CDATA[<p>pika的持久化存储模块称为nemo存储引擎，其本质上是对rocksDB(只支持KV存储)的改造和封装。使其支持多数据结构的存储。<br>pika作为类redis数据库，所以肯定得兼容redis最基本的五种数据结构：string、hash、list、set、zset。 </p><h2 id="KV存储"><a href="#KV存储" class="headerlink" title="KV存储"></a>KV存储</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae07se7opj30k204tq33.jpg" alt=""><br>KV存储作为rocksDB原生支持的存储方式，所以并没有做太多的处理。仅仅只是在value的结尾加上8个字节的附加信息(前4个字节表示version，后4个字节表示ttl)。<br>version字段用于对该键值对进行标记，以便后续处理，如删除一个键值对时，可以在该version进行标记，后续再进行真正的删除，这样可以减少删除操作造成的服务阻塞时间。</p><h2 id="Hash存储"><a href="#Hash存储" class="headerlink" title="Hash存储"></a>Hash存储</h2><p>对于每一个Hash结构，它都包含hash键(key)、域名(field)、值(value)。<br>nome的存储方式是将key和field组合成为一个新的key，将这个新生成的key与要存储的value组成最终落盘的kv键值对。<br>对于每一个hash键，nome还为它添加了一个存储元数据信息的落盘kv，它保存的是对应hash键下的所有域值对的个数。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae07pcssxj30jx04y0t0.jpg" alt=""></p><ul><li>左图字段保存的是hash键的对象，它由标记位+key+version+ttl组成</li><li>右图字段仅仅只保存一个数字，表示该hash下field的数量</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae0docgmtj30rg06iq3b.jpg" alt=""><br>上图表示nome对传统hash结构转换成kv结构的拆分存储模式。</p><ul><li>k结构部分由标记位+长度+key+field组成。size表示的是hash键key的长度。</li><li>v结构部分就由具体的value+version+ttl组成。<a id="more"></a></li></ul><h2 id="List存储"><a href="#List存储" class="headerlink" title="List存储"></a>List存储</h2><p>每个List结构的底层存储也是采用链表结构来完成，对于每个List键，它的每个元素都落盘成一个kv键值对。<br>和Hash结构一样，每个List也需要拥有一个它的元素信息结构。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae0oa3gxuj30m806mjrq.jpg" alt=""></p><ul><li>List的key存储和hash的一样，只有标记位不一样而已。</li><li>value则存储了List的元数据信息，它有四个字段，从前到后分别为该List键内的元素个数、最左边元素节点的sequence(表头)、最右边元素节点的sequence(表尾)、下一个插入元素节点应该使用的sequence。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae0oe8d2tj30qx06mq3b.jpg" alt=""></p><ul><li>k结构部分由标记位+长度+key+sequence组成。size表示的是hash键key的长度。</li><li>v结构部分由前一个元素的sequence+后一个元素的sequence+value+version+ttl组成。从而实现了一个双向链表的结构。</li></ul><h2 id="Set存储"><a href="#Set存储" class="headerlink" title="Set存储"></a>Set存储</h2><p>Set，本质上就是一个value值为nil的Hash结构。在Java和Redis中，都是利用hashtable来实现的。nome并没有做什么特殊处理，只是在存储value时，只保存了version和ttl结构。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae10jcgjdj30lw06oglt.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae10oq2i8j30kw06mq35.jpg" alt=""></p><h2 id="Zset存储"><a href="#Zset存储" class="headerlink" title="Zset存储"></a>Zset存储</h2><p>Zset就是一个有序的Set结构，所以对于每个元素，增加了一个scope值。把该元素对应的score值整合进去，这样便于依据Score值进行排序（因为从rocksdb内拿出的数据时按键排序的）<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae13azcgrj30ii068q33.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae13e4n73j30oa068wep.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae13hlow6j30oa068wep.jpg" alt=""><br>score是从double类型转变过来的int64_t类型，这样做是为了可以让原来的浮点型的score直接参与到字符串的排序当中（浮点型的存储格式与字符串的比较方式不兼容）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pika的持久化存储模块称为nemo存储引擎，其本质上是对rocksDB(只支持KV存储)的改造和封装。使其支持多数据结构的存储。&lt;br&gt;pika作为类redis数据库，所以肯定得兼容redis最基本的五种数据结构：string、hash、list、set、zset。 &lt;/p&gt;
&lt;h2 id=&quot;KV存储&quot;&gt;&lt;a href=&quot;#KV存储&quot; class=&quot;headerlink&quot; title=&quot;KV存储&quot;&gt;&lt;/a&gt;KV存储&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gae07se7opj30k204tq33.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;KV存储作为rocksDB原生支持的存储方式，所以并没有做太多的处理。仅仅只是在value的结尾加上8个字节的附加信息(前4个字节表示version，后4个字节表示ttl)。&lt;br&gt;version字段用于对该键值对进行标记，以便后续处理，如删除一个键值对时，可以在该version进行标记，后续再进行真正的删除，这样可以减少删除操作造成的服务阻塞时间。&lt;/p&gt;
&lt;h2 id=&quot;Hash存储&quot;&gt;&lt;a href=&quot;#Hash存储&quot; class=&quot;headerlink&quot; title=&quot;Hash存储&quot;&gt;&lt;/a&gt;Hash存储&lt;/h2&gt;&lt;p&gt;对于每一个Hash结构，它都包含hash键(key)、域名(field)、值(value)。&lt;br&gt;nome的存储方式是将key和field组合成为一个新的key，将这个新生成的key与要存储的value组成最终落盘的kv键值对。&lt;br&gt;对于每一个hash键，nome还为它添加了一个存储元数据信息的落盘kv，它保存的是对应hash键下的所有域值对的个数。&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gae07pcssxj30jx04y0t0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左图字段保存的是hash键的对象，它由标记位+key+version+ttl组成&lt;/li&gt;
&lt;li&gt;右图字段仅仅只保存一个数字，表示该hash下field的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gae0docgmtj30rg06iq3b.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;上图表示nome对传统hash结构转换成kv结构的拆分存储模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;k结构部分由标记位+长度+key+field组成。size表示的是hash键key的长度。&lt;/li&gt;
&lt;li&gt;v结构部分就由具体的value+version+ttl组成。
    
    </summary>
    
      <category term="Pika" scheme="http://yoursite.com/categories/Pika/"/>
    
    
      <category term="Pika" scheme="http://yoursite.com/tags/Pika/"/>
    
  </entry>
  
  <entry>
    <title>redis复制过程演变</title>
    <link href="http://yoursite.com/2019/12/29/new/redis%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E6%BC%94%E5%8F%98/"/>
    <id>http://yoursite.com/2019/12/29/new/redis复制过程演变/</id>
    <published>2019-12-29T14:19:06.000Z</published>
    <updated>2019-12-29T14:21:46.576Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的主从复制主要经历以下的几个阶段：</p><ol><li>2.8版本以下—-sync</li><li>2.8-4.0版本—-psync</li><li>4.0版本+ —-psync2</li></ol><p>下面我就来简单的讲讲Redis主从复制的演变过程。</p><h2 id="Redis主从复制过程"><a href="#Redis主从复制过程" class="headerlink" title="Redis主从复制过程"></a>Redis主从复制过程</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadwq7etd2j31r50u0464.jpg" alt=""></p><ul><li>客户端发送slaveof命令给Redis实例</li><li>准备阶段函数为<code>replicationSetMaster</code>，这个函数主要会做一些复制之前的数据和状态清理工作。</li><li>更新server.master</li><li>将实例状态修改为REPL_STATE_CONNECT<a id="more"></a><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadwqm9ps9j31pc0u045z.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadxodwcpuj31pf0u0dns.jpg" alt=""><br>Redis每秒会调用一次<code>replicationCron</code>定时任务。根据Redis当前所处状态来决定下一步操作。</li><li>当Redis状态为<code>REPL_STATE_CONNECT</code>时会调用<code>connectWithMaster</code>创建连接master事件。该函数会将Redis状态修改为<code>REPL_STATE_CONNECTING</code></li><li>接下来进行心跳检查、权限校验等操作</li><li>master接收到slave的复制命令后，就会触发一次rdb全备，并记录下全备期间的命令。</li><li>master将全备文件发送给slave后，将增量命令发送给slave。</li><li>心跳维持和持续复制</li></ul><h2 id="主从复制的演变"><a href="#主从复制的演变" class="headerlink" title="主从复制的演变"></a>主从复制的演变</h2><p>在2.8之前的版本中，如果由于网络等原因导致主从复制断开。那么就会将从节点状态修改为<code>REPL_STATE_CONNECTING</code>。进而会重新进行全量同步流程。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadxz7g5aoj31rq0gcju1.jpg" alt=""><br>在2.8版本中，Redis增加了psync命令，并且增加了一个复制积压缓冲区的数据结构（默认为1M）。<br>复制积压缓冲区是一个环形的结构，保存了最近可用的写命令数据。<br>在<code>replicationCron</code>定时任务中每秒发送一个<code>REPLCONF ACK OFFSET</code>命令将自身的偏移量信息发送给master，如果offset的命令在复制积压缓冲区中，那么说明增量数据是可用的。就没必要进行全量同步，直接将复制积压缓冲区中的增量数据发送给slave就可以了。</p><p>在redis4.0+版本中又引进了psync2命令来避免一些特殊场景(主从架构、级联架构)下发生主从切换后不必要的全量同步操作。<br>将一组replid和offset给增加成为两组。主要用来记录上一次复制中主实例的runid值。然后在slaveof时判断是否有必要进行全量同步操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">replid1：</span><br><span class="line">主节点：自身的replid和offset</span><br><span class="line">从节点：主节点的replid和offset</span><br><span class="line"></span><br><span class="line">replid2:</span><br><span class="line">上一次主实例的replid和offset</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的主从复制主要经历以下的几个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;2.8版本以下—-sync&lt;/li&gt;
&lt;li&gt;2.8-4.0版本—-psync&lt;/li&gt;
&lt;li&gt;4.0版本+ —-psync2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我就来简单的讲讲Redis主从复制的演变过程。&lt;/p&gt;
&lt;h2 id=&quot;Redis主从复制过程&quot;&gt;&lt;a href=&quot;#Redis主从复制过程&quot; class=&quot;headerlink&quot; title=&quot;Redis主从复制过程&quot;&gt;&lt;/a&gt;Redis主从复制过程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gadwq7etd2j31r50u0464.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送slaveof命令给Redis实例&lt;/li&gt;
&lt;li&gt;准备阶段函数为&lt;code&gt;replicationSetMaster&lt;/code&gt;，这个函数主要会做一些复制之前的数据和状态清理工作。&lt;/li&gt;
&lt;li&gt;更新server.master&lt;/li&gt;
&lt;li&gt;将实例状态修改为REPL_STATE_CONNECT
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>浅析GeoHash</title>
    <link href="http://yoursite.com/2019/12/26/new/%E6%B5%85%E6%9E%90GeoHash/"/>
    <id>http://yoursite.com/2019/12/26/new/浅析GeoHash/</id>
    <published>2019-12-26T12:16:58.000Z</published>
    <updated>2019-12-29T16:03:59.377Z</updated>
    
    <content type="html"><![CDATA[<p>GeoHash算法能够将二维的经纬度转换成字符串。主要有以下几个特性:</p><ol><li>每一个字符串代表了某一矩形区域.</li><li>字符串的长度越长，所表示的位置越精确。</li><li>字符串越相近的表示的举例越接近.</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>GeoHash将经纬度转换为hash字符串主要分为三步：</p><ol><li>将纬度(-90, 90)平均分成两个区间(-90, 0)、(0, 90)，如果坐标位置的纬度值在第一区间，则编码是0，否则编码为1</li><li>经纬度的编码合并，从0开始，奇数为是纬度，偶数为是经度</li><li>对经纬度合并后的编码，进行base32编码</li></ol><p>大概过程如下图，不断的对经纬度进行切割，直到精准度达到要求。<br><img src="https://user-gold-cdn.xitu.io/2018/7/4/1646397a223e2019?imageslim" alt="IMAGE"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote><p>将经纬度转换成二进制编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void convert(double min, double max, double value, List&lt;Character&gt; list) &#123;</span><br><span class="line">        if (list.size() &gt; (length - 1)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        double mid = (max + min) / 2;</span><br><span class="line">        if (value &lt; mid) &#123;</span><br><span class="line">            list.add(&apos;0&apos;);</span><br><span class="line">            convert(min, mid, value, list);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            list.add(&apos;1&apos;);</span><br><span class="line">            convert(mid, max, value, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><blockquote><p>合并经纬度的二进制编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Character&gt; latList = new ArrayList&lt;Character&gt;();</span><br><span class="line">List&lt;Character&gt; lngList = new ArrayList&lt;Character&gt;();</span><br><span class="line">convert(Min_Lat, Max_Lat, lat, latList);</span><br><span class="line">convert(Min_Lng, Max_Lng, lng, lngList);</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">for (int index = 0; index &lt; latList.size(); index++) &#123;</span><br><span class="line">    sb.append(lngList.get(index)).append(latList.get(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>base32编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private final String[] base32Lookup =</span><br><span class="line">            &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;,</span><br><span class="line">                    &quot;j&quot;, &quot;k&quot;, &quot;m&quot;, &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#125;;</span><br><span class="line">    private String base32Encode(final String str) &#123;</span><br><span class="line">        String unit = &quot;&quot;;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int start = 0; start &lt; str.length(); start = start + 5) &#123;</span><br><span class="line">            unit = str.substring(start, start + 5);</span><br><span class="line">            sb.append(base32Lookup[convertToIndex(unit.split(&quot;&quot;))]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    private int convertToIndex(String str) &#123;</span><br><span class="line">        int length = str.length();</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int index = 0; index &lt; length; index++) &#123;</span><br><span class="line">            result += str.charAt(index) == &apos;0&apos; ? 0 : 1 &lt;&lt; (length - 1 - index);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="Redis中的Geo使用"><a href="#Redis中的Geo使用" class="headerlink" title="Redis中的Geo使用"></a>Redis中的Geo使用</h2><p>在Redis中，Geo的内部结构实际上是一个zset。<br>Redis提供给Geo指定只有6个，但是它可以使用zset的所有指令。</p><h3 id="增加-geoadd"><a href="#增加-geoadd" class="headerlink" title="增加-geoadd"></a>增加-geoadd</h3><p>geoadd指令传入多个经纬度名称三元组，Redis内存会调用函数计算出相应的geohash字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd company 116.48105 39.996794 juejin</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.514203 39.905409 ireader</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.489033 40.007669 meituan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p><h3 id="距离-geodist"><a href="#距离-geodist" class="headerlink" title="距离-geodist"></a>距离-geodist</h3><p>geodist 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist company juejin ireader km</span><br><span class="line">&quot;10.5501&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin meituan km</span><br><span class="line">&quot;1.3878&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin jd km</span><br><span class="line">&quot;24.2739&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin xiaomi km</span><br><span class="line">&quot;12.9606&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin juejin km</span><br><span class="line">&quot;0.0000&quot;</span><br></pre></td></tr></table></figure></p><h3 id="获取元素位置-geopos"><a href="#获取元素位置-geopos" class="headerlink" title="获取元素位置-geopos"></a>获取元素位置-geopos</h3><p>geopos 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos company juejin</span><br><span class="line">1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">   2) &quot;39.99679348858259686&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company ireader</span><br><span class="line">1) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">   2) &quot;39.90540918662494363&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company juejin ireader</span><br><span class="line">1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">   2) &quot;39.99679348858259686&quot;</span><br><span class="line">2) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">   2) &quot;39.90540918662494363&quot;</span><br></pre></td></tr></table></figure></p><h3 id="获取元素的-hash-值-geohash"><a href="#获取元素的-hash-值-geohash" class="headerlink" title="获取元素的 hash 值-geohash"></a>获取元素的 hash 值-geohash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash company ireader</span><br><span class="line">1) &quot;wx4g52e1ce0&quot;</span><br><span class="line">127.0.0.1:6379&gt; geohash company juejin</span><br><span class="line">1) &quot;wx4gd94yjn0&quot;</span><br></pre></td></tr></table></figure><h3 id="附近元素-georadiusbymember"><a href="#附近元素-georadiusbymember" class="headerlink" title="附近元素-georadiusbymember"></a>附近元素-georadiusbymember</h3><p>georadiusbymember 指令是最为关键的指令，它可以用来查询指定元素附近的其它元素，它的参数非常复杂。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 asc</span><br><span class="line">1) &quot;ireader&quot;</span><br><span class="line">2) &quot;juejin&quot;</span><br><span class="line">3) &quot;meituan&quot;</span><br><span class="line"># 范围 20 公里以内最多 3 个元素按距离倒排</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 desc</span><br><span class="line">1) &quot;jd&quot;</span><br><span class="line">2) &quot;meituan&quot;</span><br><span class="line">3) &quot;juejin&quot;</span><br><span class="line"># 三个可选参数 withcoord withdist withhash 用来携带附加参数</span><br><span class="line"># withdist 很有用，它可以用来显示距离</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc</span><br><span class="line">1) 1) &quot;ireader&quot;</span><br><span class="line">   2) &quot;0.0000&quot;</span><br><span class="line">   3) (integer) 4069886008361398</span><br><span class="line">   4) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">      2) &quot;39.90540918662494363&quot;</span><br><span class="line">2) 1) &quot;juejin&quot;</span><br><span class="line">   2) &quot;10.5501&quot;</span><br><span class="line">   3) (integer) 4069887154388167</span><br><span class="line">   4) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">      2) &quot;39.99679348858259686&quot;</span><br><span class="line">3) 1) &quot;meituan&quot;</span><br><span class="line">   2) &quot;11.5748&quot;</span><br><span class="line">   3) (integer) 4069887179083478</span><br><span class="line">   4) 1) &quot;116.48903220891952515&quot;</span><br><span class="line">      2) &quot;40.00766997707732031&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GeoHash算法能够将二维的经纬度转换成字符串。主要有以下几个特性:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每一个字符串代表了某一矩形区域.&lt;/li&gt;
&lt;li&gt;字符串的长度越长，所表示的位置越精确。&lt;/li&gt;
&lt;li&gt;字符串越相近的表示的举例越接近.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;GeoHash将经纬度转换为hash字符串主要分为三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将纬度(-90, 90)平均分成两个区间(-90, 0)、(0, 90)，如果坐标位置的纬度值在第一区间，则编码是0，否则编码为1&lt;/li&gt;
&lt;li&gt;经纬度的编码合并，从0开始，奇数为是纬度，偶数为是经度&lt;/li&gt;
&lt;li&gt;对经纬度合并后的编码，进行base32编码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大概过程如下图，不断的对经纬度进行切割，直到精准度达到要求。&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/4/1646397a223e2019?imageslim&quot; alt=&quot;IMAGE&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;将经纬度转换成二进制编码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void convert(double min, double max, double value, List&amp;lt;Character&amp;gt; list) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (list.size() &amp;gt; (length - 1)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        double mid = (max + min) / 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (value &amp;lt; mid) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            list.add(&amp;apos;0&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            convert(min, mid, value, list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            list.add(&amp;apos;1&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            convert(mid, max, value, list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis4.0的大key发现和删除</title>
    <link href="http://yoursite.com/2019/12/19/new/Redis4.0%E7%9A%84%E5%A4%A7key%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2019/12/19/new/Redis4.0的大key发现和删除/</id>
    <published>2019-12-18T17:22:47.000Z</published>
    <updated>2019-12-18T17:25:03.941Z</updated>
    
    <content type="html"><![CDATA[<p>Redis4.0版本之后引入了memory usage命令和lazyfree机制。不管是对大key的发现，还是解决删除大key造成的阻塞问题都有了很大的提升。</p><h3 id="大key发现"><a href="#大key发现" class="headerlink" title="大key发现"></a>大key发现</h3><p>memory usage的实现主要在<code>object.c-&gt;memoryCommand</code>方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;memory&quot;,memoryCommand,-2,</span><br><span class="line">     &quot;random read-only&quot;,</span><br><span class="line">     0,NULL,0,0,0,0,0,0&#125;,</span><br><span class="line">     </span><br><span class="line">else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;usage&quot;) &amp;&amp; c-&gt;argc &gt;= 3) &#123;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;</span><br><span class="line">        for (int j = 3; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">            if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;samples&quot;) &amp;&amp;</span><br><span class="line">                j+1 &lt; c-&gt;argc)</span><br><span class="line">            &#123;</span><br><span class="line">                if (getLongLongFromObjectOrReply(c,c-&gt;argv[j+1],&amp;samples,NULL)</span><br><span class="line">                     == C_ERR) return;</span><br><span class="line">                if (samples &lt; 0) &#123;</span><br><span class="line">                    addReply(c,shared.syntaxerr);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (samples == 0) samples = LLONG_MAX;;</span><br><span class="line">                j++; /* skip option argument. */</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                addReply(c,shared.syntaxerr);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((de = dictFind(c-&gt;db-&gt;dict,c-&gt;argv[2]-&gt;ptr)) == NULL) &#123;</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        size_t usage = objectComputeSize(dictGetVal(de),samples);</span><br><span class="line">        usage += sdsAllocSize(dictGetKey(de));</span><br><span class="line">        usage += sizeof(dictEntry);</span><br><span class="line">        addReplyLongLong(c,usage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>我们可以看到计算使用内存大小核心逻辑是在<code>objectComputeSize</code>函数中，对不同类型的键值计算方式不一样，这里以hash类型举例。<br>在使用<code>memory usage</code>命令时可以指定一个抽样元素个数。默认为5，决定了内存计算的准确性和计算成本。<br>这个值越大，循环次数越多，计算结果越精准，性能损耗也越高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*...代码对数据类型进行了分类，此处只取hash类型说明*/</span><br><span class="line">    /*...*/</span><br><span class="line">        /*循环抽样个field，累加获取抽样样本内存值，默认抽样样本为5*/</span><br><span class="line">        while((de = dictNext(di)) != NULL &amp;&amp; samples &lt; sample_size) &#123;</span><br><span class="line">            ele = dictGetKey(de);</span><br><span class="line">            ele2 = dictGetVal(de);</span><br><span class="line">            elesize += sdsAllocSize(ele) + sdsAllocSize(ele2);</span><br><span class="line">            elesize += sizeof(struct dictEntry);</span><br><span class="line">            samples++;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        /*根据上一步计算的抽样样本内存值除以样本量，再乘以总的filed个数计算总内存值*/</span><br><span class="line">        if (samples) asize += (double)elesize/samples*dictSize(d);</span><br><span class="line">    /*...*/</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="lazyfree"><a href="#lazyfree" class="headerlink" title="lazyfree"></a>lazyfree</h3><p>在Redis4.0版本中，新增了一个删除命令<code>unlink</code>。实现了懒删除方式，减少了在删除大key时引起的阻塞影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;unlink&quot;,unlinkCommand,-2,</span><br><span class="line">     &quot;write fast @keyspace&quot;,</span><br><span class="line">     0,NULL,1,-1,1,0,0,0&#125;,</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">void unlinkCommand(client *c) &#123;</span><br><span class="line">    delGenericCommand(c,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* This command implements DEL and LAZYDEL. */</span><br><span class="line">void delGenericCommand(client *c, int lazy) &#123;</span><br><span class="line">    int numdel = 0, j;</span><br><span class="line"></span><br><span class="line">    for (j = 1; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        int deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        if (deleted) &#123;</span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                &quot;del&quot;,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看出，<code>del</code>和<code>unlink</code>命令调用的都是<code>delGenericCommand</code>方法。区别主要在于第二个参数，是否为懒删除标记。<br>如果是懒删除，调用的是异步删除方法<code>dbAsyncDelete</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/* Delete a key, value, and associated expiration entry if any, from the DB.</span><br><span class="line"> * If there are enough allocations to free the value object may be put into</span><br><span class="line"> * a lazy free list instead of being freed synchronously. The lazy free list</span><br><span class="line"> * will be reclaimed in a different bio.c thread. */</span><br><span class="line">#define LAZYFREE_THRESHOLD 64</span><br><span class="line">int dbAsyncDelete(redisDb *db, robj *key) &#123;</span><br><span class="line">    /* Deleting an entry from the expires dict will not free the sds of</span><br><span class="line">     * the key, because it is shared with the main dictionary. */</span><br><span class="line">    if (dictSize(db-&gt;expires) &gt; 0) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    /* If the value is composed of a few allocations, to free in a lazy way</span><br><span class="line">     * is actually just slower... So under a certain limit we just free</span><br><span class="line">     * the object synchronously. */</span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        /*lazyfreeGetFreeEffort来获取val对象所包含的元素个数*/</span><br><span class="line">        size_t free_effort = lazyfreeGetFreeEffort(val);</span><br><span class="line"></span><br><span class="line">        /* If releasing the object is too much work, do it in the background</span><br><span class="line">         * by adding the object to the lazy free list.</span><br><span class="line">         * Note that if the object is shared, to reclaim it now it is not</span><br><span class="line">         * possible. This rarely happens, however sometimes the implementation</span><br><span class="line">         * of parts of the Redis core may call incrRefCount() to protect</span><br><span class="line">         * objects, and then call dbDelete(). In this case we&apos;ll fall</span><br><span class="line">         * through and reach the dictFreeUnlinkedEntry() call, that will be</span><br><span class="line">         * equivalent to just calling decrRefCount(). */</span><br><span class="line">        /* 对删除key进行判断，满足阈值条件时进行后台删除 */</span><br><span class="line">        if (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == 1) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,1);</span><br><span class="line">            /*将删除对象放入BIO_LAZY_FREE后台线程任务队列*/</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,NULL,NULL);</span><br><span class="line">            /*将第一步获取到的val值设置为null*/</span><br><span class="line">            dictSetVal(db-&gt;dict,de,NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Release the key-val pair, or just the key if we set the val</span><br><span class="line">     * field to NULL in order to lazy free it later. */</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        if (server.cluster_enabled) slotToKeyDel(key);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从函数实现中可以看出，Redis并不是单纯的将所有懒删除操作都放后台线程中进行。而是会先对需要懒删除的key进行判断，不满足条件的key将会直接进行删除操作。<br>只有满足条件的key才放入到后台线程任务处理队列中。并且立即将其value设置为NULL，避免造成脏读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">else if (type == BIO_LAZY_FREE) &#123;</span><br><span class="line">           /* What we free changes depending on what arguments are set:</span><br><span class="line">            * arg1 -&gt; free the object at pointer.</span><br><span class="line">            * arg2 &amp; arg3 -&gt; free two dictionaries (a Redis DB).</span><br><span class="line">            * only arg3 -&gt; free the skiplist. */</span><br><span class="line">           if (job-&gt;arg1)</span><br><span class="line">               lazyfreeFreeObjectFromBioThread(job-&gt;arg1);</span><br><span class="line">           else if (job-&gt;arg2 &amp;&amp; job-&gt;arg3)</span><br><span class="line">               lazyfreeFreeDatabaseFromBioThread(job-&gt;arg2,job-&gt;arg3);</span><br><span class="line">           else if (job-&gt;arg3)</span><br><span class="line">               lazyfreeFreeSlotsMapFromBioThread(job-&gt;arg3);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis4.0版本之后引入了memory usage命令和lazyfree机制。不管是对大key的发现，还是解决删除大key造成的阻塞问题都有了很大的提升。&lt;/p&gt;
&lt;h3 id=&quot;大key发现&quot;&gt;&lt;a href=&quot;#大key发现&quot; class=&quot;headerlink&quot; title=&quot;大key发现&quot;&gt;&lt;/a&gt;大key发现&lt;/h3&gt;&lt;p&gt;memory usage的实现主要在&lt;code&gt;object.c-&amp;gt;memoryCommand&lt;/code&gt;方法中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;quot;memory&amp;quot;,memoryCommand,-2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;quot;random read-only&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     0,NULL,0,0,0,0,0,0&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else if (!strcasecmp(c-&amp;gt;argv[1]-&amp;gt;ptr,&amp;quot;usage&amp;quot;) &amp;amp;&amp;amp; c-&amp;gt;argc &amp;gt;= 3) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dictEntry *de;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int j = 3; j &amp;lt; c-&amp;gt;argc; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (!strcasecmp(c-&amp;gt;argv[j]-&amp;gt;ptr,&amp;quot;samples&amp;quot;) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j+1 &amp;lt; c-&amp;gt;argc)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (getLongLongFromObjectOrReply(c,c-&amp;gt;argv[j+1],&amp;amp;samples,NULL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     == C_ERR) return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (samples &amp;lt; 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    addReply(c,shared.syntaxerr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (samples == 0) samples = LLONG_MAX;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j++; /* skip option argument. */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                addReply(c,shared.syntaxerr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ((de = dictFind(c-&amp;gt;db-&amp;gt;dict,c-&amp;gt;argv[2]-&amp;gt;ptr)) == NULL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            addReplyNull(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        size_t usage = objectComputeSize(dictGetVal(de),samples);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        usage += sdsAllocSize(dictGetKey(de));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        usage += sizeof(dictEntry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        addReplyLongLong(c,usage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis初始化启动过程</title>
    <link href="http://yoursite.com/2019/12/15/new/Redis%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/12/15/new/Redis初始化启动过程/</id>
    <published>2019-12-14T17:48:31.000Z</published>
    <updated>2019-12-14T17:49:05.175Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文将基于Redis5.0 unstable版本介绍其在启动过程中所做的主要操作以及相关流程函数方法。<br>在此，先放上一张Redis初始化流程的大意图。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wqij4tmaj30a008edfz.jpg" alt=""></p><a id="more"></a><p>Redis的启动函数位于<code>server.c</code>文件main方法下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    int j;</span><br><span class="line">#ifdef REDIS_TEST</span><br><span class="line">    if (argc == 3 &amp;&amp; !strcasecmp(argv[1], &quot;test&quot;)) &#123;</span><br><span class="line">        if (!strcasecmp(argv[2], &quot;ziplist&quot;)) &#123;</span><br><span class="line">            return ziplistTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;quicklist&quot;)) &#123;</span><br><span class="line">            quicklistTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;intset&quot;)) &#123;</span><br><span class="line">            return intsetTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;zipmap&quot;)) &#123;</span><br><span class="line">            return zipmapTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;sha1test&quot;)) &#123;</span><br><span class="line">            return sha1Test(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;util&quot;)) &#123;</span><br><span class="line">            return utilTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;sds&quot;)) &#123;</span><br><span class="line">            return sdsTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;endianconv&quot;)) &#123;</span><br><span class="line">            return endianconvTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;crc64&quot;)) &#123;</span><br><span class="line">            return crc64Test(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;zmalloc&quot;)) &#123;</span><br><span class="line">            return zmalloc_test(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1; /* test not found */</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* We need to initialize our libraries, and the server configuration. */</span><br><span class="line">#ifdef INIT_SETPROCTITLE_REPLACEMENT</span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line">#endif</span><br><span class="line">    setlocale(LC_COLLATE,&quot;&quot;);</span><br><span class="line">    tzset(); /* Populates &apos;timezone&apos; global. */</span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(NULL)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,NULL);</span><br><span class="line"></span><br><span class="line">    char hashseed[16];</span><br><span class="line">    getRandomHexChars(hashseed,sizeof(hashseed));</span><br><span class="line">    dictSetHashFunctionSeed((uint8_t*)hashseed);</span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">    initServerConfig();</span><br><span class="line">    ACLInit(); /* The ACL subsystem must be initialized ASAP because the</span><br><span class="line">                  basic networking code and client creation depends on it. */</span><br><span class="line">    moduleInitModulesSystem();</span><br><span class="line"></span><br><span class="line">    /* Store the executable path and arguments in a safe place in order</span><br><span class="line">     * to be able to restart the server later. */</span><br><span class="line">    server.executable = getAbsolutePath(argv[0]);</span><br><span class="line">    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</span><br><span class="line">    server.exec_argv[argc] = NULL;</span><br><span class="line">    for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br><span class="line"></span><br><span class="line">    /* We need to init sentinel right now as parsing the configuration file</span><br><span class="line">     * in sentinel mode will have the effect of populating the sentinel</span><br><span class="line">     * data structures with master nodes to monitor. */</span><br><span class="line">    if (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig();</span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Check if we need to start in redis-check-rdb/aof mode. We just execute</span><br><span class="line">     * the program main. However the program is part of the Redis executable</span><br><span class="line">     * so that we can easily execute an RDB check on loading errors. */</span><br><span class="line">    if (strstr(argv[0],&quot;redis-check-rdb&quot;) != NULL)</span><br><span class="line">        redis_check_rdb_main(argc,argv,NULL);</span><br><span class="line">    else if (strstr(argv[0],&quot;redis-check-aof&quot;) != NULL)</span><br><span class="line">        redis_check_aof_main(argc,argv);</span><br><span class="line"></span><br><span class="line">    if (argc &gt;= 2) &#123;</span><br><span class="line">        j = 1; /* First option to parse in argv[] */</span><br><span class="line">        sds options = sdsempty();</span><br><span class="line">        char *configfile = NULL;</span><br><span class="line"></span><br><span class="line">        /* Handle special options --help and --version */</span><br><span class="line">        if (strcmp(argv[1], &quot;-v&quot;) == 0 ||</span><br><span class="line">            strcmp(argv[1], &quot;--version&quot;) == 0) version();</span><br><span class="line">        if (strcmp(argv[1], &quot;--help&quot;) == 0 ||</span><br><span class="line">            strcmp(argv[1], &quot;-h&quot;) == 0) usage();</span><br><span class="line">        if (strcmp(argv[1], &quot;--test-memory&quot;) == 0) &#123;</span><br><span class="line">            if (argc == 3) &#123;</span><br><span class="line">                memtest(atoi(argv[2]),50);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fprintf(stderr,&quot;Please specify the amount of memory to test in megabytes.\n&quot;);</span><br><span class="line">                fprintf(stderr,&quot;Example: ./redis-server --test-memory 4096\n\n&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* First argument is the config file name? */</span><br><span class="line">        if (argv[j][0] != &apos;-&apos; || argv[j][1] != &apos;-&apos;) &#123;</span><br><span class="line">            configfile = argv[j];</span><br><span class="line">            server.configfile = getAbsolutePath(configfile);</span><br><span class="line">            /* Replace the config file in server.exec_argv with</span><br><span class="line">             * its absolute path. */</span><br><span class="line">            zfree(server.exec_argv[j]);</span><br><span class="line">            server.exec_argv[j] = zstrdup(server.configfile);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* All the other options are parsed and conceptually appended to the</span><br><span class="line">         * configuration file. For instance --port 6380 will generate the</span><br><span class="line">         * string &quot;port 6380\n&quot; to be parsed after the actual file name</span><br><span class="line">         * is parsed, if any. */</span><br><span class="line">        while(j != argc) &#123;</span><br><span class="line">            if (argv[j][0] == &apos;-&apos; &amp;&amp; argv[j][1] == &apos;-&apos;) &#123;</span><br><span class="line">                /* Option name */</span><br><span class="line">                if (!strcmp(argv[j], &quot;--check-rdb&quot;)) &#123;</span><br><span class="line">                    /* Argument has no options, need to skip for parsing. */</span><br><span class="line">                    j++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (sdslen(options)) options = sdscat(options,&quot;\n&quot;);</span><br><span class="line">                options = sdscat(options,argv[j]+2);</span><br><span class="line">                options = sdscat(options,&quot; &quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* Option argument */</span><br><span class="line">                options = sdscatrepr(options,argv[j],strlen(argv[j]));</span><br><span class="line">                options = sdscat(options,&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == &apos;-&apos;) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Sentinel config from STDIN not allowed.&quot;);</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Sentinel needs config file on disk to save state.  Exiting...&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        resetServerSaveParams();</span><br><span class="line">        loadServerConfig(configfile,options);</span><br><span class="line">        sdsfree(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_WARNING, &quot;oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo&quot;);</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        &quot;Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started&quot;,</span><br><span class="line">            REDIS_VERSION,</span><br><span class="line">            (sizeof(long) == 8) ? 64 : 32,</span><br><span class="line">            redisGitSHA1(),</span><br><span class="line">            strtol(redisGitDirty(),NULL,10) &gt; 0,</span><br><span class="line">            (int)getpid());</span><br><span class="line"></span><br><span class="line">    if (argc == 1) &#123;</span><br><span class="line">        serverLog(LL_WARNING, &quot;Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf&quot;, argv[0], server.sentinel_mode ? &quot;sentinel&quot; : &quot;redis&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        serverLog(LL_WARNING, &quot;Configuration loaded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line">    int background = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line">    if (background) daemonize();</span><br><span class="line"></span><br><span class="line">    initServer();</span><br><span class="line">    if (background || server.pidfile) createPidFile();</span><br><span class="line">    redisSetProcTitle(argv[0]);</span><br><span class="line">    redisAsciiArt();</span><br><span class="line">    checkTcpBacklogSettings();</span><br><span class="line"></span><br><span class="line">    if (!server.sentinel_mode) &#123;</span><br><span class="line">        /* Things not needed when running in Sentinel mode. */</span><br><span class="line">        serverLog(LL_WARNING,&quot;Server initialized&quot;);</span><br><span class="line">    #ifdef __linux__</span><br><span class="line">        linuxMemoryWarnings();</span><br><span class="line">    #endif</span><br><span class="line">        moduleLoadFromQueue();</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        if (server.cluster_enabled) &#123;</span><br><span class="line">            if (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    &quot;You can&apos;t have keys in a DB different than DB 0 when in &quot;</span><br><span class="line">                    &quot;Cluster mode. Exiting.&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (server.ipfd_count &gt; 0)</span><br><span class="line">            serverLog(LL_NOTICE,&quot;Ready to accept connections&quot;);</span><br><span class="line">        if (server.sofd &gt; 0)</span><br><span class="line">            serverLog(LL_NOTICE,&quot;The server is now ready to accept connections at %s&quot;, server.unixsocket);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Warning the user about suspicious maxmemory setting. */</span><br><span class="line">    if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) &#123;</span><br><span class="line">        serverLog(LL_WARNING,&quot;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&quot;, server.maxmemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">    aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="初始化默认状态"><a href="#初始化默认状态" class="headerlink" title="初始化默认状态"></a>初始化默认状态</h2><p>我们可以看到在main方法中，进行的第一步操作就是初始化默认配置<code>initServerConfig</code>。有很多初始化操作都需要设置了一些默认配置后才能够继续进行的。</p><p>在这一阶段中进行初始化的主要有：</p><ul><li>Redis server的状态默认值</li><li>Redis服务运行的默认参数配置</li><li>复制参数配置</li><li>客户端输入输出缓冲区设置</li><li>部分命令参数初始化</li><li>slow log初始化</li></ul><p>为什么需要先对部分命令进行初始化：<br>因为这一部分命令是Redis对外提供服务之前时，就需要先调用的，所以必须先进行初始化。而其他非必须的命令此时仍未进行初始化。</p><h2 id="权限初始化"><a href="#权限初始化" class="headerlink" title="权限初始化"></a>权限初始化</h2><p>用户这个概念，是Redis在6.0版本中提出的。虽然还未正式投入线上使用，但是已经在unstable版本中开始投入开发。<br><code>ACLInit()</code>这个方法非常简单，只会初始化一个拥有所有权限的默认用户。</p><h2 id="初始化模块系统"><a href="#初始化模块系统" class="headerlink" title="初始化模块系统"></a>初始化模块系统</h2><p>模块系统，是Redis4.0版本中推出的一个新特性，它允许用户自己编写适合于自己的模块，并以插件的形式导入到Redis当中。<br>通过<code>moduleInitModulesSystem()</code>方法，创建模块系统所需要数据结构和资源。</p><h2 id="解析命令行参数以及读取配置"><a href="#解析命令行参数以及读取配置" class="headerlink" title="解析命令行参数以及读取配置"></a>解析命令行参数以及读取配置</h2><p>在启动Redis的时候，是允许用户在命令行中指定Redis运行的模式和参数。<br>将配置文件和运行时参数等信息通过遍历的方式确认后，调用<code>loadServerConfig</code>方法，将运行时参数写入到配置文件中。如果没有指定配置文件，就会使用默认的配置文件来运行服务。</p><p>最终会通过<code>initServer</code>方法来初始化参数配置。<br>这个方法主要会做以下的一些初始化操作：</p><ul><li>初始化共享对象<code>createSharedObjects</code></li><li>检查系统参数配置<code>adjustOpenFilesLimit</code></li><li>开启端口监听</li><li>创建事件监听和时间监听文件句柄</li><li>创建数据库并初始化状态<br>在这个方法中创建创建文件驱动和时间驱动的监听句柄。并且会进行以下的一些初始数据的初始化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (server.cluster_enabled) clusterInit();</span><br><span class="line">replicationScriptCacheInit();</span><br><span class="line">scriptingInit(1);</span><br><span class="line">slowlogInit();</span><br><span class="line">latencyMonitorInit();</span><br><span class="line">bioInit();</span><br><span class="line">server.initial_memory_usage = zmalloc_used_memory();</span><br></pre></td></tr></table></figure></li></ul><h2 id="模块文件、用户权限、数据导入"><a href="#模块文件、用户权限、数据导入" class="headerlink" title="模块文件、用户权限、数据导入"></a>模块文件、用户权限、数据导入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moduleLoadFromQueue();</span><br><span class="line">ACLLoadUsersAtStartup();</span><br><span class="line">loadDataFromDisk();</span><br></pre></td></tr></table></figure><p>如果数据文件中有数据，则需要进行数据的初始化操作。<br>如果开启了AOF，那么会优先从AOF文件中进行数据导入操作。如果没有开启AOF文件，才会去查找RDB文件。<code>loadDataFromDisk</code></p><h2 id="循环监听时间"><a href="#循环监听时间" class="headerlink" title="循环监听时间"></a>循环监听时间</h2><p>Redis服务主要运行函数为<code>aeMain()</code>。在函数中，是一个死循环操作。一旦监听的文件事件存在了可操作事件，就会进行处理逻辑流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line">aeMain(server.el);</span><br><span class="line">aeDeleteEventLoop(server.el);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文将基于Redis5.0 unstable版本介绍其在启动过程中所做的主要操作以及相关流程函数方法。&lt;br&gt;在此，先放上一张Redis初始化流程的大意图。&lt;br&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1g9wqij4tmaj30a008edfz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>缓存雪崩穿透击穿介绍</title>
    <link href="http://yoursite.com/2019/12/15/new/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/12/15/new/缓存雪崩穿透击穿介绍/</id>
    <published>2019-12-14T16:40:24.000Z</published>
    <updated>2019-12-14T16:49:41.954Z</updated>
    
    <content type="html"><![CDATA[<p>看到这个标题，你肯定在想：什么是雪崩？什么是穿透？什么是击穿？怎么感觉都是一个意思，都是缓存失效导致的数据库压力问题。</p><p>这三个问题的确都会导致数据库压力问题，但是出现的场景还是存在区别滴。在处理手段上也有很大的区别。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>需要使用的热点数据都做了缓存，但是为了保证Redis的内存够用，所以会对一些数据进行设置过期时间操作。一般情况下存在定时任务去刷新缓存信息，这个时候就存在一个隐患的问题：假设在定时任务中设置的过期时间都一样，那么在某一个时间点时，大量的key同时过期。本来缓存抵挡住了大量的请求，key过期后，这些压力全部同时打到了数据库中，数据库可能就扛不住。直接被打挂了，重启数据库后，立马又被新的流量打挂了。这就是缓存雪崩。<br>(注：这里还有个隐患，Redis可能会频繁的处理过期key，从而导致Redis性能降低)<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wq4egoo5j30er0a6aao.jpg" alt=""></p><p>处理缓存雪崩主要有以下几个思路：</p><ol><li>分散过期时间。把每个key的过期时间都加上一个随机的过期值。保证数据不会在同一时间大面积失效。</li><li>设置过期标志更新缓存。给每一个缓存数据都增加一个相应的缓存标记，记录缓存是否失效。如果缓存失效，则更新数据缓存。这样虽然在缓存首次失效时，仍会带来数据库压力问题。但是能够在一定程度上缓解后续被新流量打挂以及所有服务不可用的情况。</li><li>在代码层面上设定一定策略，比如加锁等待、减慢请求速度。给数据库留下启动和重建缓存的机会。</li></ol><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透就是指客户端不断的查询缓存和数据库都没有的数据。相当于进行了两次无用的查询。降低缓存的命中率，增加数据库的压力。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wq4nqarcj30dx0ak751.jpg" alt=""></p><p>解决手段：</p><ol><li>客户端进行校验，先将明显不符合的key给过滤掉。</li><li>对于查询不到的数据，直接赋值一个null给它。</li><li>使用布隆过滤器来对不存在数据进行过滤掉。</li><li>限流。</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿和缓存雪崩有点像。但是又不一样，缓存雪崩是大面积的缓存同时失效，打崩了DB。而缓存击穿是指一个key非常热点，在不停的扛着大并发，当这个key失效的瞬间，持续的大并发就击穿缓存，直接请求数据库。</p><p>解决手段:<br>主要场景是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。<br>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到这个标题，你肯定在想：什么是雪崩？什么是穿透？什么是击穿？怎么感觉都是一个意思，都是缓存失效导致的数据库压力问题。&lt;/p&gt;
&lt;p&gt;这三个问题的确都会导致数据库压力问题，但是出现的场景还是存在区别滴。在处理手段上也有很大的区别。&lt;/p&gt;
&lt;h2 id=&quot;缓存雪崩&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="概念介绍" scheme="http://yoursite.com/tags/%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot整合SpringTask实现定时任务</title>
    <link href="http://yoursite.com/2019/07/26/SpringBoot/Spring-boot%E6%95%B4%E5%90%88SpringTask%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/07/26/SpringBoot/Spring-boot整合SpringTask实现定时任务/</id>
    <published>2019-07-26T07:45:09.000Z</published>
    <updated>2019-12-18T17:21:15.103Z</updated>
    
    <content type="html"><![CDATA[<p>SpringTask是Spring自主研发的一个定时任务工具，不需要引入其他依赖就可以使用。</p><h2 id="SpringTask-Cron语法"><a href="#SpringTask-Cron语法" class="headerlink" title="SpringTask Cron语法"></a>SpringTask Cron语法</h2><p>类似于shell中的<code>crontab</code>，只不过最前面多了一个<code>Seconds</code>秒级别。<br>Seconds Minutes Hours DayofMonth Month DayofWeek</p><table><thead><tr><th>时间元素</th><th>可出现的字符</th><th>数值范围</th></tr></thead><tbody><tr><td>Seconds</td><td>,-*/</td><td>0-59</td></tr><tr><td>Minutes</td><td>,-*/</td><td>0-59</td></tr><tr><td>Hours</td><td>,-*/</td><td>0-23</td></tr><tr><td>Day of Month</td><td>,-*/?LW</td><td>0-31</td></tr><tr><td>Month</td><td>,-*/</td><td>1-12</td></tr><tr><td>Day of Week</td><td>,-*/?L#</td><td>1-7</td></tr></tbody></table><ul><li>“,” 列出枚举值</li><li>“-“ 触发范围</li><li>“*” 任意值</li><li>“/“ 每隔一段时间执行</li><li>“?” 任意值</li><li>“#” 确定第几个星期几</li><li>“L” 表示最后的有效值</li><li>“W” 表示有效工作日<a id="more"></a><h2 id="整合使用SpringTask"><a href="#整合使用SpringTask" class="headerlink" title="整合使用SpringTask"></a>整合使用SpringTask</h2>因为SpringTask已经存在于Spring框架中，所有不需要引入任何依赖。<br>只需要在配置类中添加一个<code>@EnableScheduling</code>注解就可以开启SpringTask的定时任务功能。<br>然后可以通过在方法上增加<code>@Scheduled</code>注解配置定时任务。或者通过代码动态创建定时任务。</li></ul><h3 id="通过spring-boot注解实现"><a href="#通过spring-boot注解实现" class="headerlink" title="通过spring boot注解实现"></a>通过spring boot注解实现</h3><p>在Spring boot的主类或者配置类中加入<code>@EnableScheduling</code>注解，启动定时任务的配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class SpringbootApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建定时任务实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringTaskDemo &#123;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span><br><span class="line">    public void printHello()&#123;</span><br><span class="line">        System.out.println(&quot;scheduled is running.........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态创建定时任务"><a href="#动态创建定时任务" class="headerlink" title="动态创建定时任务"></a>动态创建定时任务</h3><p>使用注解的方式，无法实现动态的修改、添加、关闭定时任务。这个时候就需要使用编程的方式进行任务的更新操作了。可以使用<code>ThreadPoolTaskScheduler</code>或<code>SchedulingConfigurer</code>接口来创建自定义定时任务。</p><p><strong>SchedulingConfigurer</strong><br>通过实现<code>SchedulingConfigurer</code>接口，重写<code>configureTasks</code>方法添加定时任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ScheduleConfig implements SchedulingConfigurer &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line">taskRegistrar.setTaskScheduler(taskScheduler());</span><br><span class="line"></span><br><span class="line">taskRegistrar.getScheduler().schedule(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;|SchedulingConfigurer cron task01&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, new CronTrigger(&quot;0/3 * * * * ?&quot;));</span><br><span class="line"></span><br><span class="line">taskRegistrar.addCronTask(new CronTask(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;|SchedulingConfigurer cron task02&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, new CronTrigger(&quot;0/2 * * * * ?&quot;)));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Bean</span><br><span class="line">public TaskScheduler taskScheduler() &#123;</span><br><span class="line">ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();</span><br><span class="line">taskScheduler.setPoolSize(10);</span><br><span class="line">taskScheduler.setThreadNamePrefix(&quot;spring-task-scheduler-thread-&quot;);</span><br><span class="line">taskScheduler.setAwaitTerminationSeconds(60);</span><br><span class="line">taskScheduler.setWaitForTasksToCompleteOnShutdown(true);</span><br><span class="line">taskScheduler.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">return taskScheduler;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><hr><p><code>ThreadPoolTaskScheduler</code>是Spring Task的核心实现类，该类提供了大量的重载方法进行任务调度。首先配置一个自定义任务调度线程池<code>ThreadPoolTaskScheduler</code>，然后调用<code>schedule</code>等方法对定时任务进行动态管理操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/task&quot;)</span><br><span class="line">public class SpringTaskDemo&#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ThreadPoolTaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    private ScheduledFuture&lt;?&gt; scheduledFuture;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;timing-task.cron1&#125;&quot;)</span><br><span class="line">    private String cronStr1;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;timing-task.cron2&#125;&quot;)</span><br><span class="line">    private String cronStr2;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/start&quot;)</span><br><span class="line">    public String startTask() &#123;</span><br><span class="line">        scheduledFuture = taskScheduler.schedule(new RunTask01(), new Trigger() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Date nextExecutionTime(TriggerContext triggerContext) &#123;</span><br><span class="line">                return new CronTrigger(cronStr1).nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(&quot;start timed task success ..&quot;);</span><br><span class="line">        return &quot;start task suceess&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/stop&quot;)</span><br><span class="line">    public String stopTask() &#123;</span><br><span class="line">        Boolean result = null;</span><br><span class="line">        if (scheduledFuture != null) &#123;</span><br><span class="line">            result = scheduledFuture.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;stop timed task result: &quot; + result);</span><br><span class="line">        return &quot;stop task result: &quot; + result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/modify&quot;)</span><br><span class="line">    public String modifyTask() &#123;</span><br><span class="line">        Boolean stopResult = null;</span><br><span class="line">        // 停止定时任务</span><br><span class="line">        if (scheduledFuture != null) &#123;</span><br><span class="line">            stopResult = scheduledFuture.cancel(true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;modify task error -&gt; scheduledFuture is null&quot;);</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 更换cron重新开启定时任务</span><br><span class="line">        if (stopResult) &#123;</span><br><span class="line">            scheduledFuture = taskScheduler.schedule(new RunTask01(), new Trigger() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Date nextExecutionTime(TriggerContext triggerContext) &#123;</span><br><span class="line">                    return new CronTrigger(cronStr2).nextExecutionTime(triggerContext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            log.info(&quot;modify task success ..&quot;);</span><br><span class="line">            return &quot;success&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;modify task failed ..&quot;);</span><br><span class="line">        return &quot;failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class RunTask01 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            log.info(Thread.currentThread().getName() + &quot;|schedule task01&quot; + &quot;|&quot; + new Date().toLocaleString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class RunTask02 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            log.info(Thread.currentThread().getName() + &quot;|schedule task02&quot; + &quot;|&quot; + new Date().toLocaleString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringTask是Spring自主研发的一个定时任务工具，不需要引入其他依赖就可以使用。&lt;/p&gt;
&lt;h2 id=&quot;SpringTask-Cron语法&quot;&gt;&lt;a href=&quot;#SpringTask-Cron语法&quot; class=&quot;headerlink&quot; title=&quot;SpringTask Cron语法&quot;&gt;&lt;/a&gt;SpringTask Cron语法&lt;/h2&gt;&lt;p&gt;类似于shell中的&lt;code&gt;crontab&lt;/code&gt;，只不过最前面多了一个&lt;code&gt;Seconds&lt;/code&gt;秒级别。&lt;br&gt;Seconds Minutes Hours DayofMonth Month DayofWeek&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间元素&lt;/th&gt;
&lt;th&gt;可出现的字符&lt;/th&gt;
&lt;th&gt;数值范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Seconds&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;0-59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Minutes&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;0-59&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hours&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;0-23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Day of Month&lt;/td&gt;
&lt;td&gt;,-*/?LW&lt;/td&gt;
&lt;td&gt;0-31&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Month&lt;/td&gt;
&lt;td&gt;,-*/&lt;/td&gt;
&lt;td&gt;1-12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Day of Week&lt;/td&gt;
&lt;td&gt;,-*/?L#&lt;/td&gt;
&lt;td&gt;1-7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;“,” 列出枚举值&lt;/li&gt;
&lt;li&gt;“-“ 触发范围&lt;/li&gt;
&lt;li&gt;“*” 任意值&lt;/li&gt;
&lt;li&gt;“/“ 每隔一段时间执行&lt;/li&gt;
&lt;li&gt;“?” 任意值&lt;/li&gt;
&lt;li&gt;“#” 确定第几个星期几&lt;/li&gt;
&lt;li&gt;“L” 表示最后的有效值&lt;/li&gt;
&lt;li&gt;“W” 表示有效工作日
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
  </entry>
  
  <entry>
    <title>java实现快排</title>
    <link href="http://yoursite.com/2019/07/24/java%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8E%92/"/>
    <id>http://yoursite.com/2019/07/24/java实现快排/</id>
    <published>2019-07-24T07:04:30.000Z</published>
    <updated>2019-12-18T17:21:15.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>在数组中选出一个元素做为中枢值，把所有比它小的元素都移动到它的左边，比它大的元素都移动到它的右边。直到数组有序。<br><img src="https://img-blog.csdnimg.cn/20190723124826723.gif" alt=""></p><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static void qSort(int[] a,int left,int right)&#123;</span><br><span class="line">    if(left &lt; right)&#123;</span><br><span class="line">        int mid = divide(a,left,right);</span><br><span class="line">        qSort(a,left,mid);</span><br><span class="line">        qSort(a,mid+1,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int divide(int[] a,int left,int right)&#123;</span><br><span class="line">    int mid = left;</span><br><span class="line"></span><br><span class="line">    while(left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; a[right] &gt;= a[mid]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (left &lt; right &amp;&amp; a[left] &lt; a[mid]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            swap(a, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] a, int left, int right) &#123;</span><br><span class="line">    int tmp = a[left];</span><br><span class="line">    a[left] = a[right];</span><br><span class="line">    a[right] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体流程：</p><ol><li>定义两个指针<code>left</code>和<code>right</code>代表两个初始化位置，分别表示需要排序数组的最左和最右。</li><li>一直遍历，right向左移动，直到找到小于中枢值的位置。</li><li>一直遍历，left向右移动，直到找到大于中枢值的位置。</li><li>如果left&lt;right，交换这两个元素。</li><li>重复上面步骤。</li><li>使用递归再对两边子数组进行排序。</li></ol><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//    非递归实现快排</span><br><span class="line">    private static void qSort2(int[] a,int left,int right)&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();</span><br><span class="line">        s.push(left);</span><br><span class="line">        s.push(right);</span><br><span class="line"></span><br><span class="line">        while(!s.isEmpty())&#123;</span><br><span class="line">            int r = s.pop();</span><br><span class="line">            int l = s.pop();</span><br><span class="line">            int mid = divide(a,l,r);</span><br><span class="line">            if(l &lt; mid)&#123;</span><br><span class="line">                s.push(l);</span><br><span class="line">                s.push(mid);</span><br><span class="line">            &#125;</span><br><span class="line">            if(mid + 1 &lt; right)&#123;</span><br><span class="line">                s.push(mid+1);</span><br><span class="line">                s.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对需要排序的数组的左指针和右指针l、r记录起来，压入到栈中，每次循环都会弹出一对l、r。<br>当栈为空时，说明都已经排序了。接收循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h2&gt;&lt;p&gt;在数组中选出一个元素做为中枢值，把所有比它小的元素都移动到它的左边，比它大的元素都移动到它的右边。直到数组有序。&lt;br&gt;&lt;i
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令之sort</title>
    <link href="http://yoursite.com/2019/07/23/Linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bsort/"/>
    <id>http://yoursite.com/2019/07/23/Linux/Linux命令之sort/</id>
    <published>2019-07-23T04:48:18.000Z</published>
    <updated>2019-12-18T17:21:15.065Z</updated>
    
    <content type="html"><![CDATA[<p>Linux自带排序命令：<code>sort</code><br>在一些临时性排序需求的时候，使用该命令可以快速的处理。小巧的工具使我们使用非常便捷。<br>语法：<code>sort [-bcCdfghiRMmnrsuVz] [-k field1[,field2]] [-S memsize] [-T dir] [-t char] [-o output] [file ...]</code></p><h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-b 忽略每行前面开始出的空格字符。</span><br><span class="line">-c 检查文件是否已经按照顺序排序。</span><br><span class="line">-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</span><br><span class="line">-f 排序时，将小写字母视为大写字母。</span><br><span class="line">-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</span><br><span class="line">-k：以哪个区间 (field) 来进行排序</span><br><span class="line">-m：将几个排序好的文件进行合并，只是单纯合并，不做排序</span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序</span><br><span class="line">-n：依照数值的大小排序</span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入指定的文件</span><br><span class="line">-r：降序</span><br><span class="line">-R: 乱序</span><br><span class="line">-u：忽略相同行</span><br><span class="line">-t&lt;分隔字符&gt;：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ cat sort.log</span><br><span class="line">[@huzhibindeMacBook-Pro:tmp]$ cat sort.log</span><br><span class="line">amac2000    500 2K</span><br><span class="line">dwinxp4000    300 3G</span><br><span class="line">ebsd1000    600 4M</span><br><span class="line">blinux1000200 5K</span><br><span class="line">fSUSE4000    300 6M</span><br><span class="line">gwinxp500     300 3G</span><br><span class="line">cwin72000    100 7G</span><br><span class="line">cDebian600     200 8K</span><br></pre></td></tr></table></figure><h3 id="打印从哪列开始是乱序"><a href="#打印从哪列开始是乱序" class="headerlink" title="打印从哪列开始是乱序"></a>打印从哪列开始是乱序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -c sort.log</span><br><span class="line">sort: sort.log:4: disorder: b   linux   1000    200 5K</span><br></pre></td></tr></table></figure><h3 id="指定列排序"><a href="#指定列排序" class="headerlink" title="指定列排序"></a>指定列排序</h3><p>默认按照字符排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3 sort.log</span><br><span class="line">blinux10002005K</span><br><span class="line">ebsd10006004M</span><br><span class="line">cwin720001007G</span><br><span class="line">amac20005002K</span><br><span class="line">dwinxp40003003G</span><br><span class="line">fSUSE40003006M</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br></pre></td></tr></table></figure></p><p>按照数字排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n sort.log</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br><span class="line">blinux10002005K</span><br><span class="line">ebsd10006004M</span><br><span class="line">amac20005002K</span><br><span class="line">cwin720001007G</span><br><span class="line">dwinxp40003003G</span><br><span class="line">fSUSE40003006M</span><br></pre></td></tr></table></figure></p><h3 id="u和uniq的区别"><a href="#u和uniq的区别" class="headerlink" title="-u和uniq的区别"></a>-u和uniq的区别</h3><p>在指定<code>-k</code>的时候，<code>-u</code>是会按照指定的列来忽略重复，<code>uniq</code>是按照整行来去重<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n -u  sort.log</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br><span class="line">ebsd10006004M</span><br><span class="line">amac20005002K</span><br><span class="line">dwinxp40003003G</span><br><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n   sort.log  | uniq</span><br><span class="line">gwinxp5003003G</span><br><span class="line">cDebian6002008K</span><br><span class="line">blinux10002005K</span><br><span class="line">ebsd10006004M</span><br><span class="line">amac20005002K</span><br><span class="line">cwin720001007G</span><br><span class="line">dwinxp40003003G</span><br><span class="line">fSUSE40003006M</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux自带排序命令：&lt;code&gt;sort&lt;/code&gt;&lt;br&gt;在一些临时性排序需求的时候，使用该命令可以快速的处理。小巧的工具使我们使用非常便捷。&lt;br&gt;语法：&lt;code&gt;sort [-bcCdfghiRMmnrsuVz] [-k field1[,field2]] [-S memsize] [-T dir] [-t char] [-o output] [file ...]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;可选项&quot;&gt;&lt;a href=&quot;#可选项&quot; class=&quot;headerlink&quot; title=&quot;可选项&quot;&gt;&lt;/a&gt;可选项&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-b 忽略每行前面开始出的空格字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-c 检查文件是否已经按照顺序排序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-f 排序时，将小写字母视为大写字母。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-k：以哪个区间 (field) 来进行排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-m：将几个排序好的文件进行合并，只是单纯合并，不做排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-M：将前面3个字母依照月份的缩写进行排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n：依照数值的大小排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o&amp;lt;输出文件&amp;gt;：将排序后的结果存入指定的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-r：降序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-R: 乱序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-u：忽略相同行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-t&amp;lt;分隔字符&amp;gt;：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Redis</title>
    <link href="http://yoursite.com/2019/07/21/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Redis/"/>
    <id>http://yoursite.com/2019/07/21/SpringBoot/SpringBoot整合Redis/</id>
    <published>2019-07-21T14:34:11.000Z</published>
    <updated>2019-12-18T17:21:15.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-boot中使用Redis"><a href="#Spring-boot中使用Redis" class="headerlink" title="Spring boot中使用Redis"></a>Spring boot中使用Redis</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=0</span><br><span class="line"></span><br><span class="line">## Redis自定义key配置选项</span><br></pre></td></tr></table></figure><h2 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// 保存字符串</span><br><span class="line">stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;);</span><br><span class="line">Assert.assertEquals(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-boot中使用Redis&quot;&gt;&lt;a href=&quot;#Spring-boot中使用Redis&quot; class=&quot;headerlink&quot; title=&quot;Spring boot中使用Redis&quot;&gt;&lt;/a&gt;Spring boot中使用Redis&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Swagger2</title>
    <link href="http://yoursite.com/2019/07/21/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Swagger2/"/>
    <id>http://yoursite.com/2019/07/21/SpringBoot/SpringBoot整合Swagger2/</id>
    <published>2019-07-21T13:57:43.000Z</published>
    <updated>2019-12-18T17:21:15.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a>Swagger2</h1><p>Swagger2用于解决前后端开发人员之间的api对接，减少与其他团队开发期间的沟通成本。Swagger2可以轻松的整合到Spring boot中，并与SpringMVC程序配合组织处强大的Restful API文档。即可以减少我们创建文档的工作量，同时说明内容整合到实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。<br>另外，Swagger2也提供了强大的页面测试功能来调试每个Restful API</p><h2 id="添加Swagger2依赖"><a href="#添加Swagger2依赖" class="headerlink" title="添加Swagger2依赖"></a>添加Swagger2依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="创建Swagger2配置类"><a href="#创建Swagger2配置类" class="headerlink" title="创建Swagger2配置类"></a>创建Swagger2配置类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket CreateRestApi()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.hoo.springboot&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo()&#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如以上代码，通过<code>@Configuration</code>注解，让Spring来加载该类配置。再通过<code>@EnabledSwagger2</code>注解来启用Swagger2。</p><p>再通过<code>createRestApi</code>函数创建<code>Docket</code>的Bean之后，<code>apiInfo()</code>用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。<code>select()</code>函数返回一个<code>ApiSelectorBuilder</code>实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被<code>@ApiIgnore</code>指定的请求）。</p><h2 id="添加文档内容"><a href="#添加文档内容" class="headerlink" title="添加文档内容"></a>添加文档内容</h2><p>在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过<code>@ApiOperation</code>注解来给API增加说明、通过<code>@ApiImplicitParams</code>、<code>@ApiImplicitParam</code>注解来给参数增加说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(value = &quot;/users&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  创建一个线程安全的Map模拟数据用户信息</span><br><span class="line">     */</span><br><span class="line">    static Map&lt;Integer, User&gt; userMap = Collections.synchronizedMap(new HashMap&lt;Integer,User&gt;());</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&quot;,method = RequestMethod.GET)</span><br><span class="line">    public List&lt;User&gt; getUserList()&#123;</span><br><span class="line">        List&lt;User&gt; r = new ArrayList&lt;User&gt;(userMap.values());</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&quot;,method = RequestMethod.POST)</span><br><span class="line">    public String postUser(@ModelAttribute User user)&#123;</span><br><span class="line">        userMap.put(user.getId(),user);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br><span class="line">    public User getUser(@PathVariable Integer id)&#123;</span><br><span class="line"></span><br><span class="line">        return userMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.PUT)</span><br><span class="line">    public String putUser(@PathVariable Integer id,@ModelAttribute User user)&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        User u = userMap.get(id);</span><br><span class="line">        u.setAge(user.getAge());</span><br><span class="line">        u.setName(user.getName());</span><br><span class="line"></span><br><span class="line">        userMap.put(id,u);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除对象&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span><br><span class="line">    public String deleteUser(@PathVariable Integer id)&#123;</span><br><span class="line"></span><br><span class="line">        userMap.remove(id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成上述代码添加上，启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a><br><a href="https://imgchr.com/i/eCParT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/21/eCParT.md.jpg" alt="eCParT.md.jpg"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Swagger2&quot;&gt;&lt;a href=&quot;#Swagger2&quot; class=&quot;headerlink&quot; title=&quot;Swagger2&quot;&gt;&lt;/a&gt;Swagger2&lt;/h1&gt;&lt;p&gt;Swagger2用于解决前后端开发人员之间的api对接，减少与其他团队开发期间的沟通成本。Swagger2可以轻松的整合到Spring boot中，并与SpringMVC程序配合组织处强大的Restful API文档。即可以减少我们创建文档的工作量，同时说明内容整合到实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。&lt;br&gt;另外，Swagger2也提供了强大的页面测试功能来调试每个Restful API&lt;/p&gt;
&lt;h2 id=&quot;添加Swagger2依赖&quot;&gt;&lt;a href=&quot;#添加Swagger2依赖&quot; class=&quot;headerlink&quot; title=&quot;添加Swagger2依赖&quot;&gt;&lt;/a&gt;添加Swagger2依赖&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
      <category term="mall" scheme="http://yoursite.com/categories/SpringBoot/mall/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring boot整合MyBatis逆向工程</title>
    <link href="http://yoursite.com/2019/07/18/SpringBoot/Spring-boot%E6%95%B4%E5%90%88MyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/18/SpringBoot/Spring-boot整合MyBatis逆向工程/</id>
    <published>2019-07-18T15:03:57.000Z</published>
    <updated>2019-12-18T17:21:15.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pom-xml中添加依赖"><a href="#pom-xml中添加依赖" class="headerlink" title="pom.xml中添加依赖"></a>pom.xml中添加依赖</h2><p>在这里引入了<code>pagehelper</code>，<code>pagehelper</code>是MyBatis的分页插件，通过几行简单的代码就是实现分页功能；在与Spring boot整合的时候，只要整合了<code>pagehelper</code>就自动整合了MyBatis。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- spring boot健康检查、审计、统计、监控--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--MyBatis分页插件--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- MyBatis 生成器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="修改Spring-boot配置文件"><a href="#修改Spring-boot配置文件" class="headerlink" title="修改Spring boot配置文件"></a>修改Spring boot配置文件</h2><p>在<code>application.yml</code>中添加数据源配置和MyBatis的mapper.xml的路径配置。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:13307/spring</span><br><span class="line">    password: hoo</span><br><span class="line">    username: hoo</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mapper/*.xml</span><br><span class="line">    - classpath*:com/**/mapper/*.xml</span><br></pre></td></tr></table></figure><h2 id="修改Mybatis-generator配置文件"><a href="#修改Mybatis-generator配置文件" class="headerlink" title="修改Mybatis generator配置文件"></a>修改Mybatis generator配置文件</h2><p>主要是修改数据库连接配置，MyBatis generator生成的model、mapper接口、mapper.xml文件的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;properties resource=&quot;generator.properties&quot;/&gt;</span><br><span class="line">    &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">        &lt;!-- 为模型生成序列化方法--&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 为生成的Java模型创建一个toString方法 --&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 数据库资源配置 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">                        connectionURL=&quot;jdbc:mysql://127.0.0.1:13307/spring&quot;</span><br><span class="line">                        userId=&quot;hoo&quot;</span><br><span class="line">                        password=&quot;hoo&quot;&gt;</span><br><span class="line">            &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt;</span><br><span class="line">            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!-- 生成的model放置路径 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.hoo.springboot.mbg.model&quot; targetProject=&quot;./src/main/java&quot;/&gt;</span><br><span class="line">        &lt;!-- 生成的mapper接口放置路径 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.hoo.springboot.mbg.mapper&quot; targetProject=&quot;./src/main/resources&quot;/&gt;</span><br><span class="line">        &lt;!-- 生成的mapper配置文件放置路径 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.hoo.springboot.mbg.mapper&quot;</span><br><span class="line">                             targetProject=&quot;./src/main/java&quot;/&gt;</span><br><span class="line">        &lt;!--生成全部表tableName设为%--&gt;</span><br><span class="line">        &lt;table tableName=&quot;%&quot;&gt;</span><br><span class="line">            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure></p><h2 id="运行Generator的main函数生成代码"><a href="#运行Generator的main函数生成代码" class="headerlink" title="运行Generator的main函数生成代码"></a>运行Generator的main函数生成代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Generator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //MBG 执行过程中的警告信息</span><br><span class="line">        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">        //当生成的代码重复时，覆盖原代码</span><br><span class="line">        boolean overwrite = true;</span><br><span class="line">        //读取我们的 MBG 配置文件</span><br><span class="line">        InputStream is = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;);</span><br><span class="line">        ConfigurationParser cp = new ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(is);</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">        /* 创建 MBG */</span><br><span class="line">        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        //执行生成代码</span><br><span class="line">        myBatisGenerator.generate(null);</span><br><span class="line">        //输出警告信息</span><br><span class="line">        for (String warning : warnings) &#123;</span><br><span class="line">            System.out.println(warning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pom-xml中添加依赖&quot;&gt;&lt;a href=&quot;#pom-xml中添加依赖&quot; class=&quot;headerlink&quot; title=&quot;pom.xml中添加依赖&quot;&gt;&lt;/a&gt;pom.xml中添加依赖&lt;/h2&gt;&lt;p&gt;在这里引入了&lt;code&gt;pagehelper&lt;/code&gt;，
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
      <category term="mall" scheme="http://yoursite.com/categories/SpringBoot/mall/"/>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制</title>
    <link href="http://yoursite.com/2019/07/16/Java/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/16/Java/Java类加载机制/</id>
    <published>2019-07-16T14:59:41.000Z</published>
    <updated>2019-12-18T17:21:15.061Z</updated>
    
    <content type="html"><![CDATA[<p>类的加载是指将类的<code>.class</code>文件中的<strong>二进制数据读入到内存</strong>中，将其放在运行时数据区的方法区，然后在Java堆中创建一个java.lang.Class对象(类也是对象)，用来封装类在方法区内的数据结构。<br>类加载的最终产物是位于堆中的Class对象，该Class对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。<br><a href="https://imgchr.com/i/ZqjkUs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjkUs.jpg" alt="ZqjkUs.jpg"></a></p><p>类加载器不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用的时候就预先加载，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器必须在程序<font color="red">首次主动使用该类</font>时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p><a href="https://imgchr.com/i/ZqjPbQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjPbQ.jpg" alt="ZqjPbQ.jpg"></a></p><p>类的生命周期主要包含<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>、<code>使用</code>、<code>卸载</code>。<br>在加载过程中的五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>初始化</code>发生的顺序是一定的，而<code>解析</code>在某些情况下可以在<code>初始化</code>阶段之后执行。这是为了支持Java语言的运行时绑定。<br>另外需要注意的是：这几个阶段是按照顺序开始，而不是按照顺序进行或完成，因为这些阶段通常是相互交叉混合进行的，通常在一个阶段执行的过程中需要调用或激活另一个阶段。<br><a id="more"></a></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>查找并加载类的二进制数据是类加载过程的第一个阶段，在这个阶段，虚拟机需要完成以下事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流</li><li>将这个字节流代表的静态存储结构转化成方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，连接阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。</p><p>在验证阶段，主要是完成以下的校验动作：</p><h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>验证字节流是否符合Class文件格式的规范。例如：是否以<code>OxCAFEBASE</code>开头、主版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p><h3 id="元数据校验"><a href="#元数据校验" class="headerlink" title="元数据校验"></a>元数据校验</h3><p>对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求；列如：这个类是否有父类，除了<code>java.lang.Object</code></p><h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>确保解析动作能正确执行</p><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为类的<code>静态变量</code>分配内存，并将其初始化为默认值</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区分配。</p><ul><li>这个阶段进行内存分配的<font color="red">仅包括类变量(static)</font>，不包括实例变量；实例变量会在对象实例化时随着实例一块分配在Java堆中。</li><li>这个阶段设置的初始值通常是数据类型的默认值，而不是在Java程序中被显式赋予的值。</li><li>如果是同时被final和static修饰的属性，这在准备阶段会被初始化为定义的值。</li></ul><blockquote><p>假设有一个变量public static int value = 3<br>那么变量value在准备阶段过后的初始值是0，而不是3，因为这个时候还没开始执行任何Java方法，把value赋值为3的public static指令是在程序编译后，存放在类构造器<clinit>()方法中，所以value赋值为3的动作在初始化阶段才会执行。</clinit></p></blockquote><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。<br>解析动作主要是针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号类型进行，</p><ul><li>符号引用：用一组符号描述目标，可以是任何字面量</li><li>直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><h3 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h3><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><h3 id="类初始化情况"><a href="#类初始化情况" class="headerlink" title="类初始化情况"></a>类初始化情况</h3><ul><li>使用new创建类的实例</li><li>第一次访问某个类或接口的静态变量，或者对静态变量赋值</li><li>第一次调用类的静态方法</li><li>使用反射加载类(Class.forName(“xxx.xxx”))</li><li>初始化某个类的子类，其父类也会被初始化</li><li>Java虚拟机启动的时候标明启动的类(Java Test)，直接使用<code>java.exe</code>运行某个主类。</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>JVM预定义了三种类加载器，当一个JVM启动的时候，Java会默认使用类加载器进行类加载。</p><ul><li>启动类加载器:负责加载存放在<code>JDK\jre\lib</code>下或被<code>-Xbootclasspath</code>指定路径中的类库。</li><li>扩展类加载器:负责加载<code>JDK\jre\lib\ext</code>或由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库。</li><li>引用类加载器:负责加载用户类路径（ClassPath）所指定的类。程序默认的类加载器。<br><a href="https://imgchr.com/i/ZqjFEj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjFEj.jpg" alt="ZqjFEj.jpg"></a></li></ul><blockquote><p>注：父类加载器并不是通过继承关系实现的，而是采用组合的方式<br>启动类加载器是C++实现，属于虚拟机的一部分；其他类加载器都是由启动类加载器加载到内存中的。</p></blockquote><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><ul><li>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>双亲委派：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h2 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h2><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类的加载是指将类的&lt;code&gt;.class&lt;/code&gt;文件中的&lt;strong&gt;二进制数据读入到内存&lt;/strong&gt;中，将其放在运行时数据区的方法区，然后在Java堆中创建一个java.lang.Class对象(类也是对象)，用来封装类在方法区内的数据结构。&lt;br&gt;类加载的最终产物是位于堆中的Class对象，该Class对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。&lt;br&gt;&lt;a href=&quot;https://imgchr.com/i/ZqjkUs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/17/ZqjkUs.jpg&quot; alt=&quot;ZqjkUs.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类加载器不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用的时候就预先加载，如果在预先加载的过程中遇到了&lt;code&gt;.class&lt;/code&gt;文件缺失或存在错误，类加载器必须在程序&lt;font color=&quot;red&quot;&gt;首次主动使用该类&lt;/font&gt;时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。&lt;/p&gt;
&lt;h1 id=&quot;类加载过程&quot;&gt;&lt;a href=&quot;#类加载过程&quot; class=&quot;headerlink&quot; title=&quot;类加载过程&quot;&gt;&lt;/a&gt;类加载过程&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/ZqjPbQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/17/ZqjPbQ.jpg&quot; alt=&quot;ZqjPbQ.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类的生命周期主要包含&lt;code&gt;加载&lt;/code&gt;、&lt;code&gt;验证&lt;/code&gt;、&lt;code&gt;准备&lt;/code&gt;、&lt;code&gt;解析&lt;/code&gt;、&lt;code&gt;初始化&lt;/code&gt;、&lt;code&gt;使用&lt;/code&gt;、&lt;code&gt;卸载&lt;/code&gt;。&lt;br&gt;在加载过程中的五个阶段中，&lt;code&gt;加载&lt;/code&gt;、&lt;code&gt;验证&lt;/code&gt;、&lt;code&gt;准备&lt;/code&gt;、&lt;code&gt;初始化&lt;/code&gt;发生的顺序是一定的，而&lt;code&gt;解析&lt;/code&gt;在某些情况下可以在&lt;code&gt;初始化&lt;/code&gt;阶段之后执行。这是为了支持Java语言的运行时绑定。&lt;br&gt;另外需要注意的是：这几个阶段是按照顺序开始，而不是按照顺序进行或完成，因为这些阶段通常是相互交叉混合进行的，通常在一个阶段执行的过程中需要调用或激活另一个阶段。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Arrays.sort和Collections.sort实现原理</title>
    <link href="http://yoursite.com/2019/07/16/Java/Arrays-sort%E5%92%8CCollections-sort%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/16/Java/Arrays-sort和Collections-sort实现原理/</id>
    <published>2019-07-16T14:51:54.000Z</published>
    <updated>2019-12-18T17:21:15.060Z</updated>
    
    <content type="html"><![CDATA[<p>事实上，在使用<code>Collections.sort(list)</code>的时候，就调用list.sort()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;</span><br><span class="line">        list.sort(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在深入进去后，发现其实调用的就是Array.sort()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">    default void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">        Object[] a = this.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = this.listIterator();</span><br><span class="line">        for (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>而在Array.sort中，会根据该对象是否能够通过归并排序来选择不同的排序方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            else</span><br><span class="line">                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>legacyMergeSort：归并排序</li><li><a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">TimSort</a><br>：结合归并排序和插入排序的一种排序算法</li></ul><blockquote><p>TimSort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。排序的输入的单位不是一个个单独的数字，而是一个个的块-分区。其中每一个分区叫一个run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run合并到只剩一个 run 为止。这时这个仅剩的 run 便是排好序的结果。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事实上，在使用&lt;code&gt;Collections.sort(list)&lt;/code&gt;的时候，就调用list.sort()&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>

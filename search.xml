<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Linux常用命令（简）]]></title>
      <url>/2117/10/24/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a><a href="https://omg-by.github.io/1900/01/01/Linux/cd/" title="cd详细介绍" target="_blank" rel="external">cd命令</a></h3><p>&ensp;&ensp;跟Windows中一样，进入相应的目录下。<br>&ensp;&ensp;命令格式： cd [目录]</p>
<h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a><a href="https://omg-by.github.io/1900/01/01/Linux/ls/" title="ls详细介绍" target="_blank" rel="external">ls命令</a></h3><p>&ensp;&ensp;查看当前目录下的目录、文件等及其相应权限。<br>&ensp;&ensp;命令格式： ls [选项] 目录</p>
<h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><p>&ensp;&ensp;查看当前工作目录的完整路径。<br>&ensp;&ensp;pwd [选项]</p>
<h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>&ensp;&ensp;创建一个指定的名称的目录，要求创建目录的用户具有权限且该目录名不存在。<br>&ensp;&ensp;mkdir [选项]目录<br><a id="more"></a></p>
<h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><p>&ensp;&ensp;删除一个目录中的一个或多个文件或目录。<br>&ensp;&ensp;rm [选项] 文件或目录</p>
<h3 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h3><p>&ensp;&ensp;删除空目录。<br>&ensp;&ensp;rmdir [选项] 目录</p>
<h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p>&ensp;&ensp;移动文件或者将文件改名，经常用来备份文件或者目录。<br>&ensp;&ensp;mv [选项] 源文件或目录 目标文件或者目录</p>
<h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p>&ensp;&ensp;复制文件，如果目标文件已经存在，会询问是否覆盖。<br>&ensp;&ensp;cp [选项] 源文件或目录  目的目录</p>
<h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p>&ensp;&ensp;用来修改文件时间戳或者新建一个不存在的文件。<br>&ensp;&ensp;touch [选项] 文件</p>
<h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>&ensp;&ensp;显示文件内容 或者将几个文件连接起来显示 或者从标准输入读取内容并显示，常与重定向符号配合使用。<br>&ensp;&ensp;cat [选项] 文件</p>
<h3 id="nl命令"><a href="#nl命令" class="headerlink" title="nl命令"></a>nl命令</h3><p>&ensp;&ensp;用来计算文件中行号，可以将输出的文件内容自动的加上行号。<br>&ensp;&ensp;nl [选项] 文件</p>
<h3 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h3><p>&ensp;&ensp;功能类似cat，cat是整个文件的内容从上到下显示到屏幕上，more会以一页一页的显示方便使用者阅读，空格向后，b键向前。more从前向后读取文件，因此在启动时就加载整个文件。<br>&ensp;&ensp;more [选项] [每屏几行] [查找的子串] [第几行开始] [文件] </p>
<h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p>&ensp;&ensp;跟more类似，但使用less可以任意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看前不会加载整个文件。<br>&ensp;&ensp;less [参数] 文件</p>
<h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><p>&ensp;&ensp;用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。<br>&ensp;&ensp;head [参数] 文件</p>
<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>&ensp;&ensp;用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。<br>&ensp;&ensp;tail[必要参数][选择参数] 文件</p>
<h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><p>&ensp;&ensp;which指令会在PATH变量指定的路径下，搜索某个系统命令的位置，并且返回第一个搜索结果。<br>&ensp;&ensp;which 可执行文件命令</p>
<h3 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h3><p>&ensp;&ensp;whereis命令是定位可执行文件、源代码文件、帮助文件、在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。<br>&ensp;&ensp;whereis [-bmsu] [BMS 目录名 -f ] 文件名</p>
<h3 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h3><p>&ensp;&ensp;通过系统自动生成是数据库表来查询文件，支持匹配符。但是由于有些系统的数据库表不是实时更新的，所以查到的数据可能不是最新的。<br>&ensp;&ensp;locate[选择参数][样式]</p>
<h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><p>&ensp;&ensp;用于在文件树中查找文件，并作出相应的处理。<br>&ensp;&ensp;find pathname -options [-print -exec -ok …] </p>
<h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><p>&ensp;&ensp;用来压缩和解压文件。tar本身不具有压缩功能，他是调用压缩功能实现的。<br>&ensp;&ensp;tar [必要参数][选择参数][文件]</p>
<p><br><br><br><br><center> <strong>长期不定时更新中。。。。。。。。。</strong></center></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--List数据类型]]></title>
      <url>/2017/10/30/Redis/Redis%E5%AD%A6%E4%B9%A0--List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。<br>&ensp;&ensp;从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。相信对于有良好数据结构基础的开发者而言，这一点并不难理解。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LPUSH key value [value …]</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">在指定Key所关联的List Value的头部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的头部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">LPUSHX key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的头部插入参数中给出的Value，否则将不会有任何操作发生。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">LRANGE key start stop</td>
<td style="text-align:center">O(S+N)</td>
<td style="text-align:center">时间复杂度中的S为start参数表示的偏移量，N表示元素的数量。该命令的参数start和end都是0-based。即0表示链表头部(leftmost)的第一个元素。其中start的值也可以为负值，-1将表示链表中的最后一个元素，即尾部元素，-2表示倒数第二个并以此类推。该命令在获取元素时，start和end位置上的元素也会被取出。如果start的值大于链表中元素的数量，空链表将会被返回。如果end的值大于元素的数量，该命令则获取从start(包括start)开始，链表中剩余的所有元素。</td>
<td style="text-align:center">返回指定范围内元素的列表。</td>
</tr>
<tr>
<td style="text-align:center">LPOP key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回并弹出指定Key关联的链表中的第一个元素，即头部元素，。如果该Key不存，返回nil。</td>
<td style="text-align:center">链表头部的元素。</td>
</tr>
<tr>
<td style="text-align:center">LLEN key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回指定Key关联的链表中元素的数量，如果该Key不存在，则返回0。如果与该Key关联的Value的类型不是链表，则返回相关的错误信息。</td>
<td style="text-align:center">链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">LREM key count value</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示链表中元素的数量。在指定Key关联的链表中，删除前count个值等于value的元素。如果count大于0，从头向尾遍历并删除，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。如果指定的Key不存在，则直接返回0。</td>
<td style="text-align:center">返回被删除的元素数量。</td>
</tr>
<tr>
<td style="text-align:center">LSET key index value</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示链表中元素的数量。但是设定头部或尾部的元素时，其时间复杂度为O(1)。设定链表中指定位置的值为新值，其中0表示第一个元素，即头部元素，-1表示尾部元素。如果索引值Index超出了链表中元素的数量范围，该命令将返回相关的错误信息。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LINDEX key index</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示在找到该元素时需要遍历的元素数量。对于头部或尾部元素，其时间复杂度为O(1)。该命令将返回链表中指定位置(index)的元素，index是0-based，表示头部元素，如果index为-1，表示尾部元素。如果与该Key关联的不是链表，该命令将返回相关的错误信息。</td>
<td style="text-align:center">返回请求的元素，如果index超出范围，则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">LTRIM key start stop</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示被删除的元素数量。该命令将仅保留指定范围内的元素，从而保证链接中的元素数量相对恒定。start和stop参数都是0-based，0表示头部元素。和其他命令一样，start和stop也可以为负值，-1表示尾部元素。如果start大于链表的尾部，或start大于stop，该命令不错报错，而是返回一个空的链表，与此同时该Key也将被删除。如果stop大于元素的数量，则保留从start开始剩余的所有元素。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LINSERT key BEFORE,AFTER pivot value</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示在找到该元素pivot之前需要遍历的元素数量。这样意味着如果pivot位于链表的头部或尾部时，该命令的时间复杂度为O(1)。该命令的功能是在pivot元素的前面或后面插入参数中的元素value。如果Key不存在，该命令将不执行任何操作。如果与Key关联的Value类型不是链表，相关的错误信息将被返回。</td>
<td style="text-align:center">成功插入后链表中元素的数量，如果没有找到pivot，返回-1，如果key不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">RPUSH key value [value …]</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">指定Key所关联的List Value的尾部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的尾部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">RPUSHX key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的尾部插入参数中给出的Value，否则将不会有任何操作发生。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">RPOP key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回并弹出指定Key关联的链表中的最后一个元素，即尾部元素，。如果该Key不存，返回nil</td>
<td style="text-align:center">链表尾部的元素</td>
</tr>
<tr>
<td style="text-align:center">RPOPLPUSH source destination</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性的从与source键关联的链表尾部弹出一个元素，同时再将弹出的元素插入到与destination键关联的链表的头部。如果source键不存在，该命令将返回nil，同时不再做任何其它的操作了。如果source和destination是同一个键，则相当于原子性的将其关联链表中的尾部元素移到该链表的头部。</td>
<td style="text-align:center">返回弹出和插入的元素。</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>LPUSH/LPUSHX/LRANGE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/&gt; redis-cli    #在Shell提示符下启动redis客户端工具。</div><div class="line">redis 127.0.0.1:6379&gt; del mykey</div><div class="line">(integer) 1</div><div class="line">#mykey键并不存在，该命令会创建该键及与其关联的List，之后在将参数中的values从左到右依次插入。</div><div class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d</div><div class="line">(integer) 4</div><div class="line">#取从位置0开始到位置2结束的3个元素。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 2</div><div class="line">1) &quot;d&quot;</div><div class="line">2) &quot;c&quot;</div><div class="line">3) &quot;b&quot;</div><div class="line">#取链表中的全部元素，其中0表示第一个元素，-1表示最后一个元素。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</div><div class="line">1) &quot;d&quot;</div><div class="line">2) &quot;c&quot;</div><div class="line">3) &quot;b&quot;</div><div class="line">4) &quot;a&quot;</div><div class="line">#mykey2键此时并不存在，因此该命令将不会进行任何操作，其返回值为0。</div><div class="line">redis 127.0.0.1:6379&gt; lpushx mykey2 e</div><div class="line">(integer) 0</div><div class="line">#可以看到mykey2没有关联任何List Value。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey2 0 -1</div><div class="line">(empty list or set)</div><div class="line">#mykey键此时已经存在，所以该命令插入成功，并返回链表中当前元素的数量。</div><div class="line">redis 127.0.0.1:6379&gt; lpushx mykey e</div><div class="line">(integer) 5</div><div class="line">#获取该键的List Value的头部元素。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 0</div><div class="line">1) &quot;e&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>LPOP/LLEN:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d</div><div class="line">(integer) 4</div><div class="line">redis 127.0.0.1:6379&gt; lpop mykey</div><div class="line">&quot;d&quot;</div><div class="line">redis 127.0.0.1:6379&gt; lpop mykey</div><div class="line">&quot;c&quot;</div><div class="line">#在执行lpop命令两次后，链表头部的两个元素已经被弹出，此时链表中元素的数量是2</div><div class="line">redis 127.0.0.1:6379&gt; llen mykey</div><div class="line">(integer) 2</div></pre></td></tr></table></figure>
</li>
<li><p>LREM/LSET/LINDEX/LTRIM:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#为后面的示例准备测试数据。</div><div class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d a c</div><div class="line">(integer) 6</div><div class="line">#从头部(left)向尾部(right)变量链表，删除2个值等于a的元素，返回值为实际删除的数量。</div><div class="line">redis 127.0.0.1:6379&gt; lrem mykey 2 a</div><div class="line">(integer) 2</div><div class="line">#看出删除后链表中的全部元素。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</div><div class="line">1) &quot;c&quot;</div><div class="line">2) &quot;d&quot;</div><div class="line">3) &quot;c&quot;</div><div class="line">4) &quot;b&quot;</div><div class="line">#获取索引值为1(头部的第二个元素)的元素值。</div><div class="line">redis 127.0.0.1:6379&gt; lindex mykey 1</div><div class="line">&quot;d&quot;</div><div class="line">#将索引值为1(头部的第二个元素)的元素值设置为新值e。</div><div class="line">redis 127.0.0.1:6379&gt; lset mykey 1 e</div><div class="line">OK</div><div class="line">#查看是否设置成功。</div><div class="line">redis 127.0.0.1:6379&gt; lindex mykey 1</div><div class="line">&quot;e&quot;</div><div class="line">#索引值6超过了链表中元素的数量，该命令返回nil。</div><div class="line">redis 127.0.0.1:6379&gt; lindex mykey 6</div><div class="line">(nil)</div><div class="line">#设置的索引值6超过了链表中元素的数量，设置失败，该命令返回错误信息。</div><div class="line">redis 127.0.0.1:6379&gt; lset mykey 6 hh</div><div class="line">(error) ERR index out of range</div><div class="line">#仅保留索引值0到2之间的3个元素，注意第0个和第2个元素均被保留。</div><div class="line">redis 127.0.0.1:6379&gt; ltrim mykey 0 2</div><div class="line">OK</div><div class="line">#查看trim后的结果。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</div><div class="line">1) &quot;c&quot;</div><div class="line">2) &quot;e&quot;</div><div class="line">3) &quot;c&quot;</div></pre></td></tr></table></figure>
<ol>
<li>LINSERT:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#删除该键便于后面的测试。</div><div class="line">redis 127.0.0.1:6379&gt; del mykey</div><div class="line">(integer) 1</div><div class="line">#为后面的示例准备测试数据。</div><div class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d e</div><div class="line">(integer) 5</div><div class="line">#在a的前面插入新元素a1。</div><div class="line">redis 127.0.0.1:6379&gt; linsert mykey before a a1</div><div class="line">(integer) 6</div><div class="line">#查看是否插入成功，从结果看已经插入。注意lindex的index值是0-based。</div><div class="line">redis 127.0.0.1:6379&gt; lindex mykey 0</div><div class="line">&quot;e&quot;</div><div class="line">#在e的后面插入新元素e2，从返回结果看已经插入成功。</div><div class="line">redis 127.0.0.1:6379&gt; linsert mykey after e e2</div><div class="line">(integer) 7</div><div class="line">#再次查看是否插入成功。</div><div class="line">redis 127.0.0.1:6379&gt; lindex mykey 1</div><div class="line">&quot;e2&quot;</div><div class="line">#在不存在的元素之前或之后插入新元素，该命令操作失败，并返回-1。</div><div class="line">redis 127.0.0.1:6379&gt; linsert mykey after k a</div><div class="line">(integer) -1</div><div class="line">#为不存在的Key插入新元素，该命令操作失败，返回0。</div><div class="line">redis 127.0.0.1:6379&gt; linsert mykey1 after a a2</div><div class="line">(integer) 0</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>RPUSH/RPUSHX/RPOP/RPOPLPUSH:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">#删除该键，以便于后面的测试。</div><div class="line">redis 127.0.0.1:6379&gt; del mykey</div><div class="line">(integer) 1</div><div class="line">#从链表的尾部插入参数中给出的values，插入顺序是从左到右依次插入。</div><div class="line">redis 127.0.0.1:6379&gt; rpush mykey a b c d</div><div class="line">(integer) 4</div><div class="line">#通过lrange的可以获悉rpush在插入多值时的插入顺序。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</div><div class="line">1) &quot;a&quot;</div><div class="line">2) &quot;b&quot;</div><div class="line">3) &quot;c&quot;</div><div class="line">4) &quot;d&quot;</div><div class="line">#该键已经存在并且包含4个元素，rpushx命令将执行成功，并将元素e插入到链表的尾部。</div><div class="line">redis 127.0.0.1:6379&gt; rpushx mykey e</div><div class="line">(integer) 5</div><div class="line">#通过lindex命令可以看出之前的rpushx命令确实执行成功，因为索引值为4的元素已经是新元素了。</div><div class="line">redis 127.0.0.1:6379&gt; lindex mykey 4</div><div class="line">&quot;e&quot;</div><div class="line">#由于mykey2键并不存在，因此该命令不会插入数据，其返回值为0。</div><div class="line">redis 127.0.0.1:6379&gt; rpushx mykey2 e</div><div class="line">(integer) 0</div><div class="line">#在执行rpoplpush命令前，先看一下mykey中链表的元素有哪些，注意他们的位置关系。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</div><div class="line">1) &quot;a&quot;</div><div class="line">2) &quot;b&quot;</div><div class="line">3) &quot;c&quot;</div><div class="line">4) &quot;d&quot;</div><div class="line">5) &quot;e&quot;</div><div class="line">#将mykey的尾部元素e弹出，同时再插入到mykey2的头部(原子性的完成这两步操作)。</div><div class="line">redis 127.0.0.1:6379&gt; rpoplpush mykey mykey2</div><div class="line">&quot;e&quot;</div><div class="line">#通过lrange命令查看mykey在弹出尾部元素后的结果。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</div><div class="line">1) &quot;a&quot;</div><div class="line">2) &quot;b&quot;</div><div class="line">3) &quot;c&quot;</div><div class="line">4) &quot;d&quot;</div><div class="line">#通过lrange命令查看mykey2在插入元素后的结果。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey2 0 -1</div><div class="line">1) &quot;e&quot;</div><div class="line">#将source和destination设为同一键，将mykey中的尾部元素移到其头部。</div><div class="line">redis 127.0.0.1:6379&gt; rpoplpush mykey mykey</div><div class="line">&quot;d&quot;</div><div class="line">#查看移动结果。</div><div class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</div><div class="line">1) &quot;d&quot;</div><div class="line">2) &quot;a&quot;</div><div class="line">3) &quot;b&quot;</div><div class="line">4) &quot;c&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="链表结构的小技巧"><a href="#链表结构的小技巧" class="headerlink" title="链表结构的小技巧"></a>链表结构的小技巧</h3><p>&ensp;&ensp; 针对链表结构的Value，Redis在其官方文档中给出了一些实用技巧，如RPOPLPUSH命令，下面给出具体的解释。<br>&ensp;&ensp; Redis链表经常会被用于消息队列的服务，以完成多程序之间的消息交换。假设一个应用程序正在执行LPUSH操作向链表中添加新的元素，我们通常将这样的程序称之为”生产者(Producer)”，而另外一个应用程序正在执行RPOP操作从链表中取出元素，我们称这样的程序为”消费者(Consumer)”。如果此时，消费者程序在取出消息元素后立刻崩溃，由于该消息已经被取出且没有被正常处理，那么我们就可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态的不一致等现象的发生。然而通过使用RPOPLPUSH命令，消费者程序在从主消息队列中取出消息之后再将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时我们还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其它的消费者程序继续处理。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--String数据类型]]></title>
      <url>/2017/10/30/Redis/Redis%E5%AD%A6%E4%B9%A0-String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">APPEND key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">如果该Key已经存在，APPEND命令将参数Value的数据追加到已存在Value的末尾。如果该Key不存在，APPEND命令将会创建一个新的Key/Value。</td>
<td style="text-align:center">追加后Value的长度。</td>
</tr>
<tr>
<td style="text-align:center">DECR key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的递减1。如果该Key不存在，其初始值为0，在decr之后其值为-1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">递减后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">INCR key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的递增1。如果该Key不存在，其初始值为0，在incr之后其值为1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">递增后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">DECRBY key decrement</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的减少decrement。如果该Key不存在，其初始值为0，在decrby之后其值为-decrement。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">减少后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">INCRBY key increment</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的增加increment。如果该Key不存在，其初始值为0，在incrby之后其值为increment。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">增加后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">GET key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取指定Key的Value。如果与该Key关联的Value不是string类型，Redis将返回错误信息，因为GET命令只能用于获取string Value。</td>
<td style="text-align:center">与该Key相关的Value，如果该Key不存在，返回nil。</td>
</tr>
<tr>
<td style="text-align:center">SET key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性的设置该Key为指定的Value，同时返回该Key的原有值。和GET命令一样，该命令也只能处理string Value，否则Redis将给出相关的错误信息。</td>
<td style="text-align:center">返回该Key的原有值，如果该Key之前并不存在，则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">STRLEN key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回指定Key的字符值长度，如果Value不是string类型，Redis将执行失败并给出相关的错误信息。</td>
<td style="text-align:center">返回指定Key的Value字符长度，如果该Key不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">SETEX key seconds value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性完成两个操作，一是设置该Key的值为指定字符串，同时设置该Key在Redis服务器中的存活时间(秒数)。该命令主要应用于Redis被当做Cache服务器使用时。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">SETNX key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">如果指定的Key不存在，则设定该Key持有指定字符串Value，此时其效果等价于SET命令。相反，如果该Key已经存在，该命令将不做任何操作并返回。</td>
<td style="text-align:center">1表示设置成功，否则0。</td>
</tr>
<tr>
<td style="text-align:center">SETRANGE key offset value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">替换指定Key的部分字符串值。从offset开始，替换的长度为该命令第三个参数value的字符串长度，其中如果offset的值大于该Key的原有值Value的字符串长度，Redis将会在Value的后面补齐(offset - strlen(value))数量的0x00，之后再追加新值。如果该键不存在，该命令会将其原值的长度假设为0，并在其后添补offset个0x00后再追加新值。鉴于字符串Value的最大长度为512M，因此offset的最大值为536870911。最后需要注意的是，如果该命令在执行时致使指定Key的原有值长度增加，这将会导致Redis重新分配足够的内存以容纳替换后的全部字符串，因此就会带来一定的性能折损。</td>
<td style="text-align:center">修改后的字符串Value长度。</td>
</tr>
<tr>
<td style="text-align:center">GETRANGE key start end</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">如果截取的字符串长度很短，我们可以该命令的时间复杂度视为O(1)，否则就是O(N)，这里N表示截取的子字符串长度。该命令在截取子字符串时，将以闭区间的方式同时包含start(0表示第一个字符)和end所在的字符，如果end值超过Value的字符长度，该命令将只是截取从start开始之后所有的字符数据。</td>
<td style="text-align:center">子字符串</td>
</tr>
<tr>
<td style="text-align:center">SETBIT key offset value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">设置在指定Offset上BIT的值，该值只能为1或0，在设定后该命令返回该Offset上原有的BIT值。如果指定Key不存在，该命令将创建一个新值，并在指定的Offset上设定参数中的BIT值。如果Offset大于Value的字符长度，Redis将拉长Value值并在指定Offset上设置参数中的BIT值，中间添加的BIT值为0。最后需要说明的是Offset值必须大于0</td>
<td style="text-align:center">在指定Offset上的BIT原有值。</td>
</tr>
<tr>
<td style="text-align:center">GETBIT key offset</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回在指定Offset上BIT的值，0或1。如果Offset超过string value的长度，该命令将返回0，所以对于空字符串始终返回0。</td>
<td style="text-align:center">在指定Offset上的BIT值。</td>
</tr>
<tr>
<td style="text-align:center">MGET key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示获取Key的数量。返回所有指定Keys的Values，如果其中某个Key不存在，或者其值不为string类型，该Key的Value将返回nil。</td>
<td style="text-align:center">返回一组指定Keys的Values的列表。</td>
</tr>
<tr>
<td style="text-align:center">MSET key value [key value …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SET命令。</td>
<td style="text-align:center">该命令不会失败，始终返回OK。</td>
</tr>
<tr>
<td style="text-align:center">MSETNX key value [key value …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SETNX命令。然而这里需要明确说明的是，如果在这一批Keys中有任意一个Key已经存在了，那么该操作将全部回滚，即所有的修改都不会生效。</td>
<td style="text-align:center">1表示所有Keys都设置成功，0则表示没有任何Key被修改</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>SET/GET/APPEND/STRLEN:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/&gt; redis-cli   #执行Redis客户端工具。</div><div class="line">redis 127.0.0.1:6379&gt; exists mykey                   #判断该键是否存在，存在返回1，否则返回0。</div><div class="line">(integer) 0</div><div class="line">redis 127.0.0.1:6379&gt; append mykey &quot;hello&quot;      #该键并不存在，因此append命令返回当前Value的长度。</div><div class="line">(integer) 5</div><div class="line">redis 127.0.0.1:6379&gt; append mykey &quot; world&quot;    #该键已经存在，因此返回追加后Value的长度。</div><div class="line">(integer) 11</div><div class="line">redis 127.0.0.1:6379&gt; get mykey                      #通过get命令获取该键，以判断append的结果。</div><div class="line">&quot;hello world&quot;</div><div class="line">redis 127.0.0.1:6379&gt; set mykey &quot;this is a test&quot; #通过set命令为键设置新值，并覆盖原有值。</div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; get mykey</div><div class="line">&quot;this is a test&quot;</div><div class="line">redis 127.0.0.1:6379&gt; strlen mykey                  #获取指定Key的字符长度，等效于C库中strlen函数。</div><div class="line">(integer) 14</div></pre></td></tr></table></figure>
</li>
<li><p>INCR/DECR/INCRBY/DECRBY:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; set mykey 20     #设置Key的值为20</div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; incr mykey         #该Key的值递增1</div><div class="line">(integer) 21</div><div class="line">redis 127.0.0.1:6379&gt; decr mykey        #该Key的值递减1</div><div class="line">(integer) 20</div><div class="line">redis 127.0.0.1:6379&gt; del mykey          #删除已有键。</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; decr mykey        #对空值执行递减操作，其原值被设定为0，递减后的值为-1</div><div class="line">(integer) -1</div><div class="line">redis 127.0.0.1:6379&gt; del mykey   </div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; incr mykey        #对空值执行递增操作，其原值被设定为0，递增后的值为1</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; set mykey hello #将该键的Value设置为不能转换为整型的普通字符串。</div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; incr mykey        #在该键上再次执行递增操作时，Redis将报告错误信息。</div><div class="line">(error) ERR value is not an integer or out of range</div><div class="line">redis 127.0.0.1:6379&gt; set mykey 10</div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; decrby mykey 5 </div><div class="line">(integer) 5</div><div class="line">redis 127.0.0.1:6379&gt; incrby mykey 10</div><div class="line">(integer) 15</div></pre></td></tr></table></figure>
</li>
<li><p>GETSET：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; incr mycounter      #将计数器的值原子性的递增1</div><div class="line">(integer) 1</div><div class="line">#在获取计数器原有值的同时，并将其设置为新值，这两个操作原子性的同时完成。</div><div class="line">redis 127.0.0.1:6379&gt; getset mycounter 0  </div><div class="line">&quot;1&quot;</div><div class="line">redis 127.0.0.1:6379&gt; get mycounter       #查看设置后的结果。</div><div class="line">&quot;0&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>SETEX:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; setex mykey 10 &quot;hello&quot;   #设置指定Key的过期时间为10秒。</div><div class="line">OK    </div><div class="line">#通过ttl命令查看一下指定Key的剩余存活时间(秒数)，0表示已经过期，-1表示永不过期。</div><div class="line">redis 127.0.0.1:6379&gt; ttl mykey                       </div><div class="line">(integer) 4</div><div class="line">redis 127.0.0.1:6379&gt; get mykey                      #在该键的存活期内我们仍然可以获取到它的Value。</div><div class="line">&quot;hello&quot;</div><div class="line">redis 127.0.0.1:6379&gt; ttl mykey                        #该ttl命令的返回值显示，该Key已经过期。</div><div class="line">(integer) 0</div><div class="line">redis 127.0.0.1:6379&gt; get mykey                      #获取已过期的Key将返回nil。</div><div class="line">(nil)</div></pre></td></tr></table></figure>
</li>
<li><p>SETNX:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; del mykey                      #删除该键，以便于下面的测试验证。</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; setnx mykey &quot;hello&quot;        #该键并不存在，因此该命令执行成功。</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; setnx mykey &quot;world&quot;       #该键已经存在，因此本次设置没有产生任何效果。</div><div class="line">(integer) 0</div><div class="line">redis 127.0.0.1:6379&gt; get mykey                      #从结果可以看出，返回的值仍为第一次设置的值。</div><div class="line">&quot;hello&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>SETRANGE/GETRANGE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; set mykey &quot;hello world&quot;       #设定初始值。</div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; setrange mykey 6 dd          #从第六个字节开始替换2个字节(dd只有2个字节)</div><div class="line">(integer) 11</div><div class="line">redis 127.0.0.1:6379&gt; get mykey                         #查看替换后的值。</div><div class="line">&quot;hello ddrld&quot;</div><div class="line">redis 127.0.0.1:6379&gt; setrange mykey 20 dd        #offset已经超过该Key原有值的长度了，该命令将会在末尾补0。</div><div class="line">(integer) 22</div><div class="line">redis 127.0.0.1:6379&gt; get mykey                           #查看补0后替换的结果。</div><div class="line">&quot;hello ddrld\x00\x00\x00\x00\x00\x00\x00\x00\x00dd&quot;</div><div class="line">redis 127.0.0.1:6379&gt; del mykey                         #删除该Key。</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; setrange mykey 2 dd         #替换空值。</div><div class="line">(integer) 4</div><div class="line">redis 127.0.0.1:6379&gt; get mykey                        #查看替换空值后的结果。</div><div class="line">&quot;\x00\x00dd&quot;   </div><div class="line">redis 127.0.0.1:6379&gt; set mykey &quot;0123456789&quot;   #设置新值。</div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; getrange mykey 1 2      #截取该键的Value，从第一个字节开始，到第二个字节结束。</div><div class="line">&quot;12&quot;</div><div class="line">redis 127.0.0.1:6379&gt; getrange mykey 1 20   #20已经超过Value的总长度，因此将截取第一个字节后面的所有字节。</div><div class="line">&quot;123456789&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>SETBIT/GETBIT:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; del mykey</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; setbit mykey 7 1       #设置从0开始计算的第七位BIT值为1，返回原有BIT值0</div><div class="line">(integer) 0</div><div class="line">redis 127.0.0.1:6379&gt; get mykey                #获取设置的结果，二进制的0000 0001的十六进制值为0x01</div><div class="line">&quot;\x01&quot;</div><div class="line">redis 127.0.0.1:6379&gt; setbit mykey 6 1       #设置从0开始计算的第六位BIT值为1，返回原有BIT值0</div><div class="line">(integer) 0</div><div class="line">redis 127.0.0.1:6379&gt; get mykey                #获取设置的结果，二进制的0000 0011的十六进制值为0x03</div><div class="line">&quot;\x03&quot;</div><div class="line">redis 127.0.0.1:6379&gt; getbit mykey 6          #返回了指定Offset的BIT值。</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; getbit mykey 10        #Offset已经超出了value的长度，因此返回0。</div><div class="line">(integer) 0</div></pre></td></tr></table></figure>
</li>
<li><p>MSET/MGET/MSETNX:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; mset key1 &quot;hello&quot; key2 &quot;world&quot;   #批量设置了key1和key2两个键。</div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; mget key1 key2                        #批量获取了key1和key2两个键的值。</div><div class="line">1) &quot;hello&quot;</div><div class="line">2) &quot;world&quot;</div><div class="line">#批量设置了key3和key4两个键，因为之前他们并不存在，所以该命令执行成功并返回1。</div><div class="line">redis 127.0.0.1:6379&gt; msetnx key3 &quot;stephen&quot; key4 &quot;liu&quot; </div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; mget key3 key4                   </div><div class="line">1) &quot;stephen&quot;</div><div class="line">2) &quot;liu&quot;</div><div class="line">#批量设置了key3和key5两个键，但是key3已经存在，所以该命令执行失败并返回0。</div><div class="line">redis 127.0.0.1:6379&gt; msetnx key3 &quot;hello&quot; key5 &quot;world&quot; </div><div class="line">(integer) 0</div><div class="line">#批量获取key3和key5，由于key5没有设置成功，所以返回nil。</div><div class="line">redis 127.0.0.1:6379&gt; mget key3 key5                   </div><div class="line">1) &quot;stephen&quot;</div><div class="line">2) (nil)</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[servlet的9大内置对象]]></title>
      <url>/2017/10/28/servlet%E7%9A%849%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">隐式对象</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">request</td>
<td style="text-align:center">转译后的HttpServletRquest/ServletRequest对象</td>
</tr>
<tr>
<td style="text-align:center">response</td>
<td style="text-align:center">转译后对应HttpServletRespons/ServletResponse对象</td>
</tr>
<tr>
<td style="text-align:center">session</td>
<td style="text-align:center">转译后对应HttpSession对象</td>
</tr>
<tr>
<td style="text-align:center">application</td>
<td style="text-align:center">转译后对应ServletContext对象</td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td style="text-align:center">转译后对应JspWriter对象，其内部关联一个PringWriter对象</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">转译后对应this</td>
</tr>
<tr>
<td style="text-align:center">config</td>
<td style="text-align:center">转译后对应ServletConfig对象</td>
</tr>
<tr>
<td style="text-align:center">exception</td>
<td style="text-align:center">转译后对应Throwable对象，代表由其他JSP页面抛出的异常对象，只会出现于JSP错误页面(isErrorPage设置为true的JSP页面)</td>
</tr>
<tr>
<td style="text-align:center">pageContext</td>
<td style="text-align:center">转译后对应PageContext对象，它提供了JSP页面资源的封装，并可设置页面范围属性</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="JSP隐含变量"><a href="#JSP隐含变量" class="headerlink" title="JSP隐含变量"></a>JSP隐含变量</h2><p>1.out 来源于Java.io.Writer类，它用于发送输出流到客户端。<br>2.request 来源于javax.servlet.http.HttpServletRequest接口。它被关联到每一个HTTP请求。<br>3.response 来源于javax.servlet.http.HttpServletResponse。response对象用于把取得的数据返回到客户端。<br>4.pageContext 提供访问JSP页面的命名空间。它也提供用来访问其他的JSP隐含对象。<br>5.session 来源于javax.servlet.http.HttpSession。它用于存储客户端请求的信息，因此它是有状态交互式的。<br>6.application 来源于javax.servlet.ServletContext。<br>7.config 来源于ServletConfig，它包含了当前JSP/Servlet所在的WEB应用的配置信息。<br>8.page 来源于当前被访问JSP页面的实例化。它实际使用的是JSP转换成的Servlet。<br>9.exception 用于捕获JSP抛出的异常。它只有在JSP页面属性isErrorPage=true时才可用。</p>
<h3 id="一、request对象："><a href="#一、request对象：" class="headerlink" title="一、request对象："></a>一、request对象：</h3><p>&ensp;&ensp;该对象封装了用户提交的信息，通过调用该对象相应的方法可以获取封装的信息， 即使用该对象可以获取用户提交信息。 客户端的请求参数都被封装到这个对象里面</p>
<h3 id="二、response对象："><a href="#二、response对象：" class="headerlink" title="二、response对象："></a>二、response对象：</h3><p>&ensp;&ensp;对客户的请求做出动态的响应，向客户发送数据。</p>
<h3 id="三、session对象："><a href="#三、session对象：" class="headerlink" title="三、session对象："></a>三、session对象：</h3><p>&ensp;&ensp;1.什么是session：session对象是一个JSP内置对象，它在第一个JSP页面被装载时自动创建，完成会话期管理。<br>从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。当一个客户访问一个服务器时，可能会在这个服务器的几个页面之间反复连接，反复刷新一个页面，服务器应当通过某种办法知道这是同一个客户，这就需要session对象。</p>
<p>&ensp;&ensp;2．session对象的ID：当一个客户首次访问服务器上的一个JSP页面时，JSP引擎产生一个session对象，同时分配一个String类型的ID号，JSP引擎同时将这个ID号发送到客户端，存放在Cookie中，这样session对象和客户之间就建立了一一对应的关系。当客户再访问连接该服务器的其他页面时，不再分配给客户新的session对象，直到客户关闭浏览器后，服务器端该客户的session对象才取消，并且和客户的会话对应关系消失。当客户重新打开浏览器再连接到该服务器时，服务器为该客户再创建一个新的session对象。</p>
<h3 id="四、aplication对象："><a href="#四、aplication对象：" class="headerlink" title="四、aplication对象："></a>四、aplication对象：</h3><p>&ensp;&ensp;1．什么是application:<br>服务器启动后就产生了这个application对象，当客户在所访问的网站的各个页面之间浏览时，这个application对象都是同一个，直到服务器关闭。但是与session不同的是，所有客户的application对象都是同一个，即所有客户共享这个内置的application对象。</p>
<p>&ensp;&ensp;2．application对象常用方法:<br>(1)public void setAttribute(String key,Object obj): 将参数Object指定的对象obj添加到application对象中，并为添加的对象指定一个索引关键字。<br>(2)public Object getAttribute(String key): 获取application对象中含有关键字的对象。 </p>
<h3 id="五、out对象："><a href="#五、out对象：" class="headerlink" title="五、out对象："></a>五、out对象：</h3><p>&ensp;&ensp;out 对象是一个输出流，用来向客户端输出数据。out对象用于各种数据的输出。</p>
<h3 id="六、page-java-lang-Object："><a href="#六、page-java-lang-Object：" class="headerlink" title="六、page java.lang.Object："></a>六、page java.lang.Object：</h3><p>&ensp;&ensp;对应this关键字。JSP网页本身<br>page对象是当前页面转换后的Servlet类的实例。从转换后的Servlet类的代码中，可以看到这种关系：<br>Object page = this;<br>在JSP页面中，很少使用page对象。</p>
<h3 id="七、config："><a href="#七、config：" class="headerlink" title="七、config："></a>七、config：</h3><p>&ensp;&ensp;javax.servlet. ServletConfig 的实例，该实例代表该JSP 的配置信息。常用的方法有getInitPararneter(String paramNarne) 及getInitPararneternarnes() 等方法。事实上， JSP 页面通常无须配置，也就不存在配置信息。因此，该对象更多地在Servlet 中有效。</p>
<h3 id="八、exception-java-lang-Throwable-的实例："><a href="#八、exception-java-lang-Throwable-的实例：" class="headerlink" title="八、exception java.lang.Throwable 的实例："></a>八、exception java.lang.Throwable 的实例：</h3><p>&ensp;&ensp;该实例代表其他页面中的异常和错误。只有当页面是错误处理页面，即编译指令page 的isErrorPage 属性为true 时，该对象才可以使用。常用的方法有getMessageO和printStackTraceO等。</p>
<h3 id="九、pageContext："><a href="#九、pageContext：" class="headerlink" title="九、pageContext："></a>九、pageContext：</h3><p>&ensp;&ensp;out 对象是一个输出流，用来向客户端输出数据。out对象用于各种数据的输出。</p>
<hr>
<p>//使用pageContext 设置属性，该属性默认在page 范围内<br>pageContext. setAttribute (“page” , “hello”) ; </p>
<p>  //使用request 设置属性，该属性默认在request 范围内<br>request. setAttribute (“request” , “hello”); </p>
<p>  //使用pageContext将属性设置在request 范围中<br>pageContext.setAttribute(“request2” , “hello” , pageContext.REQUEST_SCOPE); </p>
<p>  // 使用session将属性设置在session 范围中<br>session.setAttribute(“session” , “hello”l; </p>
<p>  //使用pageContext将属性设置在session范围中<br>pageContext.setAttribute(“session2” , “hello” , pageContext.SESSION_SCOPE); </p>
<p>  //使用application将属性设置在application范围中<br>application. setAttribute (“app” , “hello”) ; </p>
<p>  //使用pageContext 将属性设置在application 范围中<br>pageContext.setAttribute(“app2” , “hello” , pageContext.APPL 工CATION_SCOPE) ;</p>
<hr>
<h2 id="四个作用域："><a href="#四个作用域：" class="headerlink" title="四个作用域："></a>四个作用域：</h2><h3 id="application："><a href="#application：" class="headerlink" title="application："></a>application：</h3><p>全局作用范围，整个应用程序共享，就是在部署文件中的同一个webApp共享，生命周期为：应用程序启动到停止。</p>
<h3 id="session："><a href="#session：" class="headerlink" title="session："></a>session：</h3><p>会话作用域，当用户首次访问时，产生一个新的会话，以后服务器就可以记住这个会话状态。生命周期：会话超时，或者服务器端强制使会话失效。</p>
<h3 id="request"><a href="#request" class="headerlink" title="request:"></a>request:</h3><p>请求作用域，就是客户端的一次请求。</p>
<h3 id="page："><a href="#page：" class="headerlink" title="page："></a>page：</h3><p>一个JSP页面。</p>
<p>以上作用范围使越来越小， request和page的生命周期都是短暂的，他们之间的区别就是：一个request可以包含多个page页(include，forward以及filter)。</p>
]]></content>
      
        <categories>
            
            <category> JAVA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ActionContext]]></title>
      <url>/2017/10/21/ActionContext/</url>
      <content type="html"><![CDATA[<h3 id="ActionContext"><a href="#ActionContext" class="headerlink" title="ActionContext"></a><center>ActionContext</center></h3><p>&ensp;&ensp;ActionContext是Action的上下文，Struct2自动在其中保存了一些在Action执行过程中所需的对象，比如session、parameters、locale等。Struts2会根据每个执行HTTp请求的线程来创建对应的ActionContext，即一个线程只有一个唯一的ActionContext。因此，使用者可以使用静态方法ActionContext.getContext&#40;&#41;来获取当前线程的ActionContext，也正是由于这个原因，使用者不用去操心让Action是线程安全的。</p>
<p>&ensp;&ensp;无论如何，ActionContext都是用来存放数据的。Struts2本身会在其中放入不少数据，而使用者也可以放入自己想要的数据。ActionContext本身的数据结构是映射结构，即一个Map，用key来映射value。所以使用者完全可以像使用Map一样来使用它，或者直接使用Action.getContextMap&#40;&#41;方法来对Map进行操作。</p>
<p>&ensp;&ensp;Struts2本身在其中放入的数据有Actionlnvocation、application&#40;即ServletContext&#41;、conversionErrors、Locale、action的name、request的参数、HTTP的Session以及值栈等。完整的列表请参考它的Javadoc。</p>
<p>&ensp;&ensp;由于ActionContext的线程唯一和静态方法就能获得的特性，使得在非Action类中可以直接获得它，而不需要等待Action传入或注入。<font color="#DC143C">需要注意的是，它仅在由于request而创建的线程中有效&#40;因为request时才创建对应的ActionContext&#41;，而在服务器启动的线程中&#40;比如fliter的init方法&#41;无效。</font>由于在非Action类中访问其的方便性，ActionContext也可以用来在非Action类中向JSP传递数据&#40;因为JSP也能很方便的访问它&#41;。<br><a id="more"></a></p>
<h3 id="ValueStack与ActionContext的联系和区别"><a href="#ValueStack与ActionContext的联系和区别" class="headerlink" title="ValueStack与ActionContext的联系和区别"></a><center>ValueStack与ActionContext的联系和区别</center></h3><p>&ensp;&ensp;<font color="#DC143C">相同点：它们都是在一次HTTP请求的范围内使用的，即它们的生命周期都是一次请求。<br>&ensp;&ensp;不同点：值栈是栈的结构，ActionContext是映射&#40;Map&#41;的结构。</font></p>
<p>&ensp;&ensp;联系：ValueStack.getContext&#40;&#41;方法得到的Map其实就是ActionContext的Map。查看Struts2的源代码可知&#40;Struts2.3.1.2的org.apache.struts2.dispatcher.ng.PrepareOperations的第79行，createActionContext方法&#41;，在创建ActionContext时，就是把ValueStack.getContext&#40;&#41;作为ActionContext的构造函数的参数。所以，ValueStack和ActionContext本质上可以互相获得。</p>
<p>&ensp;&ensp;注意：在一些文档中，会出现把对象存入“stack‘s context”的字样，其实就是把值存入了ActionContext。所以在阅读这些文档时，要看清楚，到底是放入了栈结构&#40;即值栈&#41;，还是映射结构&#40;值栈的context，即ActionContext&#41;。</p>
<h3 id="如何获得ActionContext"><a href="#如何获得ActionContext" class="headerlink" title="如何获得ActionContext"></a><center>如何获得ActionContext</center></h3><p>&ensp;&ensp;在自定义的拦截器中：使用ActionInvocation.getInvocationContext&#40;&#41;或者使用ActionContext.getContext&#40;&#41;。</p>
<p>&ensp;&ensp;在Action类中：让拦截器注入或者使用ActionContext.getContext&#40;&#41;。</p>
<p>&ensp;&ensp;在非Action类中：让Action类传递参数、使用注入机制注入或者使用ActionContext.getContext&#40;&#41;。</p>
<p>&ensp;&ensp;<font color="#DC143C">注意：只有运行在request线程中的代码才能调用ActionContext.getContext&#40;&#41;，否则返回的是null。<br>在JSP中：一般不需要获得ActionContext本身。</font></p>
<h3 id="如何向ActionContext存入值"><a href="#如何向ActionContext存入值" class="headerlink" title="如何向ActionContext存入值"></a><center>如何向ActionContext存入值</center></h3><p>&ensp;&ensp;在拦截器、Action类、非Action类等Java类中：使用ActionContext.put&#40;Object key,Object value&#41;方法。</p>
<p>&ensp;&ensp;在JSP中：标签<s:set value="...">默认将值存入ActionContext中&#40;当然，<s:set>标签还可以把值存到其他地方&#41;。</s:set></s:set></p>
<p>&ensp;&ensp;另外，许多标签都有var属性&#40;以前用的是id属性，现在id属性已被抛弃&#41;，这个属性能向ActionContext存入值，key为var属性的值，value为标签的value值。&#40;有些文档写的是向ValueStack的context存入值，其实是一样的&#41;</p>
<h3 id="如何向ActionContext读取值"><a href="#如何向ActionContext读取值" class="headerlink" title="如何向ActionContext读取值"></a><center>如何向ActionContext读取值</center></h3><p>&ensp;&ensp;在拦截器、Action类、非Action类等Java类中：使用ActionContext.get&#40;Object key&#41;方法。</p>
<p>&ensp;&ensp;在JSP中：使用#开头的Ognl表达式解析，则需要使用%&#123;&#125;把表达式括起来，于是就会出现类似“%&#123;#name&#125;”的表达式。</p>
<p>&ensp;&ensp;在JSP中：总之，在JSP中使用ActionContext一方面由于它是映射结构，另一方面是能读取Action的一些配置。当你需要为许多Action提供通用的值的话，可以让每个Action都提供getXXX&#40;&#41;方法，但更好的方法是在拦截器或JSP模板中把这些通用的值存放到ActionC中&#40;因为拦截器或JSP模板往往通用于多个Action&#41;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 本类将演示拦截器中对ActionContext的操作   </span></div><div class="line">publicclass MyInterceptor extends AbstractInterceptor &#123;   </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception </span>&#123;   </div><div class="line">        <span class="comment">// 获得ActionContext   </span></div><div class="line">        ActionContext actionContext = invocation.getInvocationContext();   </div><div class="line">        <span class="comment">// 存入值   </span></div><div class="line">        Person person = <span class="keyword">new</span> Person();   </div><div class="line">        actionContext.put(<span class="string">"person"</span>, person);   </div><div class="line">        <span class="comment">// 获取值   </span></div><div class="line">        Object value = actionContext.get(<span class="string">"person"</span>);   </div><div class="line">        <span class="comment">// 获取HttpServletRequest   </span></div><div class="line">        HttpServletRequest request = (HttpServletRequest) actionContext.get(StrutsStatics.HTTP_REQUEST);   </div><div class="line">        <span class="comment">// 获取request的Map，即HttpServletRequest.getAttribute(...)和HttpServletRequest.setAttribute(...)所操作的值  </span></div><div class="line">        Map requestMap = (Map) actionContext.get(<span class="string">"request"</span>);   </div><div class="line">        <span class="comment">// 其他代码   </span></div><div class="line">        <span class="comment">// ......   </span></div><div class="line">        <span class="keyword">return</span> invocation.invoke();   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 本类将演示在Action中对ActionContext进行操作   </span></div><div class="line">publicclass MyAction extends ActionSupport &#123;   </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;   </div><div class="line">        <span class="comment">// 获得值栈   </span></div><div class="line">        ActionContext actionContext = ActionContext.getContext();   </div><div class="line">        <span class="comment">// 存入值   </span></div><div class="line">        Person person = <span class="keyword">new</span> Person();<span class="comment">// 这是之前例子中定义的类  </span></div><div class="line">        actionContext.put(<span class="string">"person"</span>, person);   </div><div class="line">        <span class="comment">// 获取值   </span></div><div class="line">        Object object = actionContext.get(<span class="string">"person"</span>);   </div><div class="line">        <span class="comment">// 其他代码   </span></div><div class="line">        <span class="comment">// ......   </span></div><div class="line">        <span class="keyword">return</span> SUCCESS;   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">metahttp-equiv="Content-Type"content="text</span>/<span class="attr">html</span>; <span class="attr">charset</span>=<span class="string">UTF-8</span>"&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </div><div class="line">        <span class="comment">&lt;!-- 本JSP将演示在JSP中对ActionContext的使用 --&gt;</span>  </div><div class="line">        <span class="comment">&lt;!-- 本JSP为MyAction对应的JSP --&gt;</span>  </div><div class="line">  </div><div class="line">        <span class="comment">&lt;!-- 由于Action中已经向ActionContext存入了key为"person"的值，所以可以使用“#person”来获取它，如下  --&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#person"</span>/&gt;</span>  </div><div class="line">        <span class="comment">&lt;!-- 获得person的name属性，如下  --&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#person.name"</span>/&gt;</span>  </div><div class="line">        <span class="comment">&lt;!-- 获得Struts2在ActionContext中存入的值，比如request的Map，如下  --&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#request"</span>/&gt;</span>  </div><div class="line">        <span class="comment">&lt;!-- 获得Struts2在ActionContext中存入的值，比如session的Map，如下  --&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#session"</span>/&gt;</span>  </div><div class="line">        <span class="comment">&lt;!-- 获得Struts2在ActionContext中存入的值，request请求传递的GET参数或POST参数的Map，如下  --&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#parameters"</span>/&gt;</span>  </div><div class="line">           </div><div class="line">        <span class="comment">&lt;!-- 以下演示在JSP中把值存入ActionContext中  --&gt;</span>  </div><div class="line">        <span class="comment">&lt;!-- 存入一个字符串"myName"，key为"myKey"，如下 --&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">s:setvalue="%&#123;‘myName‘&#125;"var="myKey"</span>/&gt;</span>  </div><div class="line">        <span class="comment">&lt;!-- 使用s:bean标签来创建一个对象，并把它存入ActionContext中，key为myObject，如下  --&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">s:beanname="com.example.Person"var="myObject"</span>/&gt;</span>  </div><div class="line">        <span class="comment">&lt;!-- 之后就可以用“#”来读取它们，如下  --&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#myKey"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#myObject"</span>/&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Struts2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java内存区域]]></title>
      <url>/2017/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="http://ocx5m3vc3.bkt.clouddn.com/JVM_1.jpg" alt=""><br><a id="more"></a></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>&ensp;&ensp;程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。（此内存区域是唯一一个在JAVA虚拟机规范中没有规定任何OME情况的区域）</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>&ensp;&ensp;与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>&ensp;&ensp;本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java（也就是字节码）服务，而本地方法栈则为虚拟机使用的Native方法服务。在虚拟机规范中对本地方法栈中使用的语言、使用方式、与数据结构并没有强制规定，因此具体的虚拟机可以自由的实现它。甚至有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>&ensp;&ensp;对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>&ensp;&ensp;方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个一个别名叫做Non-Heap（非栈），目的应该是与Java堆分开来。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>&ensp;&ensp;运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，已不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用。</p>
<h2 id="虚拟机对象探索"><a href="#虚拟机对象探索" class="headerlink" title="虚拟机对象探索"></a>虚拟机对象探索</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>&ensp;&ensp;虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。<br>&ensp;&ensp;在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后完全可以确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>
<ul>
<li>指针碰撞</li>
<li>空闲列表</li>
</ul>
<p>&ensp;&ensp;内存分配完成后，虚拟机需要将分配到的内存空间都初始化零值。<br>&ensp;&ensp;接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。<br>&ensp;&ensp;在上面工作都完成后，从虚拟机的视角看，一个新的对象已经产生了，但从Java程序的视角来就看，对象创建才刚刚开始—<init>方法还没有执行所有字段都还为零。</init></p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>&ensp;&ensp;对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><ul>
<li>句柄访问</li>
<li>直接指针</li>
</ul>
]]></content>
      
        <categories>
            
            <category> JAVA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[static]]></title>
      <url>/2017/10/18/static/</url>
      <content type="html"><![CDATA[<h1 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用:"></a>static的作用:</h1><h2 id="不考虑类"><a href="#不考虑类" class="headerlink" title="不考虑类"></a>不考虑类</h2><h3 id="第一个作用：隐藏"><a href="#第一个作用：隐藏" class="headerlink" title="第一个作用：隐藏"></a>第一个作用：隐藏</h3><p>&ensp;&ensp;当我们同时编译多个文件时，所有未加static前缀的<strong>全局变量</strong>和<strong>函数</strong>都具有全局可见性。</p>
<p>&ensp;&ensp;如果加了static，就会对其他源文件隐藏，利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。</p>
<hr>
<ul>
<li>static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用<a id="more"></a>
</li>
</ul>
<hr>
<h3 id="第二个作用：默认初始化为0"><a href="#第二个作用：默认初始化为0" class="headerlink" title="第二个作用：默认初始化为0"></a>第二个作用：默认初始化为0</h3><p>&ensp;&ensp;包括未初始化的全局静态变量与局部静态变量。其实未初始化的全局变量也具备这一属性，因为未初始化的全局变量与未初始化的静态变量是存储在同一块区域内的（BBS段）。</p>
<p>&ensp;&ensp;在BBS段中，内存中所有的字节默认值都是0x00，某些时候这一特性可以减少程序员的工作量。</p>
<h3 id="第三个作用：保持局部变量内容的持久"><a href="#第三个作用：保持局部变量内容的持久" class="headerlink" title="第三个作用：保持局部变量内容的持久"></a>第三个作用：保持局部变量内容的持久</h3><p>&ensp;&ensp;函数内的自动（局部）变量，当调用时就存在，退出函数时就消失，当静态局部变量虽然在函数内定义，当静态局部变量始终存在着，也就是说它的生存周期为整个源程序，其特点就是只进行一次初始化且具有“记忆性”。</p>
<p>&ensp;&ensp;静态局部变量的生存期虽然为整个源程序，但是其作用域仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出函数后，尽管该变量还继续存在，但是不能使用它。</p>
<hr>
<h2 id="类中static的作用"><a href="#类中static的作用" class="headerlink" title="类中static的作用"></a>类中static的作用</h2><p>&ensp;&ensp;C++重用了static这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定的对象的变量和函数（和Java中此关键字的含义相同）</p>
<ul>
<li>静态数据成员</li>
<li>静态成员函数</li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[虚函数]]></title>
      <url>/2017/10/18/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>引入原因：为了方便使用多态特性，我们常常需要在基类中定于虚函数。</p>
<p>关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p>
<p><strong>虚函数表</strong><br><a id="more"></a><br>&emsp;&ensp;虚函数是通过一张虚函数表来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p>
<p>这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。<br>假设我们有这样的一个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line">Base b;</div><div class="line">Fun pFun = <span class="literal">NULL</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表地址："</span> &lt;&lt; (<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表 — 第一个函数地址："</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="comment">//这里的一点争议的个人看法：</span></div><div class="line">原文认为(<span class="keyword">int</span>*)(&amp;b)是虚表的地址，而很多网友都说，（包括我也认为）：(<span class="keyword">int</span> *)*(<span class="keyword">int</span>*)(&amp;b)才是虚表地址</div><div class="line">而(<span class="keyword">int</span>*)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)); 才是虚表第一个虚函数的地址。</div><div class="line">其实看后面的调用pFun = (Fun)*((int*)*(int*)(&amp;b)); 就可以看出，*((int*)*(int*)(&amp;b));转成函数指针给pFun，然后正确的调用到了虚函数virtual void f()。</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Invoke the first virtual function</span></div><div class="line">pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b));</div><div class="line">pFun();</div><div class="line">实际运行经果如下：(Windows XP+VS2003, Linux <span class="number">2.6</span><span class="number">.22</span> + GCC <span class="number">4.1</span><span class="number">.3</span>)</div><div class="line">虚函数表地址：<span class="number">0012F</span>ED4</div><div class="line">虚函数表 — 第一个函数地址：<span class="number">0044F</span>148</div><div class="line">Base::f</div><div class="line">通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成<span class="keyword">int</span> *，取得</div><div class="line">虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也</div><div class="line">就是Base::f()，这在上面的程序中得到了验证（把<span class="keyword">int</span>* 强制转成了函</div><div class="line">数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和</div><div class="line">Base::h()，其代码如下：</div><div class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>); <span class="comment">// Base::f()</span></div><div class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>); <span class="comment">// Base::g()</span></div><div class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>); <span class="comment">// Base::h()</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>一般继承（无虚函数覆盖）</strong></p>
<p>下面，让我们来看看继承时的虚函数表示什么样的。假设有如下所以的一个继承关系：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_2.jpg" alt=""></p>
<p>请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：<br>对于实例：Derive d; 的虚函数表如下：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_3.jpg" alt=""></p>
<p>我们可以看到下面几点：</p>
<p>1.虚函数按照其声明顺序放于表中。</p>
<p>2.父类的虚函数在子类的虚函数前面。</p>
<p><strong>一般继承（有虚函数覆盖）</strong></p>
<p>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_4.jpg" alt=""></p>
<p>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_5.jpg" alt=""></p>
<p>我们从表中可以看到下面几点：</p>
<p>1.覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</p>
<p>2.没有被覆盖的函数依旧。</p>
<p><strong>多重继承（无虚函数覆盖）</strong></p>
<p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_6.jpg" alt=""></p>
<p>对于子类实例中的虚函数表，是下面这个样子：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_7.jpg" alt=""></p>
<p>我们可以看到：</p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<p><strong>多重继承（有虚函数覆盖）</strong></p>
<p>下面我们再来看看，如果发生虚函数覆盖的情况。</p>
<p>下图中，我们在子类中覆盖了父类的f()函数。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_8.jpg" alt=""></p>
<p>下面是对于子类实例中的虚函数表的图：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_9.jpg" alt=""></p>
<p>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。</p>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深复制和浅复制]]></title>
      <url>/2017/10/18/%E6%B7%B1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B5%85%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>浅复制：被复制对象的所有变量都含有与原来对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>深复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></div><div class="line">	<span class="keyword">char</span> *ptr;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shallow_copy</span><span class="params">(Test &amp; src,Test &amp; dest)</span></span>&#123;</div><div class="line">	dest.ptr = src.ptr;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deep_copy</span><span class="params">(Test &amp; src,Test &amp; dest)</span></span>&#123;</div><div class="line">	dest.ptr=<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src.ptr)+<span class="number">1</span>);</div><div class="line">	<span class="built_in">memcpy</span>(dest.ptr,src.ptr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>浅复制可能会导致运行时错误，特别是在对象的创建和删除过程中。</p>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存泄露和缓冲区溢出]]></title>
      <url>/2017/10/18/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
      <content type="html"><![CDATA[<p>什么是内存泄露？</p>
<ul>
<li>一般我们常说的内存泄露是指堆内存的泄露。堆内存是指程序从堆中分配的，大小任意的内存块，使用完后必须显示释放的内存。应用程序一般使用malloc、realloc、new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能再被使用，我们就说这块内存泄露了。</li>
</ul>
<hr>
<p>什么是缓冲区溢出？</p>
<ul>
<li>缓冲区溢出是指向缓冲区内填充数据位数超过了缓冲区本身的容量限制，导致溢出的数据覆盖在合法数据上的情况。理想的情况是程序检查数据长度并不允许输出超出缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的存储空间相匹配，这九尾缓冲区溢出埋下了隐患。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring工作流程]]></title>
      <url>/2017/10/18/Spring%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Spring_Running_1.png" alt=""></p>
<a id="more"></a>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Spring_Running_2.png" alt=""></p>
<hr>
<p>Spring工作流程描述：<br>1.用户向服务器发送请求，请求被Spring前端控制Servlet DispatcherServlet捕获；</p>
<p>2.DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象相应的拦截器），最后以HandlerExecutionChain对象的形式返回。</p>
<p>3.DispatcherServlet根据获得Handler，选择一个合适HandlerAdapter。（如果成功获取HandlerAdapter后，此时将开始执行拦截器的PreHandler方法）</p>
<p>4.提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller）。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConveter：将请求消息（如Json、Xml等数据）转化成一个对象，将对象转换成指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>
<li>数据格式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证：验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ul>
<p>5.Handler执行完成后，先DispatcherServlet返回一个ModelAndView对象</p>
<p>6.根据返回的ModelAndView，选择一个合适的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet</p>
<p>7.ViewResolver结合Model和View来渲染视图</p>
<p>8.将渲染结果返回给客户端</p>
<hr>
<p>Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler？</p>
<p>答：符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的是代码可复用性高。如HandlerAdapter可能会被用于处理多种Handler。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP与UDP的区别]]></title>
      <url>/2017/10/17/tcp%E4%B8%8Eudp/</url>
      <content type="html"><![CDATA[<p>1.TCP是面向连接的，在传输数据前需要建立连接；UDP是无连接的，发送数据前不需要建立连接。<br>2.TCP提供<strong>可靠</strong>的传输服务；UDP提供<strong>不可靠</strong>的传输服务。<br>3.TCP发送数据大小会受发送窗口、接收窗口及MSS（最大报文段）限制，所以会多段发送；UDP发送数据大小即为数据本身大小。<br>4.TCP拥有众多反馈机制和附加机制；UDP没有反馈机制。<br>5.TCP传输速度慢；UDP传输速度快。</p>
<p>TCP适合文件下载等传输任务，UDP适合媒体流等看中传输速度的传输任务。</p>
]]></content>
      
        <categories>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java的四种线程池]]></title>
      <url>/2017/10/17/%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>Java通过Executors提供了四种线程池：</p>
<ul>
<li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(index * <span class="number">1000</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">   &#125;</div><div class="line">   cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">     System.out.println(index);</div><div class="line">    &#125;</div><div class="line">   &#125;);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程.</p>
<ul>
<li>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超过的线程会在队列中等待。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">  ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;  </div><div class="line">   fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">     <span class="keyword">try</span> &#123;  </div><div class="line">      System.out.println(index);  </div><div class="line">      Thread.sleep(<span class="number">2000</span>);  </div><div class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">      e.printStackTrace();  </div><div class="line">     &#125;  </div><div class="line">    &#125;  </div><div class="line">   &#125;);  </div><div class="line">  &#125;  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以没两秒打印3个数字。</p>
<ul>
<li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">  ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);  </div><div class="line">  scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">    System.out.println(<span class="string">"delay 3 seconds"</span>);  </div><div class="line">   &#125;  </div><div class="line">  &#125;, <span class="number">3</span>, TimeUnit.SECONDS);  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>表示延迟3秒执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">  ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);  </div><div class="line">  scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">    System.out.println(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);  </div><div class="line">   &#125;  </div><div class="line">  &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>表示延迟1秒后每3秒执行一次。</p>
<ul>
<li>newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照指定顺序（FIFO，LIFO,优先级）执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">  ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;  </div><div class="line">   singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">     <span class="keyword">try</span> &#123;  </div><div class="line">      System.out.println(index);  </div><div class="line">      Thread.sleep(<span class="number">2000</span>);  </div><div class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">      e.printStackTrace();  </div><div class="line">     &#125;  </div><div class="line">    &#125;  </div><div class="line">   &#125;);  </div><div class="line">  &#125;  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>顺序执行每个任务。</p>
]]></content>
      
        <categories>
            
            <category> JAVA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1085-----01背包]]></title>
      <url>/2016/03/27/ACM/51nod1085-----01%E8%83%8C%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">10001</span>];</div><div class="line"><span class="keyword">int</span> w[<span class="number">101</span>],p[<span class="number">101</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n,W,i,j;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;W);</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;w[i],&amp;p[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=W;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(j&lt;w[i])</div><div class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+p[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][W]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 背包 </tag>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1046快速幂取余]]></title>
      <url>/2016/03/26/ACM/51nod1046%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E4%BD%99/</url>
      <content type="html"><![CDATA[<p>给出3个正整数A B C，求A^B Mod C。</p>
<p>例如，3 5 8，3^5 Mod 8 = 3。<br>Input<br>3个正整数A B C，中间用空格分隔。(1 &lt;= A,B,C &lt;= 10^9)<br>Output<br>输出计算结果<br>Input示例<br>3 5 8<br>Output示例<br>3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">quickmod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(b)&#123;</div><div class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</div><div class="line">            ans=(ans*a)%m;<span class="comment">//这里a是a^(2^i)%m</span></div><div class="line">            b--;</div><div class="line">        &#125;</div><div class="line">        b/=<span class="number">2</span>;</div><div class="line">        a=a*a%m;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a,b,m;</div><div class="line">    <span class="keyword">while</span>(scanf(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;m)!=EOF)&#123;</div><div class="line">      <span class="keyword">long</span> <span class="keyword">long</span>   ans=quickmod(a,b,m);</div><div class="line">        printf(<span class="string">"%lld"</span>,ans);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----任务分配问题]]></title>
      <url>/2016/03/21/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>任务执行顺序</p>
<p>有N个任务需要执行，第i个任务计算时占R[i]个空间，而后会释放一部分，最后储存计算结果需要占据O[i]个空间（O[i] &lt; R[i]）。</p>
<p>分析：可以抽象成，从一个整数开始，每次减去a，再加上b (a,b都是正数)，要求每次操作都不产生负数。令a[i] = R[i], b[i] = R[i] – O[i]，O[i] &lt; R[i],有0&lt;b[i]&lt;a[i]。 所以尽管每次有减有加，但是加的没有减的多，总数在不断减小。所以——按照b[i]递增的顺序排序，是最“有利”的。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></div><div class="line">    <span class="keyword">int</span> r,o;</div><div class="line">&#125;p[<span class="number">100001</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(point x,point y)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> x.o&gt;y.o;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//p1099t11in.txt","r",stdin);</span></div><div class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></div><div class="line">    <span class="keyword">int</span> i,N,sum,ans;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N))&#123;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].r,&amp;p[i].o);</div><div class="line">            p[i].o=p[i].r-p[i].o;</div><div class="line">        &#125;</div><div class="line">        sort(p,p+N,cmp);</div><div class="line">        sum=p[<span class="number">0</span>].r;</div><div class="line">        ans=p[<span class="number">0</span>].r;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(ans&lt;p[i].r)&#123;</div><div class="line">                sum=sum+p[i].r-ans;</div><div class="line">                ans=p[i].r;</div><div class="line">            &#125;</div><div class="line">                ans=ans-p[i].r+p[i].o;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod动态规划-----矩阵取数]]></title>
      <url>/2016/03/21/ACM/51nod%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>一个N<em>N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。<br>例如：3 </em> 3的方格。</p>
<p>1 3 3</p>
<p>2 1 3</p>
<p>2 2 1</p>
<p>能够获得的最大价值为：11。</p>
<a id="more"></a>
<p>Input</p>
<p>第1行：N，N为矩阵的大小。(2 &lt;= N &lt;= 500)</p>
<p>第2 - N + 1行：每行N个数，中间用空格隔开，对应格子中奖励的价值。（1 &lt;= N[i] &lt;= 10000)</p>
<p>OutPut</p>
<p>输出能够获得的最大价值。</p>
<p>Input示例</p>
<p>3</p>
<p>1 3 3</p>
<p>2 1 3</p>
<p>2 2 1</p>
<p>Output示例</p>
<p>11</p>
<p>状态转移方程：f(i,j) = max{f(i+1,j),f(i,j+1)|i&lt;N,j&lt;N}+A[i][j];</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//1.txt","r",stdin);</span></div><div class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></div><div class="line">    <span class="keyword">int</span> N,i,j;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N))&#123;</div><div class="line">        <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">505</span>][<span class="number">505</span>];</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</div><div class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</div><div class="line">        <span class="keyword">int</span> dp[<span class="number">505</span>][<span class="number">505</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//不知道为什么这个不能跟前面的map一起定义。。。</span></div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</div><div class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</div><div class="line">                dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="built_in">map</span>[i][j];</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[N<span class="number">-1</span>][N<span class="number">-1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----独木舟问题]]></title>
      <url>/2016/03/20/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E7%8B%AC%E6%9C%A8%E8%88%9F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>独木舟问题</p>
<p>n个人，已知每个人体重，独木舟承重固定，每只独木舟最多坐两个人，可以坐一个人或者两个人。显然要求总重量不超过独木舟承重，假设每个人体重也不超过独木舟承重，问最少需要几只独木舟？</p>
<p>分析：按照人的体重排序，最轻的人跟最重的人尽量安排在一条船上，如果超过就安排最重的.<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">int</span> i,j,ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> a[<span class="number">10001</span>];</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        &#125;</div><div class="line">        sort(a,a+n);</div><div class="line">        j=n<span class="number">-1</span>;</div><div class="line">        i=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</div><div class="line">            <span class="keyword">if</span>(a[i]+a[j]&lt;=m)&#123;</div><div class="line">                ans++;</div><div class="line">                i++;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                ans++;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i==j)</div><div class="line">            ans++;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----活动安排问题2]]></title>
      <url>/2016/03/17/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%982/</url>
      <content type="html"><![CDATA[<p>题目大意就是给几个活动，问要几个教室能够弄完。</p>
<p>这个题目的想法就是把活动的开始——结束的时间看做是数轴上的一段线段，教室的个数就是在某点的时间厚度，求最大的时间厚度就是所需要的教室个数。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">   <span class="keyword">int</span> start;</div><div class="line">   <span class="keyword">int</span> end;</div><div class="line">&#125;s[<span class="number">10001</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span><span class="comment">//结构体的一级排序</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> (*(node*)a).start&gt;(*(node*)b).start?<span class="number">1</span>:<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//data.txt","r",stdin);</span></div><div class="line"><span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></div><div class="line">    <span class="keyword">int</span> n,i,rooms=<span class="number">0</span>;</div><div class="line">     priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; myqueue;<span class="comment">//优先队列类型</span></div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s[i].start,&amp;s[i].end);</div><div class="line">    qsort(s,n,<span class="keyword">sizeof</span>(node),cmp);</div><div class="line">    myqueue.push(s[<span class="number">0</span>].end);</div><div class="line">    rooms=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(s[i].start&lt;myqueue.top())&#123;</div><div class="line">            rooms++;</div><div class="line">            myqueue.push(s[i].end);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            myqueue.pop();</div><div class="line">            myqueue.push(s[i].end);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rooms);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----活动安排问题]]></title>
      <url>/2016/03/05/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>有若干个活动，第i个开始时间和结束时间是[Si,fi)，只有一个教室，活动之间不能交叠，求最多安排多少个活动？</p>
<p>输入</p>
<p>第1行：1个数N，线段的数量(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：每行2个数，线段的起点和终点(-10^9 &lt;= S,E &lt;= 10^9)<br>输出</p>
<a id="more"></a>
<p>输出最多可以选择的线段数量。</p>
<p>输入示例</p>
<p>3<br>1 5<br>2 3<br>3 6</p>
<p>输出示例</p>
<p>2</p>
<p>我们可以知道先安排最早结束的活动可以更多的安排活动。首先就是将所有的活动结束时间按先后顺序给排序；然后以结束时间为线索一路检索下去，判断开始时间是否早于前面一次活动的结束时间。这里可以用结构体或者两个数组来把一个活动的开始时间和结束时间联系起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#define max 10001</div><div class="line">using namespace std;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n,i,j,temps,tempo;</div><div class="line">    <span class="keyword">int</span> start[max],over[max];</div><div class="line">    <span class="keyword">while</span>(scanf(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</div><div class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>,t=-<span class="number">1000000000</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">        cin&gt;&gt;start[i]&gt;&gt;over[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">       <span class="keyword">for</span>(j=i;j&lt;n;j++)&#123;</div><div class="line">           <span class="keyword">if</span>(over[i]&gt;over[j])&#123;</div><div class="line">              tempo=over[i];</div><div class="line">              over[i]=over[j];</div><div class="line">              over[j]=tempo;</div><div class="line">              temps=start[i];</div><div class="line">              start[i]=start[j];</div><div class="line">              start[j]=temps;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(t&lt;=start[i])&#123;</div><div class="line">            t=over[i];</div><div class="line">            sum+=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    printf(<span class="string">"%d\n"</span>,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//原本我还考虑了活动时间不能为负数的情况，但是在提交时系统给出的数据中把负数也给算了进去。。。。。</p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----完美字符串]]></title>
      <url>/2016/03/04/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E5%AE%8C%E7%BE%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>约翰认为字符串的完美度等于它里面所有字母的完美度之和。每个字母的完美度可以由你来分配，不同字母的完美度不同，分别对应一个1-26之间的整数。</p>
<p>约翰不在乎字母大小写。（也就是说字母F和f）的完美度相同。给定一个字符串，输出它的最大可能的完美度。例如：dad，你可以将26分配给d，25分配给a，这样整个字符串完美度为77。</p>
<p>//这题水题，只要把每个字母出现的次数统计出来然后再排序一下就OK了。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10001</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)&#123;</div><div class="line">	<span class="keyword">int</span> sum[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;,len,i,j,a,maxsum=<span class="number">0</span>;</div><div class="line">	len=s.size();</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">	    a=s[i]-<span class="string">'A'</span>+<span class="number">1</span>;</div><div class="line">	    a&lt;=<span class="number">26</span>?sum[a]++:sum[a<span class="number">-32</span>]++;</div><div class="line">	&#125;</div><div class="line">	sort(sum,sum+<span class="number">27</span>);</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">26</span>;j++)&#123;</div><div class="line">	    maxsum+=j*sum[j];</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxsum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ls命令]]></title>
      <url>/1900/01/01/Linux/ls/</url>
      <content type="html"><![CDATA[<p>&ensp;&ensp;ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印当前目录的清单，如果你是指定其他目录，那么就会显示指定目录里的文件及文件夹清单。通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限（包括目录、文件夹、文件权限），查看目录信息等等。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>ls 【选项】【目录名】</p>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>&ensp;&ensp;列出目标目录中所有的子目录和文件。<br><a id="more"></a></p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-a , -all 列出，目录下的所有文件，包括以 <strong>.</strong> 开头的隐含文件</li>
<li>-A , 同-a，但不列出“.”（表示当前目录）和“..”（表示当前目录的父目录）</li>
<li>-c 配合 -lt: 根据ctime排序及显示ctime（文件状态最后更改时间）配合 -l: 显示ctime但根据名称排序否则: 根据ctime排序</li>
<li>-C 每栏由上至下列出项目</li>
<li>–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</li>
<li>-d, –directory 将目录象文件一样显示，而不是显示其下的文件。</li>
<li>-D, –dired 产生适合 Emacs 的 dired 模式使用的结果</li>
<li>-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</li>
<li>-g 类似 -l,但不列出所有者</li>
<li>-G, –no-group 不列出任何有关组的信息</li>
<li>-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)</li>
<li>–si 类似 -h,但文件大小取 1000 的次方而不是 1024</li>
<li>-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地</li>
<li>–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</li>
<li>-i, –inode 印出每个文件的 inode 号</li>
<li>-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目</li>
<li>-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。</li>
<li>-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</li>
<li>-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息</li>
<li>-m 所有项目以逗号分隔，并填满整行行宽</li>
<li>-o 类似 -l,显示文件的除组信息外的详细信息。 </li>
<li>-r, –reverse 依相反次序排列</li>
<li>-R, –recursive 同时列出所有子目录层</li>
<li>-s, –size 以块大小为单位列出所有文件的大小</li>
<li>-S 根据文件大小排序</li>
<li>–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：<br>extension -X status -c<br>none -U time -t<br>size -S atime -u<br>time -t access -u<br>version -v use -u</li>
<li>-t 以文件修改时间排序</li>
<li>-u 配合 -lt:显示访问时间而且依访问时间排序<br>配合 -l:显示访问时间但根据名称排序<br>否则：根据访问时间排序</li>
<li>-U 不进行排序;依文件系统原有的次序列出项目</li>
<li>-v 根据版本进行排序</li>
<li>-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值</li>
<li>-x 逐行列出项目而不是逐栏列出</li>
<li>-X 根据扩展名排序</li>
<li>-1 每行只列出一个文件</li>
<li>–help 显示此帮助信息并离开</li>
<li>–version 显示版本信息并离开</li>
</ul>
<h3 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h3><hr>
<h4 id="例一：列出-home-peidachang文件夹下的所有文件和目录的详细资料"><a href="#例一：列出-home-peidachang文件夹下的所有文件和目录的详细资料" class="headerlink" title="例一：列出/home/peidachang文件夹下的所有文件和目录的详细资料"></a>例一：列出/home/peidachang文件夹下的所有文件和目录的详细资料</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -l -R /home/peidachang<br>&ensp;&ensp;在使用 ls 命令时要注意命令的格式：在命令提示符后，首先是命令的关键字，接下来是命令参数，在命令参数之前要有一短横线“-”，所有的命令参数都有特定的作用，自己可以根据需要选用一个或者多个参数，在命令参数的后面是命令的操作对象。在以上这条命令“ ls -l -R /home/peidachang”中，“ls” 是命令关键字，“-l -R”是参数，“ /home/peidachang”是命令的操作对象。在这条命令中，使用到了两个参数，分别为“l”和“R”，当然，你也可以把他们放在一起使用，如下所示：<br>&ensp;&ensp;<strong>命令：</strong> ls -lR /home/peidachang<br>&ensp;&ensp;这种形式和上面的命令形式执行的结果是完全一样的。另外，如果命令的操作对象位于当前目录中，可以直接对操作对象进行操作;如果不在当前目录则需要给出操作对象的完整路径，例如上面的例子中，我的当前文件夹是peidachang文件夹，我想对home文件夹下的peidachang文件进行操作，我可以直接输入 ls -lR peidachang，也可以用 ls -lR /home/peidachang。 </p>
<hr>
<h4 id="例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令："><a href="#例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：" class="headerlink" title="例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令："></a>例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -l t*<br>&ensp;&ensp;可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。</p>
<hr>
<h4 id="例三：只列出文件下的子目录"><a href="#例三：只列出文件下的子目录" class="headerlink" title="例三：只列出文件下的子目录"></a>例三：只列出文件下的子目录</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -F /opt/soft |grep /$<br>&ensp;&ensp;列出 /opt/soft 文件下面的子目录<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]# ls -F /opt/soft |grep /$<br>&ensp;&ensp;&ensp;&ensp;jdk1.6.0_16/<br>&ensp;&ensp;&ensp;&ensp;subversion-1.6.1/<br>&ensp;&ensp;&ensp;&ensp;tomcat6.0.32/</p>
<p>&ensp;&ensp;<strong>命令：</strong> ls -l /opt/soft | grep “^d”<br>&ensp;&ensp;列出 /opt/soft 文件下面的子目录详细情况<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]#  ls -l /opt/soft | grep “^d”<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 16 1016 1016      4096 10-11 03:25 subversion-1.6.1<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x  9 root root      4096 2011-11-01 tomcat6.0.32</p>
<hr>
<h4 id="例四：列出目前工作目录下所有名称是s-开头的档案，愈新的排愈后面，可以使用如下命令："><a href="#例四：列出目前工作目录下所有名称是s-开头的档案，愈新的排愈后面，可以使用如下命令：" class="headerlink" title="例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令："></a>例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令：</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -ltr s<em><br>&ensp;&ensp;可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]# ls -ltr s</em><br>&ensp;&ensp;&ensp;&ensp;src:<br>&ensp;&ensp;&ensp;&ensp;总计 0<br>&ensp;&ensp;&ensp;&ensp;script:<br>&ensp;&ensp;&ensp;&ensp;总计 0<br>&ensp;&ensp;&ensp;&ensp;soft:<br>&ensp;&ensp;&ensp;&ensp;总计 350644<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x  9 root root      4096 2011-11-01 tomcat6.0.32<br>&ensp;&ensp;&ensp;&ensp;-rwxr-xr-x  1 root root  81871260 09-17 18:15 jdk-6u16-linux-x64.bin<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16<br>&ensp;&ensp;&ensp;&ensp;-rw-r–r–  1 root root   5457684 09-21 00:23 tomcat6.0.32.tar.gz</p>
<hr>
<h4 id="例五：列出目前工作目录下所有档案及目录-目录于名称后加”-“-可执行档于名称后加”-”"><a href="#例五：列出目前工作目录下所有档案及目录-目录于名称后加”-“-可执行档于名称后加”-”" class="headerlink" title="例五：列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加”*”"></a>例五：列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加”*”</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -AF<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;ls -l <em> |grep “^-“|wc -l —文件个数<br>&ensp;&ensp;&ensp;&ensp;ls -l </em> |grep “^d”|wc -l    —目录个数</p>
<hr>
<h4 id="例七-在ls中列出文件的绝对路径"><a href="#例七-在ls中列出文件的绝对路径" class="headerlink" title="例七: 在ls中列出文件的绝对路径"></a>例七: 在ls中列出文件的绝对路径</h4><p>&ensp;&ensp;<strong>命令：</strong> ls | sed “s:^:<code>pwd</code>/:”<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]# ls | sed “s:^:<code>pwd</code>/:”<br>&ensp;&ensp;&ensp;&ensp;/opt/log<br>&ensp;&ensp;&ensp;&ensp;/opt/script<br>&ensp;&ensp;&ensp;&ensp;/opt/soft<br>&ensp;&ensp;&ensp;&ensp;/opt/src<br>&ensp;&ensp;&ensp;&ensp;/opt/svndata<br>&ensp;&ensp;&ensp;&ensp;/opt/web</p>
<hr>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p><strong>显示彩色目录列表</strong><br>    打开/etc/bashrc, 加入如下一行:<br>    alias ls=”ls –color”<br>    下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下:</p>
<pre><code>1. 蓝色--&gt;目录
2. 绿色--&gt;可执行文件
3. 红色--&gt;压缩文件
4. 浅蓝色--&gt;链接文件
5. 灰色--&gt;其他文件
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[cd命令]]></title>
      <url>/1900/01/01/Linux/cd/</url>
      <content type="html"><![CDATA[<p>&ensp;&ensp;cd命令可以说是Linux中最基本的命令语句，其他命令要进行操作，都是建立在使用cd命令上的。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>cd [目录名]</p>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>&ensp;&ensp;切换当前目录到dirName<br><a id="more"></a></p>
<h3 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h3><hr>
<h4 id="例1：进入系统根目录"><a href="#例1：进入系统根目录" class="headerlink" title="例1：进入系统根目录"></a>例1：进入系统根目录</h4><p>cd /</p>
<hr>
<h4 id="例2：使用-cd-命令进入当前用户主目录"><a href="#例2：使用-cd-命令进入当前用户主目录" class="headerlink" title="例2：使用 cd 命令进入当前用户主目录"></a>例2：使用 cd 命令进入当前用户主目录</h4><p>&ensp;&ensp;“当前用户主目录”和“系统根目录”是两个不同的概念。进入当前用户主目录有两个方法。<br>1.cd<br>2.cd ~</p>
<hr>
<h4 id="例3：跳转到指定目录"><a href="#例3：跳转到指定目录" class="headerlink" title="例3：跳转到指定目录"></a>例3：跳转到指定目录</h4><p>cd /opt/soft<br>&ensp;&ensp;跳转到指定目录，从根目录开始，目录名称前加 / ,当前目录内的子目录直接写名称即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cd /opt/soft</div><div class="line">[root@localhost soft]# pwd</div><div class="line">/opt/soft</div><div class="line">[root@localhost soft]# cd jdk1.6.0_16/</div><div class="line">[root@localhost jdk1.6.0_16]# pwd</div><div class="line">/opt/soft/jdk1.6.0_16</div><div class="line">[root@localhost jdk1.6.0_16]#</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="例4：返回进入此目录之前所在的目录"><a href="#例4：返回进入此目录之前所在的目录" class="headerlink" title="例4：返回进入此目录之前所在的目录"></a>例4：返回进入此目录之前所在的目录</h4><p>cd -<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhost soft]# pwd</div><div class="line">/opt/soft</div><div class="line">[root@localhost soft]# cd -</div><div class="line">/root</div><div class="line">[root@localhost ~]# pwd</div><div class="line">/root</div><div class="line">[root@localhost ~]# cd -</div><div class="line">/opt/soft</div><div class="line">[root@localhost soft]#</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="例5：把上个命令的参数作为cd参数使用。"><a href="#例5：把上个命令的参数作为cd参数使用。" class="headerlink" title="例5：把上个命令的参数作为cd参数使用。"></a>例5：把上个命令的参数作为cd参数使用。</h4><p>cd !$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhost soft]# cd !$</div><div class="line">cd -</div><div class="line">/root</div><div class="line">[root@localhost ~]# cd !$</div><div class="line">cd -</div><div class="line">/opt/soft</div><div class="line">[root@localhost soft]#</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
  
  
</search>

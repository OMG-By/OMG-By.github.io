<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[static]]></title>
      <url>/2017/10/18/static/</url>
      <content type="html"><![CDATA[<h1 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用:"></a>static的作用:</h1><h2 id="不考虑类"><a href="#不考虑类" class="headerlink" title="不考虑类"></a>不考虑类</h2><h3 id="第一个作用：隐藏"><a href="#第一个作用：隐藏" class="headerlink" title="第一个作用：隐藏"></a>第一个作用：隐藏</h3><p>&ensp;&ensp;当我们同时编译多个文件时，所有未加static前缀的<strong>全局变量</strong>和<strong>函数</strong>都具有全局可见性。</p>
<p>&ensp;&ensp;如果加了static，就会对其他源文件隐藏，利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。</p>
<hr>
<ul>
<li>static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用<a id="more"></a>
</li>
</ul>
<hr>
<h3 id="第二个作用：默认初始化为0"><a href="#第二个作用：默认初始化为0" class="headerlink" title="第二个作用：默认初始化为0"></a>第二个作用：默认初始化为0</h3><p>&ensp;&ensp;包括未初始化的全局静态变量与局部静态变量。其实未初始化的全局变量也具备这一属性，因为未初始化的全局变量与未初始化的静态变量是存储在同一块区域内的（BBS段）。</p>
<p>&ensp;&ensp;在BBS段中，内存中所有的字节默认值都是0x00，某些时候这一特性可以减少程序员的工作量。</p>
<h3 id="第三个作用：保持局部变量内容的持久"><a href="#第三个作用：保持局部变量内容的持久" class="headerlink" title="第三个作用：保持局部变量内容的持久"></a>第三个作用：保持局部变量内容的持久</h3><p>&ensp;&ensp;函数内的自动（局部）变量，当调用时就存在，退出函数时就消失，当静态局部变量虽然在函数内定义，当静态局部变量始终存在着，也就是说它的生存周期为整个源程序，其特点就是只进行一次初始化且具有“记忆性”。</p>
<p>&ensp;&ensp;静态局部变量的生存期虽然为整个源程序，但是其作用域仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出函数后，尽管该变量还继续存在，但是不能使用它。</p>
<hr>
<h2 id="类中static的作用"><a href="#类中static的作用" class="headerlink" title="类中static的作用"></a>类中static的作用</h2><p>&ensp;&ensp;C++重用了static这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定的对象的变量和函数（和Java中此关键字的含义相同）</p>
<ul>
<li>静态数据成员</li>
<li>静态成员函数</li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[虚函数]]></title>
      <url>/2017/10/18/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>引入原因：为了方便使用多态特性，我们常常需要在基类中定于虚函数。</p>
<p>关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p>
<p><strong>虚函数表</strong><br><a id="more"></a><br>&emsp;&ensp;虚函数是通过一张虚函数表来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p>
<p>这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。<br>假设我们有这样的一个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line">Base b;</div><div class="line">Fun pFun = <span class="literal">NULL</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表地址："</span> &lt;&lt; (<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表 — 第一个函数地址："</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="comment">//这里的一点争议的个人看法：</span></div><div class="line">原文认为(<span class="keyword">int</span>*)(&amp;b)是虚表的地址，而很多网友都说，（包括我也认为）：(<span class="keyword">int</span> *)*(<span class="keyword">int</span>*)(&amp;b)才是虚表地址</div><div class="line">而(<span class="keyword">int</span>*)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)); 才是虚表第一个虚函数的地址。</div><div class="line">其实看后面的调用pFun = (Fun)*((int*)*(int*)(&amp;b)); 就可以看出，*((int*)*(int*)(&amp;b));转成函数指针给pFun，然后正确的调用到了虚函数virtual void f()。</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Invoke the first virtual function</span></div><div class="line">pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b));</div><div class="line">pFun();</div><div class="line">实际运行经果如下：(Windows XP+VS2003, Linux <span class="number">2.6</span><span class="number">.22</span> + GCC <span class="number">4.1</span><span class="number">.3</span>)</div><div class="line">虚函数表地址：<span class="number">0012F</span>ED4</div><div class="line">虚函数表 — 第一个函数地址：<span class="number">0044F</span>148</div><div class="line">Base::f</div><div class="line">通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成<span class="keyword">int</span> *，取得</div><div class="line">虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也</div><div class="line">就是Base::f()，这在上面的程序中得到了验证（把<span class="keyword">int</span>* 强制转成了函</div><div class="line">数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和</div><div class="line">Base::h()，其代码如下：</div><div class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>); <span class="comment">// Base::f()</span></div><div class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>); <span class="comment">// Base::g()</span></div><div class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>); <span class="comment">// Base::h()</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>一般继承（无虚函数覆盖）</strong></p>
<p>下面，让我们来看看继承时的虚函数表示什么样的。假设有如下所以的一个继承关系：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_2.jpg" alt=""></p>
<p>请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：<br>对于实例：Derive d; 的虚函数表如下：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_3.jpg" alt=""></p>
<p>我们可以看到下面几点：</p>
<p>1.虚函数按照其声明顺序放于表中。</p>
<p>2.父类的虚函数在子类的虚函数前面。</p>
<p><strong>一般继承（有虚函数覆盖）</strong></p>
<p>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_4.jpg" alt=""></p>
<p>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_5.jpg" alt=""></p>
<p>我们从表中可以看到下面几点：</p>
<p>1.覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</p>
<p>2.没有被覆盖的函数依旧。</p>
<p><strong>多重继承（无虚函数覆盖）</strong></p>
<p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_6.jpg" alt=""></p>
<p>对于子类实例中的虚函数表，是下面这个样子：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_7.jpg" alt=""></p>
<p>我们可以看到：</p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<p><strong>多重继承（有虚函数覆盖）</strong></p>
<p>下面我们再来看看，如果发生虚函数覆盖的情况。</p>
<p>下图中，我们在子类中覆盖了父类的f()函数。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_8.jpg" alt=""></p>
<p>下面是对于子类实例中的虚函数表的图：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_9.jpg" alt=""></p>
<p>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。</p>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深复制和浅复制]]></title>
      <url>/2017/10/18/%E6%B7%B1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B5%85%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>浅复制：被复制对象的所有变量都含有与原来对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>深复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></div><div class="line">	<span class="keyword">char</span> *ptr;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shallow_copy</span><span class="params">(Test &amp; src,Test &amp; dest)</span></span>&#123;</div><div class="line">	dest.ptr = src.ptr;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deep_copy</span><span class="params">(Test &amp; src,Test &amp; dest)</span></span>&#123;</div><div class="line">	dest.ptr=<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src.ptr)+<span class="number">1</span>);</div><div class="line">	<span class="built_in">memcpy</span>(dest.ptr,src.ptr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>浅复制可能会导致运行时错误，特别是在对象的创建和删除过程中。</p>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存泄露和缓冲区溢出]]></title>
      <url>/2017/10/18/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
      <content type="html"><![CDATA[<p>什么是内存泄露？</p>
<ul>
<li>一般我们常说的内存泄露是指堆内存的泄露。堆内存是指程序从堆中分配的，大小任意的内存块，使用完后必须显示释放的内存。应用程序一般使用malloc、realloc、new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能再被使用，我们就说这块内存泄露了。</li>
</ul>
<hr>
<p>什么是缓冲区溢出？</p>
<ul>
<li>缓冲区溢出是指向缓冲区内填充数据位数超过了缓冲区本身的容量限制，导致溢出的数据覆盖在合法数据上的情况。理想的情况是程序检查数据长度并不允许输出超出缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的存储空间相匹配，这九尾缓冲区溢出埋下了隐患。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring工作流程]]></title>
      <url>/2017/10/18/Spring%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Spring_Running_1.png" alt=""></p>
<a id="more"></a>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Spring_Running_2.png" alt=""></p>
<hr>
<p>Spring工作流程描述：<br>1.用户向服务器发送请求，请求被Spring前端控制Servlet DispatcherServlet捕获；</p>
<p>2.DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象相应的拦截器），最后以HandlerExecutionChain对象的形式返回。</p>
<p>3.DispatcherServlet根据获得Handler，选择一个合适HandlerAdapter。（如果成功获取HandlerAdapter后，此时将开始执行拦截器的PreHandler方法）</p>
<p>4.提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller）。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConveter：将请求消息（如Json、Xml等数据）转化成一个对象，将对象转换成指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>
<li>数据格式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证：验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ul>
<p>5.Handler执行完成后，先DispatcherServlet返回一个ModelAndView对象</p>
<p>6.根据返回的ModelAndView，选择一个合适的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet</p>
<p>7.ViewResolver结合Model和View来渲染视图</p>
<p>8.将渲染结果返回给客户端</p>
<hr>
<p>Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler？</p>
<p>答：符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的是代码可复用性高。如HandlerAdapter可能会被用于处理多种Handler。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP与UDP的区别]]></title>
      <url>/2017/10/17/tcp%E4%B8%8Eudp/</url>
      <content type="html"><![CDATA[<p>1.TCP是面向连接的，在传输数据前需要建立连接；UDP是无连接的，发送数据前不需要建立连接。<br>2.TCP提供<strong>可靠</strong>的传输服务；UDP提供<strong>不可靠</strong>的传输服务。<br>3.TCP发送数据大小会受发送窗口、接收窗口及MSS（最大报文段）限制，所以会多段发送；UDP发送数据大小即为数据本身大小。<br>4.TCP拥有众多反馈机制和附加机制；UDP没有反馈机制。<br>5.TCP传输速度慢；UDP传输速度快。</p>
<p>TCP适合文件下载等传输任务，UDP适合媒体流等看中传输速度的传输任务。</p>
]]></content>
      
        <categories>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java的四种线程池]]></title>
      <url>/2017/10/17/%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>Java通过Executors提供了四种线程池：</p>
<ul>
<li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(index * <span class="number">1000</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">   &#125;</div><div class="line">   cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">     System.out.println(index);</div><div class="line">    &#125;</div><div class="line">   &#125;);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程.</p>
<ul>
<li>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超过的线程会在队列中等待。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">  ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;  </div><div class="line">   fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">     <span class="keyword">try</span> &#123;  </div><div class="line">      System.out.println(index);  </div><div class="line">      Thread.sleep(<span class="number">2000</span>);  </div><div class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">      e.printStackTrace();  </div><div class="line">     &#125;  </div><div class="line">    &#125;  </div><div class="line">   &#125;);  </div><div class="line">  &#125;  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以没两秒打印3个数字。</p>
<ul>
<li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">  ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);  </div><div class="line">  scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">    System.out.println(<span class="string">"delay 3 seconds"</span>);  </div><div class="line">   &#125;  </div><div class="line">  &#125;, <span class="number">3</span>, TimeUnit.SECONDS);  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>表示延迟3秒执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">  ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);  </div><div class="line">  scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">    System.out.println(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);  </div><div class="line">   &#125;  </div><div class="line">  &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>表示延迟1秒后每3秒执行一次。</p>
<ul>
<li>newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照指定顺序（FIFO，LIFO,优先级）执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">  ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;  </div><div class="line">   singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">     <span class="keyword">try</span> &#123;  </div><div class="line">      System.out.println(index);  </div><div class="line">      Thread.sleep(<span class="number">2000</span>);  </div><div class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">      e.printStackTrace();  </div><div class="line">     &#125;  </div><div class="line">    &#125;  </div><div class="line">   &#125;);  </div><div class="line">  &#125;  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>顺序执行每个任务。</p>
]]></content>
      
        <categories>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----活动安排问题]]></title>
      <url>/2016/03/05/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>有若干个活动，第i个开始时间和结束时间是[Si,fi)，只有一个教室，活动之间不能交叠，求最多安排多少个活动？</p>
<p>输入</p>
<p>第1行：1个数N，线段的数量(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：每行2个数，线段的起点和终点(-10^9 &lt;= S,E &lt;= 10^9)<br>输出</p>
<a id="more"></a>
<p>输出最多可以选择的线段数量。</p>
<p>输入示例</p>
<p>3<br>1 5<br>2 3<br>3 6</p>
<p>输出示例</p>
<p>2</p>
<p>我们可以知道先安排最早结束的活动可以更多的安排活动。首先就是将所有的活动结束时间按先后顺序给排序；然后以结束时间为线索一路检索下去，判断开始时间是否早于前面一次活动的结束时间。这里可以用结构体或者两个数组来把一个活动的开始时间和结束时间联系起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#define max 10001</div><div class="line">using namespace std;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> n,i,j,temps,tempo;</div><div class="line">    <span class="keyword">int</span> start[max],over[max];</div><div class="line">    <span class="keyword">while</span>(scanf(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</div><div class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>,t=-<span class="number">1000000000</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">        cin&gt;&gt;start[i]&gt;&gt;over[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">       <span class="keyword">for</span>(j=i;j&lt;n;j++)&#123;</div><div class="line">           <span class="keyword">if</span>(over[i]&gt;over[j])&#123;</div><div class="line">              tempo=over[i];</div><div class="line">              over[i]=over[j];</div><div class="line">              over[j]=tempo;</div><div class="line">              temps=start[i];</div><div class="line">              start[i]=start[j];</div><div class="line">              start[j]=temps;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(t&lt;=start[i])&#123;</div><div class="line">            t=over[i];</div><div class="line">            sum+=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    printf(<span class="string">"%d\n"</span>,sum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//原本我还考虑了活动时间不能为负数的情况，但是在提交时系统给出的数据中把负数也给算了进去。。。。。</p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----完美字符串]]></title>
      <url>/2016/03/04/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E5%AE%8C%E7%BE%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>约翰认为字符串的完美度等于它里面所有字母的完美度之和。每个字母的完美度可以由你来分配，不同字母的完美度不同，分别对应一个1-26之间的整数。</p>
<p>约翰不在乎字母大小写。（也就是说字母F和f）的完美度相同。给定一个字符串，输出它的最大可能的完美度。例如：dad，你可以将26分配给d，25分配给a，这样整个字符串完美度为77。</p>
<p>//这题水题，只要把每个字母出现的次数统计出来然后再排序一下就OK了。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10001</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)&#123;</div><div class="line">	<span class="keyword">int</span> sum[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;,len,i,j,a,maxsum=<span class="number">0</span>;</div><div class="line">	len=s.size();</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">	    a=s[i]-<span class="string">'A'</span>+<span class="number">1</span>;</div><div class="line">	    a&lt;=<span class="number">26</span>?sum[a]++:sum[a<span class="number">-32</span>]++;</div><div class="line">	&#125;</div><div class="line">	sort(sum,sum+<span class="number">27</span>);</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">26</span>;j++)&#123;</div><div class="line">	    maxsum+=j*sum[j];</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxsum);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>

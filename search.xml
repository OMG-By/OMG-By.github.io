<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[一条更新语句的执行过程]]></title>
      <url>/2019/01/14/mysql/%E4%B8%80%E4%B8%AA%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>下面我们以下面这个表和更新语句来进行分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table T(ID int primary key, c int);</span><br><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p>
<p>对于更新语句，查询语句的那一套流程，更新语句同样是会走一遍。</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>如果每一次更新操作都要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新；整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL采用了WAL技术来提升更新效率。WAL的全称是write-Ahead Logging。它的关键点在于<font color="red">先写日志，再写磁盘</font>。</p>
<p>具体来说，就是当有一条记录需要更新的时候，innodb引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，innodb引擎会在适当的时候，将这个操作记录更新到次磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>innodb的redo log是固定大小的，比如可以配置为一组4个文件，每个文件大小是1GB，那么redo log总共就可以记录4GB的操作，从头开始写，写到末尾就又回到开头循环写。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/cO8DivjlNOs4*4J.jc9sWkTtPIM5APzdpDE8aPjQews!/b/dLYAAAAAAAAA&amp;bo=hAUyAwAAAAADB5I!&amp;rf=viewer_4" alt=""><br>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos和checkpoint之间的部分是用来记录新的操作。如果write pos追上checkpoint，那么表示redo log写满了，得先停下来擦掉一些记录，把checkpoint推进一点后才能够继续写入。</p>
<p>有了redo log，innodb就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称作crash-safe。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>MySQL从整体来说，其实有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。redo log是innodb引擎特有的日志，Server层也有自己的日志，称为binlog（归档日志）<br>最开始MySQL里并没有innodb引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而innodb是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力，所以innodb使用另一套日志系统（redo log）来实现crash-safe能力。</p>
<p>redo log 和 binlog主要有以下三点不同:</p>
<ol>
<li>redo log是innodb引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑。</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。</li>
</ol>
<p>我们回过头来看执行器和innodb引擎在执行这个简单的update语句时的内部流程。</p>
<ol>
<li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎的给的行数据，把这个值加上1，等到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/7vc6Wi5rjgpfIRIhIttNcrFLh7FmB1heWy5NCCPr8to!/b/dFIBAAAAAAAA&amp;bo=OASgBQAAAAADB7s!&amp;rf=viewer_4" alt=""></li>
</ol>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>binlog会记录所有的逻辑操作，并且采用的是“追加写”的形式。当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，可以这样做：</p>
<ul>
<li>首先找到最近一次的全年备份</li>
<li>然后从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li>
<li>将表数据从临时库中取出来，按需要恢复到线上库去。</li>
</ul>
<p>说完数据恢复过程，我们来说说为什么日志需要“两阶段提交”。<br>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，那么就是先写完redo log再写binlog或者放过来。</p>
<ol>
<li><b>先写redo log后写binlog</b>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过，redo log写完后，系统及时崩溃，仍然能够将数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写就crash了，这时候binlog是没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要这个binlog恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0。造成了数据不一致。（主从情况也是一样的）</li>
<li><b>先写binlog后写 redo log</b>。如果binlog写完后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binglog里面已经记录了“把c从0改成1”这个日子。所以binlog恢复后就多了一个事务。</li>
</ol>
<p>可以看到，如果不使用两阶段提交，那么数据库的状态与应用它日子的其他数据库数据不一致。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>redo log用来宝成crash-safe能力，innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都会直接持久化到磁盘。<br>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MySQL实战45讲 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一条查询语句的执行过程]]></title>
      <url>/2019/01/13/mysql/MySQL%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="MySQL基本架构"><a href="#MySQL基本架构" class="headerlink" title="MySQL基本架构"></a>MySQL基本架构</h2><p><img src="https://m.qpic.cn/psb?/V140pON30woojR/ussYTDB3vJmBbUYn8*kQP.aOU4fUXs6XhkExUtrBwWA!/b/dMMAAAAAAAAA&amp;bo=oAU4BAAAAAARB6k!&amp;rf=viewer_4" alt=""><br>MySQL基本架构可以分为Server层和存储引擎层两部分。</p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，覆盖MySQL大多数核心服务功能，以及<font color="red">所有的内置函数</font>（如日期、时间、数学等），所有的跨存储引擎的功能都在这一层实现，如存储过程、触发器、视图等。<br><a id="more"></a><br>下面以select * from T where ID=10；这条语句做讲解。</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器负责和客户端建立连接、获取权限、维持和管理连接。<br>使用mysql客户端工具来跟服务端进行建立连接。在完成经典的TCP握手后，连接器就要验证用户身份。</p>
<ul>
<li>如果用户名或密码不对，会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认真通过，连接器会到权限表里面查出你拥有的权限。在此连接后续过程中进行的权限判断逻辑都依赖于此时读取到的权限。</li>
</ul>
<p>这意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限进行了修改，也不会影响到已经存在连接的权限。</p>
<p>连接完成后，如果没有后续动作，这个连接就处于空闲状态；如果处于空闲状态太久没有进行操作，连接器就会自动将它断开。如果在连接端口后，客户端再发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query。这时候会进行重连才能够执行请求了。</p>
<p>有时候会发现MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。但是由于长连接积累一直不释放，导致内存占用太大，被系统强行杀掉（OOM），从现象来看就是MySQL异常重启了。<br>怎么解决这个问题呢？</p>
<ol>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>如果使用的是MySQL5.7以上版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
</ol>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接建立完成后，就可以开始执行命令了。那么在进行查询语句时，会先到缓存中去查询缓存，之前是不是执行过这条语句。之前执行过的语句和结果可能会以键值对的形式被直接缓存在内存中。key是查询的语句，value是查询的结果。如果能够在缓存中找到查询的语句，那么就会直接返回value值给客户端。</p>
<p><b>但是大多数情况下，建议是不要使用查询缓存</b><br>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存就会被清空。对于更新压力大的数据库来说，查询缓存的命中率非常低。出给你的业务就是一张静态表，很长时间才更新一次。<br>你可以将参数query_cache_type设置为DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select SQL_CACHE * from T where ID=10;</span><br></pre></td></tr></table></figure></p>
<p>MySQL8.0版本直接将查询缓存的整块功能给删掉了。</p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果没有命中缓存，就要开始真正执行语句了。首先MySQL需要知道你要做什么，所以需要对SQL语句进行解析。</p>
<p>分析器先会做“词法解析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。<br>MySQL从输入的“select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。<br>做完识别后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，将会收到“you hava an error in your SQL syntax”的错处提醒。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL就知道你要做什么了。在正式开始执行前，还要经过优化器的处理。<br>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联的时候，决定各个表的连接顺序。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL知道了你要做什么，该怎么做后就开始执行了。<br>开始执行的时候，要先判断一下你对这个表T有没有执行权限，如果没有，就会返回没有权限的错误。<br>如果有权限，就打开表继续执行。打开表的时候，执行器会根据表的引擎定义，去使用这个引擎提供的接口。<br>比如我们例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<pre><code>1. 调用InnodDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中。
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，知道取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
</code></pre><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口。<br>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。<br>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描函数跟rows_examined并不是完全相同的。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果表中没有字段k，而执行select * from T where k=1;肯定会报“不存在列”错误，这个错误是在哪个阶段报出来的？<br>答案：分析器，MySQL设计受Oracle影响，会在分析判断语句是否正确，表是否存在，列是否存在。<br>《高性能MySQL》里提到解析器处理语法和解析查询，会生成一颗对应的解析树</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MySQL实战45讲 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次磁盘空间不足]]></title>
      <url>/2018/12/29/Linux/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%EF%BC%8C%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>在一台虚拟机机器上发现磁盘空间不足的情况，通过登录上去查看，发现是挂载盘占用磁盘资源太多，通过df命令查看，但是并找不到具体是哪个文件占用过多。<br>通过以下查找大文件命令也没有找到相应的大文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size +100M</span><br></pre></td></tr></table></figure></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>文件被删除后，并没有及时的释放磁盘资源，导致磁盘空间不足的情况。<br>通过以下命令，查看已经标记为删除但是没有释放的文件。对相应程序进行重启后解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof|grep -i delete|less</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL问答]]></title>
      <url>/2018/11/29/mysql/MySQL%E9%97%AE%E7%AD%94/</url>
      <content type="html"><![CDATA[<h2 id="导致主从不一致的原因"><a href="#导致主从不一致的原因" class="headerlink" title="导致主从不一致的原因"></a>导致主从不一致的原因</h2><ol>
<li>人为原因（从库写入）</li>
<li>主库异常宕机</li>
<li>设置了ignore/do/rewrite等replication等规则</li>
<li>binlog使用了非row格式</li>
<li>从库中断</li>
<li>从库启用了存储过程</li>
<li>主从数据库版本不一致</li>
<li>重做时，mysqldump备份没有指定参数</li>
<li>主从sql_mode不一致</li>
<li>采用5.6的after_commit方式半同步，主库宕机可能会引起主从不一致。</li>
<li>启用了增强半同步，但是从库延迟超时自动切换成了异步复制</li>
</ol>
<h3 id="预防和解决的方案"><a href="#预防和解决的方案" class="headerlink" title="预防和解决的方案"></a>预防和解决的方案</h3><ol>
<li>master:innodb_flush_log_at_trx_commit=1&amp;sync_binlog=1</li>
<li>slave:master_info_repository=”TABLE”&amp;relay_log_info_repository=”TABLE”&amp;relay_log_recovery=1</li>
<li>设置从库库为只读模式</li>
<li>可以使用5.7增强半同步避免数据丢失等</li>
<li>binlog row格式</li>
<li>必须引定期的数据校验机制</li>
<li>当使用延迟复制的时候，此时主从数据也是不一致的（计划内），但在切换中，不要把延迟从提升为主库哦~</li>
<li>mha在主从切换的过程中，因主库系统宕机，可能造成主从不一致（mha本身机制导致这个问题）</li>
</ol>
<a id="more"></a>
<h2 id="为什么决定使用分库分表"><a href="#为什么决定使用分库分表" class="headerlink" title="为什么决定使用分库分表"></a>为什么决定使用分库分表</h2><ol>
<li>根据业务类型和业务容量评估</li>
<li>当前数据库本身具有的能力、压力评估</li>
<li>数据库的物理隔离，如：减少锁的争夺，资源的消耗和隔离</li>
<li>热点表较多，并且数据量大，可能会引起锁增强，性能下降</li>
<li>数据库的高并发，数据库读写压力大，可能会导致数据库或启动宕机</li>
<li>数据库（5.7以下）连接数过高，会增加系统压力</li>
<li>单表数据量大，如SQL使用不当，导致IO随机读写比例高；查询慢</li>
<li>备份和恢复时间比较长</li>
</ol>
<h3 id="会有什么问题"><a href="#会有什么问题" class="headerlink" title="会有什么问题"></a>会有什么问题</h3><ol>
<li>全局pk（主键和唯一索引）的冲突检测不准确，全局的自增主键支持不够好</li>
<li>分片键的选择</li>
<li>分布式事务</li>
<li>开发方面：需要进行业务的拆分。部分SQL不兼容。跨库查询、join。</li>
</ol>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ol>
<li>使用全局分号器。或者使用全局唯一id。</li>
<li>应用层来判断唯一索引</li>
<li>配合应用选择合适的分片键，并加上索引</li>
<li>配合应用，配合开发，对不兼容SQL进行整改</li>
</ol>
<h2 id="MySQL高可用架构应该考虑什么？"><a href="#MySQL高可用架构应该考虑什么？" class="headerlink" title="MySQL高可用架构应该考虑什么？"></a>MySQL高可用架构应该考虑什么？</h2><ol>
<li>对业务有一定了解，需要考虑业务对数据库一致性要求的敏感程度，切换过程中是否有事务丢失。</li>
<li>对于基础设施有一定了解，需要了解基础设施的高可用架构。</li>
<li>对于数据库故障时间掌握，业务方最多能容忍时间范围</li>
<li>需要了解主流的高可用的优缺点</li>
<li>考虑多机房多副本分布<h3 id="如何设计？"><a href="#如何设计？" class="headerlink" title="如何设计？"></a>如何设计？</h3></li>
<li>基础层和基础运维部门配合，了解和避免网络/硬盘/电源等是否会出现单点故障</li>
<li>应用层和开发配合，在关键日志中记录SQL日志，可以做到即使切换出现丢事务的情况，也可以通过手工补的方式保证数据一致性。</li>
<li>根据不同的应用制定合理的高可用策略</li>
<li>单机多实例</li>
<li>在数据库不可用，可以把已提交的事务先存储到队列或者其他位置，等数据库恢复，重新应用。</li>
</ol>
<h2 id="xtrabackup和mysqldump备份造成的锁等待"><a href="#xtrabackup和mysqldump备份造成的锁等待" class="headerlink" title="xtrabackup和mysqldump备份造成的锁等待"></a>xtrabackup和mysqldump备份造成的锁等待</h2><ol>
<li>xtrabackup在备份非innodb表时会有短暂的全局读锁FTWL</li>
<li>mysqldump获取一致性快照时会进行锁表</li>
<li>xtrabackup在备份时会在/tmp目录下生成一个临时文件，如果在备份过程中修改了/tmp的权限，这会造成xtrabackup hang住，正在备份的表不能正常释放锁，会造成锁等待。</li>
</ol>
<h2 id="为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？"><a href="#为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？" class="headerlink" title="为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？"></a>为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？</h2><ol>
<li>若复制中binlog使用row格式，对大表使用ps-osc把数据从旧表拷贝到临时表，期间会产生大量的binlog，从而导致延时</li>
<li>pt-osc在搬数据过程中insert..select是有行锁的，会降低事务并行度；且pt-osc搬数据过程中生成的binlog不是并行的，所以在slave不能并行回放。</li>
<li>可以通过设定参数–chunk-size、–chunk-time控制每次拷贝数据大小，也可以设定–max-log、check-interval、check-slave-lag等参数控制主从复制延迟程度（但这样可能会造成pt-osc工作耗时太久，需要执行权衡）</li>
</ol>
<h2 id="哪些原因会造成MySQL异步复制延迟"><a href="#哪些原因会造成MySQL异步复制延迟" class="headerlink" title="哪些原因会造成MySQL异步复制延迟"></a>哪些原因会造成MySQL异步复制延迟</h2><ol>
<li>master上多为并发事务，slave上则多为单线程回放（5.7起，支持真正的并行回放）</li>
<li>异步复制，本身就是有一定的延迟</li>
<li>有时为了节省机器资源，会在slave上运行多个实例</li>
<li>表结构设计不合理</li>
<li>slave上运行了大量只读低效率的SQL</li>
<li>大量大事务，也会造成slave无法并行回放</li>
<li>业务设计缺陷，或网络延迟等</li>
</ol>
<h2 id="MySQL每天产生了多大容量的binlog，可以查到吗"><a href="#MySQL每天产生了多大容量的binlog，可以查到吗" class="headerlink" title="MySQL每天产生了多大容量的binlog，可以查到吗"></a>MySQL每天产生了多大容量的binlog，可以查到吗</h2><p>binlog并不会自动的每天切分统计，所以需要人为这执行flush binlog logs再结合系统层命令完成。</p>
<h2 id="明明有索引，但是执行的时候没有选中是什么原因？"><a href="#明明有索引，但是执行的时候没有选中是什么原因？" class="headerlink" title="明明有索引，但是执行的时候没有选中是什么原因？"></a>明明有索引，但是执行的时候没有选中是什么原因？</h2><ol>
<li>隐式转换</li>
<li>表碎片，表碎片率过高</li>
<li>根据索引读取到的数据在整个表中的数据占比超过30%</li>
<li>统计信息没有及时更新</li>
</ol>
<h2 id="主从复制正常，但是主从延迟过高是什么原因"><a href="#主从复制正常，但是主从延迟过高是什么原因" class="headerlink" title="主从复制正常，但是主从延迟过高是什么原因"></a>主从复制正常，但是主从延迟过高是什么原因</h2><ol>
<li>sync_relay_log值过低，导致slave频繁刷新relay_log文件，使slave硬盘资源消耗过高。</li>
<li>Master/Slave压力过大</li>
<li>网络丢包严重</li>
<li>Master和Slave网络链接已经断开，但是slave_net_timeout值等于0（表示完全禁用心跳）或者slave_net_timeout和Slave_heart_period非常大（表示检测主从心跳的时间）</li>
<li>Master的binlog非常大，io线程的file很长时间在读同一个。</li>
</ol>
<h2 id="MySQL-hang的原因有哪些？"><a href="#MySQL-hang的原因有哪些？" class="headerlink" title="MySQL hang的原因有哪些？"></a>MySQL hang的原因有哪些？</h2><ol>
<li>MySQL使用资源过高导致服务器太累扛不住。</li>
<li>磁盘无可用空间</li>
<li>MySQL频繁的创建和销毁连接。</li>
<li>MySQL使用的最大文件打开数和连接数，超过了操作系统的限制。</li>
<li>MySQL的锁不能有效的释放。例如持有行锁或者表锁，造成MDL等待。</li>
<li>MySQL的bug导致的</li>
</ol>
<h2 id="MySQL中如果发现乱码该怎么处理？"><a href="#MySQL中如果发现乱码该怎么处理？" class="headerlink" title="MySQL中如果发现乱码该怎么处理？"></a>MySQL中如果发现乱码该怎么处理？</h2><ol>
<li>直接修改法，alter或者pt-osc等工具直接对工具进行修改。</li>
<li>备份修改法，利用mysqldump等其他逻辑备份进行备份，备份的结果集再利用iconv进行转换。</li>
<li>跳过字符集备份，–skip-set-charset</li>
</ol>
<h2 id="MySQL的表中有唯一索引，设置unique-check为0时，能否写入重复值"><a href="#MySQL的表中有唯一索引，设置unique-check为0时，能否写入重复值" class="headerlink" title="MySQL的表中有唯一索引，设置unique_check为0时，能否写入重复值"></a>MySQL的表中有唯一索引，设置unique_check为0时，能否写入重复值</h2><p>首先，即便设置unique_checks=0，也无法往唯一索引中写入重复值。</p>
<p>其次，设置unique_checks=0的作用在于，批量导入数据（例如load data）时，在确保导入数据中无重复值时，无需再次检查其唯一性，加快导入速度。</p>
<p>所以，unique_checks=0并不是允许唯一约束失效，而是再批量导数据时不再逐行检查唯一性。</p>
<h2 id="在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗-？"><a href="#在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗-？" class="headerlink" title="在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗 ？"></a>在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗 ？</h2><p>前提说明：MySQL5.7.23、innodb表、“双1” </p>
<p>1、添加/删除列，采用copy的方式 </p>
<p>1.1、ctrl+c。在当前session中，手动执行ctrl+c。无影响，并且会自动删除产生的临时文件。 </p>
<p>1.2、kill -9。在执行ddl的时候，服务器发生意外宕机或者手动执行kill -9。待MySQL启动后，则会自动执行InnoDB Recovered流程。并且不会删除产生的临时文件，需要手工处理。 </p>
<p>2、添加/删除索引，采用INPLACE方式 </p>
<p>2.1、ctrl+c，同1.1 </p>
<p>2.2、kill -9。不会删除临时文件，也不会执行InnoDB Recovered流程并且报错 Operating system error number 2 in a file operation ….OS error: 71 </p>
<p>在开始执行alter table的过程中，在没有结束的时候，并不会写入到binglog文件中。</p>
<h2 id="MySQL线上实例insert慢常见原因有哪些？"><a href="#MySQL线上实例insert慢常见原因有哪些？" class="headerlink" title="MySQL线上实例insert慢常见原因有哪些？"></a>MySQL线上实例insert慢常见原因有哪些？</h2><ol>
<li>锁等待：SQL产生的间隙锁、自增锁、死锁、MDL锁、外键检查锁，锁等待时间</li>
<li>iops达到瓶颈：例如备份任务、高频binlog redolog等文件写入</li>
<li>semi-sync：因为网络抖动，MySQL半同步、增强半同步导致语句卡住</li>
<li>高并发：高并发场景下，导致系统资源达到瓶颈，从而SQL执行慢</li>
<li>大字段：当前表索引过多，或者写入大量的text类型数据</li>
<li>硬件故障：因为磁盘、raid卡、内存等物理硬件故障导致写入慢</li>
<li>磁盘资源耗尽：操作系统的磁盘、inode资源耗尽</li>
<li>文件系统故障：MySQL data目录的所在挂在的不可写、或者被设置为只读</li>
<li>binlog group commit等待 </li>
<li>参数配置：innodb_buffer、redo_buffer过小 </li>
<li>autocommit：事物非自动提交，等待程序提交。</li>
</ol>
<h2 id="虽然命中索引，但SQL效率仍然慢，可能有哪些原因？"><a href="#虽然命中索引，但SQL效率仍然慢，可能有哪些原因？" class="headerlink" title="虽然命中索引，但SQL效率仍然慢，可能有哪些原因？"></a>虽然命中索引，但SQL效率仍然慢，可能有哪些原因？</h2><ol>
<li>索引字段重复值或者空值太多。 </li>
<li>查询条件范围太广返回结果数太多，全索引扫描 </li>
<li>没有利用到覆盖索引，造成大量回表 </li>
<li>查询字段过多，并且包含大字段</li>
<li>索引字段数据分布太随机，回表不多也会引起大量随机io </li>
<li>统计信息不准 </li>
<li>表的单行数据值很大，需要较多io </li>
<li>表中包含多个索引， 命中的索引不是最优的索引。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码阅读(启动过程)]]></title>
      <url>/2018/11/15/Redis/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B)/</url>
      <content type="html"><![CDATA[<p>Redis的启动函数main()在redis.c文件中。 </p>
<h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>在启动时会使用initServerConfig()函数进行初始化服务器配置工作，redisServer(redis.h)作为保存服务器配置的结构。 redisServer包含以下的一些Redis服务器的信息：  </p>
<ul>
<li>一般服务器状态。</li>
<li>一些服务器统计信息。</li>
<li>各种链表结构，如保存客户端的链表等。</li>
<li>配置文件及启动参数中的配置。</li>
<li>主从复制的状态。</li>
<li>持久化文件的参数和状态。</li>
</ul>
<p><img src="https://i.imgur.com/IXG8CwE.png" alt=""><br><a id="more"></a></p>
<h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><p>在initServer中会进行初始化服务器所需要的一些数据结构信息</p>
<ul>
<li>共享对象</li>
<li>事件循环</li>
<li>数据库结构</li>
<li>TCP套接字</li>
<li>服务器cron</li>
<li>事件循环</li>
<li>打开AOF</li>
</ul>
<h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>如果开启了AOF持久化，那么加载AOF文件；否则加载RDB文件。   </p>
<p><font color="red">如果开启AOF，但是没有AOF文件的话也不会去读取RDB文件，这样会造成数据的丢失！！！</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void loadDataFromDisk(void) &#123;</span><br><span class="line">    // 记录开始时间</span><br><span class="line">    long long start = ustime();</span><br><span class="line"></span><br><span class="line">    // AOF 持久化已打开？</span><br><span class="line">    if (server.aof_state == REDIS_AOF_ON) &#123;</span><br><span class="line">        // 尝试载入 AOF 文件</span><br><span class="line">        if (loadAppendOnlyFile(server.aof_filename) == REDIS_OK)</span><br><span class="line">            // 打印载入信息，并计算载入耗时长度</span><br><span class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from append only file: %.3f seconds&quot;,(float)(ustime()-start)/1000000);</span><br><span class="line">    // AOF 持久化未打开</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 尝试载入 RDB 文件</span><br><span class="line">        if (rdbLoad(server.rdb_filename) == REDIS_OK) &#123;</span><br><span class="line">            // 打印载入信息，并计算载入耗时长度</span><br><span class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from disk: %.3f seconds&quot;,</span><br><span class="line">                (float)(ustime()-start)/1000000);</span><br><span class="line">        &#125; else if (errno != ENOENT) &#123;</span><br><span class="line">            redisLog(REDIS_WARNING,&quot;Fatal error loading the DB: %s. Exiting.&quot;,strerror(errno));</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="运行事件处理器"><a href="#运行事件处理器" class="headerlink" title="运行事件处理器"></a>运行事件处理器</h3><p>Redis在每次进入事件循环时都会想调用函数beforeSleep()。<br>beforeSleep()会做两件事：  </p>
<ol>
<li>如果启用了虚拟内存系统，将会去刷新AOF到磁盘，由flushAppendOnlyFile()函数处理。  </li>
<li>该函数封装了关于刷新缓冲区的一些复杂的逻辑，该缓冲区保存了AOF的写入缓存。  </li>
</ol>
<h4 id="进入事件循环"><a href="#进入事件循环" class="headerlink" title="进入事件循环"></a>进入事件循环</h4><p>Redis通过aeMain()进入主事件循环server.el。通过aeProcessEvents()处理所有已到达的时间事件和所有已就绪的文件事件。</p>
<h3 id="处理请求并返回响应"><a href="#处理请求并返回响应" class="headerlink" title="处理请求并返回响应"></a>处理请求并返回响应</h3><p>经过上面的启动过程后，Redis已经处于主事件轮询循环中，监听端口并等待客户端连接。<br><img src="https://i.imgur.com/J2YEVoo.png" alt=""></p>
<h4 id="处理新连接"><a href="#处理新连接" class="headerlink" title="处理新连接"></a>处理新连接</h4><p>在initServer()中，Redis注册acceptHandler()，当IO事件发生时被调用。acceptHandler()会创建一个客户端对象RedisClient。</p>
<h4 id="从客户端读取命令"><a href="#从客户端读取命令" class="headerlink" title="从客户端读取命令"></a>从客户端读取命令</h4><p>当客户端发送命令请求时，主事件循环调用readQueryFromClient()函数，它会尽可能多的读取（最多1024个字节）到临时缓冲区。<br>然后调用processInputBuffer()函数将客户端对象作为参数传递。processInputBuffer()将客户端的原始查询解析为执行Redis命令的参数，并解析每个参数的Redis字符串对象，并将它存储在客户端对象的数组中。然后调用processCommand()客户端对象来实际执行客户端发送的命令。<br>processCommand()从客户端获取命令的参数并执行。在执行前会进行许多的检查，如果检查失败，会向客户端对象附加一个错误消息并返回。</p>
<h4 id="执行命令并响应"><a href="#执行命令并响应" class="headerlink" title="执行命令并响应"></a>执行命令并响应</h4><p>call()函数，从客户端对象中获取具体执行命令的指针所指向的函数对象，并调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void call(redisClient *c, struct redisCommand *cmd) &#123;</span><br><span class="line">    long long dirty;</span><br><span class="line"></span><br><span class="line">    dirty = server.dirty;</span><br><span class="line">    cmd-&gt;proc(c);</span><br><span class="line">    dirty = server.dirty-dirty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis对象结构]]></title>
      <url>/2018/11/10/Redis/Redis%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    // 类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line"></span><br><span class="line">    // 编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line"></span><br><span class="line">    // 对象最后一次被访问的时间</span><br><span class="line">    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */</span><br><span class="line"></span><br><span class="line">    // 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    // 指向实际值的指针</span><br><span class="line">    void *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line"></span><br><span class="line">    // 数据库键空间，保存着数据库中的所有键值对</span><br><span class="line">    dict *dict;                 /* The keyspace for this DB */</span><br><span class="line"></span><br><span class="line">    // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span><br><span class="line">    dict *expires;              /* Timeout of keys with a timeout set */</span><br><span class="line"></span><br><span class="line">    // 正处于阻塞状态的键</span><br><span class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */</span><br><span class="line"></span><br><span class="line">    // 可以解除阻塞的键</span><br><span class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</span><br><span class="line"></span><br><span class="line">    // 正在被 WATCH 命令监视的键</span><br><span class="line">    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */</span><br><span class="line"></span><br><span class="line">    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */</span><br><span class="line"></span><br><span class="line">    // 数据库号码</span><br><span class="line">    int id;                     /* Database ID */</span><br><span class="line"></span><br><span class="line">    // 数据库的键的平均 TTL ，统计信息</span><br><span class="line">    long long avg_ttl;          /* Average TTL, just for stats */</span><br><span class="line"></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisClient &#123;</span><br><span class="line"></span><br><span class="line">    // 套接字描述符</span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    // 当前正在使用的数据库</span><br><span class="line">    redisDb *db;</span><br><span class="line"></span><br><span class="line">    // 当前正在使用的数据库的 id （号码）</span><br><span class="line">    int dictid;</span><br><span class="line"></span><br><span class="line">    // 客户端的名字</span><br><span class="line">    robj *name;             /* As set by CLIENT SETNAME */</span><br><span class="line"></span><br><span class="line">    // 查询缓冲区</span><br><span class="line">    sds querybuf;</span><br><span class="line"></span><br><span class="line">    // 查询缓冲区长度峰值</span><br><span class="line">    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size */</span><br><span class="line"></span><br><span class="line">    // 参数数量</span><br><span class="line">    int argc;</span><br><span class="line"></span><br><span class="line">    // 参数对象数组</span><br><span class="line">    robj **argv;</span><br><span class="line"></span><br><span class="line">    // 记录被客户端执行的命令</span><br><span class="line">    struct redisCommand *cmd, *lastcmd;</span><br><span class="line"></span><br><span class="line">    // 请求的类型：内联命令还是多条命令</span><br><span class="line">    int reqtype;</span><br><span class="line"></span><br><span class="line">    // 剩余未读取的命令内容数量</span><br><span class="line">    int multibulklen;       /* number of multi bulk arguments left to read */</span><br><span class="line"></span><br><span class="line">    // 命令内容的长度</span><br><span class="line">    long bulklen;           /* length of bulk argument in multi bulk request */</span><br><span class="line"></span><br><span class="line">    // 回复链表</span><br><span class="line">    list *reply;</span><br><span class="line"></span><br><span class="line">    // 回复链表中对象的总大小</span><br><span class="line">    unsigned long reply_bytes; /* Tot bytes of objects in reply list */</span><br><span class="line"></span><br><span class="line">    // 已发送字节，处理 short write 用</span><br><span class="line">    int sentlen;            /* Amount of bytes already sent in the current</span><br><span class="line">                               buffer or object being sent. */</span><br><span class="line"></span><br><span class="line">    // 创建客户端的时间</span><br><span class="line">    time_t ctime;           /* Client creation time */</span><br><span class="line"></span><br><span class="line">    // 客户端最后一次和服务器互动的时间</span><br><span class="line">    time_t lastinteraction; /* time of the last interaction, used for timeout */</span><br><span class="line"></span><br><span class="line">    // 客户端的输出缓冲区超过软性限制的时间</span><br><span class="line">    time_t obuf_soft_limit_reached_time;</span><br><span class="line"></span><br><span class="line">    // 客户端状态标志</span><br><span class="line">    int flags;              /* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */</span><br><span class="line"></span><br><span class="line">    // 当 server.requirepass 不为 NULL 时</span><br><span class="line">    // 代表认证的状态</span><br><span class="line">    // 0 代表未认证， 1 代表已认证</span><br><span class="line">    int authenticated;      /* when requirepass is non-NULL */</span><br><span class="line"></span><br><span class="line">    // 复制状态</span><br><span class="line">    int replstate;          /* replication state if this is a slave */</span><br><span class="line">    // 用于保存主服务器传来的 RDB 文件的文件描述符</span><br><span class="line">    int repldbfd;           /* replication DB file descriptor */</span><br><span class="line"></span><br><span class="line">    // 读取主服务器传来的 RDB 文件的偏移量</span><br><span class="line">    off_t repldboff;        /* replication DB file offset */</span><br><span class="line">    // 主服务器传来的 RDB 文件的大小</span><br><span class="line">    off_t repldbsize;       /* replication DB file size */</span><br><span class="line">    </span><br><span class="line">    sds replpreamble;       /* replication DB preamble. */</span><br><span class="line"></span><br><span class="line">    // 主服务器的复制偏移量</span><br><span class="line">    long long reploff;      /* replication offset if this is our master */</span><br><span class="line">    // 从服务器最后一次发送 REPLCONF ACK 时的偏移量</span><br><span class="line">    long long repl_ack_off; /* replication ack offset, if this is a slave */</span><br><span class="line">    // 从服务器最后一次发送 REPLCONF ACK 的时间</span><br><span class="line">    long long repl_ack_time;/* replication ack time, if this is a slave */</span><br><span class="line">    // 主服务器的 master run ID</span><br><span class="line">    // 保存在客户端，用于执行部分重同步</span><br><span class="line">    char replrunid[REDIS_RUN_ID_SIZE+1]; /* master run id if this is a master */</span><br><span class="line">    // 从服务器的监听端口号</span><br><span class="line">    int slave_listening_port; /* As configured with: SLAVECONF listening-port */</span><br><span class="line"></span><br><span class="line">    // 事务状态</span><br><span class="line">    multiState mstate;      /* MULTI/EXEC state */</span><br><span class="line"></span><br><span class="line">    // 阻塞类型</span><br><span class="line">    int btype;              /* Type of blocking op if REDIS_BLOCKED. */</span><br><span class="line">    // 阻塞状态</span><br><span class="line">    blockingState bpop;     /* blocking state */</span><br><span class="line"></span><br><span class="line">    // 最后被写入的全局复制偏移量</span><br><span class="line">    long long woff;         /* Last write global replication offset. */</span><br><span class="line"></span><br><span class="line">    // 被监视的键</span><br><span class="line">    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */</span><br><span class="line"></span><br><span class="line">    // 这个字典记录了客户端所有订阅的频道</span><br><span class="line">    // 键为频道名字，值为 NULL</span><br><span class="line">    // 也即是，一个频道的集合</span><br><span class="line">    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */</span><br><span class="line"></span><br><span class="line">    // 链表，包含多个 pubsubPattern 结构</span><br><span class="line">    // 记录了所有订阅频道的客户端的信息</span><br><span class="line">    // 新 pubsubPattern 结构总是被添加到表尾</span><br><span class="line">    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */</span><br><span class="line">    sds peerid;             /* Cached peer ID. */</span><br><span class="line"></span><br><span class="line">    /* Response buffer */</span><br><span class="line">    // 回复偏移量</span><br><span class="line">    int bufpos;</span><br><span class="line">    // 回复缓冲区</span><br><span class="line">    char buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line"></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----主从复制]]></title>
      <url>/2018/10/26/Redis/Redis%E5%8E%9F%E7%90%86----%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>很多企业都没有使用到Redis的集群，但是至少都做了主从。有了主从，当master挂掉的时候，运维让从库过来接管，服务就可以继续，否则master需要经过数据恢复和重启的过程，这就可能会拖很长时间，影响线上业务的持续服务。  </p>
<p>在了解Redis主从复制之前，让我们先来理解一下现代分布式系统的理论基石–CAP原理。</p>
<h2 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h2><p>CAP原理就好比分布式领域的牛顿定律，它是分布式存储的理论基石。自打CAP的论文发表之后，分布式存储中间件犹如雨后春笋一个一个涌现出来。  </p>
<ul>
<li>C-Consistent 一致性</li>
<li>A-Availability 可用性</li>
<li>P-Partition tolerance 分区容忍性</li>
</ul>
<p>分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着「网络分区」。</p>
<a id="more"></a>
<p>在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的「一致性」将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲「可用性」，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。<br><img src="https://i.imgur.com/owNDznt.jpg" alt=""><br>一句话概括CAP原理就是–<b>网络分区发生时，一致性和可用性两难全。</b>  </p>
<p>Redis的主从数据是异步同步的，所以分布式的Redis系统并不满足[一致性]要求。当客户端在Redis的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主从节点依旧可以正常对外提供服务，所以Redis满足[可用性]。  </p>
<p>Redis保证[最终一致性]，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态保持一致。如果网络断开，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续经历保持和主节点一致。  </p>
<h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><p>Redis同步支持主从同步和从从同步，从从同步功能是Redis后续版本增加的功能，为了减轻主库的同步负担。<br><img src="https://i.imgur.com/1IiirbA.jpg" alt="">  </p>
<h2 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h2><p>Redis同步的是指令流，主节点会将那些对自己状态产生修改性影响的指令记录在本地的内存buffer中，然后异步将buffer中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一边向主节点反馈自己同步的偏移量。  </p>
<p>因为内存的buffer（复制积压缓冲区）是有限的，所以Redis主库不能将所有的指令都记录在内存buffer中。Redis的复制内存buffer是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。<br><img src="https://i.imgur.com/I9g0mo3.jpg" alt=""><br>如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么在网络状况恢复时，Redis的主节点中那些没有同步的指令在buffer中有可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制–快照同步。  </p>
<h2 id="快照同步"><a href="#快照同步" class="headerlink" title="快照同步"></a>快照同步</h2><p>快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次bgsave将当前内存中的数据全部快照到磁盘文件中，然后再将快照文件的传送给从节点。从节点在接收完毕后，立即执行一次全量加载，加载之前会将内存中的数据清空。加载完毕后通知主节点继续进行增量同步。  </p>
<p>在整个快照同步执行的过程中，主节点的复制buffer还在不停的往前移动，如果快照同步的时间过长或者复制buffer太小，都会导致同步期间的增量指令在复制buffer中被覆盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如果极有可能陷入无限的死循环，从而影响主节点的正常服务。<br><img src="https://i.imgur.com/aw8EZAS.jpg" alt=""><br><b>请务必设置一个合适复制buffer大小参数，避免这种情况的发生。</b>  </p>
<h2 id="无盘复制"><a href="#无盘复制" class="headerlink" title="无盘复制"></a>无盘复制</h2><p>主节点在进行快照同步时，会进行很重的文件IO操作，特别是对于非SSD磁盘存储时，快照会对系统的负载产生较大影响。特别是当系统正在进行AOF的fsync操作时如果发生快照，fsync将会被推迟执行，这就会严重影响主节点的服务效率。  </p>
<p>所以从Redis2.8.18版开始支持无盘复制。所谓无盘复制就是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内容，一边将序列化的内容发送给从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。  </p>
<h2 id="Wait指令"><a href="#Wait指令" class="headerlink" title="Wait指令"></a>Wait指令</h2><p>Redis的复制是异步进行的，wait指令可以让异步复制变身同步复制，确保系统的强一致性（不严格）。wait指令时Redis3.0版本以后出现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;set key value  </span><br><span class="line">OK  </span><br><span class="line">&gt;wait 1 0  </span><br><span class="line">(interge) 1</span><br></pre></td></tr></table></figure></p>
<p>wait提供两个参数，第一个参数是从库的数量N，第二个参数是时间t，以毫秒为单位。它表示等待wait指令之前的所有写操作同步到N个从库（也就是确保N个从库的同步没有滞后），最多等待时间t。如果时间t=0，代表无限等待知道N个从库同步完成达到一致。  </p>
<p>假设此时出现了网络分区，wait指令第二个参数时间t=0，主从同步无法继续进行，wait指令会永远阻塞，Redis服务器将丧失可用性。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>主从复制是Redis分布式的基础，Redis的高可用离开了朱重构复制将无法进行。  </p>
<p>如果你将Redis只用作缓存，跟memcache一样对待，也就唔需要从库做备份，挂掉了重新启动一下就行了。但是只要你使用了Redis的持久化功能，就必须认真对待主从复制，它是系统数据安全的基础保障。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----事务]]></title>
      <url>/2018/10/25/Redis/Redis%E5%8E%9F%E7%90%86----%E4%BA%8B%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>为了确保连续多个操作的原子性，一个成熟的数据库通常都会有事务支持，Redis也不例外。Redis的事务使用非常简单，不同于关系数据库，我们无需理解那么多复杂的事务模型了，就可以直接使用。不过也正是因为这种简单性，它的事务模型很不严格，这要求我们不能像使用关系数据库的事务一样使用Redis。</p>
<h2 id="Redis事务的基本使用"><a href="#Redis事务的基本使用" class="headerlink" title="Redis事务的基本使用"></a>Redis事务的基本使用</h2><p>每个事务的操作都有begin、commit、和rollback、begin指示事务的开始，commit指示事务的提交，rollback指示事务的回滚。</p>
<p>Redis与其差不多，对应的分别是multi/exec/discard。multi指示事务的开始，exec指示事务的执行，discard指示事务的丢弃。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;multi  </span><br><span class="line">OK  </span><br><span class="line">&gt;incr books  </span><br><span class="line">QUEUED  </span><br><span class="line">&gt;incr books  </span><br><span class="line">QUEUED  </span><br><span class="line">&gt;exec  </span><br><span class="line">(integer) 1</span><br><span class="line">(integer）2</span><br></pre></td></tr></table></figure>
<p>上面的指令演示了一个完整的事务过程，所有的指令在exec之前不执行，而是<font color="red">缓存在服务器的一个事务队列中</font>，服务器一旦受到exec指令，就开始执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。因为Redis的单线程特性，它不用担心自己在执行队列的时候被其他指令打搅，可以保证他们得到的[原子性]执行。<br><img src="https://i.imgur.com/l8Awrjs.jpg" alt=""><br>上图显示了以上事务过程完整的交互结果。QUEUED是一个简单字符串，同OK是一个形式，它表示指令已经被服务器缓存到队列里了。<br><a id="more"></a></p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>事务的原子性是指要么事务全部成功，要么全部失败，那么Redis事务的执行时原子性的么？  </p>
<p>下面我们来看一个特别的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;multi  </span><br><span class="line">OK  </span><br><span class="line">&gt;set books iamstring  </span><br><span class="line">QUEUED  </span><br><span class="line">&gt;incr books  </span><br><span class="line">QUEUED  </span><br><span class="line">&gt;set poorman iamdesperate  </span><br><span class="line">QUEUED  </span><br><span class="line">&gt;exec  </span><br><span class="line">1) OK  </span><br><span class="line">2) (error)ERR value is not an integer or out of range  </span><br><span class="line">3) OK  </span><br><span class="line">&gt;get books  </span><br><span class="line">&quot;iamstring&quot;  </span><br><span class="line">&gt;get poorman  </span><br><span class="line">&quot;iamdesperate&quot;</span><br></pre></td></tr></table></figure>
<p>上面的例子是事务执行到中间遇到失败了，因为我们不能对一个字符串进行数学运算，事务在遇到指令执行失败后，后面的指令还继续执行，所以poorman的值能继续得到设置。  </p>
<p>到这里，应该明白Redis的事务根本不能算[原子性]，而仅仅是满足了事务的[隔离性]，隔离性中的串行化–当前执行的事务有着不被其他事务打断的权利。</p>
<h2 id="discard-丢弃"><a href="#discard-丢弃" class="headerlink" title="discard(丢弃)"></a>discard(丢弃)</h2><p>Redis为事务提供了一个discard指令，用于丢弃事务缓存队列中的所有指令，在exec执行之前。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面Redis事务在发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部的指令较多时，需要的网络IO时间也会线性增长。所以通常Redis的客户端在执行事务时都会结合pipeline一起使用，这样可以将多次IO操作压缩为单次IO操作。</p>
<h2 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h2><p>考虑到一个业务场景，Redis存储了我们的账户余额数据，它是一个整数。现在有两个并发的客户端要对账户余额进行修改操作，这个修改不是简单的incrby指令，而是要对余额乘以一个倍数。Redis可没有提供multiplyby这样的指令。我们需要先取出余额然后在内存里乘以倍数，再将结果写回到Redis。  </p>
<p>这就会出现并发问题，因为有多个客户端会并发进行操作。我们可以通过Redis的分布式锁来避免冲突，这是一个很好的解决方案。<b>分布式锁是一种悲观锁，那是不是可以使用悲观锁的方式来解决冲突呢？</b>  </p>
<p>Redis提供了watch的机制，它就是一种悲观锁。有了watch我们又多了一种可以用来解决并发修改的方法。watch的使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while True:  </span><br><span class="line">	do_watch()  </span><br><span class="line">	commands()  </span><br><span class="line">	multi()  </span><br><span class="line">	send_commands()  </span><br><span class="line">	try:  </span><br><span class="line">		exec()  </span><br><span class="line">		break  </span><br><span class="line">	except WatchError:  </span><br><span class="line">		continue</span><br></pre></td></tr></table></figure></p>
<p>watch会在事务开始之前盯住一个或多个关键变量，当事务执行时，也就是服务受到exec指令要顺序执行缓存的事务队列时，Redis会检查关键变量只watch之后，是否被修改了（包括当前事务所在客户端）。如果关键变量被人动过了，exec指令就会返回null回复告知客户端事务执行失败，这个时候客户端一般会想着重试。  </p>
<pre><code>&gt;watch books  
OK  
&gt;incr books  #被修改了  
(integer) 1  
&gt;multi  
OK  
&gt;incr books  
QUEUED  
&gt;exec  #事务执行失败  
(nil)  
</code></pre><p>当服务器给exec指令返回一个null回复时，客户端知道了事务执行是失败的，通常客户端(redis-py)都会抛出一个WatchError这种错误，不过也有些语言(jedis)不会抛出异常，而是通过在exec方法里返回一个null，这样客户端需要检查一下返回结果是否为null来确定事务是否执行失败。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Redis禁止在multi和exec之间执行watch指令，而必须在multi之前做好盯住关键变量，否则会出错。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----管道]]></title>
      <url>/2018/10/24/Redis/Redis%E5%8E%9F%E7%90%86----%E7%AE%A1%E9%81%93/</url>
      <content type="html"><![CDATA[<p>大多数人一直对Redis管道有一个误解，他们以为这是Redis服务器提供的一种特别的技术，有了这种技术就可以加速Redis的存取效率。但是实际上Redis管道（Pipeline）本身并不是Redis服务器直接提供的技术，这个技术本质上是由客户端提供的，跟服务器没有什么直接的关系。</p>
<h2 id="Redis的消息交互"><a href="#Redis的消息交互" class="headerlink" title="Redis的消息交互"></a>Redis的消息交互</h2><p>当我们使用客户端对Redis进行一次操作时，如下图所示，客户端将请求传送给服务器，服务器处理完毕后，再将响应回复给客户端。这要花费一个网络数据包的来回时间。  </p>
<p><img src="https://i.imgur.com/ulCYBhP.jpg" alt=""><br><a id="more"></a><br>如果连续执行多条指令，那就会花费多个网络数据包来回的时间。如下图所示。  </p>
<p><img src="https://i.imgur.com/zxGuLwE.jpg" alt="">  </p>
<p>回到客户端代码层面，客户端是经历了写-读-写-读四个操作才完整的执行了两条指令。  </p>
<p><img src="https://i.imgur.com/kW9apz0.jpg" alt="">  </p>
<p>现在如果我们调整读写顺序，改成写-写-读-读，这两个指令同样可以正常完成。  </p>
<p><img src="https://i.imgur.com/V6yvFoA.jpg" alt=""><br>两个连续的写操作和两个连续的读操作总共只会花费一次网络来回，就好比连续的write操作合并了，连续的read操作也合并了一样。</p>
<p><img src="https://i.imgur.com/qvHYXje.jpg" alt="">    </p>
<p>这便是管道操作的本质，服务器根本没有任何区别对待，还是收到一条消息，执行一条消息，回复一条消息的正常流程。客户端通过对管道中的指令列表改变读写顺序就可以大幅度节省IO时间，管道中指令越多，效果越好。  </p>
<h2 id="深入理解管道本质"><a href="#深入理解管道本质" class="headerlink" title="深入理解管道本质"></a>深入理解管道本质</h2><p>接下来我们深入分析一个请求交互的流程，真实的情况是它很复杂，因为要经过网络协议栈，这个就得深入内核了。  </p>
<p><img src="https://i.imgur.com/Ub6GJ4Z.jpg" alt="">  </p>
<p>上图就是一个完整的请求交互图。  </p>
<ol>
<li>客户端进程挑用write将消息写到操作系统内核为套接字分配的发送缓冲send buffer。  </li>
<li>客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过[网际路由]送到服务器的网卡。  </li>
<li>服务器操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲recv buffer。  </li>
<li>服务器进程调用read从接收缓冲中取出消息进行处理。  </li>
<li>服务器进程调用write将响应消息写到内核为套接字分配的发送缓冲send buffer。  </li>
<li>服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过[网际路由]送到客户端网卡。  </li>
<li>客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲recv buffer。  </li>
<li>客户端进程调用read从接收缓冲中取出消息返回给上层业务逻辑进行处理。  </li>
<li>结束。  </li>
</ol>
<p>其中步骤5-8和1-4是一样的，只不过方向是反过来的，一个是请求，一个是响应。  </p>
<p>我们开始以为write操作是要等到对方收到消息才会返回，但实际上不是这样的。write操作只负责将数据写到本地操作系统内核的发送缓冲然后就返回了。剩下的事交给操作系统内核异步将数据送到目标机器。但是如果发送缓冲满了，那么就需要等待缓冲空出空间来，这个就是写IO操作的真正耗时。  </p>
<p>我们开始以为read操作是从目标机器拉取数据，但实际上不是这样的。read操作只负责将数据从本地操作系统内核的接收缓冲中取出来。但是如果缓冲是空的，那么就需要等待数据到来，这个就是读IO操作的真正耗时。  </p>
<p>所以对于value = redis.get(key)这样一个简单的请求来说，write操作几乎没有耗时，直接写到发送缓冲就返回，而read就比较耗时了，因为他要等待消息经过网际路由到目标机器处理后的响应消息，再回送到当前的内核读缓冲才可以返回。<b>这是才是一个网络来回的真正开销。</b>  </p>
<p>而对于管道来说，连续的write操作根本没有耗时，之后第一个read操作会等待一个网络的来回开销，然后所有的响应消息就都已经回送到内核的读缓存了，后续的read操作直接就可以从缓冲拿到结果，瞬间就返回了。  </p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----持久化]]></title>
      <url>/2018/10/22/Redis/Redis%E5%8E%9F%E7%90%86----%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>Redis的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证Redis的数据不会因为故障而丢失，这种机制就是Redis的持久化机制。  </p>
<p>Redis的持久化机制有两种，第一种就是快照（RDB文件），第二种就是AOF日志。快照是一次全量备份，AOF日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而AOF日志记录的是内存数据修改的指令记录文本。AOF日志在长期的运行过程中会变得非常大，数据库重启时需要加载AOF日志进行指令重放，这个时间会变得无比漫长。所以需要定期进行AOF重写，给AOF文件瘦身。</p>
<h2 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h2><p>我们知道Redis是单线程程序，这个线程要同时负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写。  </p>
<p>在服务线上请求的同时，Redis还需要进行内存快照，内存快照要求Redis必须进行文件IO操作，可文件IO操作是不能使用多路复用API。  </p>
<p>这意味着单线程同时在服务线上的请求和吉林文件IO操作，文件IO操作会严重拖垮服务器请求的性能。还有个<b>重要的问题就是为了不阻塞线上的业务，就需要边持久化边响应客户端请求</b>。持久化的同时，内存数据结构还在变化，比如一个大型的hash字典正在持久化，结果一个请求过来把它给删除了，还没持久化，这该怎么办？  </p>
<font color="red">Redis使用操作系统的多进程COW（copy On Write）机制来实现快照持久化。</font>

<a id="more"></a>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>Redis在持久化时会调用glibc的函数fork产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。这时你可以将父子进程想象成一个连体婴儿，共享身体。这时liunx操作系统的机制，为了节约内存资源，所以尽可能让他们共享。在进程分离的一瞬间，内存的增长几乎没有明显变化。  </p>
<p>子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断修改。  </p>
<p>这个时候就会使用操作系统的COW机制进行数据段页的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程像一粒的页面是没有变化的，还是进程产生时那一瞬间的数据。  </p>
<p>随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的2倍大小。另外一个Redis实例里冷数据占的比例往往是比较高的，所以很少会出现所有的页面都会被分离，被分离的往往只有其中一部分。每个页面的大小只有4k，一个Redis实例里面一般会有成千上万的页面。  </p>
<p>子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么Redis的持久化交【快照】的原因。接下来子进程就可以非常安心的遍历数据进行序列化写磁盘了。</p>
<h2 id="AOF原理"><a href="#AOF原理" class="headerlink" title="AOF原理"></a>AOF原理</h2><p>AOF日志存储的Redis服务器的顺序指令序列，AOF日志只记录对内存进行修改的指令记录。  </p>
<p>假设AOF日志记录了自Redis实例创建以来所有的修改性指令序列，那么就可以通过对一个空的Redis实例顺序执行所有的指令，也就是重放来恢复Redis当前实例的内存数据结构的状态。  </p>
<p>Redis会在收到客户端修改指令后，进行参数校验进行逻辑处理后，如果没有问题，就立即将该指令存储到AOF日志中，也就是先执行指令才将日志存盘。这点不同于leveldb、hbase等存储引擎，他们都是先存储日志再做逻辑处理。  </p>
<p>Redis在长期运行的过程中，AOF的日志会变得越来越多。如果实例宕机重启，重放整个AOF日志会非常耗时，导致 长时间Redis无法对外提供服务，所以需要对AOF进行日志瘦身。</p>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>Redis提供了bgrewriteaof指令用于对AOF日志进行瘦身。其原理就是开辟一个子进程对内存进行遍历转换成一系列Redis的操作指令，序列化到一个新的AOF日志文件中。序列化完毕后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，追加完毕后就立即替换旧的日志文件。</p>
<h2 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h2><p>AOF日志是以文件的形式存在的，当程序对AOF日志文件进行写操作时，实际上就是内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回到磁盘。  </p>
<p>这意味着如果机器突然宕机，AOF日志内容可能还没来得及完全刷到磁盘，这个时候就会出现日志丢失。  </p>
<p>Linux的glibc提供了fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷到磁盘。只要Redis进程实时调用fsync函数就可以保证aof日志不丢失。但是fsync是一个磁盘IO操作，这意味着他很慢。如果Reids执行一条指令就要fsync一次，那么Redis的高性能地位就不保了。  </p>
<p>所以在生产环境的服务器中，Redis通常是每隔1s左右执行一次fsync操作，这是在数据安全性和性能之间做了一个折中，在保持高性能的同时，尽可能使得数据少丢失。  </p>
<p>Redis提供了另外两种策略：永不fsync（让操作系统来决定何时同步磁盘），用一个指令就fsync一次（非常慢，基本不会在生产中使用）</p>
<h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><p>快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。<br>1、遍历整个内存，大块写磁盘会加重系统负载。<br>2、AOF的fsync是一个比较耗时的IO操作，它会降低Redis性能，同时也会增加系统IO负担。  </p>
<p>所以通常Redis的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源比较充沛。  </p>
<p>但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，所以在生产环境要做好实例监控工作，保证网络畅通或者能快速修复。另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失。</p>
<h2 id="Redis4-0混合持久化"><a href="#Redis4-0混合持久化" class="headerlink" title="Redis4.0混合持久化"></a>Redis4.0混合持久化</h2><p>重启Redis时，我们很少使用rdb来恢复内存状态，因为会丢失大量数据。我们通常使用AOF日志重做，但是重放AOF日志性能相对RDB来说要慢很多，这样在Redis实例很大的情况下，启动需要花费很长的时间。  </p>
<p>Redis4.0为了解决这个问题，带来了一个新的持久化选项–混合持久化。将RDB文件的内容和增量的AOF日志文件存在一起。这里的AOF日志不在是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量AOF日志，通常这部分AOF日志很小。  </p>
<p>于是在Redis重启的时候，可以先加载rdb的内容，然后再重放增量AOF日志就可以完全替代之前的AOF全量文件重放，重启效率大幅度提升。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码阅读目录]]></title>
      <url>/2018/10/21/Redis/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>文件</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>adlist.c 、 adlist.h</td>
<td style="text-align:center">双端链表数据结构的实现。</td>
</tr>
<tr>
<td>ae.c 、 ae.h 、 ae_epoll.c 、 ae_evport.c 、 ae_kqueue.c 、 ae_select.c</td>
<td style="text-align:center">事件处理器，以及各个具体实现。</td>
</tr>
<tr>
<td>anet.c 、 anet.h</td>
<td style="text-align:center">Redis 的异步网络框架，内容主要为对 socket 库的包装。</td>
</tr>
<tr>
<td>aof.c</td>
<td style="text-align:center">AOF 功能的实现。</td>
</tr>
<tr>
<td>asciilogo.h</td>
<td style="text-align:center">保存了 Redis 的 ASCII LOGO 。</td>
</tr>
<tr>
<td>bio.c 、 bio.h</td>
<td style="text-align:center">Redis 的后台 I/O 程序，用于将 I/O 操作放到子线程里面执行， 减少 I/O 操作对主线程的阻塞。</td>
</tr>
<tr>
<td>bitops.c</td>
<td style="text-align:center">二进制位操作命令的实现文件。</td>
</tr>
<tr>
<td>blocked.c</td>
<td style="text-align:center">用于实现 BLPOP 命令和 WAIT 命令的阻塞效果。</td>
</tr>
<tr>
<td>cluster.c 、 cluster.h</td>
<td style="text-align:center">Redis 的集群实现。</td>
</tr>
<tr>
<td>config.c 、 config.h</td>
<td style="text-align:center">Redis 的配置管理实现，负责读取并分析配置文件， 然后根据这些配置修改 Redis 服务器的各个选项。</td>
</tr>
<tr>
<td>crc16.c 、 crc64.c 、 crc64.h</td>
<td style="text-align:center">计算 CRC 校验和。</td>
</tr>
<tr>
<td>db.c</td>
<td style="text-align:center">数据库实现。</td>
</tr>
<tr>
<td>debug.c</td>
<td style="text-align:center">调试实现。</td>
</tr>
<tr>
<td>dict.c 、 dict.h</td>
<td style="text-align:center">字典数据结构的实现。</td>
</tr>
<tr>
<td>endianconv.c 、 endianconv.h</td>
<td style="text-align:center">二进制的大端、小端转换函数。</td>
</tr>
<tr>
<td>fmacros.h</td>
<td style="text-align:center">一些移植性方面的宏。</td>
</tr>
<tr>
<td>help.h</td>
<td style="text-align:center">utils/generate-command-help.rb 程序自动生成的命令帮助信息。</td>
</tr>
<tr>
<td>hyperloglog.c</td>
<td style="text-align:center">HyperLogLog 数据结构的实现。</td>
</tr>
<tr>
<td>intset.c 、 intset.h</td>
<td style="text-align:center">整数集合数据结构的实现，用于优化 SET 类型。</td>
</tr>
<tr>
<td>lzf_c.c 、 lzf_d.c 、 lzf.h 、 lzfP.h</td>
<td style="text-align:center">Redis 对字符串和 RDB 文件进行压缩时使用的 LZF 压缩算法的实现。</td>
</tr>
<tr>
<td>Makefile 、 Makefile.dep</td>
<td style="text-align:center">构建文件。</td>
</tr>
<tr>
<td>memtest.c</td>
<td style="text-align:center">内存测试。</td>
</tr>
<tr>
<td>mkreleasehdr.sh</td>
<td style="text-align:center">用于生成释出信息的脚本。</td>
</tr>
<tr>
<td>multi.c</td>
<td style="text-align:center">Redis 的事务实现。</td>
</tr>
<tr>
<td>networking.c</td>
<td style="text-align:center">Redis 的客户端网络操作库， 用于实现命令请求接收、发送命令回复等工作， 文件中的函数大多为 write 、 read 、 close 等函数的包装， 以及各种协议的分析和构建函数。</td>
</tr>
<tr>
<td>notify.c</td>
<td style="text-align:center">Redis 的数据库通知实现。</td>
</tr>
<tr>
<td>object.c</td>
<td style="text-align:center">Redis 的对象系统实现。</td>
</tr>
<tr>
<td>pqsort.c 、 pqsort.h</td>
<td style="text-align:center">快速排序（QuickSort）算法的实现。</td>
</tr>
<tr>
<td>pubsub.c</td>
<td style="text-align:center">发布与订阅功能的实现。</td>
</tr>
<tr>
<td>rand.c 、 rand.h</td>
<td style="text-align:center">伪随机数生成器。</td>
</tr>
<tr>
<td>rdb.c 、 rdb.h</td>
<td style="text-align:center">RDB 持久化功能的实现。</td>
</tr>
<tr>
<td>redisassert.h</td>
<td style="text-align:center">Redis 自建的断言系统。</td>
</tr>
<tr>
<td>redis-benchmark.c</td>
<td style="text-align:center">Redis 的性能测试程序。</td>
</tr>
<tr>
<td>redis.c</td>
<td style="text-align:center">负责服务器的启动、维护和关闭等事项。</td>
</tr>
<tr>
<td>redis-check-aof.c 、 redis-check-dump.c</td>
<td style="text-align:center">RDB 文件和 AOF 文件的合法性检查程序。</td>
</tr>
<tr>
<td>redis-cli.c</td>
<td style="text-align:center">Redis 客户端的实现。</td>
</tr>
<tr>
<td>redis.h</td>
<td style="text-align:center">Redis 的主要头文件，记录了 Redis 中的大部分数据结构， 包括服务器状态和客户端状态。</td>
</tr>
<tr>
<td>redis-trib.rb</td>
<td style="text-align:center">Redis 集群的管理程序。</td>
</tr>
<tr>
<td>release.c 、 release.h</td>
<td style="text-align:center">记录和生成 Redis 的释出版本信息。</td>
</tr>
<tr>
<td>replication.c</td>
<td style="text-align:center">复制功能的实现。</td>
</tr>
<tr>
<td>rio.c 、 rio.h</td>
<td style="text-align:center">Redis 对文件 I/O 函数的包装， 在普通 I/O 函数的基础上增加了显式缓存、以及计算校验和等功能。</td>
</tr>
<tr>
<td>scripting.c</td>
<td style="text-align:center">脚本功能的实现。</td>
</tr>
<tr>
<td>sds.c 、 sds.h</td>
<td style="text-align:center">SDS 数据结构的实现，SDS 为 Redis 的默认字符串表示。</td>
</tr>
<tr>
<td>sentinel.c</td>
<td style="text-align:center">Redis Sentinel 的实现。</td>
</tr>
<tr>
<td>setproctitle.c</td>
<td style="text-align:center">进程环境设置函数。</td>
</tr>
<tr>
<td>sha1.c 、 sha1.h</td>
<td style="text-align:center">SHA1 校验和计算函数。</td>
</tr>
<tr>
<td>slowlog.c 、 slowlog.h</td>
<td style="text-align:center">慢查询功能的实现。</td>
</tr>
<tr>
<td>solarisfixes.h</td>
<td style="text-align:center">针对 Solaris 系统的补丁。</td>
</tr>
<tr>
<td>sort.c</td>
<td style="text-align:center">SORT 命令的实现。</td>
</tr>
<tr>
<td>syncio.c</td>
<td style="text-align:center">同步 I/O 操作。</td>
</tr>
<tr>
<td>testhelp.h</td>
<td style="text-align:center">测试辅助宏。</td>
</tr>
<tr>
<td>t_hash.c 、 t_list.c 、 t_set.c、 t_string.c 、 t_zset.c</td>
<td style="text-align:center">定义了 Redis 的各种数据类型，以及这些数据类型的命令。</td>
</tr>
<tr>
<td>util.c 、 util.h</td>
<td style="text-align:center">各种辅助函数。</td>
</tr>
<tr>
<td>valgrind.sup</td>
<td style="text-align:center">valgrind 的suppression文件。</td>
</tr>
<tr>
<td>version.h</td>
<td style="text-align:center">记录了 Redis 的版本号。</td>
</tr>
<tr>
<td>ziplist.c 、 ziplist.h</td>
<td style="text-align:center">ZIPLIST 数据结构的实现，用于优化 LIST 类型。</td>
</tr>
<tr>
<td>zipmap.c 、 zipmap.h</td>
<td style="text-align:center">ZIPMAP 数据结构的实现，在 Redis 2.6 以前用与优化 HASH 类型， Redis 2.6 开始已经废弃。</td>
</tr>
<tr>
<td>zmalloc.c 、 zmalloc.h</td>
<td style="text-align:center">内存管理程序。</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----通信协议]]></title>
      <url>/2018/10/21/Redis/Redis%E5%8E%9F%E7%90%86----%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>Redis的作者认为数据库系统的瓶颈一般不在于网络流量，而是数据库自身内部逻辑处理上。所以即使Redis使用了浪费流量的文本协议，依然可以取得极高的访问性能。Redis将所有数据都放在内存，用一个单线程对外提供服务，单个节点在跑满一个CPU核心的情况下可以达到10w/s的超高QPS。</p>
<h2 id="RESP"><a href="#RESP" class="headerlink" title="RESP"></a>RESP</h2><p>RESP（Redis Serialization Protocol）是Redis序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简单，解析性能极好。</p>
<p>Redis歇息将传输的数据结构分为5种最小单元类型，单元结束时统一加上回车换行符号\r\n。  </p>
<ul>
<li>单行字符以<font color="red">+</font>符号开头</li>
<li>多行字符以<font color="red">$</font>符号开头，后跟字符串长度</li>
<li>整数值以<font color="red">：</font>符号开头，后跟整数的字符串形式</li>
<li>错误消息以<font color="red">-</font>符号开头</li>
<li>数组以<font color="red">*</font>符号开头，后跟数组的长度</li>
</ul>
<p>单行字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+hello world\r\n</span><br></pre></td></tr></table></figure></p>
<p>多行字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$11\r\n  </span><br><span class="line">hello world\r\n</span><br></pre></td></tr></table></figure></p>
<p>整数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1024\r\n</span><br></pre></td></tr></table></figure></p>
<p>错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-WRONGTYPE Operation ....</span><br></pre></td></tr></table></figure></p>
<p>数组[1,2,3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n  </span><br><span class="line">:1\r\n</span><br><span class="line">:2\r\n  </span><br><span class="line">:3\r\n</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="客户端-gt-服务器"><a href="#客户端-gt-服务器" class="headerlink" title="客户端-&gt;服务器"></a>客户端-&gt;服务器</h2><p>客户端向服务器发送的指令只有一种格式，多行字符串数组。比如一个简单的set指令set k v会被序列化成以下字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n  </span><br><span class="line">$3\r\n  </span><br><span class="line">set\r\n</span><br><span class="line">$1\r\n</span><br><span class="line">k\r\n</span><br><span class="line">$1\r\n</span><br><span class="line">v\r\n</span><br></pre></td></tr></table></figure></p>
<h2 id="服务器-gt-客户端"><a href="#服务器-gt-客户端" class="headerlink" title="服务器-&gt;客户端"></a>服务器-&gt;客户端</h2><p>服务器向客户端恢复的响应要支持多种数据结构，所以消息响应在结构上要复杂不少。不过在复杂的响应消息也是以上的5种基本类型的组合。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redis协议里有大量冗余的回车换行符，但是这并不影响它成为互联网技术领域非常受欢迎的一个文本歇息。有很多开源项目目前使用RESP作为它的通讯协议。在技术领域性能并不是一切，还有简单性、易理解性和易实现性，这些都是需要进行适当权衡的。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----线程IO模型]]></title>
      <url>/2018/10/20/Redis/Redis%E5%8E%9F%E7%90%86----%E7%BA%BF%E7%A8%8BIO%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p><b>Redis是一个单线程程序</b></p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>当我们调用套接字的读写方法，默认他们是阻塞的，比如read方法要传递一个参数n，表示最多读取这门多字节后返回，如果一个字节都没有，那么线程就会卡在那里，直到新的数据到来或者连接关闭，read方法才可以返回，线程才能够继续处理。而write方法一般来说不会阻塞，除非内核为套接字分配的写缓冲区已经写满了，write方法才会阻塞，直到缓冲区有空闲空间。<img src="https://i.imgur.com/0sE9kXD.png" alt=""><br>非阻塞IO在套接字对象上提供了一个选项Non_Blocking,当这个选项打开时，读写方法不会阻塞。能读多少取决于内核为套接字分配的读缓冲区的空闲空间字节数，能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数。读方法和写方法都会通过返回值来告知程序实际读写了多少字节。</p>
<h2 id="事件轮询（多路复用）"><a href="#事件轮询（多路复用）" class="headerlink" title="事件轮询（多路复用）"></a>事件轮询（多路复用）</h2><p>非阻塞IO有个问题，就是线程要读数据，但是读了一部分就返回了，线程如何知道什么时候应该继续读，也就是当数据到来时，线程如何得到通知。写也是一样。<img src="https://i.imgur.com/bxF8jbN.png" alt=""><br>事件轮询API就是用来解决这个问题的，最简单的时间轮询API是select函数，它是操作系统提供给用户程序的API。输入时读写描述符列表read_fds &amp; write_fds，输出是与之对应的可读可写时间。同时还提供了一个timeout参数，如果没有任何事件的到来，那么最多等待timeout时间，线程处于阻塞状态。一旦期间有事件到来，就可以立即返回。线程就可以继续挨个处理相应的事件。处理完了继续过来轮询。于是线程就进入了一个死循环。我们把这个死循环称为事件轮询，一个循环为一个周期。<br><b>事件轮询API就是Java语言中的NIO技术</b></p>
<h2 id="指令队列"><a href="#指令队列" class="headerlink" title="指令队列"></a>指令队列</h2><p>Redis会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。</p>
<h2 id="响应队列"><a href="#响应队列" class="headerlink" title="响应队列"></a>响应队列</h2><p>Redis同样会为每个客户端套接字关联一个响应队列。<br>Redis服务器通过响应队列来将指令的返回结果回复给客户端。如果队列为空，那么以为这连接暂时处于空闲状态，不需要去获取写事件，也就是可以将当前的客户端描述符从write_fds里面移除。等到队列有数据了，再将描述符放进去。避免select系统调用立即返回写事件，结果发现没什么数据可以写。<b>出现这种情况的线程会飙高CPU</b></p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>服务器处理要响应的IO事件外，还要处理其他事情。比如定时任务。<br>如果线程阻塞在select系统调用上，定时任务将无法得到准时调度。那么Redis是如何解决这个问题的呢？  </p>
<p>Redis的定时任务会记录在一个最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是select系统调用的timeout参数。因为Redis知道未来timeout时间内，没有其他定时任务需要处理，所以可以安心睡眠timeout时间。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[reset master和reset slave]]></title>
      <url>/2018/09/23/mysql/reset%20master%E5%92%8Crester%20slave/</url>
      <content type="html"><![CDATA[<h3 id="reset-master"><a href="#reset-master" class="headerlink" title="reset master"></a>reset master</h3><p>删除index file中记录的所有binlog文件，将日志索引文件清空，创建一个新的日志文件，这个命令通常用于第一次搭建主从关系的主库。  </p>
<h4 id="reset-master和purge-binary-log的区别"><a href="#reset-master和purge-binary-log的区别" class="headerlink" title="reset master和purge binary log的区别"></a>reset master和purge binary log的区别</h4><ol>
<li>reset master 删除日志索引文件中记录的所有binlog文件，重新建立一个新的日志文件，起始值从000001开始，purge binary log 命令不会修改记录binlog顺序的数值</li>
<li>reset master 不能用于有任何slave正在运行的主从关系的主库。因为在slave运行时刻reset master命令不被支持。从库此时会报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In MySQL 5.6.5 and later, RESET MASTER also clears the values of the gtid_purged system variable (known as gtid_lost in MySQL 5.6.8 and earlier) as well as the global value of the gtid_executed (gtid_done, prior to MySQL 5.6.9) system variable (but not its session value); that is, executing this statement sets each of these values to an empty string (&apos;&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="reset-slave"><a href="#reset-slave" class="headerlink" title="reset slave"></a>reset slave</h3><p>reset slave 将使slave忘记主从复制关系的位置信息。该语句用于干净的启动，它删除master.info文件和relay-log.info文件以及所有的relay log文件并重新启用一个新的relay-log文件。</p>
<h3 id="reset-slave-all"><a href="#reset-slave-all" class="headerlink" title="reset slave all"></a>reset slave all</h3><p>在 5.6 版本中 reset slave 并不会清理存储于内存中的复制信息比如  master host, master port, master user, or master password,也就是说如果没有使用change master 命令做重新定向，执行start slave 还是会指向旧的master 上面。<br>当从库执行reset slave之后,将mysqld shutdown 复制参数将被重置。<br>在5.6.3 版本以及以后 使用使用 RESET SLAVE ALL 来完全的清理复制连接参数信息。(Bug #11809016)<br>RESET SLAVE ALL does not clear the IGNORE_SERVER_IDS list set by CHANGE MASTER TO. This issue is fixed in MySQL 5.7. (Bug #18816897)<br>In MySQL 5.6.7 and later, RESET SLAVE causes an implicit commit of an ongoing transaction. See Section 13.3.3, “Statements That Cause an Implicit Commit”.</p>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python装饰器]]></title>
      <url>/2018/08/19/python/python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>python装饰器就是用于<font color="red">扩展原来函数功能的一种函数</font>，这个函数的特殊之处在于它的返回值也是一个函数。使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原函数</span><br><span class="line">def func():</span><br><span class="line">	print(&quot;hello&quot;)</span><br></pre></td></tr></table></figure></p>
<p>要想扩展一个函数的功能，最简单的方法就是直接修改原函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def func():</span><br><span class="line">	print(&quot;before&quot;)</span><br><span class="line">	print(&quot;hello&quot;)</span><br><span class="line">	print(&quot;after&quot;)</span><br></pre></td></tr></table></figure></p>
<p>如果不想修改原函数，还是想增强函数的功能时，可以另外定义一个函数调用原函数。（类似于设计模式中的装饰模式，有组合和代理两种方式）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def deco(func):</span><br><span class="line">	print(&quot;before&quot;)</span><br><span class="line">	func()</span><br><span class="line">	print(&quot;after&quot;)</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">	print(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    f = func</span><br><span class="line">    deco(f)#只有把func()或者f()作为参数执行，新加入功能才会生效</span><br><span class="line">    print(&quot;f.__name__ is&quot;,f.__name__)#f的name就是func()</span><br><span class="line">    print()</span><br><span class="line">    #func()</span><br></pre></td></tr></table></figure></p>
<p>但是如果存在很多个类似于func的函数需要相同的扩展，那岂不是要执行deco函数许多次？<br>下面我们实现一个最简陋的装饰器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def deco(func):</span><br><span class="line">	def wrapper(*args, **kwargs):</span><br><span class="line">		print(&quot;before&quot;)</span><br><span class="line">		func(*args, **kwargs)</span><br><span class="line">		print(&quot;after&quot;)</span><br><span class="line">	return wrapper</span><br><span class="line"></span><br><span class="line">@deco</span><br><span class="line">def func():</span><br><span class="line">	print(&quot;hello&quot;)</span><br></pre></td></tr></table></figure></p>
<p>这里的deco函数就是最原始的装饰器，它的参数是一个函数，然后返回值也是一个函数。其中作为参数的这个函数func()就在返回函数wrapper()的内部执行。然后在函数func()前面加上@deco。<br>所以这里装饰器就像一个注入符号：有了它，拓展了原来函数的功能既不需要侵入函数内更改代码，也不需要重复执行原函数。<br>在func函数前还可以使用多个@的方式来执行多个装饰器，多个装饰器的执行顺序就是从最后一个装饰器开始执行到第一个装饰器，在执行函数本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def dec1(func):  </span><br><span class="line">    print(&quot;1111&quot;)  </span><br><span class="line">    def one():  </span><br><span class="line">        print(&quot;2222&quot;)  </span><br><span class="line">        func()  </span><br><span class="line">        print(&quot;3333&quot;)  </span><br><span class="line">    return one  </span><br><span class="line"></span><br><span class="line">def dec2(func):  </span><br><span class="line">    print(&quot;aaaa&quot;)  </span><br><span class="line">    def two():  </span><br><span class="line">        print(&quot;bbbb&quot;)  </span><br><span class="line">        func()  </span><br><span class="line">        print(&quot;cccc&quot;)  </span><br><span class="line">    return two  </span><br><span class="line"></span><br><span class="line">@dec1  </span><br><span class="line">@dec2  </span><br><span class="line">def test():  </span><br><span class="line">    print(&quot;test test&quot;)  </span><br><span class="line"></span><br><span class="line">test()  </span><br><span class="line"></span><br><span class="line">aaaa  </span><br><span class="line">1111  </span><br><span class="line">2222  </span><br><span class="line">bbbb  </span><br><span class="line">test test  </span><br><span class="line">cccc  </span><br><span class="line">3333</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[innobackupex的备份和恢复]]></title>
      <url>/2018/08/17/mysql/innobackupex%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/</url>
      <content type="html"><![CDATA[<p>还原分为3个阶段：backup（备份）、prepare（预恢复）、restore（恢复）  </p>
<p>首先复制所有的innodb数据文件，这样复制出来的文件肯定是不一致的，然后对每个文件进行崩溃恢复处理，最终达到一致。  </p>
<p>XtraBackup在启动的时候会记录一个LSN（log sequence number)，然后就把所有的innodb数据文件复制出来，这样复制出来的数据文件是不一致的。但是XtraBackup会在后台运行一个进程把所有对redo log file的修改记录下来。</p>
<p>以上步骤完成后innobackupex就会去备份MyIsam表和.frm文件，这时要保证数据的一致性就会先锁表，通过FLUSH TABLES WITH READ LOCK命令锁表后把文件复制出来，再释放掉这个锁。</p>
<p>在恢复数据的时候，要经过prepare和restore两个步骤。在prepare结束以后，innodb的表恢复到了复制innodb文件结束的时间点，这个时间点也就是锁表复制MyIsam表的起点，所以最终数据是一致的。一般我们在恢复的时候执行了两次prepare，是因为第二次prepare会帮助我们生成redo log文件，从而加快MySQL数据库启动的速度。</p>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL主从复制]]></title>
      <url>/2018/08/16/mysql/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h3><p>将主数据库中的DDL和DML操作通过二进制日志文件传输到从数据库上，然后将这些日志重新执行（重做）；从而使从数据库的数据和主数据库的数据保持一致。</p>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ul>
<li>主数据库出现问题时，可以切换到从数据库</li>
<li>可以在数据库层面进行读写分离</li>
<li>可以在从数据库上进行备份操作</li>
</ul>
<h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p><img src="http://ocx5m3vc3.bkt.clouddn.com/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt=""><br>Binary log：主数据库的二进制文件<br>Relay log：从服务器的中继日志<br><a id="more"></a></p>
<ol>
<li>master在每个事物更新数据完成之前，将该操作记录串行地写入binlog文件中。</li>
<li>salve开启一个I/O线程，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的时间。I/O线程最终的目的是将这些事件写入到中继日志中。</li>
<li>SQL线程会读取中继日志，并顺序执行该日志中的SQL时间，从而与主数据库中的数据保持一致。</li>
</ol>
<h3 id="配置主从"><a href="#配置主从" class="headerlink" title="配置主从"></a>配置主从</h3><p>一、主服务器</p>
<ul>
<li>开启二进制日志</li>
<li>配置唯一的server-id</li>
<li>创建一个用于slave和master通信的用户账号</li>
<li>获得master二进制日志文件名及位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">basedir = /home/huzb/mysql</span><br><span class="line">datadir = /home/huzb/mysql/data</span><br><span class="line">port = 23307</span><br><span class="line">server_id = 119961011</span><br><span class="line">socket = /home/huzb/mysql/mysql_23307.sock</span><br><span class="line">log-bin = master-bin</span><br><span class="line">log-bin-index = master-bin.index</span><br><span class="line"> </span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"> </span><br><span class="line">[client]</span><br><span class="line">port = 23307</span><br><span class="line">socket = /home/huzb/mysql/mysql_23307.sock</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#添加复制权限的用户</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE USER &apos;repl&apos;@&apos;100.73.41.62&apos; IDENTIFIED BY &apos;slavepass&apos;;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;100.73.41.62&apos;;</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看master状态</span><br><span class="line"></span><br><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure>
<p>二、从服务器：</p>
<ul>
<li>配置唯一的server-id</li>
<li>使用master分配的用户账号读取master二进制日志</li>
<li>启动slave服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">basedir = /home/huzb/mysql</span><br><span class="line">datadir = /home/huzb/mysql/data</span><br><span class="line">port = 23306</span><br><span class="line">server_id = 220180801</span><br><span class="line">socket = /home/huzb/mysql/mysql_23306.sock</span><br><span class="line">relay-log = slave-relay-bin</span><br><span class="line">relay-log-index = slave-relay-bin.index</span><br><span class="line"> </span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"> </span><br><span class="line">[client]</span><br><span class="line">port = 23306</span><br><span class="line">socket = /home/huzb/mysql/mysql_23306.sock</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#添加master信息</span><br><span class="line"></span><br><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line"></span><br><span class="line">MASTER_HOST=&apos;100.73.41.53&apos;,</span><br><span class="line">MASTER_PORT=23307,</span><br><span class="line">MASTER_USER=&apos;repl&apos;,</span><br><span class="line">MASTER_PASSWORD=&apos;slavepass&apos;,</span><br><span class="line">MASTER_LOG_FILE=&apos;master-bin.000001&apos;,</span><br><span class="line">MASTER_LOG_POS=629;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动slave进程</span><br><span class="line"></span><br><span class="line">mysql&gt; start slave;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看slave状态</span><br><span class="line"></span><br><span class="line">当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL之备份]]></title>
      <url>/2018/08/11/mysql/MySQL%E4%B9%8B%E5%A4%87%E4%BB%BD/</url>
      <content type="html"><![CDATA[<h2 id="备份的类型"><a href="#备份的类型" class="headerlink" title="备份的类型"></a>备份的类型</h2><h3 id="根据是否需要数据库离线"><a href="#根据是否需要数据库离线" class="headerlink" title="根据是否需要数据库离线"></a>根据是否需要数据库离线</h3><p>1、取决于业务的需求，而不是备份工具。<br>2、MyISAM不支持热备，INNODB支持热备，但是需要专门的工具。  </p>
<ul>
<li>冷备：需要关闭mysql服务，读写请求均不支持    状态下进行。</li>
<li>温备：服务在线，但仅支持读请求，不允许写请求。</li>
<li>热备：备份的同时，业务不受影响。</li>
</ul>
<h3 id="根据备份的数据集合的范围"><a href="#根据备份的数据集合的范围" class="headerlink" title="根据备份的数据集合的范围"></a>根据备份的数据集合的范围</h3><ul>
<li>完全备份：备份全部字符集。</li>
<li>增量备份：上一次完全备份或增量备份以来改变的数据。</li>
<li>差异备份：上一次完全备份以来改变的数。</li>
</ul>
<h3 id="根据备份数据或文件"><a href="#根据备份数据或文件" class="headerlink" title="根据备份数据或文件"></a>根据备份数据或文件</h3><ul>
<li>物理备份：直接备份数据文件。</li>
<li>逻辑备份：备份表中的数据和代码。<a id="more"></a>
</li>
</ul>
<h2 id="常用的备份工具"><a href="#常用的备份工具" class="headerlink" title="常用的备份工具"></a>常用的备份工具</h2><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>mysqldump是逻辑备份，所以使用这种备份方式数据的安全的。跨平台、版本都很容易。  </p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>mysqldump的优势是可以查看或者编辑十分方面，他可以灵活的恢复之前的数据。它也不关心底层的存储引擎，即适用于支持事务的，也适用于不支持事务的的表。  </p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>mysql的缺点是如果数据过大，即使备份步骤需要的时间不算太久，但有可能恢复数据的速度很慢，因为他涉及的SQL语句插入磁盘IO，创建索引等。</p>
<h3 id="mysqlhotcopy"><a href="#mysqlhotcopy" class="headerlink" title="mysqlhotcopy"></a>mysqlhotcopy</h3><p>mysqlhotcopy使用lock tables、flush tables、cp和scp来快速备份数据库。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>它是备份数据库或单个表最快的途径，完全属于物理备份。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>只能用于备份MyIsam和archive存储引擎；并且是一个服务器命令，只能运行在数据库目录所在的机器上。使用mysqlhotcopy命令之前需要安装相应的软件依赖包。</p>
<h3 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h3><p>Percona XtraBackup是一款基于MySQL的物理热备份的开源实用程序。xtrabackup基于innodb的crash-recovery（实例恢复）功能，先copy innodb的物理文件（这个时候数据的一致性是无法满足的），然后进行基于redo log进行恢复，达到数据的一致性。</p>
<h3 id="mysqlbackup"><a href="#mysqlbackup" class="headerlink" title="mysqlbackup"></a>mysqlbackup</h3><p>首先检测并应用全备事务日志文件，然后基于全备去应用增量的log。这个时候如果有多次增量备份也可以（基于LSN点向后应用）。所有的的应用完成之后就是一个可以直接cp的数据库了。</p>
<h2 id="备份和恢复的实现"><a href="#备份和恢复的实现" class="headerlink" title="备份和恢复的实现"></a>备份和恢复的实现</h2><ol>
<li>使用select into outfile实现数据的备份和还原。<br>1.1 把需要备份的数据备份出来<br>select * from test into outfile ‘/tmp/out.txt’;<br>1.2 导入<br>load data infile ‘/tmp/out.txt’ into table XXX;</li>
<li>利用mysqldump工具对数据进行备份和还原<br>mysqldump常用来做温备，所以需要对想备份的数据施加读锁。<br>2.1 施加读锁的方式：<br>2.1.1 直接在备份时添加选项<br>–lock-all-tables：对要备份的数据库的所有表施加读锁。<br>–lock-table：对单表施加读锁。<br>2.1.2 在服务端书写命令<br>mysql&gt;flush tables with read lock;施加锁，表示把内存上的表统统同步到磁盘上去后施加读锁。<br>mysql&gt;flush tables with read unlock;释放锁。<br>2.2 备份策略：完全备份+增量备份+二进制文件。</li>
</ol>
<ul>
<li>先给数据库做全量备份</li>
<li>回到mysql服务器更新数据</li>
<li>做增量备份</li>
<li>到处二进制文件</li>
<li>让mysql离线</li>
</ul>
<ol start="3">
<li>利用lvm快照实现几乎热备的数据备份和恢复</li>
<li>基于Xtrabackup做备份恢复<br>优势：</li>
</ol>
<ul>
<li>快速可靠的进行完全备份</li>
<li>在备份过程中会影响事务</li>
<li>支持数据流、网络传输、压缩，所以它可以有效的节约磁盘资源和网络带宽。</li>
<li>可以自动备份校验数据的可用性。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL之权限管理]]></title>
      <url>/2018/08/11/mysql/Mysql%E4%B9%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="一、MySQL权限简介"><a href="#一、MySQL权限简介" class="headerlink" title="一、MySQL权限简介"></a>一、MySQL权限简介</h2><p>关于mysql的权限简单的理解就是mysql允许你做你权利以内的事情，不可以越界。</p>
<h3 id="mysql权限控制的实现"><a href="#mysql权限控制的实现" class="headerlink" title="mysql权限控制的实现"></a>mysql权限控制的实现</h3><p>第一阶段：服务器首先会检查你是否允许连接。因为创建用户的时候会加上主机限制，可以限制成本地、IP、网段、任何地方等。只允许你从配置的指定地方登陆。<br>第二阶段：Mysql会检查你发出的每个请求，看你是否有足够的权限实施它。</p>
<table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:center">权限级别</th>
<th style="text-align:center">权限说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CREATE</td>
<td style="text-align:center">数据库、表或索引</td>
<td style="text-align:center">创建</td>
</tr>
<tr>
<td style="text-align:center">DROP</td>
<td style="text-align:center">数据库或表</td>
<td style="text-align:center">删除</td>
</tr>
<tr>
<td style="text-align:center">GRANT OPTION</td>
<td style="text-align:center">数据库、表或保存的程序</td>
<td style="text-align:center">赋予权限</td>
</tr>
<tr>
<td style="text-align:center">REFERENCES</td>
<td style="text-align:center">数据库或表</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ALTER</td>
<td style="text-align:center">表</td>
<td style="text-align:center">修改表</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">表</td>
<td style="text-align:center">删除数据</td>
</tr>
<tr>
<td style="text-align:center">INDEX</td>
<td style="text-align:center">表</td>
<td style="text-align:center">索引权限</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="二、MySQL权限实战"><a href="#二、MySQL权限实战" class="headerlink" title="二、MySQL权限实战"></a>二、MySQL权限实战</h2><ol>
<li>GRANT命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all privileges on *.* to jack@&apos;localhost&apos; identified by &quot;jack&quot; with grant option;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>grant:授予权限操作。</li>
<li>all:具体权限。(all代表所有权限，还可以为select、update、delete等单项权限选择)</li>
<li>on <em>.</em>:权限操作的数据库和表。(第一个<em>代表数据库，第二个</em>代表具体的表。<em>.</em>代表所有的库和表，可以指定具体库和表）</li>
<li>to user@ip:被授予权限的用户和ip。</li>
<li>identified by “passwd”:被授予用户的密码。</li>
<li>with grant option:是否拥有授予其他用户权限的权限。</li>
</ul>
<ol start="2">
<li>刷新权限：flush privileges;</li>
<li><p>查看权限：show grants;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">查看当前用户的权限：</span><br><span class="line">mysql&gt; show grants;</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">| Grants for root@localhost                                           |</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">| GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION |</span><br><span class="line">| GRANT PROXY ON &apos;&apos;@&apos;&apos; TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION        |</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">查看某个用户的权限：</span><br><span class="line">mysql&gt; show grants for &apos;jack&apos;@&apos;%&apos;;</span><br><span class="line">+-----------------------------------------------------------------------------------------------------+</span><br><span class="line">| Grants for jack@%                                                                                   |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------+</span><br><span class="line">| GRANT USAGE ON *.* TO &apos;jack&apos;@&apos;%&apos; IDENTIFIED BY PASSWORD &apos;*9BCDC990E611B8D852EFAF1E3919AB6AC8C8A9F0&apos; |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>回收权限：revoke</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; revoke delete on *.* from &apos;jack&apos;@&apos;localhost&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop user &apos;jack&apos;@&apos;localhost&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对用户重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; rename user &apos;jack&apos;@&apos;%&apos; to &apos;jim&apos;@&apos;%&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1、用set password命令</span><br><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">2、用mysqladmin</span><br><span class="line">[root@rhel5 ~]# mysqladmin -uroot -p123456 password 1234abcd</span><br><span class="line">备注：</span><br><span class="line">格式：mysqladmin -u用户名 -p旧密码 password 新密码</span><br><span class="line">3、用update直接编辑user表</span><br><span class="line">mysql&gt; use mysql</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; update user set PASSWORD = PASSWORD(&apos;1234abcd&apos;) where user = &apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">4、在丢失root密码的时候：</span><br><span class="line">[root@rhel5 ~]# mysqld_safe --skip-grant-tables &amp;</span><br><span class="line">[1] 15953</span><br><span class="line">[root@rhel5 ~]# 130911 09:35:33 mysqld_safe Logging to &apos;/mysql/mysql5.5/data/rhel5.4.err&apos;.</span><br><span class="line">130911 09:35:33 mysqld_safe Starting mysqld daemon with databases from /mysql/mysql5.5/data</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="三、MySQL权限经验原则"><a href="#三、MySQL权限经验原则" class="headerlink" title="三、MySQL权限经验原则"></a>三、MySQL权限经验原则</h2><ul>
<li>只授予能满足需要的最小权限。</li>
<li>创建用户时限制用户的登录主机，一般是限制成指定IP或内网IP段。</li>
<li>初始化数据库时删除没有密码的用户。</li>
<li>为每个用户设置满足密码复杂度的密码。</li>
<li>定期清理不需要的用户，回收权限或者删除用户。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[information_schema]]></title>
      <url>/2018/08/11/mysql/information_schema/</url>
      <content type="html"><![CDATA[<p>information_schema数据库是mysql系统自带的数据库，它提供了数据库元数据的访问方式。可以说information_schema就是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了解的信息，比如字符集、权限相关、数据库实体对象信息、外键等。<br><a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show tables;</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| Tables_in_information_schema          |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| CHARACTER_SETS                        |</span><br><span class="line">| COLLATIONS                            |</span><br><span class="line">| COLLATION_CHARACTER_SET_APPLICABILITY |</span><br><span class="line">| COLUMNS                               |</span><br><span class="line">| COLUMN_PRIVILEGES                     |</span><br><span class="line">| ENGINES                               |</span><br><span class="line">| EVENTS                                |</span><br><span class="line">| FILES                                 |</span><br><span class="line">| GLOBAL_STATUS                         |</span><br><span class="line">| GLOBAL_VARIABLES                      |</span><br><span class="line">| KEY_COLUMN_USAGE                      |</span><br><span class="line">| OPTIMIZER_TRACE                       |</span><br><span class="line">| PARAMETERS                            |</span><br><span class="line">| PARTITIONS                            |</span><br><span class="line">| PLUGINS                               |</span><br><span class="line">| PROCESSLIST                           |</span><br><span class="line">| PROFILING                             |</span><br><span class="line">| REFERENTIAL_CONSTRAINTS               |</span><br><span class="line">| ROUTINES                              |</span><br><span class="line">| SCHEMATA                              |</span><br><span class="line">| SCHEMA_PRIVILEGES                     |</span><br><span class="line">| SESSION_STATUS                        |</span><br><span class="line">| SESSION_VARIABLES                     |</span><br><span class="line">| STATISTICS                            |</span><br><span class="line">| TABLES                                |</span><br><span class="line">| TABLESPACES                           |</span><br><span class="line">| TABLE_CONSTRAINTS                     |</span><br><span class="line">| TABLE_PRIVILEGES                      |</span><br><span class="line">| TRIGGERS                              |</span><br><span class="line">| USER_PRIVILEGES                       |</span><br><span class="line">| VIEWS                                 |</span><br><span class="line">| INNODB_LOCKS                          |</span><br><span class="line">| INNODB_TRX                            |</span><br><span class="line">| INNODB_SYS_DATAFILES                  |</span><br><span class="line">| INNODB_LOCK_WAITS                     |</span><br><span class="line">| INNODB_SYS_TABLESTATS                 |</span><br><span class="line">| INNODB_CMP                            |</span><br><span class="line">| INNODB_METRICS                        |</span><br><span class="line">| INNODB_CMP_RESET                      |</span><br><span class="line">| INNODB_CMP_PER_INDEX                  |</span><br><span class="line">| INNODB_CMPMEM_RESET                   |</span><br><span class="line">| INNODB_FT_DELETED                     |</span><br><span class="line">| INNODB_BUFFER_PAGE_LRU                |</span><br><span class="line">| INNODB_SYS_FOREIGN                    |</span><br><span class="line">| INNODB_SYS_COLUMNS                    |</span><br><span class="line">| INNODB_SYS_INDEXES                    |</span><br><span class="line">| INNODB_FT_DEFAULT_STOPWORD            |</span><br><span class="line">| INNODB_SYS_FIELDS                     |</span><br><span class="line">| INNODB_CMP_PER_INDEX_RESET            |</span><br><span class="line">| INNODB_BUFFER_PAGE                    |</span><br><span class="line">| INNODB_CMPMEM                         |</span><br><span class="line">| INNODB_FT_INDEX_TABLE                 |</span><br><span class="line">| INNODB_FT_BEING_DELETED               |</span><br><span class="line">| INNODB_SYS_TABLESPACES                |</span><br><span class="line">| INNODB_FT_INDEX_CACHE                 |</span><br><span class="line">| INNODB_SYS_FOREIGN_COLS               |</span><br><span class="line">| INNODB_SYS_TABLES                     |</span><br><span class="line">| INNODB_BUFFER_POOL_STATS              |</span><br><span class="line">| INNODB_FT_CONFIG                      |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">59 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<h3 id="CHARACTER-SETS（字符集）"><a href="#CHARACTER-SETS（字符集）" class="headerlink" title="CHARACTER_SETS（字符集）"></a>CHARACTER_SETS（字符集）</h3><p>CHARACTER_SETS表提供了有关字符集的信息，它包含了以下列：</p>
<ul>
<li>CHARACTER_SET_NAME：字符集名称</li>
<li>DEFAULT_COLLATE_NAME：默认字符集排序规则</li>
<li>DESCRIPTION：字符集描述</li>
<li>MAXLEN：存储一个字符需要的最大字节数</li>
</ul>
<h3 id="COLLATIONS（字符集排序规则）"><a href="#COLLATIONS（字符集排序规则）" class="headerlink" title="COLLATIONS（字符集排序规则）"></a>COLLATIONS（字符集排序规则）</h3><p>COLLATIONS表提供了有关每个字符集排序规则的信息，它包含以下列：</p>
<ul>
<li>COLLATION_NAME：排序规则名称</li>
<li>CHARACTER_SET_NAME：与排序规则关联的字符集的名称</li>
<li>ID：排序规则的ID</li>
<li>IS_DEFAULT：排序规则是否为其字符集的默认规则</li>
<li>IS_COMPILED：字符集是否编译到服务器中</li>
<li>SORTLEN：对应字符集中表示的字符串进行排序需要的内存量</li>
</ul>
<h3 id="COLLATION-CHARACTER-SET-APPLICABILITY（排序规则）"><a href="#COLLATION-CHARACTER-SET-APPLICABILITY（排序规则）" class="headerlink" title="COLLATION_CHARACTER_SET_APPLICABILITY（排序规则）"></a>COLLATION_CHARACTER_SET_APPLICABILITY（排序规则）</h3><p>表COLLATION_CHARACTER_SET_APPLICABILITY表示哪种字符集适用于哪种排序规则，它包含以下列：</p>
<ul>
<li>COLLATION_NAME：排序规则名称</li>
<li>CHARACTER_SET_NAME与培训规则关联的字符集名称</li>
</ul>
<h3 id="COLUMNS（列信息）"><a href="#COLUMNS（列信息）" class="headerlink" title="COLUMNS（列信息）"></a>COLUMNS（列信息）</h3><p>表COLUMNS提供表中列的信息，它包含以下列：</p>
<ul>
<li>TABLE_CATALOG：包含改列的表所属的目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA：包含改列的表所属的数据库名称</li>
<li>TABLE_NAME：包含改列的表的名称</li>
<li>COLUMN_NAME：列名</li>
<li>ORDINAL_POSITION：表中列的位置</li>
<li>COLUMN_DEFAULT：列的默认值</li>
<li>IS_NULLABLE：列是否可控</li>
<li>DATA_TYPE：列的数据类型</li>
<li>CHARACTER_MAXIMUM_LENGTH：对于字符串列，表示最大长度（以字符为单位）</li>
<li>CHARACTER_OCTET_LENGTH：对于字符串列，表示最大长度（以字节为单位）</li>
<li>NUMERIC_PRECISION：对于数字列，数字精度</li>
<li>NUMERIC_SCALE：对于数字列，数字刻度</li>
<li>DATETIME_PRECISION：对于时间列，小数秒精度</li>
<li>DATETIME_PRECISION：对于字符串列，字符集名称</li>
<li>COLLATION_NAME：对于字符串列，排序规则名称</li>
<li>COLUMN_TYPE：列数据类型，包含类名称以及可能的其他信息，列如精度或长度</li>
<li>COLUMN_TYPE：列是否编入索引</li>
<li>EXTRA：指定列的任何其他可用信息</li>
<li>PRIVILEGES：当前用户对改列的权限</li>
<li>COLUMN_COMMENT：列的注释</li>
<li>GENERATION_EXPRESSION：对于生成的列，显示用于计算列值的表达式</li>
</ul>
<h3 id="COLUMN-PRIVILEGES（列权限）"><a href="#COLUMN-PRIVILEGES（列权限）" class="headerlink" title="COLUMN_PRIVILEGES（列权限）"></a>COLUMN_PRIVILEGES（列权限）</h3><p>表COLUMN_PRIVILEGES提供有关列权限的信息，它是从mysql.columns_priv系统表中获取的信息。主要包含以下列：</p>
<ul>
<li>GRANTEE：授予权限的账户的名称，格式为’用户名‘@’主机名’</li>
<li>TABLE_CATALOG：包含该列的表所属的目录名称，总默认为def</li>
<li>TABLE_SCHEMA：包含该列的表所属数据库名称</li>
<li>TABLE_NAME：包含该列的表的名称</li>
<li>COLUMN_NAME：列的名称</li>
<li>PRIVILEGE_TYPE：授予的特权</li>
<li>IS_GRANTABLE：该用户是否能够将此列权利授予给他人</li>
</ul>
<h3 id="ENGINES（存储引擎）"><a href="#ENGINES（存储引擎）" class="headerlink" title="ENGINES（存储引擎）"></a>ENGINES（存储引擎）</h3><p>表ENGINES提供有关存储引擎的信息，这对于检查是否支持存储引擎或查看默认引擎是特别有用。主要包含以下列：</p>
<ul>
<li>ENGINE：存储引擎名称</li>
<li>SUPPORT：服务器对该存储引擎的支持级别</li>
<li>COMMENT：简要说明</li>
<li>TRANSACTIONS：是否支持XA事务</li>
<li>SAVEPOINTS：是否支持保存点</li>
</ul>
<h3 id="EVENTS（事件）"><a href="#EVENTS（事件）" class="headerlink" title="EVENTS（事件）"></a>EVENTS（事件）</h3><p>表EVENTS提供有关事件管理器事件的信息，它包含以下列：</p>
<ul>
<li>EVENT_CATALOG：事件所属目录的名称。该值始终为def</li>
<li>EVENT_SCHEMA：事件所属的数据库名称</li>
<li>EVENT_NAME：事件名称</li>
<li>DEFINER：创建事件的用户账号</li>
<li>TIME_ZONE：事件时区，默认为SYSTEM</li>
<li>EVENT_BODY：事件的DO子句中的语言，始终为SQL</li>
<li>EVENT_DEFINITION：事件执行的语句</li>
<li>EVENT_TYPE：事件重复类型，一次/重复</li>
<li>EXECUTE_AT：一次性事件执行事件点</li>
<li>INTERVAL_VALUE：重复事件的间隔时间</li>
<li>INTERVAL_FIELD：重复事件间隔的时间单位</li>
<li>SQL_MODE：创建或更改时间时生效的SQL模式，以及执行事件的情况</li>
<li>STARTS：重复事件开始的时间</li>
<li>ENDS：重复事件结束的时间</li>
<li>STATUS：事件状态。ENABLED|DISABLED|SLAVESIDE_DISABLED|SLAVESIDE_DISABLED</li>
<li>ON_COMPLETION：</li>
<li>CREATED：事件的创建事件</li>
<li>LAST_ALTERED：最后一次修改事件的时间</li>
<li>LAST_EXECUTED：最后一次执行事件的时间</li>
<li>EVENT_COMMENT：事件注释</li>
<li>ORIGINATOR：创建事件的MySQL服务器ID</li>
<li>CHARACTER_SET_CLIENT：创建事件时CHARACTER_SET_CLIENT系统变量的会话值</li>
<li>COLLATION_CONNECTION：创建事件时COLLATION_CONNECTION系统变量的会话值</li>
<li>DATABASE_COLLATION：与事件关联的数据库排序规则</li>
</ul>
<h3 id="FILES（文件）"><a href="#FILES（文件）" class="headerlink" title="FILES（文件）"></a>FILES（文件）</h3><p>表FILES提供有关存储MySQL表空间数据的文件信息，它包含以下列（innodb）：</p>
<ul>
<li>FILES_ID：表空间ID；</li>
<li>FILE_NAME：数据文件的名称</li>
<li>FILE_TYPE：表空间文件类型</li>
<li>TABLESPACE_NAME：表空间的SQL名称</li>
<li>TABLE_CATALOG：始终为空</li>
<li>TABLE_SCHEMA：始终为NULL</li>
<li>TABLE_NAME：始终为NULL</li>
<li>LOGFILE_GROUP_NAME：始终为NULL</li>
<li>LOGFILE_GROUP_NUMBER：始终为NULL</li>
<li>ENGINE：始终为INNODB</li>
<li>FULLTEXT_KEYS：始终为NULL</li>
<li>DELETED_ROWS：始终为NULL</li>
<li>UPDATE_COUNT：始终为NULL</li>
<li>FREE_EXTENTS：当前数据文件中完全空闲的extents数</li>
<li>TOTAL_EXTENTS：当前数据文件中使用的完整的extents的数量</li>
<li>EXTENT_SIZE：对于页面大小为4k/8k/16k的文件，范围大小为1048576(1MB),对于页面大小为32k的文件，范围大小为2097152(2MB)，对于页面大小为64k的文件，范围大小为4194304(4MB)。</li>
<li>INITIAL_SIZE：文件的初始大小（以字节为单位）。</li>
<li>MAXIMUM_SIZE：文件中允许的最大字节数</li>
<li>AUTOEXTEND_SIZE：系统表空间的innodb_data_file_path定义的自动扩展大小，或者是临时表空间的innodb_temp_data_file_path。</li>
<li>CREATION_TIME：始终为NULL</li>
<li>LAST_UPDATE_TIME：始终为NULL</li>
<li>LAST_ACCESS_TIME：始终为NULL</li>
<li>RECOVER_TIME：始终为NULL</li>
<li>TRANSACTION_COUNTER：始终为NULL</li>
<li>VERSION：始终为NULL</li>
<li>ROW_FORMAT：始终为NULL</li>
<li>TABLE_ROWS：始终为NULL</li>
<li>AVG_ROW_LENGTH：始终为NULL</li>
<li>DATA_LENGTH：始终为NULL</li>
<li>MAX_DATA_LENGTH：始终为NULL</li>
<li>INDEX_LENGTH：始终为NULL</li>
<li>DATA_FREE：整个表空间的可用空间总量（以字节为单位）</li>
<li>CREATE_TIME：始终为NULL</li>
<li>UPDATE_TIME：始终为NULL</li>
<li>CHECK_TIME：始终为NULL</li>
<li>CHECKSUM：始终为NULL</li>
<li>STATUS：默认为NORMAL</li>
<li>EXTRA：始终为NULL</li>
</ul>
<h3 id="GLOBAL-STATUS-与-SESSION-STATUS（服务器状态变量）"><a href="#GLOBAL-STATUS-与-SESSION-STATUS（服务器状态变量）" class="headerlink" title="GLOBAL_STATUS 与 SESSION_STATUS（服务器状态变量）"></a>GLOBAL_STATUS 与 SESSION_STATUS（服务器状态变量）</h3><p>GLOBAL_STATUS和SESSION_STATUS表提供有关服务器状态变量的信息。它们的内容对应于SHOW GLOBAL STATUS和SHOW SESSION STATUS语句产生的结果。<a href="https://dev.mysql.com/doc/refman/5.7/en/show-status.html" target="_blank" rel="noopener">SHOW STATUS语法</a></p>
<h3 id="GLOBAL-VARIABLES-与-SESSION-VARIABLES（服务器状态变量）"><a href="#GLOBAL-VARIABLES-与-SESSION-VARIABLES（服务器状态变量）" class="headerlink" title="GLOBAL_VARIABLES 与 SESSION_VARIABLES（服务器状态变量）"></a>GLOBAL_VARIABLES 与 SESSION_VARIABLES（服务器状态变量）</h3><p>GLOBAL_VARIABLES和SESSION_VARIABLES表提供有关服务器状态变量的信息，它们的内容对应于SHOW GLOBAL VARIABLES和SHOW SESSION VARIABLES语句产生的信息。<a href="https://dev.mysql.com/doc/refman/5.7/en/show-variables.html" target="_blank" rel="noopener">SHOW VARIABLES语法</a></p>
<h3 id="KEY-COLUMN-USAGE（键列约束）"><a href="#KEY-COLUMN-USAGE（键列约束）" class="headerlink" title="KEY_COLUMN_USAGE（键列约束）"></a>KEY_COLUMN_USAGE（键列约束）</h3><p>KEY_COLUMN_USAGE表描述哪些键列具有约束，它包含以下列：</p>
<ul>
<li>CONSTRAINT_CATALOG：约束所属目录的名称。该值始终为def</li>
<li>CONSTRAINT_SCHEMA：约束所属数据库名称</li>
<li>CONSTRAINT_NAME：约束名称</li>
<li>TABLE_CATALOG：表所属目录名称，该值始终为def</li>
<li>TABLE_SCHEMA：表所属数据库名称</li>
<li>TABLE_NAME：表名</li>
<li>COLUMN_NAME：具有约束的列的名称，如果约束是外键，则是外键的列，而不是外键引用的列。</li>
<li>ORDINAL_POSITION：列在约束内的位置，而不是列在表中的位置。</li>
<li>POSITION_IN_UNIQUE_CONSTRAINT：NULL对于唯一和主键约束。对于外键约束，此列是正在引用的表的键中的序号位置</li>
<li>REFERENCED_TABLE_SCHEMA：约束引用的数据库名称</li>
<li>REFERENCED_TABLE_NAME：约束引用的表的名称</li>
<li>REFERENCED_COLUMN_NAME：约束引用的列的名称</li>
</ul>
<h3 id="OPTIMIZER-TRACE（语句优化程序）"><a href="#OPTIMIZER-TRACE（语句优化程序）" class="headerlink" title="OPTIMIZER_TRACE（语句优化程序）"></a>OPTIMIZER_TRACE（语句优化程序）</h3><p>OPTIMIZER_TRACE表提供由跟踪语句的优化程序跟踪功能生成的信息，它包含以下列：</p>
<ul>
<li>QUERY：跟踪的文本</li>
<li>TRACE：以JSON格式跟踪</li>
<li>MISSING_BYTES_BEYOND_MAX_MEM_SIZE：跟踪的每个文件是一个字符串，随着优化的进行而扩展，并将数据附加到该字符串。</li>
<li>INSUFFICIENT_PRIVILEGES：如果跟踪查询使用具有值为DEFINER的SQL SECURITY的视图或存储例程，则可能会拒绝定义者以外的用户查看查询的跟踪。 在这种情况下，跟踪显示为空INSUFFICIENT_PRIVILEGES的值为1.否则，该值为0。</li>
</ul>
<h3 id="PARAMETERS（存储例程参数）"><a href="#PARAMETERS（存储例程参数）" class="headerlink" title="PARAMETERS（存储例程参数）"></a>PARAMETERS（存储例程参数）</h3><p>PARAMETERS表提供有关存储例程的参数（存储过程和存储函数）的参数以及存储函数的返回值的信息。</p>
<ul>
<li>SPECIFIC_CATALOG：包含参数的例程所属的目录的名称，该值始终为def</li>
<li>SPECIFIC_SCHEMA：包含参数的例程所属的数据库名称</li>
<li>SPECIFIC_NAME：包含参数的例程的名称</li>
<li>ORDINAL_POSITION：对于存储过程或函数的连续参数，ORDINAL_POSITION值为1，2，3等。对于存储函数，还有一行适用于函数返回值</li>
<li>PARAMETER_MODE：参数的模式</li>
<li>PARAMETER_NAME：参数的名称</li>
<li>DATA_TYPE：参数数据类型</li>
<li>CHARACTER_MAXIMUM_LENGTH：对于字符串，以字符为单位的最大长度</li>
<li>CHARACTER_OCTET_LENGTH：对于字符串，以字节为单位的最大长度</li>
<li>NUMERIC_PRECISION：对于数字参数，显示数字精度</li>
<li>NUMERIC_SCALE：对于数字参数，显示数字刻度</li>
<li>DATETIME_PRECISION：对于时间参数，以小数秒精度</li>
<li>CHARACTER_SET_NAME：对于字符串参数，字符集名称</li>
<li>COLLATION_NAME：对于字符串参数，排序规则名称</li>
<li>DTD_IDENTIFIER：参数数据类型</li>
<li>ROUTINE_TYPE：PROCEDURE用于存储过程， FUNCTION用于存储的函数</li>
</ul>
<h3 id="PARTITIONS（表分区）"><a href="#PARTITIONS（表分区）" class="headerlink" title="PARTITIONS（表分区）"></a>PARTITIONS（表分区）</h3><p>PARTITIONS表提供有关表分区的信息。</p>
<ul>
<li>TABLE_CATALOG：表所属目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA：表所属数据库名称</li>
<li>TABLE_NAME：分区表名称</li>
<li>PARTITION_NAME：分区名称</li>
<li>SUBPARTITION_NAME：如果PARTITIONS表行代表子分区，则为子分区的名称，否则为NULL</li>
<li>PARTITION_ORDINAL_POSITION：所有分区的索引顺序与它们的定义的顺序相同。</li>
<li>SUBPARTITION_ORDINAL_POSITION：给定分区中的子分区也被索引和重新索引，其方式与在表中索引分区的方式相同</li>
<li>PARTITION_METHOD：分区的方式。值RANGE，LIST，HASH，LINEAR HASH，KEY或LINEAR KEY之一</li>
<li>SUBPARTITION_METHOD：值HASH, LINEAR HASH, KEY, 或者 LINEAR KEY之一</li>
<li>PARTITION_EXPRESSION：创建表的当前分区方案的CREATE TABLE或ALTER TABLE语句中使用的分区函数的表达式</li>
</ul>
<h3 id="PLUGINS（插件）"><a href="#PLUGINS（插件）" class="headerlink" title="PLUGINS（插件）"></a>PLUGINS（插件）</h3><p>PLUGINS表提供有关服务器插件的信息</p>
<ul>
<li>PLUGINS_NAME：用于在诸如INSTALL PLUGINS和UNINSTALL PLUGINS之类的语句中引用插件的名称</li>
<li>PLUGIN_VERSION：插件的常规类型描述符中的版本。</li>
<li>PLUGIN_STATUS：插件状态，ACTIVE、INACTIVE、DISABLED或DELETED之一</li>
<li>PLUGIN_TYPE：插件的类型，列如STORAGE ENGINE，INFORMATION_SCHEMA或AUTHENTICATION。</li>
<li>PLUGIN_TYPE_VERSION：插件的特定于类型的描述符中的版本</li>
<li>PLUGIN_LIBRARY：插件共享库文件的名称</li>
<li>PLUGIN_LIBRARY_VERSION：插件API接口版本</li>
<li>PLUGIN_AUTHOR：插件作者</li>
<li>PLUGIN_DESCRIPTION：插件的简短描述</li>
<li>PLUGIN_LICENSE：插件如何获得许可</li>
<li>LOAD_OPTION：如何加载插件</li>
</ul>
<h3 id="PROCESSLIST（线程）"><a href="#PROCESSLIST（线程）" class="headerlink" title="PROCESSLIST（线程）"></a>PROCESSLIST（线程）</h3><p>PROCESSLIST表提供有关正在运行的线程的信息</p>
<ul>
<li>ID：连接标识符</li>
<li>USER：发出语句的用户</li>
<li>HOST：发出语句的客户端的主机名</li>
<li>DB：默认数据库</li>
<li>COMMAND：线程正在执行的命令类型</li>
<li>TIME：线程处于当前状态的时间</li>
<li>STATE：指示献出了正在执行的操作，事件或状态。</li>
<li>INFO：线程正在执行的语句</li>
</ul>
<h3 id="PROFILING（语句分析）"><a href="#PROFILING（语句分析）" class="headerlink" title="PROFILING（语句分析）"></a>PROFILING（语句分析）</h3><p>PROFILING表提供语句分析信息。其内容对应于SHOW PROFILE和SHOW PROFILES语句生成的信息。</p>
<ul>
<li>QUERY_ID：数字语句标识符</li>
<li>SEQ：一个序列号，指示具有相同QUERY_ID值得行的显示顺序</li>
<li>STATUS：状态</li>
<li>DURATION：语句执行在给定状态中保持多长时间，以秒为单位</li>
<li>CPU_USER：用户使用CPU时间，以s为单位</li>
<li>CPU_SYSTEM：系统使用CPU时间，以s为单位</li>
<li>CONTEXT_VOLUNTARY：发生了多少自愿的上下文切换</li>
<li>CONTEXT_INVOLUNTARY：发生了多少非自愿的上下文切换</li>
<li>BLOCK_OPS_IN：块输入操作数量</li>
<li>BLOCK_OPS_OUT：块输出操作数量</li>
<li>MESSAGES_SENT：发送的通信消息数</li>
<li>MESSAGES_RECEIVED：接受的通信消息数</li>
<li>PAGE_FAULTS_MAJOR：主页面错误数量</li>
<li>PAGE_FAULTS_MINOR：次页面错误数量</li>
<li>SWAPS：发生了多少次swap</li>
<li>SOURCE_FUNCTION：指配置文件状态在源代码function位置的执行的信息</li>
<li>SOURCE_FILE：指配置文件状态在源代码file位置的执行的信息</li>
<li>SOURCE_LINE：指配置文件状态在源代码line位置的执行的信息</li>
</ul>
<h3 id="REFERENTIAL-CONSTRAINTS（外键）"><a href="#REFERENTIAL-CONSTRAINTS（外键）" class="headerlink" title="REFERENTIAL_CONSTRAINTS（外键）"></a>REFERENTIAL_CONSTRAINTS（外键）</h3><p>REFERENTIAL_CONSTRAINTS表提供有关外键的信息</p>
<ul>
<li>CONSTRAINT_CATALOG：约束所属目录的名称，始终为def</li>
<li>CONSTRAINT_SCHEMA：约束所属数据库名称</li>
<li>CONSTRAINT_NAME：约束名称</li>
<li>UNIQUE_CONSTRAINT_CATALOG：包含约束引用的唯一约束的目录的名称，始终为def</li>
<li>UNIQUE_CONSTRAINT_SCHEMA：包含约束引用的唯一约束的数据库名称</li>
<li>UNIQUE_CONSTRAINT_NAME：约束引用的唯一约束的名称</li>
<li>MATCH_OPTION：约束MATCH属性的值</li>
<li>UPDATE_RULE：约束ON UPDATE属性的值，可能为CASCADE，SET NULL，SET DEFAULT，RESTRICT，NO ACTION</li>
<li>DELETE_RULE：约束ON DELETE属性的值。可能的值是CASCADE，SET NULL，SET DEFAULT，RESTRICT，NO ACTION</li>
<li>TABLE_NAME：表的名称</li>
<li>REFERENCED_TABLE_NAME：约束引用的表的名称</li>
</ul>
<h3 id="ROUTINES（存储例程）"><a href="#ROUTINES（存储例程）" class="headerlink" title="ROUTINES（存储例程）"></a>ROUTINES（存储例程）</h3><p>ROUTINES表提供有关存储例程的信息。ROUTINES表不包含内置SQL函数或用户定义函数（UDF）</p>
<ul>
<li>SPECIFIC_NAME：例程的名称</li>
<li>ROUTINE_CATALOG：例程所属目录名称，默认def</li>
<li>ROUTINE_SCHEMA：例程所属数据库名称</li>
<li>ROUTINE_NAME：例程名称</li>
<li>ROUTINE_TYPE：存储过程的PROCEDURE ，存储函数的FUNCTION</li>
<li>DATA_TYPE ：如果例程是存储函数，则返回值数据类型。如果例程是存储过程，则此值为空</li>
<li>CHARACTER_MAXIMUM_LENGTH：对于存储的函数字符串返回值，以字符为单位的最大长度。如果例程是存储过程，则此值为NULL</li>
<li>CHARACTER_OCTET_LENGTH ：对于存储的函数字符串返回值，以字节为单位的最大长度。如果例程是存储过程，则此值为NULL</li>
<li>NUMERIC_PRECISION ：对于存储函数数字返回值，数字精度。如果例程是存储过程，则此值为NULL</li>
<li>NUMERIC_SCALE ：对于存储的函数数字返回值，数字刻度。如果例程是存储过程，则此值为NULL</li>
<li>DATETIME_PRECISION ：对于存储的函数时间返回值，小数秒精度。如果例程是存储过程，则此值为NULL</li>
<li>CHARACTER_SET_NAME ：对于存储的函数字符串返回值，字符集名称。如果例程是存储过程，则此值为NULL</li>
<li>COLLATION_NAME ：对于存储的函数字符串返回值，排序规则名称。如果例程是存储过程，则此值为NULL</li>
<li>DTD_IDENTIFIER ：如果例程是存储函数，则返回值数据类型。如果例程是存储过程，则此值为空。DATA_TYPE值只是类型名称，没有其他信息。 DTD_IDENTIFIER值包含类型名称以及可能的其他信息，例如精度或长度</li>
<li>ROUTINE_BODY ：用于例程定义的语言。该值始终为SQL</li>
<li>ROUTINE_DEFINITION ：例程执行的SQL语句的文本</li>
<li>EXTERNAL_NAME ：此值始终为NULL</li>
<li>EXTERNAL_LANGUAGE ：存储例程的语言</li>
<li>PARAMETER_STYLE ：该值始终为SQL</li>
<li>IS_DETERMINISTIC ：yes或no，取决于是否使用DETERMINISTIC特性定义例程</li>
<li>SQL_DATA_ACCESS ：例程的数据访问特性。该值是CONTAINS SQL，NO SQL，READS SQL DATA或MODIFIES SQL DATA之一</li>
<li>SQL_PATH ：此值始终为NULL</li>
<li>SECURITY_TYPE ：例程SQL SECURITY特性。该值是DEFINER或INVOKER之一</li>
<li>CREATED ：创建例程的日期和时间。这是TIMESTAMP值</li>
<li>LAST_ALTERED ：上次修改例程的日期和时间。这是TIMESTAMP值。如果例程自创建以来未被修改，则此值与CREATED值相同</li>
<li>SQL_MODE ：创建或更改例程时执行的SQL模式，以及执行例程的情况</li>
<li>ROUTINE_COMMENT ：如果例程有注释，则以文本显示。反正，则为空</li>
<li>DEFINER ：以“user_name”@“host_name”格式创建例程的用户的帐户</li>
<li>CHARACTER_SET_CLIENT ：创建例程时character_set_client系统变量的会话值</li>
<li>COLLATION_CONNECTION ：创建例程时collat​​ion_connection系统变量的会话值</li>
<li>DATABASE_COLLATION ：与例程关联的数据库的排序规则</li>
</ul>
<h3 id="SCHEMATA（数据库）"><a href="#SCHEMATA（数据库）" class="headerlink" title="SCHEMATA（数据库）"></a>SCHEMATA（数据库）</h3><p>SCHEMATA表提供有关数据库的信息</p>
<ul>
<li>CATALOG_NAME：SCHEMA所属目录的名称。该值始终为def</li>
<li>SCHEMA_NAME ：SCHEMA名称</li>
<li>DEFAULT_CHARACTER_SET_NAME：SCHEMA默认字符集</li>
<li>DEFAULT_COLLATION_NAME ：SCHEMA字符集排序规则</li>
<li>SQL_PATH ：此值始终为NULL</li>
</ul>
<h3 id="SCHEMA-PRIVILEGES（数据库权限）"><a href="#SCHEMA-PRIVILEGES（数据库权限）" class="headerlink" title="SCHEMA_PRIVILEGES（数据库权限）"></a>SCHEMA_PRIVILEGES（数据库权限）</h3><p>SCHEMA_PRIVILEGES表提供有关数据库权限的信息，从mysql.db系统表获取值</p>
<ul>
<li>GRANTEE ：授予权限的帐户的名称，格为“user_name”@“host_name”</li>
<li>TABLE_CATALOG ：schema所属目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA ：schema的名称</li>
<li>PRIVILEGE_TYPE：授予的特权。</li>
<li>IS_GRANTABLE ：如果用户具有GRANT OPTION权限，则为YES，否则为NO</li>
</ul>
<h3 id="STATISTICS（表索引）"><a href="#STATISTICS（表索引）" class="headerlink" title="STATISTICS（表索引）"></a>STATISTICS（表索引）</h3><p>STATISTICS表提供有关表索引的信息</p>
<ul>
<li>TABLE_CATALOG：包含索引的表所属的目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA ：包含索引的表所属的schema（数据库）的名称</li>
<li>TABLE_NAME ：包含索引的表的名称</li>
<li>NON_UNIQUE ：如果索引不能包含重复项，则为0;如果可以，则为1</li>
<li>INDEX_SCHEMA ：索引所属的schema（数据库）的名称</li>
<li>INDEX_NAME ：索引的名称。如果索引是主键，则名称始终为PRIMARY</li>
<li>SEQ_IN_INDEX ：索引中的列序列号，以1开头</li>
<li>COLUMN_NAME ：列名称</li>
<li>COLLATION ：列如何在索引中排序</li>
<li>CARDINALITY ：估计索引中唯一值的数量</li>
<li>SUB_PART ：索引前缀</li>
</ul>
<h3 id="TABLES（表）"><a href="#TABLES（表）" class="headerlink" title="TABLES（表）"></a>TABLES（表）</h3><p>TABLES表提供有关数据库中表的信息，它包含以下列：</p>
<ul>
<li>TABLE_CATALOG：表所属目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA：表所在库的名称</li>
<li>TABLE_NAME：表名称</li>
<li>TABLE_TYPE：BASE TABLE(表)、VIEW(视图)、SYSTEM VIEW(INFORMATION_SCHEMA库中的表)</li>
<li>ENGINE：表的存储引擎</li>
<li>VERSION：表的.frm文件的版本号</li>
<li>ROW_FORMAT：行存储格式</li>
<li>TABLE_ROWS：行数</li>
<li>AVG_ROW_LENGTH：平均行长</li>
<li>DATA_LENGTH：对于MyISAM表，代表数据文件的长度，单位为字节；对于Innodb，代表聚簇索引配置的近似内存量，单位为字节</li>
<li>MAX_DATA_LENGTH：数据文件的最大长度</li>
<li>INDEX_LENGTH：索引文件的长度</li>
<li>DATA_FREE：已分配但未使用的字节数</li>
<li>AUTO_INCREMENT：自增主键的下一个值</li>
<li>CREATE_TIME：创建表的时间</li>
<li>UPDATE_TIME：上次更新数据文件的时间</li>
<li>CHECK_TIME：上次检查表的时间</li>
<li>TABLE_COLLATION：表的默认排序规则</li>
<li>CHECKSUM：实时校验和值</li>
<li>CREATE_OPTIONS：CREATE TABLE使用的额外选项</li>
<li>TABLE_COMMENT：创建表时使用的注释</li>
</ul>
<h3 id="TABLESPACES（表空间）"><a href="#TABLESPACES（表空间）" class="headerlink" title="TABLESPACES（表空间）"></a>TABLESPACES（表空间）</h3><p>TABLESPACES表提供有关活动MySQL Cluster表空间的信息</p>
<ul>
<li>TABLESPACE_NAME ：表空间名称</li>
<li>ENGINE ：表空间使用的存储引擎名称</li>
<li>TABLESPACE_TYPE ：表空间类型</li>
<li>LOGFILE_GROUP_NAME：分配给表空间的日志文件组的名称</li>
<li>EXTENT_SIZE ：属于表空间的文件使用的扩展区的大小（以字节为单位）</li>
<li>AUTOEXTEND_SIZE ：不使用</li>
<li>MAXIMUM_SIZE ：不使用</li>
<li>NODEGROUP_ID ：不使用</li>
<li>TABLESPACE_COMMENT：不使用</li>
</ul>
<h3 id="TABLE-CONSTRAINTS（表约束）"><a href="#TABLE-CONSTRAINTS（表约束）" class="headerlink" title="TABLE_CONSTRAINTS（表约束）"></a>TABLE_CONSTRAINTS（表约束）</h3><p>TABLE_CONSTRAINTS表描述哪些表具有约束</p>
<ul>
<li>CONSTRAINT_CATALOG：约束所属目录的名称。该值始终为def</li>
<li>CONSTRAINT_SCHEMA ：约束所属的schema（数据库）的名称</li>
<li>CONSTRAINT_NAME ：约束名称</li>
<li>TABLE_SCHEMA ：表所属的schema（数据库）的名称</li>
<li>TABLE_NAME ：表名称</li>
<li>CONSTRAINT_TYPE ：约束的类型</li>
</ul>
<h3 id="TABLE-PRIVILEGES（表权限）"><a href="#TABLE-PRIVILEGES（表权限）" class="headerlink" title="TABLE_PRIVILEGES（表权限）"></a>TABLE_PRIVILEGES（表权限）</h3><p>TABLE_PRIVILEGES表提供有关表权限的信息，它从mysql.tables_priv系统表中获取值。</p>
<ul>
<li>GRANTEE ：授予权限的帐户的名称，格为”user_name”@”host_name”</li>
<li>TABLE_CATALOG ：表所属目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA ：表所属的schema（数据库）的名称</li>
<li>TABLE_NAME ：表名称</li>
<li>PRIVILEGE_TYPE：授予的特权</li>
<li>IS_GRANTABLE ：如果用户具有GRANT OPTION权限，则为YES，否则为NO</li>
</ul>
<h3 id="TRIGGERS（触发器）"><a href="#TRIGGERS（触发器）" class="headerlink" title="TRIGGERS（触发器）"></a>TRIGGERS（触发器）</h3><p>TRIGGERS表提供有关触发器的信息</p>
<ul>
<li>TRIGGER_CATALOG：触发器所属目录的名称。该值始终为def</li>
<li>TRIGGER_SCHEMA ：触发器所属schema（database）的名称</li>
<li>TRIGGER_NAME ：触发器名称</li>
<li>EVENT_MANIPULATION ：触发事件</li>
<li>EVENT_OBJECT_CATALOG，EVENT_OBJECT_SCHEMA，EVENT_OBJECT_TABLE：如“使用触发器”中所述，每个触发器只与一个表相关联。 这些列分别表示此表所在的目录和schema（数据库）以及表名。 EVENT_OBJECT_CATALOG值始终为def</li>
<li>ACTION_ORDER ：触发器操作在具有相同EVENT_MANIPULATION和ACTION_TIMING值的同一表上的触发器列表中的序号位置</li>
<li>ACTION_CONDITION ：此值始终为NULL</li>
<li>ACTION_STATEMENT ：触发体</li>
<li>ACTION_ORIENTATION ：该值始终为ROW</li>
<li>ACTION_TIMING ：触发器在触发事件之前还是之后激活</li>
<li>ACTION_REFERENCE_OLD_TABLE：此值始终为NULL</li>
<li>ACTION_REFERENCE_NEW_TABLE：此值始终为NULL</li>
<li>ACTION_REFERENCE_OLD_ROW,ACTION_REFERENCE_NEW_ROW：分别是旧的和新的列标识符。 ACTION_REFERENCE_OLD_ROW值始终为OLD，ACTION_REFERENCE_NEW_ROW值始终为NEW</li>
<li>CREATED ：创建触发器的日期和时间</li>
<li>SQL_MODE ：创建触发器时生效的SQL模式，以及触发器执行的模式</li>
<li>DEFINER ：以‘user_name‘@’host_name’格式创建触发器的用户的帐户</li>
<li>CHARACTER_SET_CLIENT ：创建触发器时character_set_client系统变量的会话值</li>
<li>COLLATION_CONNECTION ：创建触发器时collat​​ion_connection系统变量的会话值</li>
<li>DATABASE_COLLATION ：与触发器关联的数据库的排序规则</li>
</ul>
<h3 id="USER-PRIVILEGES（全局特权）"><a href="#USER-PRIVILEGES（全局特权）" class="headerlink" title="USER_PRIVILEGES（全局特权）"></a>USER_PRIVILEGES（全局特权）</h3><p>USER_PRIVILEGES提供有关全局特权的信息，它从mysql.user系统表中获取值</p>
<ul>
<li>GRANTEE ：授予权限的帐户的名称，格为‘user_name‘@’host_name’</li>
<li>TABLE_CATALOG ：目录的名称。该值始终为def</li>
<li>PRIVILEGE_TYPE：授予的特权</li>
<li>IS_GRANTABLE ：如果用户具有GRANT OPTION权限，则为YES，否则为NO</li>
</ul>
<h3 id="VIEWS（视图）"><a href="#VIEWS（视图）" class="headerlink" title="VIEWS（视图）"></a>VIEWS（视图）</h3><p>VIEWS表提供数据库视图信息</p>
<ul>
<li>TABLE_CATALOG ：视图所属目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA ：视图所属的schema（数据库）的名称</li>
<li>TABLE_NAME ：视图名称</li>
<li>VIEW_DEFINITION ：提供视图定义的SELECT语句</li>
<li>CHECK_OPTION ：CHECK_OPTION属性的值</li>
<li>IS_UPDATABLE ：MySQL在CREATE VIEW时设置一个标志，称为视图可更新性标志</li>
<li>DEFINER ：以’user_name’@’host_name’格式创建视图的用户的帐户</li>
<li>SECURITY_TYPE ：视图SQL SECURITY特性。该值是DEFINER或INVOKER之一</li>
<li>CHARACTER_SET_CLIENT：创建视图时character_set_client系统变量的会话值</li>
<li>COLLATION_CONNECTION：创建视图时collat​​ion_connection系统变量的会话值</li>
</ul>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql事务]]></title>
      <url>/2018/08/11/mysql/mysql%E4%BA%8B%E5%8A%A1/</url>
      <content type="html"><![CDATA[<h2 id="一、事务的基本要素（ACID）"><a href="#一、事务的基本要素（ACID）" class="headerlink" title="一、事务的基本要素（ACID）"></a>一、事务的基本要素（ACID）</h2><ul>
<li>原子性（Atomicity):事务开始后所有的操作，要么全部做完，要么全部不做，不可能在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。</li>
<li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。</li>
<li>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同事务之间彼此没有任何干扰。</li>
<li>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。<a id="more"></a>
<h2 id="二、事务的并发问题"><a href="#二、事务的并发问题" class="headerlink" title="二、事务的并发问题"></a>二、事务的并发问题</h2></li>
<li>脏读：事务A读取了事务B未提交的数据。</li>
<li>不可重复读：事务A多次读取同一数据，事务B在事务A多次读取过程中，对数据进行了更新，导致事务A读取同一事务时结果不一致。</li>
<li>幻读：事务A在更新过程中，事务B对同数据库进行了操作并提交，事务A提交不成功。</li>
</ul>
<h2 id="三、Mysql事务隔离级别"><a href="#三、Mysql事务隔离级别" class="headerlink" title="三、Mysql事务隔离级别"></a>三、Mysql事务隔离级别</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>事务1对A进行操作还没提交，事务2就对A进行了读取，之后事务1对A进行再次操作或回滚，导致事务A读取的数据不对。（脏读）<br><img src="http://ocx5m3vc3.bkt.clouddn.com/%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4.png" alt="">  </p>
<h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>事务2多次读取同一数据，事务1在事务2读取过程中对数据进行了修改，导致事务1读取的数据不一致。（解决了脏读，不可重复读）<br><img src="http://ocx5m3vc3.bkt.clouddn.com/%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A42.png" alt=""><br>读已提交是大多数数据库的默认隔离级别。</p>
<h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>事务与事务之间相互隔离，数据之间不相互影响。整个事务过程中多次执行同一个查询，查询得到的结果是不一样的，幻读针对的多笔记录。（解决了不可重复读，导致了幻读）</p>
<p>可重复读是mysql的默认隔离级别。 </p>
<h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>在事务进行操作时对表进行加锁操作，拒绝其他事务进行操作。保证了数据的安全性，但是效率大大降低。</p>
]]></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python获取本机IP]]></title>
      <url>/2018/07/21/python/%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAIP/</url>
      <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_ip</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">      s.connect((<span class="string">'8.8.8.8'</span>, <span class="number">80</span>))</span><br><span class="line">      ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">      s.close()</span><br><span class="line">  <span class="keyword">return</span> ip</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（6）-压缩列表]]></title>
      <url>/2018/06/12/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%886%EF%BC%89--%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数类型，要么就是长度比较短的字符串，那么Redis会使用压缩列表来做列表键的底层实现。</p>
<h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序性数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/ziplist.png" alt="">  </p>
<ul>
<li>zlbytes：4字节，记录整个压缩列表占用内存的字节数</li>
<li>zltail：4字节，记录压缩列表尾部节点距离起始地址的偏移量</li>
<li>zllen：2字节，记录压缩列表包含的节点数量</li>
<li>entry：不定，列表中的每个节点</li>
<li>zlend：1字节，特殊值0xFF，标记压缩列表的结束</li>
</ul>
<a id="more"></a>
<h3 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h3><p>每个压缩列表节点可以保存一个字节数组或者一个整数值。其中，字节数组可以是以下的类型：  </p>
<ul>
<li>长度小于等于63字节的字节数组</li>
<li>长度小于等于16381字节的字节数组</li>
<li>长度小于等于4294967295字节的字节数组</li>
</ul>
<p>而整数值则可以是以下类型：  </p>
<ul>
<li>4位长，介于0~12之间的无符号整数</li>
<li>1字节长的有符号整数</li>
<li>3字节长的有符号整数</li>
<li>int16_t类型整数</li>
<li>int32_t类型整数</li>
<li>int64_t类型整数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zlentry &#123;</span><br><span class="line">    unsigned int prevrawlensize, prevrawlen;</span><br><span class="line">    unsigned int lensize, len;</span><br><span class="line">    unsigned int headersize;</span><br><span class="line">    unsigned char encoding;</span><br><span class="line">    unsigned char *p;</span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>
<ul>
<li>prevrawlen：前置节点的长度</li>
<li>prevrawlensize：编码 prevrawlen 所需的字节大小</li>
<li>len：当前节点的长度</li>
<li>lensize：编码 len 所需的字节大小</li>
<li>headersize：当前节点 header 的大小，等于 prevrawlensize + lensize</li>
<li>encoding：当前节点值所使用的编码类型</li>
<li>p：指向当前节点的指针</li>
</ul>
<p>当加入新节点后，后一个节点需要保存新节点的长度信息，当后一个节点的长度字段在内存中占有的长度不足以表示该长度信息时，就需要对后一个节点进行更新，并扩展其内存。因此这个步骤可能会导致连锁更新。而删除操作也类似<br><img src="http://ocx5m3vc3.bkt.clouddn.com/ziplist%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（5）-整数集合]]></title>
      <url>/2018/06/11/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%885%EF%BC%89-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<p>整数集合是集合键的底层实现之一，当一个集合只傲寒整数值元素，并且这个集合的元素不多时，Redis就会使用整数集合作为集合键的底层实现。</p>
<h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef stuct intset&#123;</span><br><span class="line">	//编码方式</span><br><span class="line">	uint32_t encodingl</span><br><span class="line">	//集合包含的元素数量</span><br><span class="line">	uint32_t length;</span><br><span class="line">	//保存元素的数组</span><br><span class="line">	int8_t contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure></p>
<p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数据的一个数组项，每个项在数组中按值的大小从小到大有序的排列，并且数组中不包含重复项。</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面去。</p>
<h4 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h4><ul>
<li>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>
<li>将底层数组中的元素都转换成与新元素相同的类型，并将元素放在对应的位置上，在放置过程中需要维持底层数组的有序性质不变。</li>
<li>将新元素加到底层数组中。<h4 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h4></li>
<li>提高灵活性</li>
<li>节约内存</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（4）--跳跃表]]></title>
      <url>/2018/06/10/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%884%EF%BC%89-%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><p>Redis跳跃表由zskiplistNode和zskiplist两个结构定义。其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/skiplist.png" alt=""><br><a id="more"></a><br>位于图片最左边的是zskiplist结构，该结构包含以下属性：</p>
<ul>
<li>header：指向跳跃表的表头节点。</li>
<li>tail：指向跳跃表的表尾节点。</li>
<li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li>length：记录跳跃表的长度，即是跳跃表目前包含节点的数量（表头节点不计算在内）。<br>位于图片右侧的是zskiplistNode结构，该结构包含以下属性：</li>
<li>层（level）：每次创建一个新的跳跃表节点的时候，程序都根据幂次定律随机生成一个介于1~32之间的值作为level数组的大小，这就是层的高度。</li>
<li>前进指针（forward):每层都有一个指向表尾方向的前进指针。</li>
<li>后退指针（backward）：用于从表尾向表头方向访问节点。</li>
<li>跨度（span）：用于记录两个节点之间的距离。</li>
<li>分值（score）</li>
<li>成员对象（obj）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode&#123;</span><br><span class="line">	//后退指针</span><br><span class="line">	struct zskiplistNode *backward;</span><br><span class="line">	//分值</span><br><span class="line">	double score;</span><br><span class="line">	//成员对象</span><br><span class="line">	robj *obj;</span><br><span class="line">	//层</span><br><span class="line">	struct zskiplistLevel&#123;</span><br><span class="line">		//前进指针</span><br><span class="line">		struct zskiplistNode *forward;</span><br><span class="line">		//跨度</span><br><span class="line">		unsigned int span;</span><br><span class="line">	&#125;level[];</span><br><span class="line">&#125;zskiplistNode；</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（3）--字典]]></title>
      <url>/2018/06/10/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%883%EF%BC%89-%E5%AD%97%E5%85%B8/</url>
      <content type="html"><![CDATA[<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht&#123;</span><br><span class="line">	//哈希表数组</span><br><span class="line">	dictEntry **table;</span><br><span class="line">	//哈希表大小</span><br><span class="line">	unsigned long size;</span><br><span class="line">	//哈希表大小掩码，用于计算索引值</span><br><span class="line">	//总是等size-1</span><br><span class="line">	unsigned long sizemask;</span><br><span class="line">	//该哈希表已有节点的数量</span><br><span class="line">	unsigned long used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/dictht.png" alt=""><br><a id="more"></a><br>table是一个数组，数组中的每个元素都是一个指向dictEntry结构的指针，每个dictEntry结构保存这一个键值对。</p>
<h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry&#123;</span><br><span class="line">	//键</span><br><span class="line">	void *key;</span><br><span class="line">	//值</span><br><span class="line">	union&#123;</span><br><span class="line">		void *val;</span><br><span class="line">		uint64_t u64;</span><br><span class="line">		int64_t	s64;</span><br><span class="line">	&#125;v;</span><br><span class="line">	//指向下个哈希表节点，形成链表</span><br><span class="line">	struct dictEntry *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/dictEntry.png" alt=""></p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">	//类型特定函数</span><br><span class="line">	dictType *type;</span><br><span class="line">	//私有数据</span><br><span class="line">	void *privdata;</span><br><span class="line">	//哈希表</span><br><span class="line">	dictht ht[2];</span><br><span class="line">	//rehash索引</span><br><span class="line">	//当rehash不在进行时，值为-1</span><br><span class="line">	int trehashidx;</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>
<p>ht是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在ht[0]哈希表进行rehash时使用。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/dict.png" alt=""></p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行，哈希表保存的键值对会逐渐增多或者减少，为了让哈希表的负债因子维持在一个合理的范围内，程序需要对哈希表大小进行相应的扩展或者收缩。<br>步骤：<br>1）为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：<br>2）将保存在ht[0]中的所有键值对rehash到ht[1]上面，rehash值的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。<br>3）当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0],将ht[1]设置为ht[0],并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。  </p>
<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>1）为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。<br>2）在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。<br>3）在rehash期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定操作外，还会顺带将ht[0]哈希表再rehashidx索引上的所有键值对rehash到ht[1]，将rehashidx值增加1。<br>4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]，这时将rehashidx设置为-1，表示rehash操作完成。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（2）--链表]]></title>
      <url>/2018/06/09/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%882%EF%BC%89-%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><p>每个链表节点都使用一个listNode结构来表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode&#123;</span><br><span class="line">	//前置节点</span><br><span class="line">	struct listNode *prev;</span><br><span class="line">	//后置节点</span><br><span class="line">	struct listNode *next;</span><br><span class="line">	//节点的值</span><br><span class="line">	void *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></p>
<p>虽然使用多个listNode结构就可以组成链表，但是使用list来持有链表的话，操作起来会更方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list&#123;</span><br><span class="line">	//表头节点</span><br><span class="line">	listNode *head;</span><br><span class="line">	//表尾节点</span><br><span class="line">	listNode *tail;</span><br><span class="line">	//链表所包含的节点数量</span><br><span class="line">	unsigned long len;</span><br><span class="line">	//节点值复制函数</span><br><span class="line">	void *(*dup)(void *ptr);</span><br><span class="line">	//节点值释放函数</span><br><span class="line">	void *(*free)(void *ptr);</span><br><span class="line">	//节点值对比函数</span><br><span class="line">	void *(match)(void *ptr,void *key);</span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/list.png" alt=""></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>双端：获取某个节点的前置和后置节点的复杂度都是O(1)</li>
<li>无环：两端都指向NULL</li>
<li>获取表头节点和表尾节点的复杂度为O(1)</li>
<li>O(1)获取链表长度</li>
<li>链表可以用来保存各种不同类型的值。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[杂记]]></title>
      <url>/2018/06/09/%E5%90%8D%E8%A8%80/</url>
      <content type="html"><![CDATA[<ul>
<li>乌云遮蔽了整个天空，闪电便已在其中酝酿。</li>
<li>世界上只有两种秘密，骗自己的和以为能骗住别人的。</li>
<li>身不由己的抉择是痛苦的，你看似自己做了决定，但做决定的始终是命运</li>
<li>越是充满诱惑的东西，往往会越致命。你是否还会选择？</li>
<li>天空没有痕迹，风雨已在心中。</li>
<li>天地之间的无形之力，也在无形之中改变着天地。</li>
<li>在最深沉的夜里，连自己的影子都会离你而去。</li>
<li>向黑暗走去的人，或许会被黑暗吞噬，或许会化作明灯。</li>
<li>死亡能带走生命，却带不走生命的痕迹。</li>
<li>空谷足音，听到的却是自己的心。</li>
<li>行走在两个世界的边缘，得到更多。</li>
<li>不要随意翻动回忆，因为它是不可测的深渊。</li>
<li>花开在天边，而我需要走过一路的荆棘。</li>
<li>想要看清雾中的景物，不能仅仅相信自己的眼睛。    </li>
<li>若是献出生命就能赢得正义，我下一刻已身在炽热的烈焰中。</li>
<li>恶魔的爪牙伸向每个人的心，你是否还依然纯真？</li>
<li>经历过真正绝望的人，生已是一种施舍，死令他无所畏惧。</li>
<li>炽热火焰焚尽了执念，灰烬里只留下黑色的心。</li>
<li>被岁月冰封的一簇火苗，等待理想把它融化、燃烧。</li>
<li>若承受不了十指连心的痛楚，就别轻易去拼凑记忆的碎片。</li>
<li>锋芒毕露并不一定耀眼，忍辱负重才是求生之道。</li>
<li>世间本没有相思，奈何离分人世，将痴心种出了果实。</li>
<li>蝎子和人的最大区别在于，蝎子往往亮出自己的狠毒，而人则会将之隐藏。</li>
<li>蒙上双眼，看尽黑暗中的风景，心便不再惧怕。</li>
<li>枯井中的人仰观宇宙大千，坐拥天下者四顾高墙如井。</li>
<li>天空其实是无色的，但眼睛欺骗了你；灵魂其实是无欲的，但感情欺骗了你。</li>
<li>利益这杯美酒让人陶醉，但也同样剧毒无比。</li>
<li>时间沉淀为回忆，过去沉淀为传奇，你沉淀为我！</li>
<li>敢于弯腰的树枝，便不会被冰雪压折。</li>
<li>在落子的瞬间，棋手也是心魔控制的棋子。</li>
<li>执着与执念的区别，前者是为了守护珍视的人，后者则是逃避内心的怯懦。</li>
<li>灰烬并不是失败的代表，而是燃烧的证明。</li>
<li>世上最精致的面具，就是我们自己的脸皮。</li>
<li>沾过鲜血的剑可以回鞘，但手执利刃的心却无法轻易收回。</li>
<li>常在夜路独行的人，目光总能捕捉到不易察觉的危险。</li>
<li>许多东西本该腐朽，那就任它悲戚；许多事情本该舍弃，那就别怪它肆虐。</li>
<li>不要以世俗得眼光看低我的梦想，现实与虚幻终究是要斗一场。</li>
<li>在你需要做出选择的时候，你的内心就会经历一场战争。</li>
<li>即使是无尽的黑暗，舍弃一切踏入的价值，是探索无尽的重点。</li>
<li>这世上没有能真正忘记的事，只有你愿不愿意想起，和敢不敢想起。</li>
<li>机会不过是一场稍纵即逝的梦，犹豫只能令你错失改变。</li>
<li>生之路的尽头，好似铺满了荆棘和玫瑰，每一步都是苦海。</li>
<li>我们无法避免失败，只能避免因为失败而选择沉沦。</li>
<li>重点不在他怎么离开，而在其他人看着他背影的目光。</li>
<li>山高一寸，风景独好一寸，然危机也伏多一寸。</li>
<li>摘下面具的一场对话，比穿上铠甲奔赴战场更需要勇气。</li>
<li>规则的制定往往是用来掩盖游戏的本质，用来迷惑那些执着于胜负的人。</li>
<li>对手和敌人是不同的，敌人希望你更弱，对手希望你更强。</li>
<li>没有什么能够禁锢你的强大，除了你的内心。</li>
<li>云淡风轻，满月低垂，脚下万丈悬崖，天空触手可及。</li>
<li>真相虽隐藏在假象之后，但它总有一天会降临。</li>
<li>能者逞霸道之势，强者隐百转之谋。</li>
<li>如果你感到寸步难行，也许是耀眼的光明蒙蔽了你的眼睛。</li>
<li>直到曲终人散，才知晓真相已暗藏于每个符音间。</li>
<li>真正的危机，总在不经意时降临。</li>
<li>隐藏在假象后面的未必是真理，也许是另一个骗局。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（1）--简单动态字符串SDS]]></title>
      <url>/2018/06/09/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%881%EF%BC%89--%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/</url>
      <content type="html"><![CDATA[<h2 id="Redis中的SDS结构"><a href="#Redis中的SDS结构" class="headerlink" title="Redis中的SDS结构"></a>Redis中的SDS结构</h2><p>Redis并没有直接使用C语言中的字符串，而是自己构建了SDS这样的一种简单动态字符串，并且将它作为Redis中字符串的默认表示。<br>在早期的版本中记录了其长度、剩余空间、以及字符数组；<br>最新版本3.2.4中，已经对SDS做了一定的改动：长度、分配内存大小（除去’\0’）、标志位（低三位表示类型，其余五位未使用）、以及字符数组。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/SDS.png" alt=""><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">	//buf中已用空间长度</span><br><span class="line">	int len;</span><br><span class="line">	//buf中剩余可用空间长度</span><br><span class="line">	int free;</span><br><span class="line">	//数据空间</span><br><span class="line">	char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="SDS与C字符串区别"><a href="#SDS与C字符串区别" class="headerlink" title="SDS与C字符串区别"></a>SDS与C字符串区别</h2><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><p>&ensp;&ensp;SDS字符串保存了自身的长度，当需要获取长度的时候可以O(1)获得。（3.2中的剩余空间需要用alloc-len算出）</p>
<h3 id="杜绝缓存区溢出"><a href="#杜绝缓存区溢出" class="headerlink" title="杜绝缓存区溢出"></a>杜绝缓存区溢出</h3><p>&ensp;&ensp;SDS在进行字符串拼接的时候，会自行检查内存空间是否满足要求，如果不满足，将自动进行分配；而且在进行分配空间的时候，会实行预先分配的策略。</p>
<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p>&ensp;&ensp;C语言字符串在进行字符串的扩充和收缩的时候，都会面临着内存空间的重新分配问题。<br>&ensp;&ensp;Redis在内存空间分配的问题上进行了优化，只要分为两个过程。  </p>
<ol>
<li>内存预分配<br>如果修改之后SDS的长度小于1MB，那么程序将会分配和当前字符串len相同的空间给该字符串对象。<br>如果修改之后的SDS的长度大于等于1MB的话，程序将分配1MB剩余空间给该字符串对象。</li>
<li>惰性释放<br>当字符串进行缩短操作的时候，并不立即将空间释放出来，而是将这部分空间通过free进行标识。<br>当然，Redis中提供了专门的API，需要的时候，会真正的释放这部分空闲内存。</li>
</ol>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>&ensp;&ensp;由于在Redis中，不是根据空字符而是通过len来判断字符串结束的。所以，即便是中间出现了空字符，对于SDS来说，读取该字符串还是可以的。</p>
<h3 id="兼容部分C语言函数"><a href="#兼容部分C语言函数" class="headerlink" title="兼容部分C语言函数"></a>兼容部分C语言函数</h3>]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis逆向工程]]></title>
      <url>/2018/04/23/Mybatis/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>&ensp;&ensp;逆向工程的字面意思就是反向生成工程。<br>使用逆向工程时，需要注意的是表之间的关系无法映射出来！也就是说Mybatis的逆向工程生成的都是单表操作。</p>
<ol>
<li><p>Mybatis逆向工程开发文档<br><a href="http://www.mybatis.org/generator/configreference/xmlconfig.html" target="_blank" rel="noopener">http://www.mybatis.org/generator/configreference/xmlconfig.html</a></p>
</li>
<li><p>使用逆向工程生成代码有好几种方式，这里就介绍一种最简单的，Java程序生成（解释在配置中)<br>&ensp;&ensp;2.1 准备逆向工程配置文件genreatorConfig.xml,名字无所谓,只要在java程序中作为file传入就好:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;!--数据库驱动,最好不要有中文字符,不然会找不到--&gt;</span><br><span class="line">    &lt;classPathEntry location=&quot;F:/cache/mysql-connector-java-5.1.28-bin.jar&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;context id=&quot;DB2Tables&quot;    targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;commentGenerator&gt;</span><br><span class="line">            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;!--数据库链接地址账号密码--&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost/test&quot; userId=&quot;root&quot; password=&quot;&quot;&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;/javaTypeResolver&gt;</span><br><span class="line">        &lt;!--生成Model类存放位置--&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.leige.domain&quot; targetProject=&quot;src&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/javaModelGenerator&gt;</span><br><span class="line">        &lt;!--生成映射文件存放位置--&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.leige.domain&quot; targetProject=&quot;src&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line">        &lt;!--生成DaoMapper类存放位置--&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.leige.dao&quot; targetProject=&quot;src&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line">        &lt;!--生成对应表及类名,需要记住的一点是逆向工程无法生成关联关系,只能生成单表操作--&gt;</span><br><span class="line">        &lt;table tableName=&quot;student&quot; </span><br><span class="line">            domainObjectName=&quot;Student&quot; </span><br><span class="line">          &gt;&lt;/table&gt;</span><br><span class="line">           &lt;table tableName=&quot;teacher&quot; </span><br><span class="line">            domainObjectName=&quot;Teacher&quot; </span><br><span class="line">          &gt;&lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<p>&ensp;&ensp;2.2<a href="http://pan.baidu.com/s/1jIvLufG" target="_blank" rel="noopener">下载jar包</a><br>&ensp;&ensp;2.3准备java程序,在开发文档首页,粘贴一下就好了,没必要记住:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.leige.test;</span><br><span class="line"></span><br><span class="line">import java.awt.geom.GeneralPath;</span><br><span class="line">import java.awt.im.InputContext;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.log4j.chainsaw.Main;</span><br><span class="line">import org.apache.log4j.lf5.util.Resource;</span><br><span class="line">import org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line">import org.mybatis.generator.config.Configuration;</span><br><span class="line">import org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line">import org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line">public class MybatisGen &#123;</span><br><span class="line">    public static void generator() throws Exception&#123;</span><br><span class="line">           List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">           boolean overwrite = true;</span><br><span class="line">           //项目根路径不要有中文,我的有中文,所以使用绝对路径</span><br><span class="line">           File configFile = new File(&quot;F:/cache/generatorConfig.xml&quot;);</span><br><span class="line">           ConfigurationParser cp = new ConfigurationParser(warnings);</span><br><span class="line">           Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">           DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">           MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);</span><br><span class="line">           myBatisGenerator.generate(null);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            generator();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;2.4运行java程序,就会发现生成的代码: </p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[缓存机制]]></title>
      <url>/2018/04/21/Mybatis/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>Mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。<br>Mybatis提供一级缓存和二级缓存。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98.png" alt="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98.png"><br><a id="more"></a><br>一级缓存是SqlSession级别的缓存。在操作数据库时需要构造SqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的SqlSession之间的缓存数据区域是互相不影响的。</p>
<p>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"><br>第一次发起查询的时候，先在缓存中查询是否有相应数据，有就直接返回；如果没有则从数据库获取信息并存储在一级缓存中。  </p>
<p>如果SqlSession执行commit操作（执行插入、更新、删除）时，清空SqlSession中的一级缓存。这是为了让缓存中存储的是最新的信息，避免脏读。  </p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>Mybatis默认支持一级缓存。不需要配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">    public void testCacha_1()&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user = userMapper.findUserById(1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">//        user.setName(&quot;heh&quot;);</span><br><span class="line">//        userMapper.updateUserName(user);</span><br><span class="line">        User user1 = userMapper.findUserById(1);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98debug.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98debug.png"><br>去掉代码中的注释后，输出：<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0debug.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0debug.png"></p>
<p>只用一级缓存时读取出来的值可能不是最新的。<br>例如：SqlSession1查询，SqlSession2修改，SqlSession1再查询，此时会导致SqlSession1第一次查找的结果不是最新的。此时就需要二级缓存了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacha_1_more</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="line">        SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user = userMapper1.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        user1.setName(<span class="string">"zan"</span>);</span><br><span class="line">        user1.setId(<span class="number">1</span>);</span><br><span class="line">        userMapper2.updateUserName(user1);</span><br><span class="line"></span><br><span class="line">        User user2 = userMapper1.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E4%B8%8D%E5%8F%8A%E6%97%B6.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E4%B8%8D%E5%8F%8A%E6%97%B6.png"></p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><h3 id="二级缓存原理"><a href="#二级缓存原理" class="headerlink" title="二级缓存原理"></a>二级缓存原理</h3><p><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>
<p>开启Mybatis的二级缓存后。</p>
<p>SqlSession1去查询信息，查询到的信息将会存储到二级缓存中。<br>如果SqlSession3去执行相同mapper下SQL，执行commit提交；将会清空二级缓存。<br>SqlSession去查询信息，现在二级缓存中查找数据。如果存在就直接取出。</p>
<font color="red">二级缓存的范围更大，多个SqlSession可以共享Mapper的二级缓存区域。</font>

<h3 id="开启二级缓存"><a href="#开启二级缓存" class="headerlink" title="开启二级缓存"></a>开启二级缓存</h3><ul>
<li><p>在SqlMapConfig.xml中加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在UserMapper.xml中开启二级缓存。UserMapper.xml下的sql磁性完成会存储到它的缓存区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;dao.UserMapper&quot;&gt;</span><br><span class="line">    &lt;cache /&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为二级缓存存储介质多种多样，不一定在内存。对应的实体需要实现序列化接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacha_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user1 = userMapper1.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        User user = new User();</span></span><br><span class="line"><span class="comment">//        user.setId(2);</span></span><br><span class="line"><span class="comment">//        user.setName("GG");</span></span><br><span class="line"><span class="comment">//        userMapper1.updateUserName(user);</span></span><br><span class="line"></span><br><span class="line">        sqlSession1.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user2 = userMapper2.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">        sqlSession2.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="useCache配置"><a href="#useCache配置" class="headerlink" title="useCache配置"></a>useCache配置</h3><p>在statement中设置&lt;font color = ‘red”&gt;useCache=”false”可以禁用当前select的二级缓存，即每次查询都会发出SQL去查询。默认情况是true。<br>如果每次查询都需要最新的数据sql时要禁用二级缓存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findOrderListResultMap&quot; resultMap=&quot;ordersUserMap&quot; useCache=&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h3><p>刷新缓存就是清空缓存。在mapper的同一个namespace中，如果有其他insert、update、delete操作数据后需要刷新缓存，否则会出现脏读现象。</p>
<p>设置statement配置中的&lt;font color = ‘red”&gt;flushCache=”true”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;pojo.User&quot; flushCache=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="应用场景和局限性"><a href="#应用场景和局限性" class="headerlink" title="应用场景和局限性"></a>应用场景和局限性</h3><ul>
<li><p>应用场景<br>对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。<br>实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。</p>
</li>
<li><p>局限性<br>mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[延迟加载]]></title>
      <url>/2018/04/21/Mybatis/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>resultMap可以实现高级映射（使用association、collection实现一对一以及一对多映射），association、collection具备延迟加载功能。</p>
<p>延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能。<br><a id="more"></a><br>开启延迟加载需要在SqlMapConfig.xml的setting中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!-- 打开延迟加载 的开关 --&gt;</span><br><span class="line">    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;!-- 将积极加载改为消极加载即按需要加载 --&gt;</span><br><span class="line">    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure></p>
<p>书写需要的两个satatement </p>
<ul>
<li>查询用户</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUserLazy&quot; resultMap=&quot;findUserAndCarLazyMap&quot;&gt;</span><br><span class="line">        SELECT *</span><br><span class="line">        FROM user</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查询拥有的Car  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findCarByUserId&quot; parameterType=&quot;int&quot; resultType=&quot;pojo.Car&quot;&gt;</span><br><span class="line">        SELECT *</span><br><span class="line">        FROM car</span><br><span class="line">        WHERE user_id = #&#123;value&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>书写resultMap  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;findUserAndCarLazyMap&quot; type=&quot;pojo.User&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;password&quot; column=&quot;password&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            多了select和column</span><br><span class="line">            select:会去寻找相应的方法，如果不在本mapper中则需要在前面添加其namespace（我这里是放在本mapper中的）</span><br><span class="line">            column:根据哪一列去进行查询。</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;association property=&quot;car&quot;</span><br><span class="line">                     select=&quot;findCarByUserId&quot; </span><br><span class="line">                     column=&quot;id&quot;</span><br><span class="line">                     javaType=&quot;pojo.Car&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/association&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在相应的Mapper接口中书写方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public User findUserLazy(int id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testFindUserLazyLoding()&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user = userMapper.findUserLazy(2);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        //System.out.println(user.getCar().toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>PS:这里不知道是我用的IDEA的问题还是怎么的，在输出的时候竟然也执行了第二条sql语句。。。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDdebug.png" alt="http://ocx5m3vc3.bkt.clouddn.com/mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDdebug.png"></p>
<center>延迟加载debug</center><br><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis%E4%B8%8D%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDdebug.png" alt="http://ocx5m3vc3.bkt.clouddn.com/mybatis%E4%B8%8D%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDdebug.png"><br><center>不延迟加载debug</center>

<hr>
<p>更新：后来发现出现上面第一图的情况是由于在System.out.println(user);会执行第二条SQL。。  需要配置一下设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting     name=&quot;lazyLoadTriggerMethods&quot; value=&quot; &quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>lazyLoadTriggerMethods默认情况下仅仅支持自动将equals,clone,hashCode,toString这几个方法定义为延迟加载的加载触发方法。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动态sql]]></title>
      <url>/2018/04/21/Mybatis/%E5%8A%A8%E6%80%81sql/</url>
      <content type="html"><![CDATA[<p>mybatis核心。对sql语句进行灵活操作，通过表达式进行判断，对SQL进行灵活拼接、组装。<br><a id="more"></a></p>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><ul>
<li>mapper.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"pojp.UserQueryVo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"pojo.UserCustom"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="comment">&lt;!--  where 可以自动去掉条件中的第一个and --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom!=null"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.sex!=null and userCustom.sex != '' "</span>&gt;</span></span><br><span class="line">               AND user.sex=#&#123;userCustom.sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.username!=null and userCustom.username != '' "</span>&gt;</span></span><br><span class="line">               AND user.username LIKE '%$&#123;userCustom.username&#125;%'</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：如果传入的userCustom为null<br>那么查询语句会变成<font color="red">SELECT * FROM user</font></p>
<h3 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h3><p>将上面实现的动态sql判断代码块抽取出来，组成一个sql片段。其他的statement中就可以应用sql片段。</p>
<ul>
<li><p>定义SQL片段</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义sql片段</span></span><br><span class="line"><span class="comment">id：sql片段的唯 一标识</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">经验：是基于单表来定义sql片段，这样话这个sql片段可重用性才高</span></span><br><span class="line"><span class="comment">在sql片段中不要包括 where</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"query_user_where"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom!=null"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.sex!=null and userCustom.sex!=''"</span>&gt;</span></span><br><span class="line">            AND user.sex = #&#123;userCustom.sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.username!=null and userCustom.username!=''"</span>&gt;</span></span><br><span class="line">            AND user.username LIKE '%$&#123;userCustom.username&#125;%'</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用SQL片段</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"pojo.UserQueryVo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"pojo.UserCustom"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"query_user_where"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在这里还要引用其它的sql片段  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p>向SQL传递数组或List，mybatis使用foreach解析<br>多id条件查询常有以下两种sql写法：  </p>
<ul>
<li><font color="red">SELECT * FROM USER WHERE id=1 OR id=10 OR id=16</font>  </li>
<li><font color="red">SELECT * FROM USER WHERE id IN(1,10,16)</font>

</li>
</ul>
<p>在输入参数类型中添加<font color="red">List<integer> ids</integer></font>传入多个id<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserQueryVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入多个id</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line"></span><br><span class="line">    getter、setter方法</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改mapper.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids!=null"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 foreach遍历传入ids</span></span><br><span class="line"><span class="comment">    collection：指定输入 对象中集合属性</span></span><br><span class="line"><span class="comment">    item：每个遍历生成对象中</span></span><br><span class="line"><span class="comment">    open：开始遍历时拼接的串</span></span><br><span class="line"><span class="comment">    close：结束遍历时拼接的串</span></span><br><span class="line"><span class="comment">    separator：遍历的两个对象中需要拼接的串</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用实现下边的sql拼接：</span></span><br><span class="line"><span class="comment">     AND (id=1 OR id=10 OR id=16)</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"user_id"</span> <span class="attr">open</span>=<span class="string">"AND ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">"or"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每个遍历需要拼接的串 --&gt;</span></span><br><span class="line">        id=#&#123;user_id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 实现  “ and id IN(1,10,16)”拼接 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;foreach collection="ids" item="user_id" open="and id IN(" close=")" separator=","&gt;</span></span><br><span class="line"><span class="comment">        每个遍历需要拼接的串</span></span><br><span class="line"><span class="comment">        #&#123;user_id&#125;</span></span><br><span class="line"><span class="comment">    &lt;/foreach&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[phpStudy升级MySQL]]></title>
      <url>/2018/04/20/%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E5%9D%91/phpStudy%E5%8D%87%E7%BA%A7MySQL/</url>
      <content type="html"><![CDATA[<p>今天在导入别人给我的sql文件的时候，怎么也导不进去。后来才知道我用的phpStudy的SQL版本太低了。于是需要升级一下。</p>
<p>首先从官网下载MySql安装包<a href="https://dev.mysql.com/downloads/file/?id=467269" title="https://dev.mysql.com/downloads/file/?id=467269" target="_blank" rel="noopener">https://dev.mysql.com/downloads/file/?id=467269</a></p>
<p>步骤：<br>1.最好先备份一份原来phpStudy的MYSQL文件夹<br>2.把下载的 MySQL 压缩文件解压至 phpStudy 下的 MySQL目录，复制 my-default.ini ，重命名为 my.ini。<br>3.打开 my.ini，找到 #basedir 处编辑：  </p>
<pre><code>basedir = I:\phpStudy\MySQL  
datadir = I:\phpStudy\MySQL\data  
</code></pre>
注：有任何错误都是因为以上路径配置错误导致的
<a id="more"></a>
4.把 MySQL 安装路径添加至系统环境变量  
PATH=…….;I:\phpStudy\MySQL\bin

5.在 cmd 下进入 MySQL 的 bin 目录（我的是 I:\phpStudy\MySQL\bin），执行：  
初始化数据库：  
<pre><code>mysqld --initialize
</code></pre>  

<p>安装服务：  </p>
<pre><code>mysqld -install
</code></pre> 

<p>启动服务：  </p>
<pre><code>net start MySQL
</code></pre>

<p>6.打开 my.ini，找到 [mysqld]，在下面添加：<br>skip-grant-tables(此参数用于忘记mysql密码)<br>此时使用 root 账号，密码处按回车即可登录。</p>
<p>7.修改密码：  </p>
<pre><code>mysql>update mysql.user set authentication_string=password('新密码') where user='root' and Host ='localhost';
</code></pre>  
8.刷新权限：  
<pre><code>FLUSH PRIVILEGES;
</code></pre>  
9.注释掉 my.ini 中刚才添加的
skip-grant-tables
重新登录。

10.更新用户信息：  
<pre><code>mysql> ALTER USER USER() IDENTIFIED BY '新密码';
</code></pre>
11.查看 mySQL 版本：  
<pre><code>mysql> select version();  
+-----------+  
| version() |  
+-----------+  
| 5.7.17 |  
+-----------+  
</code></pre>]]></content>
      
        <categories>
            
            <category> 软件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 坑 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[输入映射和输出映射]]></title>
      <url>/2018/04/20/Mybatis/%E8%BE%93%E5%85%A5%E6%98%A0%E5%B0%84%E5%92%8C%E8%BE%93%E5%87%BA%E6%98%A0%E5%B0%84/</url>
      <content type="html"><![CDATA[<h2 id="输入映射"><a href="#输入映射" class="headerlink" title="输入映射"></a>输入映射</h2><p>Mybatis映射文件通过<font color="red">parameterType</font>指定输入参数的类型，类型可以是  </p>
<ul>
<li>简单类型</li>
<li>hashmap</li>
<li>pojo的包装类型</li>
</ul>
<p>在xml映射文件中sql语句会根据OGNL自动获取传入类型中的属性值。<br>如果传入类型中没有相应的属性值，就会报找不到对应属性的错。  </p>
<p>即使传入类型的具体对象中的相应属性为null，也并不会报错。因为Mybatis使用的是动态sql，如果没有设置某个值，条件就不会拼接在sql中去。<br><a id="more"></a></p>
<h2 id="输出映射"><a href="#输出映射" class="headerlink" title="输出映射"></a>输出映射</h2><p>输入映射主要有两种方式： </p>
<ul>
<li><font color="red">resultType</font></li>
<li><font color="red">resultMap</font>

</li>
</ul>
<h3 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h3><ul>
<li>使用<font color="red">resultType</font>进行输出映射时，只有查询出来的列名和pojo中的属性名一致，才能映射成功。<ul>
<li>列名与pojo的属性名<b>只要有一个不一致</b>就不会创建pojo对象，此时会报错。</li>
<li>列名与pojo的属性名<b>只要有一个一致</b>就会创建一个pojo对象并返回。</li>
</ul>
</li>
</ul>
<h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>如果查询出来的列名和pojo的属性名不一致，可以通过定义一个resultMap对列名和属性名之间进行映射。<br>1.定义resultMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt;</span><br><span class="line">        &lt;!-- id表示查询结果集中唯一标识 </span><br><span class="line">        column：查询出来的列名</span><br><span class="line">        property：type指定的pojo类型中的属性名</span><br><span class="line">        最终resultMap对column和property作一个映射关系 （对应关系）</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;!-- </span><br><span class="line">        result：对普通名映射定义</span><br><span class="line">        column：查询出来的列名</span><br><span class="line">        property：type指定的pojo类型中的属性名</span><br><span class="line">        最终resultMap对column和property作一个映射关系 （对应关系）</span><br><span class="line">         --&gt;</span><br><span class="line">        &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        一对一映射</span><br><span class="line">        association：用于映射关联查询单个对象的信息</span><br><span class="line">        property：要将关联查询的用户信息映射到Orders中哪个属性</span><br><span class="line">        javaType：映射到user的哪个属性</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;!--</span><br><span class="line">       一对多映射</span><br><span class="line">       collection：对关联查询到多条记录映射到集合对象中</span><br><span class="line">       property：将关联查询到多条记录映射到com.iot.mybatis.po.Orders哪个属性</span><br><span class="line">       ofType：指定映射到list集合属性中pojo的类型</span><br><span class="line">       --&gt;</span><br><span class="line">     &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<p>2.使用resultMap作为statement的输出映射类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用resultMap进行输出映射</span><br><span class="line">        resultMap：指定定义的resultMap的id，如果这个resultMap在其它的mapper文件，前边需要加namespace</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;</span><br><span class="line">        SELECT id id_,username username_ FROM USER WHERE id=#&#123;value&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>使用resultMap多表查询时，可能会导致重复字段赋值错误。<br>解决方法：在查询时定义别名。resultMap中根据别名列来映射</p>
<hr>
<p>resultType和resultMap区别：</p>
<ul>
<li>resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。</li>
<li>resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。</li>
<li>resultMap可以实现延迟加载，resultType无法实现延迟加载。</li>
</ul>
<hr>
<p>association：</p>
<ul>
<li>作用：将关联查询信息映射到一个pojo对象中。  </li>
<li>场合：为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。</li>
</ul>
<p>collection：  </p>
<ul>
<li>作用：将关联查询信息映射到一个list集合中。</li>
<li>场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。如果使用resultType无法将查询结果映射到list集合中。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SqlMapConfig]]></title>
      <url>/2018/04/20/Mybatis/SqlMapConfig/</url>
      <content type="html"><![CDATA[<p>SqlMapConfig.xml中配置的内容和顺序： </p>
<ul>
<li>properties(属性)</li>
<li>settings(全局配置参数)</li>
<li><b>typeAliases(类型别名)</b></li>
<li><em>objectFactory(对象工厂)</em></li>
<li><em>plugins(插件)</em></li>
<li>environments(环境集合属性对象)  <ul>
<li>environment(环境属性对象)<ul>
<li>transactionManager(事务管理)</li>
<li>dataSource(数据源)</li>
</ul>
</li>
</ul>
</li>
<li><b>mappers(映射器）</b></li>
</ul>
<a id="more"></a>
<h3 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties(属性)"></a>properties(属性)</h3><p>将数据库连接参数单独配置在db.properties中，可以避免xml硬编码，方便以后更改以及其他文件使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:////mybatis?characterEncoding=utf-8</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123</span><br></pre></td></tr></table></figure></p>
<p>在sqlMapConfig.xml中加载属性文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--properties中还可以配置一些属性名和属性值  --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="jdbc.driver" value=""/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><font color="red">Mybatis加载资源属性顺序：(后面加载的会覆盖前面）</font>  </p>
<ol>
<li>在<b>properties</b>元素体内定义的属性</li>
<li><b>properties</b>元素中resource或url加载的属性</li>
<li><b>parameterType</b>传递的属性</li>
</ol>
<h3 id="settings-全局参数配置"><a href="#settings-全局参数配置" class="headerlink" title="settings(全局参数配置)"></a>settings(全局参数配置)</h3><p>Mybatis框架运行时的一些参数。比如：二级缓存、延迟加载等<br>官方文档：<a href="http://www.mybatis.org/mybatis-3/configuration.html#settings" title="http://www.mybatis.org/mybatis-3/configuration.html#settings" target="_blank" rel="noopener">mybatis-settings</a></p>
<h3 id="typeAliases-类型别名"><a href="#typeAliases-类型别名" class="headerlink" title="typeAliases(类型别名)"></a>typeAliases(类型别名)</h3><p><font color="red">parameterType</font> 指定输入参数的类型  </p>
<p><font color="red">resultType</font> 指定输出参数的映射类型<br>每次都要输入全名路径太过于麻烦,类型别名简化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 别名定义 --&gt;</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 针对单个别名定义</span><br><span class="line">    type：类型的路径</span><br><span class="line">    alias：别名</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;!-- &lt;typeAlias type=&quot;Pojo.User&quot; alias=&quot;user&quot;/&gt; --&gt;</span><br><span class="line">    &lt;!-- 批量别名定义</span><br><span class="line">    指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写或小写都可以）</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;package name=&quot;Pojo&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure></p>
<p>具体参考官网文档：<a href="http://www.mybatis.org/mybatis-3/configuration.html#typeAliases" title="http://www.mybatis.org/mybatis-3/configuration.html#typeAliases" target="_blank" rel="noopener">typeAliases</a></p>
<p>Mybatis默认支持的别名 </p>
<center>（8大基本类型及其包装类+Data+大数类型） </center>

<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型   </th>
</tr>
</thead>
<tbody>
<tr>
<td>_byte</td>
<td>byte  </td>
</tr>
<tr>
<td>_long</td>
<td>long  </td>
</tr>
<tr>
<td>_short</td>
<td>short  </td>
</tr>
<tr>
<td>_int</td>
<td>int  </td>
</tr>
<tr>
<td>_integer</td>
<td>int  </td>
</tr>
<tr>
<td>_double</td>
<td>double  </td>
</tr>
<tr>
<td>_float</td>
<td>float  </td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean  </td>
</tr>
<tr>
<td>string</td>
<td>String  </td>
</tr>
<tr>
<td>byte</td>
<td>Byte  </td>
</tr>
<tr>
<td>long</td>
<td>Long  </td>
</tr>
<tr>
<td>short</td>
<td>Short  </td>
</tr>
<tr>
<td>int</td>
<td>Integer  </td>
</tr>
<tr>
<td>integer</td>
<td>Integer  </td>
</tr>
<tr>
<td>double</td>
<td>Double  </td>
</tr>
<tr>
<td>float</td>
<td>Float  </td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean  </td>
</tr>
<tr>
<td>date</td>
<td>Date  </td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal  </td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal  </td>
</tr>
</tbody>
</table>
<h3 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers(类型处理器)"></a>typeHandlers(类型处理器)</h3><p>mybatis中通过typeHandlers完成jdbc类型和java类型的转换。<br>参考：<a href="http://www.mybatis.org/mybatis-3/configuration.html#typeHandlers" title="http://www.mybatis.org/mybatis-3/configuration.html#typeHandlers" target="_blank" rel="noopener">typeHandlers</a></p>
<h3 id="mappers-映射配置"><a href="#mappers-映射配置" class="headerlink" title="mappers(映射配置)"></a>mappers(映射配置)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--通过resource方法一次加载一个映射文件 --&gt;</span><br><span class="line">&lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--通过mapper接口加载单个mapper--&gt;</span><br><span class="line">&lt;mapper class=&quot;mapper.UserMapper&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 批量加载mapper(推荐使用)</span><br><span class="line">        指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载</span><br><span class="line">        遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 中</span><br><span class="line">        上边规范的前提是：使用的是mapper代理方法</span><br><span class="line">         --&gt;</span><br><span class="line">&lt;package name=&quot;mapper&quot;/&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis--原始dao和mapper代理方法]]></title>
      <url>/2018/04/20/Mybatis/Mybatis-%E5%8E%9F%E5%A7%8Bdao%E5%92%8Cmapper%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<ul>
<li><p>SqlSessionFactoryBuilder<br>通过<font color="red">SqlSessionFactoryBuilder</font>创建会话工厂<font color="red">SqlSessionFactory</font>。将<font color="red">SqlSessionFactoryBuilder</font>当成一个工具类使用即可，不需要使用单例管理<font color="red">SqlSessionFactoryBuilder</font>。在创建<font color="red">SqlSessionFactory</font>时候，只需要new一次<font color="red">SqlSessionFactoryBuilder</font>即可。</p>
</li>
<li><p>SqlSessionFactory<br>通过<font color="red">SqlSessionFactory</font>创建<font color="red">SqlSession</font>；由于<font color="red">SqlSessionFactory</font>是线程安全的，应该在应用执行期间都存在，所以在应用运行期间不要重复创建多次，建议使用单例模式。</p>
</li>
<li><p>SqlSession<br><font color="red">SqlSession</font>是应用程序和持久层之间执行交互操作的一个单线程对象。<font color="red">SqlSession</font>中提供了许多操作数据库的方法。<br><font color="red">SqlSession</font>是线程不安全的。<br>使用完<font color="red">SqlSession</font>要确保在finally块中关闭它。</p>
<a id="more"></a>
<h2 id="原始dao接口开发"><a href="#原始dao接口开发" class="headerlink" title="原始dao接口开发"></a>原始dao接口开发</h2><p>程序员需要写dao接口和dao实现类  </p>
<h3 id="dao接口"><a href="#dao接口" class="headerlink" title="dao接口"></a>dao接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="dao接口实现类"><a href="#dao接口实现类" class="headerlink" title="dao接口实现类"></a>dao接口实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用构造方法注入SqlSessionFactory</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoImpl</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        User user = sqlSession.selectOne(<span class="string">"test.findUserById"</span>,id);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">"test.findUserByName"</span>,name);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//mybatis配置文件</span></span><br><span class="line">        String resource = <span class="string">"sqlMapConfig.xml"</span>;</span><br><span class="line">        <span class="comment">//得到配置文件流</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="comment">//创建会话工厂</span></span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDao</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建UserDao的对象</span></span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDaoImpl(sqlSessionFactory);</span><br><span class="line">        User user = userDao.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        List&lt;User&gt; list = userDao.findUserByName(<span class="string">"ho"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结原始dao开发问题"><a href="#总结原始dao开发问题" class="headerlink" title="总结原始dao开发问题"></a>总结原始dao开发问题</h3><p>1.dao接口实现类方法中存在大量的模板方法。<br>2.调用SqlSession方法时传入参数硬编码。<br>3.由于SqlSession方法使用泛型，即使变量类型传入错误，在编译阶段也不会报错，不利于程序员开发。</p>
<hr>
<h2 id="mapper代理方法"><a href="#mapper代理方法" class="headerlink" title="mapper代理方法"></a>mapper代理方法</h2><p>程序员只需要mapper接口(相当于dao接口)<br>程序员还需要编写mapper.xml映射文件<br>程序员编写mapper接口需要遵循一些开发规范，Mybatis可以自动生成mapper接口实现类代理对象。</p>
<h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><ul>
<li><p>在mapper.xml中namespace等于mapper接口地址</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离</span></span><br><span class="line"><span class="comment"> 注意：使用mapper代理方法开发，namespace有特殊重要的作用,namespace等于mapper接口地址</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"mapper.UserMapper"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mapper.java接口中的方法名和mapper.xml中statement的id一致  </p>
</li>
<li>mapper.java接口中的方法输入参数类型和mapper.xml中statement的parameterType指定的类型一致。  </li>
<li>mapper.java接口中的方法返回值类型和mapper.xml中statement的resultType指定的类型一致。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis入门程序2]]></title>
      <url>/2018/04/19/Mybatis/Mybatis%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F2/</url>
      <content type="html"><![CDATA[<p>在User.xml文件中增加增删改三个功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">       parameterType 为实体对象</span><br><span class="line">       #&#123;&#125; 会使用OGNL来获得同名的值</span><br><span class="line">       insert update delete 默认返回的都是影响的条数</span><br><span class="line">   --&gt;</span><br><span class="line">   &lt;insert id=&quot;insertUser&quot; parameterType=&quot;Pojo.User&quot;&gt;</span><br><span class="line">       &lt;!--</span><br><span class="line">           如果要求返回刚插入的id值则需要增加&lt;selectKey&gt;</span><br><span class="line"></span><br><span class="line">           SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用与自增主键</span><br><span class="line">           keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性</span><br><span class="line">           order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序</span><br><span class="line">           resultType：指定SELECT LAST_INSERT_ID()的结果类型</span><br><span class="line"></span><br><span class="line">           //也可以使用以下这种方法</span><br><span class="line">           useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</span><br><span class="line"></span><br><span class="line">           以上两种方法可以自动将id赋值给传入的那个实体相应的属性中去</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">           SELECT LAST_INSERT_ID()</span><br><span class="line">       &lt;/selectKey&gt;</span><br><span class="line">       INSERT INTO user(name,password)</span><br><span class="line">       VALUES (#&#123;name&#125;,#&#123;password&#125;)</span><br><span class="line"></span><br><span class="line">   &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--更新用户信息，id必须存在--&gt;</span><br><span class="line">   &lt;update id=&quot;updateUser&quot; parameterType=&quot;Pojo.User&quot;&gt;</span><br><span class="line">       UPDATE user</span><br><span class="line">       SET password = #&#123;password&#125;</span><br><span class="line">       WHERE id = #&#123;id&#125;</span><br><span class="line">   &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--根据id删除用户--&gt;</span><br><span class="line">   &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">       DELETE FROM</span><br><span class="line">       user</span><br><span class="line">       WHERE id = #&#123;id&#125;</span><br><span class="line">   &lt;/delete&gt;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在测试类中添加相应的三个测试方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//增加测试</span><br><span class="line">      User user = new User();</span><br><span class="line">      user.setName(&quot;JJ&quot;);</span><br><span class="line">      user.setPassword(&quot;JJ&quot;);</span><br><span class="line">      sqlSession.insert(&quot;test.insertUser&quot;,user);</span><br><span class="line">      System.out.println(user.getId());</span><br><span class="line"></span><br><span class="line">//更新测试</span><br><span class="line">      User user = new User();</span><br><span class="line">      user.setId(4);</span><br><span class="line">      user.setName(&quot;JJ&quot;);</span><br><span class="line">      user.setPassword(&quot;KK&quot;);</span><br><span class="line">      sqlSession.update(&quot;test.updateUser&quot;,user);</span><br><span class="line"></span><br><span class="line">      //删除测试</span><br><span class="line">sqlSession.delete(&quot;test.deleteUser&quot;,4);</span><br></pre></td></tr></table></figure></p>
<h3 id="mybatis和hibernate本质区别和应用场景"><a href="#mybatis和hibernate本质区别和应用场景" class="headerlink" title="mybatis和hibernate本质区别和应用场景"></a>mybatis和hibernate本质区别和应用场景</h3><ul>
<li>hibernate  </li>
</ul>
<p>是一个标准ORM框架（对象关系映射）。入门门槛较高的，不需要程序写sql，sql语句自动生成了。对sql语句进行优化、修改比较困难的。<font color="red">hibernate对象/关系映射能力强，数据库无关性好。</font></p>
<p>应用场景：适用与需求变化不多的中小型项目，比如：后台管理系统，erp、orm、oa。。</p>
<ul>
<li>mybatis</li>
</ul>
<p>专注是sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，mybatis也可以实现映射（输入映射、输出映射）。<font color="red">但是灵活的前提是Mybatis无法做到数据库无关性。</font></p>
<p>应用场景：适用与需求变化较多的项目，比如：互联网项目。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis入门程序]]></title>
      <url>/2018/04/19/Mybatis/Mybatis%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>在IDEA中新建一个Java项目。并加入jar包，工程结构如图。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="">  </p>
<a id="more"></a>
<ul>
<li>在config文件夹中创建出所需要的配置文件</li>
<li>log4j.properties</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"># Console output...</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>
<ul>
<li><p>SqlMapConfig.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 和spring整合后 environments配置将废除 --&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;!-- 使用jdbc事务管理 --&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot; /&gt;</span><br><span class="line">            &lt;!-- 数据库连接池 --&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot;</span><br><span class="line">                          value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;!--加载你书写的xml文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;sqlmapper/User.xml&quot;&gt;&lt;/mapper&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>User.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离</span><br><span class="line"> 注意：使用mapper代理方法开发，namespace有特殊重要的作用</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;test&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">         根据id查询单条数据</span><br><span class="line">         id方法名，与dao类的方法名相同</span><br><span class="line">         parameterType输入参数的类型</span><br><span class="line">         resultType指定返回类型</span><br><span class="line">         #&#123;&#125;接受参数占位符</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;Pojo.User&quot;&gt;</span><br><span class="line">        SELECT *</span><br><span class="line">        FROM user</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        根据用户名模糊查询多条数据</span><br><span class="line">        resultType返回的是单条数据的类型</span><br><span class="line">        $&#123;&#125;:表示拼接sql串，将接收到的参数不加任何修饰的拼接到sql中（可能会引起SQL注入）</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;Pojo.User&quot;&gt;</span><br><span class="line">        SELECT *</span><br><span class="line">        FROM  user</span><br><span class="line">        WHERE name LIKE &apos;%$&#123;value&#125;%&apos;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>User实体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编写测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by huzhibin on 2018/4/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//mybatis配置文件</span></span><br><span class="line">        String resource = <span class="string">"sqlMapConfig.xml"</span>;</span><br><span class="line">        <span class="comment">//得到配置文件流</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="comment">//创建会话工厂</span></span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUserByIdTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//通过工厂得到Session</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//操作数据库</span></span><br><span class="line">        User user = sqlSession.selectOne(<span class="string">"test.findUserById"</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUserByNameTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//通过工厂得到Session</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//操作数据库</span></span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">"test.findUserByName"</span>,<span class="string">"ho"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意测试返回集合类型的时候使用的是selectList，如果使用selectOne会报错：查询有多个结果</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis概述]]></title>
      <url>/2018/04/17/Mybatis/Mybatis%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h3 id="Mybatis介绍"><a href="#Mybatis介绍" class="headerlink" title="Mybatis介绍"></a>Mybatis介绍</h3><p>mybatis是一个持久层的框架，是apache下的顶级项目。</p>
<p>mybatis托管到goolecode下，再后来托管到github下（<a href="https://github.com/mybatis/mybatis-3/releases" title="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a>)。</p>
<p>Mybatis让程序将主要精力放在sql上，通过Mybatis提供的映射方式，只有灵活生成（半自动化，大部分需要程序员编写sql）满足需要SQL语句。</p>
<p>Mybatis可以将向preparedStatement中的输入参数自动进行输入映射，将查询结果灵活映射成java对象。（输出映射）<br><a id="more"></a></p>
<h2 id="框架原理"><a href="#框架原理" class="headerlink" title="框架原理"></a>框架原理</h2><p>Mybatis框架<br><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt=""></p>
<h3 id="Mybatis框架执行过程"><a href="#Mybatis框架执行过程" class="headerlink" title="Mybatis框架执行过程"></a>Mybatis框架执行过程</h3><p>1、配置Mybatis的配置文件，sqlMapConfig.xml（名称不固定）<br>2、通过配置文件，加载Mybatis运行环境，创建SQLSessionFactory会话工厂（SQLSessionFactory在实际使用时按单例方式）<br>3、通过SQLSessionFactory创建SQLSession。SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议SqlSession应用场合在方法体内。<br>4、调用SqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。<br>5、释放资源，关闭SqlSession。</p>
<h3 id="Mybatis开发dao的方法"><a href="#Mybatis开发dao的方法" class="headerlink" title="Mybatis开发dao的方法"></a>Mybatis开发dao的方法</h3><p>1.原始dao的方法</p>
<ul>
<li>需要程序员编写dao接口和实现类</li>
<li>需要在dao实现类中注入一个SQLSessionFactory工厂</li>
</ul>
<p>2.mapper代理开发方法（建议使用）<br>只需要程序员编写mapper接口（就是dao接口）。<br>程序员在编写mapper.xml（映射文件）和mapper.java需要遵循一个开发规范：</p>
<ul>
<li>mapper.xml中namespace就是mapper.java的类全路径。  </li>
<li>mapper.xml中statement的id和mapper.java中方法名一致。  </li>
<li>mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法输入参数类型一致。  </li>
<li>mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致。</li>
</ul>
<p>SqlMapConfig.xml配置文件：可以配置properties属性、别名、mapper加载。</p>
<h3 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h3><p>输入映射：</p>
<ul>
<li>parameterType：指定输入参数类型可以简单类型、pojo、hashmap。</li>
<li>对于综合查询，建议parameterType使用包装的pojo，有利于系统 扩展。</li>
</ul>
<p>输出映射：  </p>
<ul>
<li>resultType：查询到的列名和resultType指定的pojo的属性名一致，才能映射成功。  </li>
<li>reusltMap：可以通过resultMap 完成一些高级映射。如果查询到的列名和映射的pojo的属性名不一致时，通过resultMap设置列名和属性名之间的对应关系（映射关系）。可以完成映射。   </li>
<li>高级映射：<br>&ensp;&ensp;&ensp;&ensp;将关联查询的列映射到一个pojo属性中。（一对一）<br>&ensp;&ensp;&ensp;&ensp;将关联查询的列映射到一个List中。（一对多）</li>
</ul>
<h3 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h3><ul>
<li>动态sql：（重点）<br>&ensp;&ensp;&ensp;&ensp; - if判断（掌握）<br>&ensp;&ensp;&ensp;&ensp; - where<br>&ensp;&ensp;&ensp;&ensp; - foreach<br>&ensp;&ensp;&ensp;&ensp; - sql片段（掌握）  </li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原生JDBC的问题总结]]></title>
      <url>/2018/04/17/Mybatis/%E5%8E%9F%E7%94%9FJDBC%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="JDBC编程步骤"><a href="#JDBC编程步骤" class="headerlink" title="JDBC编程步骤"></a>JDBC编程步骤</h3><p>1.加载数据库驱动<br>2.创建并获取数据库连接<br>3.创建jdbc statement对象<br>4.设置SQL语句<br>5.设置SQL语句中的参数（使用preparedStatement)<br>6.通过statement执行sql并获取结果<br>7.对sql执行结果进行解析处理<br>8.释放资源（resultSet、preparedStatement、connection)</p>
<h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><a id="more"></a>
<p>1.数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。</p>
<p>设想：使用数据库连接池管理数据库连接。</p>
<p>2.将sql语句硬编码到java代码中，如果sql语句修改，需要重新编译java代码，不利于系统维护。</p>
<p>设想：将SQL语句配置在xml配置文件中，即时SQL变化，不需要对java代码进行重新编译。</p>
<p>3.向preparedStatement设置参数，对占位符位置和设置参数值，硬编码在java代码中，不利于系统维护。</p>
<p>设想：将sql语句及占位符号和参数全部配置在xml中。</p>
<p>4.从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。</p>
<p>设想：将查询的结果集，自动映射成Java对象。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate关系映射]]></title>
      <url>/2018/02/05/kuangjia/Hibernate/Hibernate_%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<h2 id="Hibernate关系映射"><a href="#Hibernate关系映射" class="headerlink" title="Hibernate关系映射"></a>Hibernate关系映射</h2><h3 id="一对多关系映射"><a href="#一对多关系映射" class="headerlink" title="一对多关系映射"></a>一对多关系映射</h3><p>数据库：在多的一方添加外键来描述关联关系。<br>实体对象：在一的一方，增加一个集合用来存放多的一方。在多的一方添加一个一的一方的属性。<br>映射文件配置：<br>User.hbm.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">           set代表用的什么集合</span><br><span class="line">           name代表多的一方的集合的属性名</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;set name=&quot;carSet&quot;&gt;</span><br><span class="line">           &lt;!--</span><br><span class="line">               key：多的一方的外键名称</span><br><span class="line">           --&gt;</span><br><span class="line">           &lt;key column=&quot;user_id&quot;&gt;&lt;/key&gt;</span><br><span class="line">           &lt;one-to-many class=&quot;pojo.Car&quot;&gt;&lt;/one-to-many&gt;</span><br><span class="line">       &lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>Car.hbm.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">            name：一的一方的属性名</span><br><span class="line">            class：一的一方的类全路径</span><br><span class="line">            colum：表中的外键外键名称</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;many-to-one name=&quot;user&quot; class=&quot;pojo.User&quot; column=&quot;user_id&quot;&gt;&lt;/many-to-one&gt;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>编写测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test_HiernateYinshe()&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName(&quot;cl&quot;);</span><br><span class="line">        user.setPassword(&quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">        Car car1 = new Car();</span><br><span class="line">        car1.setCar_name(&quot;byd&quot;);</span><br><span class="line">        car1.setColor(&quot;red&quot;);</span><br><span class="line">        Car car2 = new Car();</span><br><span class="line">        car2.setCar_name(&quot;baoma&quot;);</span><br><span class="line">        car2.setColor(&quot;blue&quot;);</span><br><span class="line"></span><br><span class="line">        //建立关系</span><br><span class="line">        user.getCarSet().add(car1);</span><br><span class="line">        user.getCarSet().add(car2);</span><br><span class="line">        car1.setUser(user);</span><br><span class="line">        car2.setUser(user);</span><br><span class="line"></span><br><span class="line">        session.save(user);</span><br><span class="line">//        以下两句在测试只保存一方时注释</span><br><span class="line">        session.save(car1);</span><br><span class="line">        session.save(car2);</span><br><span class="line"></span><br><span class="line">        tx.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过观察控制台，会发现控制台输出了三条insert语句和两条update语句。<br>既然两个对象以及进行了双向关联，那我们只保存一方是否可以呢？<br>将上面的测试代码中保存Car的两条语句注释。会报一下错误：<br><img src="http://ocx5m3vc3.bkt.clouddn.com/%E7%9E%AC%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%BC%82%E5%B8%B8.png" alt="http://ocx5m3vc3.bkt.clouddn.com/%E7%9E%AC%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%BC%82%E5%B8%B8.png"><br>这样保存是不行的，无论是从哪一方保存都会报错：瞬时对象异常。一个持久化对象关联了一个瞬时态对象。<br>如果我们只想保存一个方向，那么我们可以使用Hibernate的级联操作。<br>首先要确定我们要保存的的主控方式哪一方，用户拥有车，所以用户是主控方。我们需要在用户的映射文件中进行以下配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;set name=&quot;carSet&quot; cascade=&quot;save-update&quot;&gt;</span><br><span class="line">           &lt;key column=&quot;user_id&quot; &gt;&lt;/key&gt;</span><br><span class="line">           &lt;one-to-many class=&quot;pojo.Car&quot;&gt;&lt;/one-to-many&gt;</span><br><span class="line">       &lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>当我们在一方配置了级联配置后，保存时会将其级联的对象也保存在数据库。此时运行测试代码，会发现还是三条insert和两条update语句。因为在Car中还会进行维护外键的操作。其实这是没必要的了。所以我们必须选择一方放弃维护关系。<br>我们选择User放弃维护，因为一个老师要记住所有学生是比较困难的，但是让学生记住老师确是很容易的。<br>我们再修改User.hbm.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">           inverse默认值为false,代表不放弃维护。</span><br><span class="line">       --&gt;</span><br><span class="line">&lt;set name=&quot;carSet&quot; cascade=&quot;save-update&quot; inverse=&quot;true&quot;&gt;</span><br><span class="line">           &lt;key column=&quot;user_id&quot; &gt;&lt;/key&gt;</span><br><span class="line">           &lt;one-to-many class=&quot;pojo.Car&quot;&gt;&lt;/one-to-many&gt;</span><br><span class="line">       &lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>此时再执行测试代码。会发现只剩下了三条insert语句</p>
<ul>
<li>区分cascade和inverse<br>cascade强调的是操作一个对象时，是否操作其关联对象。<br>inverse强调的是外键的维护权</li>
</ul>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>数据库：通过一张中间表来描述其对应关系。<br>实体对象：在两个实体类中都创建一个集合来代表拥有的另一方。<br>User.hbm.xml配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">           name：关联的另一方的集合名称</span><br><span class="line">           table：中间表的名称</span><br><span class="line">           cascade：级联维护相关对象</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;set name=&quot;roleSet&quot; table=&quot;tb_user_role&quot; cascade=&quot;save-update&quot;&gt;</span><br><span class="line">           &lt;!--</span><br><span class="line">               colum：当前对象在中间表的外键名称</span><br><span class="line">           --&gt;</span><br><span class="line">           &lt;key column=&quot;user_id&quot;&gt;&lt;/key&gt;</span><br><span class="line">           &lt;!--</span><br><span class="line">               class：关联另一方的类的全路径。</span><br><span class="line">               colum：关联的另一方在中间表的外键</span><br><span class="line">           --&gt;</span><br><span class="line">           &lt;many-to-many class=&quot;pojo.Role&quot; column=&quot;role_id&quot;&gt;&lt;/many-to-many&gt;</span><br><span class="line">       &lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>Role.hbm.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">           inverse：多对多的关系映射中必须要有一方放弃维护外键。</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;set name=&quot;userSet&quot; table=&quot;tb_user_role&quot; inverse=&quot;true&quot;&gt;</span><br><span class="line">           &lt;key column=&quot;role_id&quot;&gt;&lt;/key&gt;</span><br><span class="line">           &lt;many-to-many class=&quot;pojo.User&quot; column=&quot;user_id&quot;&gt;&lt;/many-to-many&gt;</span><br><span class="line">       &lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们很容易就发现多对多的两方的映射文件差不多。<br>加载映射配置后编写测试代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void test_many2Many()&#123;</span><br><span class="line">       Session session = HibernateUtils.openSession();</span><br><span class="line">       Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">       User user1 = new User(&quot;u1&quot;,&quot;u1&quot;);</span><br><span class="line">       User user2 = new User(&quot;u2&quot;,&quot;u2&quot;);</span><br><span class="line"></span><br><span class="line">       Role role1 = new Role(&quot;前台&quot;);</span><br><span class="line">       Role role2 = new Role(&quot;人事&quot;);</span><br><span class="line">       Role role3 = new Role(&quot;助理&quot;);</span><br><span class="line"></span><br><span class="line">       //建立关系，如果建立了双向关系，一定要有一方放弃外键维护。</span><br><span class="line">       user1.getRoleSet().add(role1);</span><br><span class="line">       user1.getRoleSet().add(role2);</span><br><span class="line">       user2.getRoleSet().add(role1);</span><br><span class="line">       user2.getRoleSet().add(role3);</span><br><span class="line"></span><br><span class="line">       role1.getUserSet().add(user1);</span><br><span class="line">       role1.getUserSet().add(user2);</span><br><span class="line">       role2.getUserSet().add(user1);</span><br><span class="line">       role3.getUserSet().add(user2);</span><br><span class="line"></span><br><span class="line">       session.save(user1);</span><br><span class="line">       session.save(user2);</span><br><span class="line"></span><br><span class="line">       tx.commit();</span><br><span class="line">       session.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在多对多的关系映射中，进行了双向维护，此时必须有一方需要放弃维护。  </p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate_一级缓存]]></title>
      <url>/2018/02/04/kuangjia/Hibernate/Hibernate_%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>Hibernate的一级缓存就是Session缓存，Session缓存是一块内存空间，用来存放相互管理的java对象，在Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值对象，则会去数据库中查找相应数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。<font color="red">Hibernate的一级缓存的作用就是减少对数据库的访问次数。</font><br><a id="more"></a></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>当应用程序调用Session接口的save()、update()、savaOrUpdate()时，如果Session缓存中没有相应的对象，Hibernate就会自动的把数据库查询到的相应对象信息加入到一级缓存中去。</li>
<li>当调用Session接口的load()、get()方法以及Query接口的list()、iterator()方法时，会判断缓存中是否有该对象，有则返回；没有就去数据库中查询并添加到一级缓存中。</li>
<li>当调用Session的close()方法时。Session缓存会被清空。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test_Cacha()&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        User user = session.get(User.class,1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        User user1 = session.get(User.class,1);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line"></span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E7%BC%93%E5%AD%98%E6%B5%8B%E8%AF%95.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E7%BC%93%E5%AD%98%E6%B5%8B%E8%AF%95.png"><br>测试发现，只执行一次查询操作，并且user和user1是同一个对象。这说明了第二次查询操作时直接从缓存中取的。</p>
<ul>
<li>一级缓存的内存结构（快照区）<br>Hibernate向一级缓存放入数据时，同时复制一份数据放入Hibernate快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，<font color="red">这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的数据发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照：如果一致，则不执行update语句。</font>Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test_Cacha_2()&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        User user = session.get(User.class,1);</span><br><span class="line"></span><br><span class="line">        //先改变姓名后改回去再提交</span><br><span class="line">        user.setName(&quot;haha&quot;);</span><br><span class="line">        //后一个测试时会将此处注释</span><br><span class="line">        user.setName(&quot;xixi&quot;);</span><br><span class="line"></span><br><span class="line">        tx.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>更改姓名后更改回去，Hibernate发现user对象和快照区的一样，不会执行update方法。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%BF%AB%E7%85%A7%E6%B5%8B%E8%AF%95.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%BF%AB%E7%85%A7%E6%B5%8B%E8%AF%95.png"><br>更改姓名，Hibernate发现user对象和快照区的不一样，执行update方法。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%BF%AB%E7%85%A7%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%BF%AB%E7%85%A7%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95.png"></p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate_持久化类]]></title>
      <url>/2018/02/04/kuangjia/Hibernate/Hibernate_%E6%8C%81%E4%B9%85%E5%8C%96%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="Hibernate持久化类"><a href="#Hibernate持久化类" class="headerlink" title="Hibernate持久化类"></a>Hibernate持久化类</h2><p>在Hibernate中持久化的英文名称时Persistent Object（简称PO），PO = POJO+hbm映射配置文件。  </p>
<h3 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h3><ol>
<li>必须提供一个无参数的public构造方法。</li>
<li>所有属性用private修饰，对外提供public的get/set方法。</li>
<li>在PO类必须提供一个标识属性，与数据库中的主键对应。我们管这属性叫OID。</li>
<li>PO类中的属性尽量使用基本类型的包装类。</li>
<li>PO类不能使用final修饰符。<a id="more"></a></li>
</ol>
<ul>
<li><p>为什么PO类必须提供一个标识属性OID，让它与数据库中的主键对应呢？<br>OID指的是数据库中表的主键对应的属性。Hibernate框架是通过OID来区分不同的PO对象，如果在内存中有两个相同的OID对象，那么Hibernate认为它们是一个对象。</p>
</li>
<li><p>为什么PO类中的属性要尽量使用基本类型的包装类？<br>使用基本数据类型是没有办法去描述不存在的概念的。如果使用包装类型，它就是一个对象，对于对象它的默认值是null。如果它为null就代表这不存在。</p>
</li>
<li><p>为什么PO类不能使用final修饰符？<br>因为Hibernate会使用代理模式在延迟关联的情况下提高性能。如果把实体类定义成final类之后，java不允许对final类进行扩展；所以Hibernate就无法再使用代理了。</p>
</li>
</ul>
<h2 id="持久化对象的三种状态"><a href="#持久化对象的三种状态" class="headerlink" title="持久化对象的三种状态"></a>持久化对象的三种状态</h2><ul>
<li>瞬时态：也叫做临时态或自由态，他一般指的我们new出来的对象，此时它<font color="red">不存在OID，与Hibernate Session无关联，在数据库中也无记录。</font></li>
<li>持久态：在Hibernate Session管理范围内，他具有持久化标识OID。它的特点是在事务未提交前一直是持久态，当它发生改变时，Hibernate会检测到。<font color="red">有OID且由Session管理，在数据库中可能有，也可能没有。</font></li>
<li>托管态：也叫游离态或离线态。它是指<font color="red">持久态对象失去了Session的关联。</font>对于托管态对象，发生改变时Hibernate不会检测。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HibernateTest &#123;</span><br><span class="line"></span><br><span class="line">    // 测试持久化对象的三种状态</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        // 1.得到session</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        Customer c = new Customer(); // 瞬时态(无OID，与session无关联)</span><br><span class="line">        c.setName(&quot;张三&quot;);</span><br><span class="line">        c.setSex(&quot;男&quot;);</span><br><span class="line"></span><br><span class="line">        session.save(c); // 建立c与session的关联关系，它就是持久态的了(有OID)</span><br><span class="line"></span><br><span class="line">        // 2.事务提交，并关闭session</span><br><span class="line">        session.getTransaction().commit();</span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(c.getId()); // 断开了与session的关联，它就是脱管态的了(有OID)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png"></p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate主键生成策略]]></title>
      <url>/2018/02/04/kuangjia/Hibernate/Hibernate%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<ol>
<li><p>increment<br>用于long、short、int类型，由Hibernate自动以递增的方式生成唯一标识符，每次增量为1。只有当没有其他进程向同一张表中插入数据时才可以使用，不能在集群环境下使用。适用于代理主键。</p>
</li>
<li><p>identity<br>采用底层数据库本身提供的主键生成标识符，条件是数据库支持自动增长数据类型。在DB2、MySQL、MS SQL Server、Sybase和HypersonicSQL数据库中可以使用该生成器，该生成器要求在数据库中把主键定义成为自增长类型。适用于代理主键。</p>
</li>
<li><p>sequence<br>Hibernate根据底层数据库序列生成标识符。条件是数据库支持序列。适用于代理主键。</p>
</li>
<li><p>native<br>根据底层数据库对自动生成表示符的能力来选择identity、sequence、hilo三种生成器中的一种，适合跨数据库平台开发。适用于代理主键。</p>
</li>
<li><p>uuid<br>Hibernate采用128位的UUID算法来生成标识符。该算法能够在网络环境中生成唯一的字符串标识符，其UUID被编码为一个长度为32位的十六进制字符串。这种策略并不流行，因为字符串类型的主键比整数类型的主键占用更多的数据库空间。适用于代理主键。</p>
</li>
<li><p>assigned<br>由Java程序负责生成标识符，如果不指定ID元素的generator属性，则默认使用该主键生成策略。适用于自然主键。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate框架搭建]]></title>
      <url>/2018/02/03/kuangjia/Hibernate/Hibernate_01/</url>
      <content type="html"><![CDATA[<ul>
<li>Hibernate框架关键词：dao层框架、以面向对象的方式操作数据库、orm思想（对象关系映射，通过映射文件配置对象和数据库中表的关系）</li>
</ul>
<h2 id="Hibernate框架搭建步骤"><a href="#Hibernate框架搭建步骤" class="headerlink" title="Hibernate框架搭建步骤"></a>Hibernate框架搭建步骤</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>required+驱动包<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E9%A9%B1%E5%8A%A8%E5%8C%85.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E9%A9%B1%E5%8A%A8%E5%8C%85.png"><br><a id="more"></a></p>
<h3 id="准备实体类和orm元数据"><a href="#准备实体类和orm元数据" class="headerlink" title="准备实体类和orm元数据"></a>准备实体类和orm元数据</h3><ul>
<li><p>User.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>User.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"pojo"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        name：即实体类的全名</span></span><br><span class="line"><span class="comment">        table：映射到数据库里面的那个表的名称</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"tb_user"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- class下必须要有一个id的子元素 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id是用于描述主键的 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- type是规定类型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            使用property来描述属性与字段的对应关系</span></span><br><span class="line"><span class="comment">            如果length忽略不写，且你的表是自动创建这种方案，那么length的默认长度是255</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">length</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">length</span>=<span class="string">"50"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下表是Hibernate的类型对应表<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84.png"></p>
<h3 id="创建主配置文件"><a href="#创建主配置文件" class="headerlink" title="创建主配置文件"></a>创建主配置文件</h3><ul>
<li>hibernate.cfg.xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置关于数据库连接的四个项：driverClass  url username password --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 可以将向数据库发送的SQL语句显示出来 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式化SQL语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- hibernate的方言 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">               create:每次加载hibernate时都自动创建表</span></span><br><span class="line"><span class="comment">               create-drop:每次加载hibernate时自动创建表，结束时删除表。适合用于开发环境。</span></span><br><span class="line"><span class="comment">               update：最常用的属性。第一次加载hibernate时创建表结构；</span></span><br><span class="line"><span class="comment">                        以后每次加载都会更新表结构，但是不会删除以前的记录。。适用于运行环境。</span></span><br><span class="line"><span class="comment">               validate：每次加载都验证数据库表结构，并不会创建表</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>create<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置hibernate的映射文件所在的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"pojo/User.hbm.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="书写测试代码"><a href="#书写测试代码" class="headerlink" title="书写测试代码"></a>书写测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savaUserTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        u.setName(<span class="string">"xixi"</span>);</span><br><span class="line">        u.setPassword(<span class="string">"xixi"</span>);</span><br><span class="line"></span><br><span class="line">        Configuration config = <span class="keyword">new</span> Configuration().configure(); <span class="comment">// Hibernate框架加载hibernate.cfg.xml文件</span></span><br><span class="line">        SessionFactory sessionFactory = config.buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession(); <span class="comment">// 相当于得到一个Connection</span></span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        session.save(u);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事务提交</span></span><br><span class="line">        session.getTransaction().commit();</span><br><span class="line">        session.close();</span><br><span class="line">        sessionFactory.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查看控制台会发现创表语句和插入语句。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%88%9B%E8%A1%A8debug.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%88%9B%E8%A1%A8debug.png"></p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS中搭建redis]]></title>
      <url>/2017/11/14/Redis/CentOS%E4%B8%AD%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/</url>
      <content type="html"><![CDATA[<h3 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">首先安装环境：</span><br><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line">安装步骤：</span><br><span class="line">1. 将Redis源码包上传到服务器</span><br><span class="line"></span><br><span class="line">2. 解压缩</span><br><span class="line">tar zxf redis-3.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">3. 进入redis-3.0.0目录下编译</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">4. 安装</span><br><span class="line">make install PREFIX=/root/redis</span><br><span class="line"></span><br><span class="line">5.复制配置文件</span><br><span class="line">cp redis.conf ~/redis-3.0.0/redis.conf </span><br><span class="line"></span><br><span class="line">6.修改配置文件</span><br><span class="line">vim redis.conf</span><br><span class="line">修改    daemonize yes</span><br><span class="line">	</span><br><span class="line">7.启动</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">这样redis在后端启动了</span><br><span class="line"></span><br><span class="line">8.查看</span><br><span class="line">ps aux|grep redis</span><br></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<h3 id="集群版"><a href="#集群版" class="headerlink" title="集群版"></a>集群版</h3><p>Redis集群中至少应该有3个节点，每个节点有一个备用机。<br>所以Redis集群至少需要6台服务器。<br>我们采用伪分布式。用一台服务器搭建6个Redis实例。需要修改Redis的端口号7001-7006</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.复制一个单机版的bin目录到一个实例中</span><br><span class="line">cp -r redis/bin/ redis-cluster/redis01/</span><br><span class="line"></span><br><span class="line">2.删除快照</span><br><span class="line">rm -rf dump.rdb</span><br><span class="line"></span><br><span class="line">3.修改配置文件</span><br><span class="line">vim redis.conf</span><br><span class="line">修改端口:port 7001</span><br><span class="line">打开可以使用集群 cluster-enabled yes</span><br><span class="line"></span><br><span class="line">4.将这个实例复制几份</span><br><span class="line">cp -r redis01/ redis02</span><br><span class="line">cp -r redis01/ redis03</span><br><span class="line">cp -r redis01/ redis04</span><br><span class="line">cp -r redis01/ redis05</span><br><span class="line">cp -r redis01/ redis06</span><br><span class="line"></span><br><span class="line">5.分别修改其中配置文件中的端口</span><br><span class="line"></span><br><span class="line">6.启动（可以用批处理）</span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line">搭建集群</span><br><span class="line"></span><br><span class="line">使用ruby脚本搭建集群。需要ruby的运行环境</span><br><span class="line">yum install ruby</span><br><span class="line">yum install rubygems</span><br><span class="line"></span><br><span class="line">将redis-3.0.0.gem上传到服务器</span><br><span class="line">gem install redis-3.0.0.gem</span><br><span class="line"></span><br><span class="line">进入redis-3.0.0/src目录下</span><br><span class="line">cp redis-trip.rb /redis-cluster/</span><br><span class="line"></span><br><span class="line">到redis-cluster目录下执行脚本</span><br><span class="line">./redis-trib.rb create --replicas 1 192.168.25.153:7001 192.168.25.153:7002 192.168.25.153:7003 192.168.25.153:7004 192.168.25.153:7005 192.168.25.153:7006</span><br></pre></td></tr></table></figure>
<p><a href="http://pan.baidu.com/s/1i4Vzydv" target="_blank" rel="noopener">redis-3.0.0.gem</a><br><a href="http://pan.baidu.com/s/1bp532sn" target="_blank" rel="noopener">redis-3.0.0.tar.gz</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS安装JDK、MySQL、tomcat、zookeeper]]></title>
      <url>/2017/11/07/CentOS%E5%AE%89%E8%A3%85JDK/</url>
      <content type="html"><![CDATA[<p>&ensp;&ensp;最近跟着视频做项目的时候发觉如果本机又是服务端又是客户端总感觉哪里有点那么不爽–<br>&ensp;&ensp;于是本来打算在我本机上的虚拟机试试看结果感觉效果不是很好，然后就珍惜自己最后一年的学生身份去晚上买了一个云服务器= =</p>
<ul>
<li><a href="https://www.mtyun.com/activity-school?site=mos&amp;campaign=20170706sales" target="_blank" rel="noopener">云帆校园扶持计划-美团云</a></li>
</ul>
<hr>
<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.查看是否安装JDK</span><br><span class="line">	rpm -qa|grep java</span><br><span class="line"></span><br><span class="line">2.卸载已经安装的两个openJDK</span><br><span class="line">	rpm -e--nodeps [要卸载的软件]</span><br><span class="line"></span><br><span class="line">3.上传JDK到Linux</span><br><span class="line">//安装JDK运行需要的插件 yum install glibc.i686</span><br><span class="line">4.解压JDK到/usr/local/目录下</span><br><span class="line">	tar –xvf jdk-7u71-linux-i586.tar.gz –C /usr/local</span><br><span class="line"></span><br><span class="line">5.配置JDK环境变量，将下面的配置拷贝进去</span><br><span class="line">	vim /etc/profile</span><br><span class="line"></span><br><span class="line">	#set java environment</span><br><span class="line">	JAVA_HOME=/usr/local/jdk1.7.0_71</span><br><span class="line">	CLASSPATH=.:$JAVA_HOME/lib.tools.jar</span><br><span class="line">	PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">	export JAVA_HOME CLASSPATH PATH </span><br><span class="line"></span><br><span class="line">6.重新加载/etc/profile配置文件</span><br><span class="line">	source /etc/profile</span><br><span class="line"></span><br><span class="line">测试是否安装成功</span><br><span class="line">	java -version</span><br></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1.查看Centos自带的MySQL</span><br><span class="line">	rpm -qa|grep mysql</span><br><span class="line"></span><br><span class="line">2.卸载自带的MySQL  （rpm -e--nodeps)</span><br><span class="line"></span><br><span class="line">3.上传MySQL到Linux</span><br><span class="line">/*</span><br><span class="line">安装MySQL所需要的依赖</span><br><span class="line">yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6</span><br><span class="line">yum  update libstdc++-4.4.7-4.el6.x86_64</span><br><span class="line">*/</span><br><span class="line">4.解压Mysql到/usr/local/下的mysql目录(mysql目录需要手动创建)内</span><br><span class="line">	cd /usr/local</span><br><span class="line">	mkdir mysql</span><br><span class="line">	tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /usr/local/mysql</span><br><span class="line">5.在/usr/local/mysql下安装mysql</span><br><span class="line">安装服务器端：rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm</span><br><span class="line">安装客户端：rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm</span><br><span class="line">6.启动mysql</span><br><span class="line">	service mysql start</span><br><span class="line">7.将mysql加到系统服务中并设置开机启动</span><br><span class="line">加入到系统服务：chkconfig --add mysql</span><br><span class="line">自动启动：chkconfig mysql on</span><br><span class="line">8.登录mysql</span><br><span class="line">mysql安装好后会生成一个临时随机密码，存储位置在/root/.mysql_secret</span><br><span class="line">9.登录后修改密码</span><br><span class="line">	set password = password(&apos;root&apos;);</span><br><span class="line">10.开启mysql的远程登录</span><br><span class="line">默认情况下mysql为安全起见，不支持远程登录mysql，所以需要设置开启	远程登录mysql的权限</span><br><span class="line">登录mysql后输入如下命令：</span><br><span class="line">	grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;root&apos;;</span><br><span class="line">flush privileges;</span><br><span class="line">11.开放Linux的对外访问的端口3306</span><br><span class="line">	/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT</span><br><span class="line">	/etc/rc.d/init.d/iptables save ---将修改永久保存到防火墙中</span><br><span class="line"></span><br><span class="line">PS：后面操作数据库时发现中文会乱码。。。。</span><br><span class="line">-进入/etc/my.cnf文件</span><br><span class="line">	在[mysqld]段增加下面的代码</span><br><span class="line">	character-set-server=utf8</span><br><span class="line">	collation-server=utf8_general_ci</span><br><span class="line">重启mysql。</span><br><span class="line">/*</span><br><span class="line">	如果没有这个文件只需要复制一个/usr/share/mysql目录下的.cnf文件到/etc目录，并改名为my.cnf即可。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h3><p><a href="http://pan.baidu.com/s/1kVvJKKv" target="_blank" rel="noopener">tomcat压缩包</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.上传Tomcat到linux上</span><br><span class="line">2.解压Tomcat到/usr/local下</span><br><span class="line">3.开放Linux的对外访问的端口8080</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</span><br><span class="line">/etc/rc.d/init.d/iptables save</span><br><span class="line">4.启动关闭Tomcat</span><br><span class="line">进入tomcat的bin下启动：./startup.sh</span><br><span class="line">进入tomcat的bin下关闭：./shutdown.sh</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h3><ol>
<li><p>创建/usr/local/zookeeper文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/zookeeper</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入到/usr/local/zookeeper目录中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/zookeeper</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载 zookeeper-3.4.9.tar.gz：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.9/zookeeper-3.4.9.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压缩 zookeeper-3.4.9.tar.gz：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.9.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建/usr/local/services/zookeeper/zookeeper-3.4.9/data:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/services/zookeeper/zookeeper-3.4.9/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入到 /usr/local/services/zookeeper/zookeeper-3.4.9/conf 目录中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd zookeeper-3.4.9/conf/</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制 zoo_sample.cfg 文件的并命名为为 zoo.cfg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>用 vim 打开 zoo.cfg 文件并修改其dataDir内容为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 数据文件夹</span><br><span class="line">dataDir=/root/usr/local/services/zookeeper/zookeeper-3.4.9/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存并关闭 zoo.cfg 文件:</p>
</li>
<li><p>进入到 /usr/local/services/zookeeper/zookeeper-3.4.9/bin 目录中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../bin/</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 zookeeper 服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    zkServer.sh start</span><br><span class="line">    如打印如下信息则表明启动成功：</span><br><span class="line">    ZooKeeper JMX enabled by default</span><br><span class="line">    Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg</span><br><span class="line">    Starting zookeeper ... STARTED</span><br><span class="line">``` </span><br><span class="line">12. 查询 zookeeper 状态：</span><br><span class="line">```    </span><br><span class="line">zkServer.sh status</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="13">
<li><p>关闭 zookeeper 服务：<br>zkServer.sh stop<br>如打印如下信息则表明成功关闭：<br>ZooKeeper JMX enabled by default<br>Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg<br>Stopping zookeeper … STOPPED</p>
</li>
<li><p>重启 zookeeper 服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh restart</span><br><span class="line">如打印如下信息则表明重启成功：</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg</span><br><span class="line">Stopping zookeeper ... STOPPED</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件安装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQL优化]]></title>
      <url>/2017/11/02/SQL%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<ol>
<li>避免查询的模糊匹配</li>
<li>索引问题</li>
</ol>
<ul>
<li>避免对索引字段进行计算操作</li>
<li>避免在索引字段上使用not,&lt;&gt;,!=</li>
<li>避免在索引列上使用IS NULL和IS NOT NULL</li>
<li>避免在索引列上出现数据类型转换</li>
<li>避免在索引字段上使用函数</li>
<li>避免建立索引的列中使用空值</li>
</ul>
<ol start="3">
<li><p>复杂操作<br>&ensp;&ensp;部分UPDATE、SELETE语句写的很复杂（经常嵌套多级子查询）—可以考虑适当拆成几步，先生成一些临时数据表，再进行关联操作。</p>
</li>
<li><p>在可以使用UNION ALL的语句里，使用了UNION</p>
</li>
<li>在WHERE语句中，尽量避免对索引字段进行计算操作</li>
<li>对WHERE语句的法则</li>
</ol>
<ul>
<li>避免在WHERE子句中使用in，not  in，or 或者having。</li>
<li>不要以字符格式声明数字，要以数字格式声明字符值。（日期同样）否则会使索引无效，产生全表扫描。</li>
</ul>
<ol start="7">
<li><p>对SELECT语句的法则<br>&ensp;&ensp;尽量避免使用SELECT * FROM 这种方式</p>
</li>
<li><p>排序<br>&ensp;&ensp;避免使用耗费资源的操作，带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎 执行，耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序</p>
</li>
<li><p>慎重使用临时表可以极大的提高系统性能</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--Sorted-Sets数据结构]]></title>
      <url>/2017/10/31/Redis/Redis%E5%AD%A6%E4%B9%A0--Sorted-Sets%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)却是可以重复的。<br>&ensp;&ensp;在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数。由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ZADD key score member [score] [member]</td>
<td style="text-align:center">O(log(N))</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Sets中成员的数量。添加参数中指定的所有成员及其分数到指定key的Sorted-Set中，在该命令中我们可以指定多组score/member作为参数。如果在添加时参数中的某一成员已经存在，该命令将更新此成员的分数为新值，同时再将该成员基于新值重新排序。如果键不存在，该命令将为该键创建一个新的Sorted-Sets Value，并将score/member对插入其中。如果该键已经存在，但是与其关联的Value不是Sorted-Sets类型，相关的错误信息将被返回。</td>
<td style="text-align:center">本次操作实际插入的成员数量。</td>
</tr>
<tr>
<td style="text-align:center">ZCARD key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取与该Key相关联的Sorted-Sets中包含的成员数量。</td>
<td style="text-align:center">返回Sorted-Sets中的成员数量，如果该Key不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">ZCOUNT key min max</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Sets中成员的数量，M则表示min和max之间元素的数量。该命令用于获取分数(score)在min和max之间的成员数量。针对min和max参数需要额外说明的是，-inf和+inf分别表示Sorted-Sets中分数的最高值和最低值。缺省情况下，min和max表示的范围是闭区间范围，即min &lt;= score &lt;= max内的成员将被返回。然而我们可以通过在min和max的前面添加”(“字符来表示开区间，如(min max表示min &lt; score &lt;= max，而(min (max表示min &lt; score &lt; max。</td>
<td style="text-align:center">分数指定范围内成员的数量。</td>
</tr>
<tr>
<td style="text-align:center">ZINCRBY key increment member</td>
<td style="text-align:center">O(log(N))</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Sets中成员的数量。该命令将为指定Key中的指定成员增加指定的分数。如果成员不存在，该命令将添加该成员并假设其初始分数为0，此后再将其分数加上increment。如果Key不存，该命令将创建该Key及其关联的Sorted-Sets，并包含参数指定的成员，其分数为increment参数。如果与该Key关联的不是Sorted-Sets类型，相关的错误信息将被返回。</td>
<td style="text-align:center">以字符串形式表示的新分数。</td>
</tr>
<tr>
<td style="text-align:center">ZRANGE key start stop [WITHSCORES]</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令返回顺序在参数start和stop指定范围内的成员，这里start和stop参数都是0-based，即0表示第一个成员，-1表示最后一个成员。如果start大于该Sorted-Set中的最大索引值，或start &gt; stop，此时一个空集合将被返回。如果stop大于最大索引值，该命令将返回从start到集合的最后一个成员。如果命令中带有可选参数WITHSCORES选项，该命令在返回的结果中将包含每个成员的分数值，如value1,score1,value2,score2…。　　</td>
<td style="text-align:center">返回索引在start和stop之间的成员列表。</td>
</tr>
<tr>
<td style="text-align:center">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令将返回分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的成员，其中返回的成员是按照其分数从低到高的顺序返回，如果成员具有相同的分数，则按成员的字典顺序返回。可选参数LIMIT用于限制返回成员的数量范围。可选参数offset表示从符合条件的第offset个成员开始返回，同时返回count个成员。可选参数WITHSCORES的含义参照ZRANGE中该选项的说明。最后需要说明的是参数中min和max的规则可参照命令ZCOUNT。</td>
<td style="text-align:center">返回分数在指定范围内的成员列表。</td>
</tr>
<tr>
<td style="text-align:center">ZRANK key member</td>
<td style="text-align:center">O(log(N))</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量。Sorted-Set中的成员都是按照分数从低到高的顺序存储，该命令将返回参数中指定成员的位置值，其中0表示第一个成员，它是Sorted-Set中分数最低的成员。</td>
<td style="text-align:center">如果该成员存在，则返回它的位置索引值。否则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">ZREM key member [member …]</td>
<td style="text-align:center">O(M log(N))</td>
<td style="text-align:center">时间复杂度中N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。该命令将移除参数中指定的成员，其中不存在的成员将被忽略。如果与该Key关联的Value不是Sorted-Set，相应的错误信息将被返回。</td>
<td style="text-align:center">实际被删除的成员数量。</td>
</tr>
<tr>
<td style="text-align:center">ZREVRANGE key start stop [WITHSCORES]</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令的功能和ZRANGE基本相同，唯一的差别在于该命令是通过反向排序获取指定位置的成员，即从高到低的顺序。如果成员具有相同的分数，则按降序字典顺序排序。</td>
<td style="text-align:center">返回指定的成员列表。</td>
</tr>
<tr>
<td style="text-align:center">ZREVRANK key member</td>
<td style="text-align:center">O(log(N))</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量。该命令的功能和ZRANK基本相同，唯一的差别在于该命令获取的索引是从高到低排序后的位置，同样0表示第一个元素，即分数最高的成员。</td>
<td style="text-align:center">如果该成员存在，则返回它的位置索引值。否则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">ZSCORE key member</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取指定Key的指定成员的分数。</td>
<td style="text-align:center">如果该成员存在，以字符串的形式返回其分数，否则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令除了排序方式是基于从高到低的分数排序之外，其它功能和参数含义均与ZRANGEBYSCORE相同。</td>
<td style="text-align:center">返回分数在指定范围内的成员列表。</td>
</tr>
<tr>
<td style="text-align:center">ZREMRANGEBYRANK key start stop</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。删除索引位置位于start和stop之间的成员，start和stop都是0-based，即0表示分数最低的成员，-1表示最后一个成员，即分数最高的成员。</td>
<td style="text-align:center">被删除的成员数量。</td>
</tr>
<tr>
<td style="text-align:center">ZREMRANGEBYSCORE key min max</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。删除分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的所有成员。对于min和max参数，可以采用开区间的方式表示，具体规则参照ZCOUNT。</td>
<td style="text-align:center">被删除的成员数量。</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>ZADD/ZCARD/ZCOUNT/ZREM/ZINCRBY/ZSCORE/ZRANGE/ZRANK:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#在Shell的命令行下启动Redis客户端工具。</span><br><span class="line">/&gt; redis-cli</span><br><span class="line">#添加一个分数为<span class="number">1</span>的成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> <span class="string">"one"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#添加两个分数分别是<span class="number">2</span>和<span class="number">3</span>的两个成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">2</span> <span class="string">"two"</span> <span class="number">3</span> <span class="string">"three"</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#<span class="number">0</span>表示第一个成员，<span class="number">-1</span>表示最后一个成员。WITHSCORES选项表示返回的结果中包含每个成员及其分数，否则只返回成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"3"</span></span><br><span class="line">#获取成员one在Sorted-Set中的位置索引值。<span class="number">0</span>表示第一个位置。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrank myzset one</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#成员four并不存在，因此返回nil。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrank myzset four</span><br><span class="line">(nil)</span><br><span class="line">#获取myzset键中成员的数量。    </span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcard myzset</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">#返回与myzset关联的Sorted-Set中，分数满足表达式<span class="number">1</span> &lt;= score &lt;= <span class="number">2</span>的成员的数量。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcount myzset <span class="number">1</span> <span class="number">2</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#删除成员one和two，返回实际删除成员的数量。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrem myzset one two</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#查看是否删除成功。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcard myzset</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#获取成员three的分数。返回值是字符串形式。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zscore myzset three</span><br><span class="line"><span class="string">"3"</span></span><br><span class="line">#由于成员two已经被删除，所以该命令返回nil。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zscore myzset two</span><br><span class="line">(nil)</span><br><span class="line">#将成员one的分数增加<span class="number">2</span>，并返回该成员更新后的分数。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zincrby myzset <span class="number">2</span> one</span><br><span class="line"><span class="string">"3"</span></span><br><span class="line">#将成员one的分数增加<span class="number">-1</span>，并返回该成员更新后的分数。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zincrby myzset <span class="number">-1</span> one</span><br><span class="line"><span class="string">"2"</span></span><br><span class="line">#查看在更新了成员的分数后是否正确。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"3"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ZRANGEBYSCORE/ZREMRANGEBYRANK/ZREMRANGEBYSCORE</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del myzset</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> one <span class="number">2</span> two <span class="number">3</span> three <span class="number">4</span> four</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line">#获取分数满足表达式<span class="number">1</span> &lt;= score &lt;= <span class="number">2</span>的成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrangebyscore myzset <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br><span class="line">#获取分数满足表达式<span class="number">1</span> &lt; score &lt;= <span class="number">2</span>的成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrangebyscore myzset (<span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"two"</span></span><br><span class="line">#-inf表示第一个成员，+inf表示最后一个成员，limit后面的参数用于限制返回成员的自己，</span><br><span class="line">#<span class="number">2</span>表示从位置索引(<span class="number">0</span>-based)等于<span class="number">2</span>的成员开始，去后面<span class="number">3</span>个成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrangebyscore myzset -inf +inf limit <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"four"</span></span><br><span class="line">#删除分数满足表达式<span class="number">1</span> &lt;= score &lt;= <span class="number">2</span>的成员，并返回实际删除的数量。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zremrangebyscore myzset <span class="number">1</span> <span class="number">2</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#看出一下上面的删除是否成功。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"four"</span></span><br><span class="line">#删除位置索引满足表达式<span class="number">0</span> &lt;= rank &lt;= <span class="number">1</span>的成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zremrangebyrank myzset <span class="number">0</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#查看上一条命令是否删除成功。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcard myzset</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ZREVRANGE/ZREVRANGEBYSCORE/ZREVRANK:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#为后面的示例准备测试数据。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del myzset</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> one <span class="number">2</span> two <span class="number">3</span> three <span class="number">4</span> four</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line">#以位置索引从高到低的方式获取并返回此区间内的成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrange myzset <span class="number">0</span> <span class="number">-1</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) <span class="string">"four"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"4"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"3"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">8</span>) <span class="string">"1"</span></span><br><span class="line">#由于是从高到低的排序，所以位置等于<span class="number">0</span>的是four，<span class="number">1</span>是three，并以此类推。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrange myzset <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"one"</span></span><br><span class="line">#由于是从高到低的排序，所以one的位置是<span class="number">3</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrank myzset one</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">#由于是从高到低的排序，所以four的位置是<span class="number">0</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrank myzset four</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#获取分数满足表达式<span class="number">3</span> &gt;= score &gt;= <span class="number">0</span>的成员，并以相反的顺序输出，即从高到底的顺序。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrangebyscore myzset <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"one"</span></span><br><span class="line">#该命令支持limit选项，其含义等同于zrangebyscore中的该选项，只是在计算位置时按照相反的顺序计算和获取。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrangebyscore myzset <span class="number">4</span> <span class="number">0</span> limit <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h3><ol>
<li>可以用于一个大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行ZADD命令更新玩家的分数，此后再通过ZRANGE命令获取积分TOP TEN的用户信息。当然我们也可以利用ZRANK命令通过username来获取玩家的排行信息。最后我们将组合使用ZRANGE和ZRANK命令快速的获取和某个玩家积分相近的其他用户的信息。</li>
<li>Sorted-Sets类型还可用于构建索引数据。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--Hashs数据结构]]></title>
      <url>/2017/10/31/Redis/Redis%E5%AD%A6%E4%B9%A0--Hashs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;我们可以将Redis中的Hashes类型看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash可以存储4294967295个键值对。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HSET key field value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">为指定的Key设定Field/Value对，如果Key不存在，该命令将创建新Key以参数中的Field/Value对，如果参数中的Field在该Key中已经存在，则用新值覆盖其原有值。</td>
<td style="text-align:center">1表示新的Field被设置了新值，0表示Field已经存在，用新值覆盖原有值。</td>
</tr>
<tr>
<td style="text-align:center">HGET key field</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回指定Key中指定Field的关联值。</td>
<td style="text-align:center">返回参数中Field的关联值，如果参数中的Key或Field不存，返回nil。</td>
</tr>
<tr>
<td style="text-align:center">HEXISTS key field</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">判断指定Key中的指定Field是否存在。</td>
<td style="text-align:center">1表示存在，0表示参数中的Field或Key不存在。</td>
</tr>
<tr>
<td style="text-align:center">HLEN key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取该Key所包含的Field的数量。</td>
<td style="text-align:center">返回Key包含的Field数量，如果Key不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">HDEL key field [field …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示参数中待删除的字段数量。从指定Key的Hashes Value中删除参数中指定的多个字段，如果不存在的字段将被忽略。如果Key不存在，则将其视为空Hashes，并返回0.</td>
<td style="text-align:center">实际删除的Field数量。</td>
</tr>
<tr>
<td style="text-align:center">HSETNX key field value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">只有当参数中的Key或Field不存在的情况下，为指定的Key设定Field/Value对，否则该命令不会进行任何操作。</td>
<td style="text-align:center">1表示新的Field被设置了新值，0表示Key或Field已经存在，该命令没有进行任何操作。</td>
</tr>
<tr>
<td style="text-align:center">HINCRBY key field increment</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">增加指定Key中指定Field关联的Value的值。如果Key或Field不存在，该命令将会创建一个新Key或新Field，并将其关联的Value初始化为0，之后再指定数字增加的操作。该命令支持的数字是64位有符号整型，即increment可以负数。</td>
<td style="text-align:center">返回运算后的值。</td>
</tr>
<tr>
<td style="text-align:center">HGETALL key</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示Key包含的Field数量。获取该键包含的所有Field/Value。其返回格式为一个Field、一个Value，并以此类推。</td>
<td style="text-align:center">Field/Value的列表。</td>
</tr>
<tr>
<td style="text-align:center">HKEYS key</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示Key包含的Field数量。返回指定Key的所有Fields名</td>
<td style="text-align:center">Field的列表。</td>
</tr>
<tr>
<td style="text-align:center">HVALS key</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示Key包含的Field数量。返回指定Key的所有Values名。</td>
<td style="text-align:center">Value的列表。</td>
</tr>
<tr>
<td style="text-align:center">HMGET key field [field …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示请求的Field数量。获取和参数中指定Fields关联的一组Values。如果请求的Field不存在，其值返回nil。如果Key不存在，该命令将其视为空Hash，因此返回一组nil。</td>
<td style="text-align:center">返回和请求Fields关联的一组Values，其返回顺序等同于Fields的请求顺序。</td>
</tr>
<tr>
<td style="text-align:center">HMSET key field value [field value …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示被设置的Field数量。逐对依次设置参数中给出的Field/Value对。如果其中某个Field已经存在，则用新值覆盖原有值。如果Key不存在，则创建新Key，同时设定参数中的Field/Value。</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>LPUSH/LPUSHX/LRANGE:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#在Shell命令行启动Redis客户端程序</span><br><span class="line">/&gt; redis-cli</span><br><span class="line">#给键值为myhash的键设置字段为field1，值为stephen。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset myhash field1 <span class="string">"stephen"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#获取键值为myhash，字段为field1的值。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget myhash field1</span><br><span class="line"><span class="string">"stephen"</span></span><br><span class="line"><span class="meta">#myhash键中不存在field2字段，因此返回nil。</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget myhash field2</span><br><span class="line">(nil)</span><br><span class="line">#给myhash关联的Hashes值添加一个新的字段field2，其值为liu。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset myhash field2 <span class="string">"liu"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#获取myhash键的字段数量。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hlen myhash</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#判断myhash键中是否存在字段名为field1的字段，由于存在，返回值为<span class="number">1</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hexists myhash field1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#删除myhash键中字段名为field1的字段，删除成功返回<span class="number">1</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hdel myhash field1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#再次删除myhash键中字段名为field1的字段，由于上一条命令已经将其删除，因为没有删除，返回<span class="number">0</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hdel myhash field1</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#判断myhash键中是否存在field1字段，由于上一条命令已经将其删除，因为返回<span class="number">0</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hexists myhash field1</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#通过hsetnx命令给myhash添加新字段field1，其值为stephen，因为该字段已经被删除，所以该命令添加成功并返回<span class="number">1</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hsetnx myhash field1 stephen</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#由于myhash的field1字段已经通过上一条命令添加成功，因为本条命令不做任何操作后返回<span class="number">0</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hsetnx myhash field1 stephen</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HINCRBY：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#删除该键，便于后面示例的测试。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del myhash</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#准备测试数据，该myhash的field字段设定值<span class="number">1</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset myhash field <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#给myhash的field字段的值加<span class="number">1</span>，返回加后的结果。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hincrby myhash field <span class="number">1</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line">#给myhash的field字段的值加<span class="number">-1</span>，返回加后的结果。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hincrby myhash field <span class="number">-1</span></span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line">#给myhash的field字段的值加<span class="number">-10</span>，返回加后的结果。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hincrby myhash field <span class="number">-10</span></span><br><span class="line">(integer) <span class="number">-5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HGETALL/HKEYS/HVALS/HMGET/HMSET:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#删除该键，便于后面示例测试。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del myhash</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#为该键myhash，一次性设置多个字段，分别是field1 = <span class="string">"hello"</span>, field2 = <span class="string">"world"</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hmset myhash field1 <span class="string">"hello"</span> field2 <span class="string">"world"</span></span><br><span class="line">OK</span><br><span class="line">#获取myhash键的多个字段，其中field3并不存在，因为在返回结果中与该字段对应的值为nil。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hmget myhash field1 field2 field3</span><br><span class="line"><span class="number">1</span>) <span class="string">"hello"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"world"</span></span><br><span class="line"><span class="number">3</span>) (nil)</span><br><span class="line">#返回myhash键的所有字段及其值，从结果中可以看出，他们是逐对列出的。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hgetall myhash</span><br><span class="line"><span class="number">1</span>) <span class="string">"field1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"hello"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"field2"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"world"</span></span><br><span class="line">#仅获取myhash键中所有字段的名字。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hkeys myhash</span><br><span class="line"><span class="number">1</span>) <span class="string">"field1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"field2"</span></span><br><span class="line">#仅获取myhash键中所有字段的值。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hvals myhash</span><br><span class="line"><span class="number">1</span>) <span class="string">"hello"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"world"</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--Set数据类型]]></title>
      <url>/2017/10/31/Redis/Redis%E5%AD%A6%E4%B9%A0--Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为O(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295。<br>&ensp;&ensp;和List类型不同的是，Set集合中不允许出现重复的元素，这一点和C++标准库中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SADD key member [member …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示操作的成员数量。如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。如果该Key的Value不是Set类型，该命令将返回相关的错误信息。</td>
<td style="text-align:center">本次操作实际插入的成员数量。</td>
</tr>
<tr>
<td style="text-align:center">SCARD key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取Set中成员的数量。</td>
<td style="text-align:center">返回Set中成员的数量，如果该Key并不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">SISMEMBER key member</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">判断参数中指定成员是否已经存在于与Key相关联的Set集合中。</td>
<td style="text-align:center">1表示已经存在，0表示不存在，或该Key本身并不存在。</td>
</tr>
<tr>
<td style="text-align:center">SMEMBERS key</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示Set中已经存在的成员数量。获取与该Key关联的Set中所有的成员。</td>
<td style="text-align:center">返回Set中所有的成员。</td>
</tr>
<tr>
<td style="text-align:center">SPOP key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">随机的移除并返回Set中的某一成员。 由于Set中元素的布局不受外部控制，因此无法像List那样确定哪个元素位于Set的头部或者尾部。</td>
<td style="text-align:center">返回移除的成员，如果该Key并不存在，则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">SREM key member [member …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示被删除的成员数量。从与Key关联的Set中删除参数中指定的成员，不存在的参数成员将被忽略，如果该Key并不存在，将视为空Set处理。</td>
<td style="text-align:center">从Set中实际移除的成员数量，如果没有则返回0。</td>
</tr>
<tr>
<td style="text-align:center">SRANDMEMBER key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">和SPOP一样，随机的返回Set中的一个成员，不同的是该命令并不会删除返回的成员。</td>
<td style="text-align:center">返回随机位置的成员，如果Key不存在则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">SMOVE source destination member</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性的将参数中的成员从source键移入到destination键所关联的Set中。因此在某一时刻，该成员或者出现在source中，或者出现在destination中。如果该成员在source中并不存在，该命令将不会再执行任何操作并返回0，否则，该成员将从source移入到destination。如果此时该成员已经在destination中存在，那么该命令仅是将该成员从source中移出。如果和Key关联的Value不是Set，将返回相关的错误信息。</td>
<td style="text-align:center">1表示正常移动，0表示source中并不包含参数成员。</td>
</tr>
<tr>
<td style="text-align:center">SDIFF key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示所有Sets中成员的总数量。返回参数中第一个Key所关联的Set和其后所有Keys所关联的Sets中成员的差异。如果Key不存在，则视为空Set。</td>
<td style="text-align:center">差异结果成员的集合。</td>
</tr>
<tr>
<td style="text-align:center">SDIFFSTORE destination key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">该命令和SDIFF命令在功能上完全相同，两者之间唯一的差别是SDIFF返回差异的结果成员，而该命令将差异成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。</td>
<td style="text-align:center">返回差异成员的数量。</td>
</tr>
<tr>
<td style="text-align:center">SINTER key [key …]</td>
<td style="text-align:center">O(N*M)</td>
<td style="text-align:center">时间复杂度中的N表示最小Set中元素的数量，M则表示参数中Sets的数量。该命令将返回参数中所有Keys关联的Sets中成员的交集。因此如果参数中任何一个Key关联的Set为空，或某一Key不存在，那么该命令的结果将为空集。</td>
<td style="text-align:center">交集结果成员的集合。</td>
</tr>
<tr>
<td style="text-align:center">SINTERSTORE destination key [key …]</td>
<td style="text-align:center">O(N*M)</td>
<td style="text-align:center">该命令和SINTER命令在功能上完全相同，两者之间唯一的差别是SINTER返回交集的结果成员，而该命令将交集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。</td>
<td style="text-align:center">返回交集成员的数量。</td>
</tr>
<tr>
<td style="text-align:center">SUNION key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示所有Sets中成员的总数量。该命令将返回参数中所有Keys关联的Sets中成员的并集。</td>
<td style="text-align:center">并集结果成员的集合。</td>
</tr>
<tr>
<td style="text-align:center">SUNIONSTORE destination key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">该命令和SUNION命令在功能上完全相同，两者之间唯一的差别是SUNION返回并集的结果成员，而该命令将并集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。</td>
<td style="text-align:center">返回并集成员的数量。</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>SADD/SMEMBERS/SCARD/SISMEMBER:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#在Shell命令行下启动Redis的客户端程序。</span><br><span class="line">/&gt; redis-cli</span><br><span class="line">#插入测试数据，由于该键myset之前并不存在，因此参数中的三个成员都被正常插入。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset a b c</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">#由于参数中的a在myset中已经存在，因此本次操作仅仅插入了d和e两个新成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset a d e</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#判断a是否已经存在，返回值为<span class="number">1</span>表示存在。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sismember myset a</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#判断f是否已经存在，返回值为<span class="number">0</span>表示不存在。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sismember myset f</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#通过smembers命令查看插入的结果，从结果可以，输出的顺序和插入顺序无关。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"e"</span></span><br><span class="line">#获取Set集合中元素的数量。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; scard myset</span><br><span class="line">(integer) <span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SPOP/SREM/SRANDMEMBER/SMOVE:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#删除该键，便于后面的测试。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del myset</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#为后面的示例准备测试数据。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset a b c d</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line">#查看Set中成员的位置。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"b"</span></span><br><span class="line">#从结果可以看出，该命令确实是随机的返回了某一成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srandmember myset</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line">#Set中尾部的成员b被移出并返回，事实上b并不是之前插入的第一个或最后一个成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; spop myset</span><br><span class="line"><span class="string">"b"</span></span><br><span class="line">#查看移出后Set的成员信息。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line">#从Set中移出a、d和f三个成员，其中f并不存在，因此只有a和d两个成员被移出，返回为<span class="number">2</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem myset a d f</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#查看移出后的输出结果。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line">#为后面的smove命令准备数据。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset a b</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset2 c d</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#将a从myset移到myset2，从结果可以看出移动成功。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smove myset myset2 a</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#再次将a从myset移到myset2，由于此时a已经不是myset的成员了，因此移动失败并返回<span class="number">0</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smove myset myset2 a</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#分别查看myset和myset2的成员，确认移动是否真的成功。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"b"</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset2</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SDIFF/SDIFFSTORE/SINTER/SINTERSTORE:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">    #为后面的命令准备测试数据。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sadd myset a b c d</span></span><br><span class="line"><span class="string">    (integer) 4</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sadd myset2 c</span></span><br><span class="line"><span class="string">    (integer) 1</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sadd myset3 a c e</span></span><br><span class="line"><span class="string">    (integer) 3</span></span><br><span class="line"><span class="string">    #myset和myset2相比，a、b和d三个成员是两者之间的差异成员。再用这个结果继续和myset3进行差异比较，b和d是myset3不存在的成员。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sdiff myset myset2 myset3</span></span><br><span class="line"><span class="string">    1) "</span>d<span class="string">"</span></span><br><span class="line"><span class="string">    2) "</span>b<span class="string">"</span></span><br><span class="line"><span class="string">    #将3个集合的差异成员存在在diffkey关联的Set中，并返回插入的成员数量。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sdiffstore diffkey myset myset2 myset3</span></span><br><span class="line"><span class="string">    (integer) 2</span></span><br><span class="line"><span class="string">    #查看一下sdiffstore的操作结果。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; smembers diffkey</span></span><br><span class="line"><span class="string">    1) "</span>d<span class="string">"</span></span><br><span class="line"><span class="string">    2) "</span>b<span class="string">"</span></span><br><span class="line"><span class="string">    #从之前准备的数据就可以看出，这三个Set的成员交集只有c。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sinter myset myset2 myset3</span></span><br><span class="line"><span class="string">    1) "</span>c<span class="string">"</span></span><br><span class="line"><span class="string">    #将3个集合中的交集成员存储到与interkey关联的Set中，并返回交集成员的数量。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sinterstore interkey myset myset2 myset3</span></span><br><span class="line"><span class="string">    (integer) 1</span></span><br><span class="line"><span class="string">    #查看一下sinterstore的操作结果。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; smembers interkey</span></span><br><span class="line"><span class="string">    1) "</span>c<span class="string">"</span></span><br><span class="line"><span class="string">    #获取3个集合中的成员的并集。    </span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sunion myset myset2 myset3</span></span><br><span class="line"><span class="string">    1) "</span>b<span class="string">"</span></span><br><span class="line"><span class="string">    2) "</span>c<span class="string">"</span></span><br><span class="line"><span class="string">    3) "</span>d<span class="string">"</span></span><br><span class="line"><span class="string">    4) "</span>e<span class="string">"</span></span><br><span class="line"><span class="string">    5) "</span>a<span class="string">"</span></span><br><span class="line"><span class="string">    #将3个集合中成员的并集存储到unionkey关联的set中，并返回并集成员的数量。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sunionstore unionkey myset myset2 myset3</span></span><br><span class="line"><span class="string">    (integer) 5</span></span><br><span class="line"><span class="string">    #查看一下suiionstore的操作结果。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; smembers unionkey</span></span><br><span class="line"><span class="string">    1) "</span>b<span class="string">"</span></span><br><span class="line"><span class="string">    2) "</span>c<span class="string">"</span></span><br><span class="line"><span class="string">    3) "</span>d<span class="string">"</span></span><br><span class="line"><span class="string">    4) "</span>e<span class="string">"</span></span><br><span class="line"><span class="string">    5) "</span>a<span class="string">"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h3><ol>
<li>可以使用Redis的Set数据类型跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性。</li>
<li>充分利用Set类型的服务端聚合操作方便、高效的特性，可以用于维护数据对象之间的关联关系。比如所有购买某一电子设备的客户ID被存储在一个指定的Set中，而购买另外一种电子产品的客户ID被存储在另外一个Set中，如果此时我们想获取有哪些客户同时购买了这两种商品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--List数据类型]]></title>
      <url>/2017/10/30/Redis/Redis%E5%AD%A6%E4%B9%A0--List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。<br>&ensp;&ensp;从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。相信对于有良好数据结构基础的开发者而言，这一点并不难理解。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LPUSH key value [value …]</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">在指定Key所关联的List Value的头部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的头部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">LPUSHX key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的头部插入参数中给出的Value，否则将不会有任何操作发生。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">LRANGE key start stop</td>
<td style="text-align:center">O(S+N)</td>
<td style="text-align:center">时间复杂度中的S为start参数表示的偏移量，N表示元素的数量。该命令的参数start和end都是0-based。即0表示链表头部(leftmost)的第一个元素。其中start的值也可以为负值，-1将表示链表中的最后一个元素，即尾部元素，-2表示倒数第二个并以此类推。该命令在获取元素时，start和end位置上的元素也会被取出。如果start的值大于链表中元素的数量，空链表将会被返回。如果end的值大于元素的数量，该命令则获取从start(包括start)开始，链表中剩余的所有元素。</td>
<td style="text-align:center">返回指定范围内元素的列表。</td>
</tr>
<tr>
<td style="text-align:center">LPOP key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回并弹出指定Key关联的链表中的第一个元素，即头部元素，。如果该Key不存，返回nil。</td>
<td style="text-align:center">链表头部的元素。</td>
</tr>
<tr>
<td style="text-align:center">LLEN key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回指定Key关联的链表中元素的数量，如果该Key不存在，则返回0。如果与该Key关联的Value的类型不是链表，则返回相关的错误信息。</td>
<td style="text-align:center">链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">LREM key count value</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示链表中元素的数量。在指定Key关联的链表中，删除前count个值等于value的元素。如果count大于0，从头向尾遍历并删除，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。如果指定的Key不存在，则直接返回0。</td>
<td style="text-align:center">返回被删除的元素数量。</td>
</tr>
<tr>
<td style="text-align:center">LSET key index value</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示链表中元素的数量。但是设定头部或尾部的元素时，其时间复杂度为O(1)。设定链表中指定位置的值为新值，其中0表示第一个元素，即头部元素，-1表示尾部元素。如果索引值Index超出了链表中元素的数量范围，该命令将返回相关的错误信息。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LINDEX key index</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示在找到该元素时需要遍历的元素数量。对于头部或尾部元素，其时间复杂度为O(1)。该命令将返回链表中指定位置(index)的元素，index是0-based，表示头部元素，如果index为-1，表示尾部元素。如果与该Key关联的不是链表，该命令将返回相关的错误信息。</td>
<td style="text-align:center">返回请求的元素，如果index超出范围，则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">LTRIM key start stop</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示被删除的元素数量。该命令将仅保留指定范围内的元素，从而保证链接中的元素数量相对恒定。start和stop参数都是0-based，0表示头部元素。和其他命令一样，start和stop也可以为负值，-1表示尾部元素。如果start大于链表的尾部，或start大于stop，该命令不错报错，而是返回一个空的链表，与此同时该Key也将被删除。如果stop大于元素的数量，则保留从start开始剩余的所有元素。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LINSERT key BEFORE,AFTER pivot value</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示在找到该元素pivot之前需要遍历的元素数量。这样意味着如果pivot位于链表的头部或尾部时，该命令的时间复杂度为O(1)。该命令的功能是在pivot元素的前面或后面插入参数中的元素value。如果Key不存在，该命令将不执行任何操作。如果与Key关联的Value类型不是链表，相关的错误信息将被返回。</td>
<td style="text-align:center">成功插入后链表中元素的数量，如果没有找到pivot，返回-1，如果key不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">RPUSH key value [value …]</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">指定Key所关联的List Value的尾部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的尾部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">RPUSHX key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的尾部插入参数中给出的Value，否则将不会有任何操作发生。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">RPOP key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回并弹出指定Key关联的链表中的最后一个元素，即尾部元素，。如果该Key不存，返回nil</td>
<td style="text-align:center">链表尾部的元素</td>
</tr>
<tr>
<td style="text-align:center">RPOPLPUSH source destination</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性的从与source键关联的链表尾部弹出一个元素，同时再将弹出的元素插入到与destination键关联的链表的头部。如果source键不存在，该命令将返回nil，同时不再做任何其它的操作了。如果source和destination是同一个键，则相当于原子性的将其关联链表中的尾部元素移到该链表的头部。</td>
<td style="text-align:center">返回弹出和插入的元素。</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>LPUSH/LPUSHX/LRANGE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/&gt; redis-cli    #在Shell提示符下启动redis客户端工具。</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey</span><br><span class="line">(integer) 1</span><br><span class="line">#mykey键并不存在，该命令会创建该键及与其关联的List，之后在将参数中的values从左到右依次插入。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d</span><br><span class="line">(integer) 4</span><br><span class="line">#取从位置0开始到位置2结束的3个元素。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 2</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">#取链表中的全部元素，其中0表示第一个元素，-1表示最后一个元素。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;a&quot;</span><br><span class="line">#mykey2键此时并不存在，因此该命令将不会进行任何操作，其返回值为0。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpushx mykey2 e</span><br><span class="line">(integer) 0</span><br><span class="line">#可以看到mykey2没有关联任何List Value。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey2 0 -1</span><br><span class="line">(empty list or set)</span><br><span class="line">#mykey键此时已经存在，所以该命令插入成功，并返回链表中当前元素的数量。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpushx mykey e</span><br><span class="line">(integer) 5</span><br><span class="line">#获取该键的List Value的头部元素。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 0</span><br><span class="line">1) &quot;e&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LPOP/LLEN:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d</span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; lpop mykey</span><br><span class="line">&quot;d&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; lpop mykey</span><br><span class="line">&quot;c&quot;</span><br><span class="line">#在执行lpop命令两次后，链表头部的两个元素已经被弹出，此时链表中元素的数量是2</span><br><span class="line">redis 127.0.0.1:6379&gt; llen mykey</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>LREM/LSET/LINDEX/LTRIM:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#为后面的示例准备测试数据。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d a c</span><br><span class="line">(integer) 6</span><br><span class="line">#从头部(left)向尾部(right)变量链表，删除2个值等于a的元素，返回值为实际删除的数量。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrem mykey 2 a</span><br><span class="line">(integer) 2</span><br><span class="line">#看出删除后链表中的全部元素。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;d&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line">#获取索引值为1(头部的第二个元素)的元素值。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 1</span><br><span class="line">&quot;d&quot;</span><br><span class="line">#将索引值为1(头部的第二个元素)的元素值设置为新值e。</span><br><span class="line">redis 127.0.0.1:6379&gt; lset mykey 1 e</span><br><span class="line">OK</span><br><span class="line">#查看是否设置成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 1</span><br><span class="line">&quot;e&quot;</span><br><span class="line">#索引值6超过了链表中元素的数量，该命令返回nil。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 6</span><br><span class="line">(nil)</span><br><span class="line">#设置的索引值6超过了链表中元素的数量，设置失败，该命令返回错误信息。</span><br><span class="line">redis 127.0.0.1:6379&gt; lset mykey 6 hh</span><br><span class="line">(error) ERR index out of range</span><br><span class="line">#仅保留索引值0到2之间的3个元素，注意第0个和第2个元素均被保留。</span><br><span class="line">redis 127.0.0.1:6379&gt; ltrim mykey 0 2</span><br><span class="line">OK</span><br><span class="line">#查看trim后的结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;e&quot;</span><br><span class="line">3) &quot;c&quot;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>LINSERT:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#删除该键便于后面的测试。</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey</span><br><span class="line">(integer) 1</span><br><span class="line">#为后面的示例准备测试数据。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d e</span><br><span class="line">(integer) 5</span><br><span class="line">#在a的前面插入新元素a1。</span><br><span class="line">redis 127.0.0.1:6379&gt; linsert mykey before a a1</span><br><span class="line">(integer) 6</span><br><span class="line">#查看是否插入成功，从结果看已经插入。注意lindex的index值是0-based。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 0</span><br><span class="line">&quot;e&quot;</span><br><span class="line">#在e的后面插入新元素e2，从返回结果看已经插入成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; linsert mykey after e e2</span><br><span class="line">(integer) 7</span><br><span class="line">#再次查看是否插入成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 1</span><br><span class="line">&quot;e2&quot;</span><br><span class="line">#在不存在的元素之前或之后插入新元素，该命令操作失败，并返回-1。</span><br><span class="line">redis 127.0.0.1:6379&gt; linsert mykey after k a</span><br><span class="line">(integer) -1</span><br><span class="line">#为不存在的Key插入新元素，该命令操作失败，返回0。</span><br><span class="line">redis 127.0.0.1:6379&gt; linsert mykey1 after a a2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>RPUSH/RPUSHX/RPOP/RPOPLPUSH:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#删除该键，以便于后面的测试。</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey</span><br><span class="line">(integer) 1</span><br><span class="line">#从链表的尾部插入参数中给出的values，插入顺序是从左到右依次插入。</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mykey a b c d</span><br><span class="line">(integer) 4</span><br><span class="line">#通过lrange的可以获悉rpush在插入多值时的插入顺序。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br><span class="line">#该键已经存在并且包含4个元素，rpushx命令将执行成功，并将元素e插入到链表的尾部。</span><br><span class="line">redis 127.0.0.1:6379&gt; rpushx mykey e</span><br><span class="line">(integer) 5</span><br><span class="line">#通过lindex命令可以看出之前的rpushx命令确实执行成功，因为索引值为4的元素已经是新元素了。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 4</span><br><span class="line">&quot;e&quot;</span><br><span class="line">#由于mykey2键并不存在，因此该命令不会插入数据，其返回值为0。</span><br><span class="line">redis 127.0.0.1:6379&gt; rpushx mykey2 e</span><br><span class="line">(integer) 0</span><br><span class="line">#在执行rpoplpush命令前，先看一下mykey中链表的元素有哪些，注意他们的位置关系。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br><span class="line">5) &quot;e&quot;</span><br><span class="line">#将mykey的尾部元素e弹出，同时再插入到mykey2的头部(原子性的完成这两步操作)。</span><br><span class="line">redis 127.0.0.1:6379&gt; rpoplpush mykey mykey2</span><br><span class="line">&quot;e&quot;</span><br><span class="line">#通过lrange命令查看mykey在弹出尾部元素后的结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br><span class="line">#通过lrange命令查看mykey2在插入元素后的结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey2 0 -1</span><br><span class="line">1) &quot;e&quot;</span><br><span class="line">#将source和destination设为同一键，将mykey中的尾部元素移到其头部。</span><br><span class="line">redis 127.0.0.1:6379&gt; rpoplpush mykey mykey</span><br><span class="line">&quot;d&quot;</span><br><span class="line">#查看移动结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;c&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="链表结构的小技巧"><a href="#链表结构的小技巧" class="headerlink" title="链表结构的小技巧"></a>链表结构的小技巧</h3><p>&ensp;&ensp; 针对链表结构的Value，Redis在其官方文档中给出了一些实用技巧，如RPOPLPUSH命令，下面给出具体的解释。<br>&ensp;&ensp; Redis链表经常会被用于消息队列的服务，以完成多程序之间的消息交换。假设一个应用程序正在执行LPUSH操作向链表中添加新的元素，我们通常将这样的程序称之为”生产者(Producer)”，而另外一个应用程序正在执行RPOP操作从链表中取出元素，我们称这样的程序为”消费者(Consumer)”。如果此时，消费者程序在取出消息元素后立刻崩溃，由于该消息已经被取出且没有被正常处理，那么我们就可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态的不一致等现象的发生。然而通过使用RPOPLPUSH命令，消费者程序在从主消息队列中取出消息之后再将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时我们还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其它的消费者程序继续处理。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--String数据类型]]></title>
      <url>/2017/10/30/Redis/Redis%E5%AD%A6%E4%B9%A0-String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">APPEND key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">如果该Key已经存在，APPEND命令将参数Value的数据追加到已存在Value的末尾。如果该Key不存在，APPEND命令将会创建一个新的Key/Value。</td>
<td style="text-align:center">追加后Value的长度。</td>
</tr>
<tr>
<td style="text-align:center">DECR key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的递减1。如果该Key不存在，其初始值为0，在decr之后其值为-1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">递减后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">INCR key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的递增1。如果该Key不存在，其初始值为0，在incr之后其值为1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">递增后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">DECRBY key decrement</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的减少decrement。如果该Key不存在，其初始值为0，在decrby之后其值为-decrement。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">减少后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">INCRBY key increment</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的增加increment。如果该Key不存在，其初始值为0，在incrby之后其值为increment。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">增加后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">GET key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取指定Key的Value。如果与该Key关联的Value不是string类型，Redis将返回错误信息，因为GET命令只能用于获取string Value。</td>
<td style="text-align:center">与该Key相关的Value，如果该Key不存在，返回nil。</td>
</tr>
<tr>
<td style="text-align:center">SET key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性的设置该Key为指定的Value，同时返回该Key的原有值。和GET命令一样，该命令也只能处理string Value，否则Redis将给出相关的错误信息。</td>
<td style="text-align:center">返回该Key的原有值，如果该Key之前并不存在，则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">STRLEN key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回指定Key的字符值长度，如果Value不是string类型，Redis将执行失败并给出相关的错误信息。</td>
<td style="text-align:center">返回指定Key的Value字符长度，如果该Key不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">SETEX key seconds value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性完成两个操作，一是设置该Key的值为指定字符串，同时设置该Key在Redis服务器中的存活时间(秒数)。该命令主要应用于Redis被当做Cache服务器使用时。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">SETNX key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">如果指定的Key不存在，则设定该Key持有指定字符串Value，此时其效果等价于SET命令。相反，如果该Key已经存在，该命令将不做任何操作并返回。</td>
<td style="text-align:center">1表示设置成功，否则0。</td>
</tr>
<tr>
<td style="text-align:center">SETRANGE key offset value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">替换指定Key的部分字符串值。从offset开始，替换的长度为该命令第三个参数value的字符串长度，其中如果offset的值大于该Key的原有值Value的字符串长度，Redis将会在Value的后面补齐(offset - strlen(value))数量的0x00，之后再追加新值。如果该键不存在，该命令会将其原值的长度假设为0，并在其后添补offset个0x00后再追加新值。鉴于字符串Value的最大长度为512M，因此offset的最大值为536870911。最后需要注意的是，如果该命令在执行时致使指定Key的原有值长度增加，这将会导致Redis重新分配足够的内存以容纳替换后的全部字符串，因此就会带来一定的性能折损。</td>
<td style="text-align:center">修改后的字符串Value长度。</td>
</tr>
<tr>
<td style="text-align:center">GETRANGE key start end</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">如果截取的字符串长度很短，我们可以该命令的时间复杂度视为O(1)，否则就是O(N)，这里N表示截取的子字符串长度。该命令在截取子字符串时，将以闭区间的方式同时包含start(0表示第一个字符)和end所在的字符，如果end值超过Value的字符长度，该命令将只是截取从start开始之后所有的字符数据。</td>
<td style="text-align:center">子字符串</td>
</tr>
<tr>
<td style="text-align:center">SETBIT key offset value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">设置在指定Offset上BIT的值，该值只能为1或0，在设定后该命令返回该Offset上原有的BIT值。如果指定Key不存在，该命令将创建一个新值，并在指定的Offset上设定参数中的BIT值。如果Offset大于Value的字符长度，Redis将拉长Value值并在指定Offset上设置参数中的BIT值，中间添加的BIT值为0。最后需要说明的是Offset值必须大于0</td>
<td style="text-align:center">在指定Offset上的BIT原有值。</td>
</tr>
<tr>
<td style="text-align:center">GETBIT key offset</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回在指定Offset上BIT的值，0或1。如果Offset超过string value的长度，该命令将返回0，所以对于空字符串始终返回0。</td>
<td style="text-align:center">在指定Offset上的BIT值。</td>
</tr>
<tr>
<td style="text-align:center">MGET key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示获取Key的数量。返回所有指定Keys的Values，如果其中某个Key不存在，或者其值不为string类型，该Key的Value将返回nil。</td>
<td style="text-align:center">返回一组指定Keys的Values的列表。</td>
</tr>
<tr>
<td style="text-align:center">MSET key value [key value …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SET命令。</td>
<td style="text-align:center">该命令不会失败，始终返回OK。</td>
</tr>
<tr>
<td style="text-align:center">MSETNX key value [key value …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SETNX命令。然而这里需要明确说明的是，如果在这一批Keys中有任意一个Key已经存在了，那么该操作将全部回滚，即所有的修改都不会生效。</td>
<td style="text-align:center">1表示所有Keys都设置成功，0则表示没有任何Key被修改</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>SET/GET/APPEND/STRLEN:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/&gt; redis-cli   #执行Redis客户端工具。</span><br><span class="line">redis 127.0.0.1:6379&gt; exists mykey                   #判断该键是否存在，存在返回1，否则返回0。</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; append mykey &quot;hello&quot;      #该键并不存在，因此append命令返回当前Value的长度。</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:6379&gt; append mykey &quot; world&quot;    #该键已经存在，因此返回追加后Value的长度。</span><br><span class="line">(integer) 11</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                      #通过get命令获取该键，以判断append的结果。</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey &quot;this is a test&quot; #通过set命令为键设置新值，并覆盖原有值。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey</span><br><span class="line">&quot;this is a test&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; strlen mykey                  #获取指定Key的字符长度，等效于C库中strlen函数。</span><br><span class="line">(integer) 14</span><br></pre></td></tr></table></figure>
</li>
<li><p>INCR/DECR/INCRBY/DECRBY:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set mykey 20     #设置Key的值为20</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; incr mykey         #该Key的值递增1</span><br><span class="line">(integer) 21</span><br><span class="line">redis 127.0.0.1:6379&gt; decr mykey        #该Key的值递减1</span><br><span class="line">(integer) 20</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey          #删除已有键。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; decr mykey        #对空值执行递减操作，其原值被设定为0，递减后的值为-1</span><br><span class="line">(integer) -1</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey   </span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; incr mykey        #对空值执行递增操作，其原值被设定为0，递增后的值为1</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey hello #将该键的Value设置为不能转换为整型的普通字符串。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; incr mykey        #在该键上再次执行递增操作时，Redis将报告错误信息。</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey 10</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; decrby mykey 5 </span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:6379&gt; incrby mykey 10</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure>
</li>
<li><p>GETSET：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; incr mycounter      #将计数器的值原子性的递增1</span><br><span class="line">(integer) 1</span><br><span class="line">#在获取计数器原有值的同时，并将其设置为新值，这两个操作原子性的同时完成。</span><br><span class="line">redis 127.0.0.1:6379&gt; getset mycounter 0  </span><br><span class="line">&quot;1&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; get mycounter       #查看设置后的结果。</span><br><span class="line">&quot;0&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SETEX:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; setex mykey 10 &quot;hello&quot;   #设置指定Key的过期时间为10秒。</span><br><span class="line">OK    </span><br><span class="line">#通过ttl命令查看一下指定Key的剩余存活时间(秒数)，0表示已经过期，-1表示永不过期。</span><br><span class="line">redis 127.0.0.1:6379&gt; ttl mykey                       </span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                      #在该键的存活期内我们仍然可以获取到它的Value。</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; ttl mykey                        #该ttl命令的返回值显示，该Key已经过期。</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                      #获取已过期的Key将返回nil。</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
</li>
<li><p>SETNX:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; del mykey                      #删除该键，以便于下面的测试验证。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; setnx mykey &quot;hello&quot;        #该键并不存在，因此该命令执行成功。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; setnx mykey &quot;world&quot;       #该键已经存在，因此本次设置没有产生任何效果。</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                      #从结果可以看出，返回的值仍为第一次设置的值。</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SETRANGE/GETRANGE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set mykey &quot;hello world&quot;       #设定初始值。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; setrange mykey 6 dd          #从第六个字节开始替换2个字节(dd只有2个字节)</span><br><span class="line">(integer) 11</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                         #查看替换后的值。</span><br><span class="line">&quot;hello ddrld&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; setrange mykey 20 dd        #offset已经超过该Key原有值的长度了，该命令将会在末尾补0。</span><br><span class="line">(integer) 22</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                           #查看补0后替换的结果。</span><br><span class="line">&quot;hello ddrld\x00\x00\x00\x00\x00\x00\x00\x00\x00dd&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey                         #删除该Key。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; setrange mykey 2 dd         #替换空值。</span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                        #查看替换空值后的结果。</span><br><span class="line">&quot;\x00\x00dd&quot;   </span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey &quot;0123456789&quot;   #设置新值。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; getrange mykey 1 2      #截取该键的Value，从第一个字节开始，到第二个字节结束。</span><br><span class="line">&quot;12&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; getrange mykey 1 20   #20已经超过Value的总长度，因此将截取第一个字节后面的所有字节。</span><br><span class="line">&quot;123456789&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SETBIT/GETBIT:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; del mykey</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit mykey 7 1       #设置从0开始计算的第七位BIT值为1，返回原有BIT值0</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                #获取设置的结果，二进制的0000 0001的十六进制值为0x01</span><br><span class="line">&quot;\x01&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit mykey 6 1       #设置从0开始计算的第六位BIT值为1，返回原有BIT值0</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                #获取设置的结果，二进制的0000 0011的十六进制值为0x03</span><br><span class="line">&quot;\x03&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; getbit mykey 6          #返回了指定Offset的BIT值。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; getbit mykey 10        #Offset已经超出了value的长度，因此返回0。</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>MSET/MGET/MSETNX:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; mset key1 &quot;hello&quot; key2 &quot;world&quot;   #批量设置了key1和key2两个键。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; mget key1 key2                        #批量获取了key1和key2两个键的值。</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">#批量设置了key3和key4两个键，因为之前他们并不存在，所以该命令执行成功并返回1。</span><br><span class="line">redis 127.0.0.1:6379&gt; msetnx key3 &quot;stephen&quot; key4 &quot;liu&quot; </span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; mget key3 key4                   </span><br><span class="line">1) &quot;stephen&quot;</span><br><span class="line">2) &quot;liu&quot;</span><br><span class="line">#批量设置了key3和key5两个键，但是key3已经存在，所以该命令执行失败并返回0。</span><br><span class="line">redis 127.0.0.1:6379&gt; msetnx key3 &quot;hello&quot; key5 &quot;world&quot; </span><br><span class="line">(integer) 0</span><br><span class="line">#批量获取key3和key5，由于key5没有设置成功，所以返回nil。</span><br><span class="line">redis 127.0.0.1:6379&gt; mget key3 key5                   </span><br><span class="line">1) &quot;stephen&quot;</span><br><span class="line">2) (nil)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[servlet的9大内置对象]]></title>
      <url>/2017/10/28/servlet%E7%9A%849%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">隐式对象</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">request</td>
<td style="text-align:center">转译后的HttpServletRquest/ServletRequest对象</td>
</tr>
<tr>
<td style="text-align:center">response</td>
<td style="text-align:center">转译后对应HttpServletRespons/ServletResponse对象</td>
</tr>
<tr>
<td style="text-align:center">session</td>
<td style="text-align:center">转译后对应HttpSession对象</td>
</tr>
<tr>
<td style="text-align:center">application</td>
<td style="text-align:center">转译后对应ServletContext对象</td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td style="text-align:center">转译后对应JspWriter对象，其内部关联一个PringWriter对象</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">转译后对应this</td>
</tr>
<tr>
<td style="text-align:center">config</td>
<td style="text-align:center">转译后对应ServletConfig对象</td>
</tr>
<tr>
<td style="text-align:center">exception</td>
<td style="text-align:center">转译后对应Throwable对象，代表由其他JSP页面抛出的异常对象，只会出现于JSP错误页面(isErrorPage设置为true的JSP页面)</td>
</tr>
<tr>
<td style="text-align:center">pageContext</td>
<td style="text-align:center">转译后对应PageContext对象，它提供了JSP页面资源的封装，并可设置页面范围属性</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="JSP隐含变量"><a href="#JSP隐含变量" class="headerlink" title="JSP隐含变量"></a>JSP隐含变量</h2><p>1.out 来源于Java.io.Writer类，它用于发送输出流到客户端。<br>2.request 来源于javax.servlet.http.HttpServletRequest接口。它被关联到每一个HTTP请求。<br>3.response 来源于javax.servlet.http.HttpServletResponse。response对象用于把取得的数据返回到客户端。<br>4.pageContext 提供访问JSP页面的命名空间。它也提供用来访问其他的JSP隐含对象。<br>5.session 来源于javax.servlet.http.HttpSession。它用于存储客户端请求的信息，因此它是有状态交互式的。<br>6.application 来源于javax.servlet.ServletContext。<br>7.config 来源于ServletConfig，它包含了当前JSP/Servlet所在的WEB应用的配置信息。<br>8.page 来源于当前被访问JSP页面的实例化。它实际使用的是JSP转换成的Servlet。<br>9.exception 用于捕获JSP抛出的异常。它只有在JSP页面属性isErrorPage=true时才可用。</p>
<h3 id="一、request对象："><a href="#一、request对象：" class="headerlink" title="一、request对象："></a>一、request对象：</h3><p>&ensp;&ensp;该对象封装了用户提交的信息，通过调用该对象相应的方法可以获取封装的信息， 即使用该对象可以获取用户提交信息。 客户端的请求参数都被封装到这个对象里面</p>
<h3 id="二、response对象："><a href="#二、response对象：" class="headerlink" title="二、response对象："></a>二、response对象：</h3><p>&ensp;&ensp;对客户的请求做出动态的响应，向客户发送数据。</p>
<h3 id="三、session对象："><a href="#三、session对象：" class="headerlink" title="三、session对象："></a>三、session对象：</h3><p>&ensp;&ensp;1.什么是session：session对象是一个JSP内置对象，它在第一个JSP页面被装载时自动创建，完成会话期管理。<br>从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。当一个客户访问一个服务器时，可能会在这个服务器的几个页面之间反复连接，反复刷新一个页面，服务器应当通过某种办法知道这是同一个客户，这就需要session对象。</p>
<p>&ensp;&ensp;2．session对象的ID：当一个客户首次访问服务器上的一个JSP页面时，JSP引擎产生一个session对象，同时分配一个String类型的ID号，JSP引擎同时将这个ID号发送到客户端，存放在Cookie中，这样session对象和客户之间就建立了一一对应的关系。当客户再访问连接该服务器的其他页面时，不再分配给客户新的session对象，直到客户关闭浏览器后，服务器端该客户的session对象才取消，并且和客户的会话对应关系消失。当客户重新打开浏览器再连接到该服务器时，服务器为该客户再创建一个新的session对象。</p>
<h3 id="四、aplication对象："><a href="#四、aplication对象：" class="headerlink" title="四、aplication对象："></a>四、aplication对象：</h3><p>&ensp;&ensp;1．什么是application:<br>服务器启动后就产生了这个application对象，当客户在所访问的网站的各个页面之间浏览时，这个application对象都是同一个，直到服务器关闭。但是与session不同的是，所有客户的application对象都是同一个，即所有客户共享这个内置的application对象。</p>
<p>&ensp;&ensp;2．application对象常用方法:<br>(1)public void setAttribute(String key,Object obj): 将参数Object指定的对象obj添加到application对象中，并为添加的对象指定一个索引关键字。<br>(2)public Object getAttribute(String key): 获取application对象中含有关键字的对象。 </p>
<h3 id="五、out对象："><a href="#五、out对象：" class="headerlink" title="五、out对象："></a>五、out对象：</h3><p>&ensp;&ensp;out 对象是一个输出流，用来向客户端输出数据。out对象用于各种数据的输出。</p>
<h3 id="六、page-java-lang-Object："><a href="#六、page-java-lang-Object：" class="headerlink" title="六、page java.lang.Object："></a>六、page java.lang.Object：</h3><p>&ensp;&ensp;对应this关键字。JSP网页本身<br>page对象是当前页面转换后的Servlet类的实例。从转换后的Servlet类的代码中，可以看到这种关系：<br>Object page = this;<br>在JSP页面中，很少使用page对象。</p>
<h3 id="七、config："><a href="#七、config：" class="headerlink" title="七、config："></a>七、config：</h3><p>&ensp;&ensp;javax.servlet. ServletConfig 的实例，该实例代表该JSP 的配置信息。常用的方法有getInitPararneter(String paramNarne) 及getInitPararneternarnes() 等方法。事实上， JSP 页面通常无须配置，也就不存在配置信息。因此，该对象更多地在Servlet 中有效。</p>
<h3 id="八、exception-java-lang-Throwable-的实例："><a href="#八、exception-java-lang-Throwable-的实例：" class="headerlink" title="八、exception java.lang.Throwable 的实例："></a>八、exception java.lang.Throwable 的实例：</h3><p>&ensp;&ensp;该实例代表其他页面中的异常和错误。只有当页面是错误处理页面，即编译指令page 的isErrorPage 属性为true 时，该对象才可以使用。常用的方法有getMessageO和printStackTraceO等。</p>
<h3 id="九、pageContext："><a href="#九、pageContext：" class="headerlink" title="九、pageContext："></a>九、pageContext：</h3><p>&ensp;&ensp;out 对象是一个输出流，用来向客户端输出数据。out对象用于各种数据的输出。</p>
<hr>
<p>//使用pageContext 设置属性，该属性默认在page 范围内<br>pageContext. setAttribute (“page” , “hello”) ; </p>
<p>  //使用request 设置属性，该属性默认在request 范围内<br>request. setAttribute (“request” , “hello”); </p>
<p>  //使用pageContext将属性设置在request 范围中<br>pageContext.setAttribute(“request2” , “hello” , pageContext.REQUEST_SCOPE); </p>
<p>  // 使用session将属性设置在session 范围中<br>session.setAttribute(“session” , “hello”l; </p>
<p>  //使用pageContext将属性设置在session范围中<br>pageContext.setAttribute(“session2” , “hello” , pageContext.SESSION_SCOPE); </p>
<p>  //使用application将属性设置在application范围中<br>application. setAttribute (“app” , “hello”) ; </p>
<p>  //使用pageContext 将属性设置在application 范围中<br>pageContext.setAttribute(“app2” , “hello” , pageContext.APPL 工CATION_SCOPE) ;</p>
<hr>
<h2 id="四个作用域："><a href="#四个作用域：" class="headerlink" title="四个作用域："></a>四个作用域：</h2><h3 id="application："><a href="#application：" class="headerlink" title="application："></a>application：</h3><p>全局作用范围，整个应用程序共享，就是在部署文件中的同一个webApp共享，生命周期为：应用程序启动到停止。</p>
<h3 id="session："><a href="#session：" class="headerlink" title="session："></a>session：</h3><p>会话作用域，当用户首次访问时，产生一个新的会话，以后服务器就可以记住这个会话状态。生命周期：会话超时，或者服务器端强制使会话失效。</p>
<h3 id="request"><a href="#request" class="headerlink" title="request:"></a>request:</h3><p>请求作用域，就是客户端的一次请求。</p>
<h3 id="page："><a href="#page：" class="headerlink" title="page："></a>page：</h3><p>一个JSP页面。</p>
<p>以上作用范围使越来越小， request和page的生命周期都是短暂的，他们之间的区别就是：一个request可以包含多个page页(include，forward以及filter)。</p>
]]></content>
      
        <categories>
            
            <category> JAVA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令（特殊功能）]]></title>
      <url>/2017/10/24/Linux/Linux%E5%91%BD%E4%BB%A4%EF%BC%88%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%EF%BC%89/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk  &apos;NR==FNR&#123;a[$0]&#125;NR&gt;FNR&#123; if(!($1 in a)) print $0&#125;&apos; file1 file2 找出文件2中不同的值</span><br><span class="line"></span><br><span class="line">awk  &apos;NR==FNR&#123;a[$0]&#125;NR&gt;FNR&#123; if($1 in a)    print $0&#125;&apos; file1 file2 找出两文件中相同的值</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux常用命令（简）]]></title>
      <url>/2017/10/24/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="目录与文件命令"><a href="#目录与文件命令" class="headerlink" title="目录与文件命令"></a>目录与文件命令</h2><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a><a href="https://omg-by.github.io/1900/01/01/Linux/cd/" title="cd详细介绍" target="_blank" rel="noopener">cd命令</a></h3><p>&ensp;&ensp;跟Windows中一样，进入相应的目录下。<br>&ensp;&ensp;命令格式： cd [目录]</p>
<h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a><a href="https://omg-by.github.io/1900/01/01/Linux/ls/" title="ls详细介绍" target="_blank" rel="noopener">ls命令</a></h3><p>&ensp;&ensp;查看当前目录下的目录、文件等及其相应权限。<br>&ensp;&ensp;命令格式： ls [选项] 目录</p>
<h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><p>&ensp;&ensp;查看当前工作目录的完整路径。<br>&ensp;&ensp;pwd [选项]</p>
<h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>&ensp;&ensp;创建一个指定的名称的目录，要求创建目录的用户具有权限且该目录名不存在。<br>&ensp;&ensp;mkdir [选项]目录<br><a id="more"></a></p>
<h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><p>&ensp;&ensp;删除一个目录中的一个或多个文件或目录。<br>&ensp;&ensp;rm [选项] 文件或目录</p>
<h3 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h3><p>&ensp;&ensp;删除空目录。<br>&ensp;&ensp;rmdir [选项] 目录</p>
<h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p>&ensp;&ensp;移动文件或者将文件改名，经常用来备份文件或者目录。<br>&ensp;&ensp;mv [选项] 源文件或目录 目标文件或者目录</p>
<h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p>&ensp;&ensp;复制文件，如果目标文件已经存在，会询问是否覆盖。<br>&ensp;&ensp;cp [选项] 源文件或目录  目的目录</p>
<h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p>&ensp;&ensp;用来修改文件时间戳或者新建一个不存在的文件。<br>&ensp;&ensp;touch [选项] 文件</p>
<h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><p>&ensp;&ensp;用来压缩和解压文件。tar本身不具有压缩功能，他是调用压缩功能实现的。<br>&ensp;&ensp;tar [必要参数][选择参数][文件]</p>
<h2 id="查看与搜索"><a href="#查看与搜索" class="headerlink" title="查看与搜索"></a>查看与搜索</h2><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>&ensp;&ensp;显示文件内容 或者将几个文件连接起来显示 或者从标准输入读取内容并显示，常与重定向符号配合使用。<br>&ensp;&ensp;cat [选项] 文件</p>
<h3 id="nl命令"><a href="#nl命令" class="headerlink" title="nl命令"></a>nl命令</h3><p>&ensp;&ensp;用来计算文件中行号，可以将输出的文件内容自动的加上行号。<br>&ensp;&ensp;nl [选项] 文件</p>
<h3 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h3><p>&ensp;&ensp;功能类似cat，cat是整个文件的内容从上到下显示到屏幕上，more会以一页一页的显示方便使用者阅读，空格向后，b键向前。more从前向后读取文件，因此在启动时就加载整个文件。<br>&ensp;&ensp;more [选项] [每屏几行] [查找的子串] [第几行开始] [文件] </p>
<h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p>&ensp;&ensp;跟more类似，但使用less可以任意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看前不会加载整个文件。<br>&ensp;&ensp;less [参数] 文件</p>
<h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><p>&ensp;&ensp;用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。<br>&ensp;&ensp;head [参数] 文件</p>
<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>&ensp;&ensp;用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。<br>&ensp;&ensp;tail[必要参数][选择参数] 文件</p>
<h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><p>&ensp;&ensp;which指令会在PATH变量指定的路径下，搜索某个系统命令的位置，并且返回第一个搜索结果。<br>&ensp;&ensp;which 可执行文件命令</p>
<h3 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h3><p>&ensp;&ensp;whereis命令是定位可执行文件、源代码文件、帮助文件、在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。<br>&ensp;&ensp;whereis [-bmsu] [BMS 目录名 -f ] 文件名</p>
<h3 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h3><p>&ensp;&ensp;通过系统自动生成是数据库表来查询文件，支持匹配符。但是由于有些系统的数据库表不是实时更新的，所以查到的数据可能不是最新的。<br>&ensp;&ensp;locate[选择参数][样式]</p>
<h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><p>&ensp;&ensp;用于在文件树中查找文件，并作出相应的处理。<br>&ensp;&ensp;find pathname -options [-print -exec -ok …] </p>
<p>##磁盘相关##</p>
<h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h3><p>&ensp;&ensp;列出文件系统的整体磁盘使用量</p>
<h3 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h3><p>&ensp;&ensp;评估文件系统的磁盘使用量（常用于评估目录所占容量）</p>
<h3 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h3><p>&ensp;&ensp;连接文件<br>&ensp;&ensp;ls [-sf] 源文件 目标文件<br>&ensp;&ensp;-s 如果不加任何参数就进行连接，那就是hard link，至于-s就是symbolic link<br>&ensp;&ensp;-f 如果目标文件存在时，就主动将目标文件删除后再创建。</p>
<h3 id="fdisk命令"><a href="#fdisk命令" class="headerlink" title="fdisk命令"></a>fdisk命令</h3><p>&ensp;&ensp;磁盘分区</p>
<h3 id="mkfs命令"><a href="#mkfs命令" class="headerlink" title="mkfs命令"></a>mkfs命令</h3><p>&ensp;&ensp;磁盘格式化<br>&ensp;&ensp;mkfs [-t 文件系统格式] 设备文件名</p>
<h3 id="fsck命令"><a href="#fsck命令" class="headerlink" title="fsck命令"></a>fsck命令</h3><p>&ensp;&ensp;磁盘检验</p>
<h3 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h3><p>&ensp;&ensp;磁盘挂载</p>
<h3 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a>umount命令</h3><p>&ensp;&ensp;磁盘卸载</p>
<p><br><br><br><br><center> <strong>长期不定时更新中。。。。。。。。。</strong></center></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ActionContext]]></title>
      <url>/2017/10/21/kuangjia/Struts/ActionContext/</url>
      <content type="html"><![CDATA[<h3 id="ActionContext"><a href="#ActionContext" class="headerlink" title="ActionContext"></a><center>ActionContext</center></h3><p>&ensp;&ensp;ActionContext是Action的上下文，Struct2自动在其中保存了一些在Action执行过程中所需的对象，比如session、parameters、locale等。Struts2会根据每个执行HTTp请求的线程来创建对应的ActionContext，即一个线程只有一个唯一的ActionContext。因此，使用者可以使用静态方法ActionContext.getContext&#40;&#41;来获取当前线程的ActionContext，也正是由于这个原因，使用者不用去操心让Action是线程安全的。</p>
<p>&ensp;&ensp;无论如何，ActionContext都是用来存放数据的。Struts2本身会在其中放入不少数据，而使用者也可以放入自己想要的数据。ActionContext本身的数据结构是映射结构，即一个Map，用key来映射value。所以使用者完全可以像使用Map一样来使用它，或者直接使用Action.getContextMap&#40;&#41;方法来对Map进行操作。</p>
<p>&ensp;&ensp;Struts2本身在其中放入的数据有Actionlnvocation、application&#40;即ServletContext&#41;、conversionErrors、Locale、action的name、request的参数、HTTP的Session以及值栈等。完整的列表请参考它的Javadoc。</p>
<p>&ensp;&ensp;由于ActionContext的线程唯一和静态方法就能获得的特性，使得在非Action类中可以直接获得它，而不需要等待Action传入或注入。<font color="#DC143C">需要注意的是，它仅在由于request而创建的线程中有效&#40;因为request时才创建对应的ActionContext&#41;，而在服务器启动的线程中&#40;比如fliter的init方法&#41;无效。</font>由于在非Action类中访问其的方便性，ActionContext也可以用来在非Action类中向JSP传递数据&#40;因为JSP也能很方便的访问它&#41;。<br><a id="more"></a></p>
<h3 id="ValueStack与ActionContext的联系和区别"><a href="#ValueStack与ActionContext的联系和区别" class="headerlink" title="ValueStack与ActionContext的联系和区别"></a><center>ValueStack与ActionContext的联系和区别</center></h3><p>&ensp;&ensp;<font color="#DC143C">相同点：它们都是在一次HTTP请求的范围内使用的，即它们的生命周期都是一次请求。<br>&ensp;&ensp;不同点：值栈是栈的结构，ActionContext是映射&#40;Map&#41;的结构。</font></p>
<p>&ensp;&ensp;联系：ValueStack.getContext&#40;&#41;方法得到的Map其实就是ActionContext的Map。查看Struts2的源代码可知&#40;Struts2.3.1.2的org.apache.struts2.dispatcher.ng.PrepareOperations的第79行，createActionContext方法&#41;，在创建ActionContext时，就是把ValueStack.getContext&#40;&#41;作为ActionContext的构造函数的参数。所以，ValueStack和ActionContext本质上可以互相获得。</p>
<p>&ensp;&ensp;注意：在一些文档中，会出现把对象存入“stack‘s context”的字样，其实就是把值存入了ActionContext。所以在阅读这些文档时，要看清楚，到底是放入了栈结构&#40;即值栈&#41;，还是映射结构&#40;值栈的context，即ActionContext&#41;。</p>
<h3 id="如何获得ActionContext"><a href="#如何获得ActionContext" class="headerlink" title="如何获得ActionContext"></a><center>如何获得ActionContext</center></h3><p>&ensp;&ensp;在自定义的拦截器中：使用ActionInvocation.getInvocationContext&#40;&#41;或者使用ActionContext.getContext&#40;&#41;。</p>
<p>&ensp;&ensp;在Action类中：让拦截器注入或者使用ActionContext.getContext&#40;&#41;。</p>
<p>&ensp;&ensp;在非Action类中：让Action类传递参数、使用注入机制注入或者使用ActionContext.getContext&#40;&#41;。</p>
<p>&ensp;&ensp;<font color="#DC143C">注意：只有运行在request线程中的代码才能调用ActionContext.getContext&#40;&#41;，否则返回的是null。<br>在JSP中：一般不需要获得ActionContext本身。</font></p>
<h3 id="如何向ActionContext存入值"><a href="#如何向ActionContext存入值" class="headerlink" title="如何向ActionContext存入值"></a><center>如何向ActionContext存入值</center></h3><p>&ensp;&ensp;在拦截器、Action类、非Action类等Java类中：使用ActionContext.put&#40;Object key,Object value&#41;方法。</p>
<p>&ensp;&ensp;在JSP中：标签&lt;S:set value=”…”/&gt;默认将值存入ActionContext中&#40;当然，&lt;s:set&gt;标签还可以把值存到其他地方&#41;。</p>
<p>&ensp;&ensp;另外，许多标签都有var属性&#40;以前用的是id属性，现在id属性已被抛弃&#41;，这个属性能向ActionContext存入值，key为var属性的值，value为标签的value值。&#40;有些文档写的是向ValueStack的context存入值，其实是一样的&#41;</p>
<h3 id="如何向ActionContext读取值"><a href="#如何向ActionContext读取值" class="headerlink" title="如何向ActionContext读取值"></a><center>如何向ActionContext读取值</center></h3><p>&ensp;&ensp;在拦截器、Action类、非Action类等Java类中：使用ActionContext.get&#40;Object key&#41;方法。</p>
<p>&ensp;&ensp;在JSP中：使用#开头的Ognl表达式解析，则需要使用%&#123;&#125;把表达式括起来，于是就会出现类似“%&#123;#name&#125;”的表达式。</p>
<p>&ensp;&ensp;在JSP中：总之，在JSP中使用ActionContext一方面由于它是映射结构，另一方面是能读取Action的一些配置。当你需要为许多Action提供通用的值的话，可以让每个Action都提供getXXX&#40;&#41;方法，但更好的方法是在拦截器或JSP模板中把这些通用的值存放到ActionC中&#40;因为拦截器或JSP模板往往通用于多个Action&#41;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本类将演示拦截器中对ActionContext的操作   </span></span><br><span class="line">publicclass MyInterceptor extends AbstractInterceptor &#123;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception </span>&#123;   </span><br><span class="line">        <span class="comment">// 获得ActionContext   </span></span><br><span class="line">        ActionContext actionContext = invocation.getInvocationContext();   </span><br><span class="line">        <span class="comment">// 存入值   </span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();   </span><br><span class="line">        actionContext.put(<span class="string">"person"</span>, person);   </span><br><span class="line">        <span class="comment">// 获取值   </span></span><br><span class="line">        Object value = actionContext.get(<span class="string">"person"</span>);   </span><br><span class="line">        <span class="comment">// 获取HttpServletRequest   </span></span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) actionContext.get(StrutsStatics.HTTP_REQUEST);   </span><br><span class="line">        <span class="comment">// 获取request的Map，即HttpServletRequest.getAttribute(...)和HttpServletRequest.setAttribute(...)所操作的值  </span></span><br><span class="line">        Map requestMap = (Map) actionContext.get(<span class="string">"request"</span>);   </span><br><span class="line">        <span class="comment">// 其他代码   </span></span><br><span class="line">        <span class="comment">// ......   </span></span><br><span class="line">        <span class="keyword">return</span> invocation.invoke();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本类将演示在Action中对ActionContext进行操作   </span></span><br><span class="line">publicclass MyAction extends ActionSupport &#123;   </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;   </span><br><span class="line">        <span class="comment">// 获得值栈   </span></span><br><span class="line">        ActionContext actionContext = ActionContext.getContext();   </span><br><span class="line">        <span class="comment">// 存入值   </span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();<span class="comment">// 这是之前例子中定义的类  </span></span><br><span class="line">        actionContext.put(<span class="string">"person"</span>, person);   </span><br><span class="line">        <span class="comment">// 获取值   </span></span><br><span class="line">        Object object = actionContext.get(<span class="string">"person"</span>);   </span><br><span class="line">        <span class="comment">// 其他代码   </span></span><br><span class="line">        <span class="comment">// ......   </span></span><br><span class="line">        <span class="keyword">return</span> SUCCESS;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">metahttp-equiv="Content-Type"content="text</span>/<span class="attr">html</span>; <span class="attr">charset</span>=<span class="string">UTF-8</span>"&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 本JSP将演示在JSP中对ActionContext的使用 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 本JSP为MyAction对应的JSP --&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!-- 由于Action中已经向ActionContext存入了key为"person"的值，所以可以使用“#person”来获取它，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#person"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 获得person的name属性，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#person.name"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 获得Struts2在ActionContext中存入的值，比如request的Map，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#request"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 获得Struts2在ActionContext中存入的值，比如session的Map，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#session"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 获得Struts2在ActionContext中存入的值，request请求传递的GET参数或POST参数的Map，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#parameters"</span>/&gt;</span>  </span><br><span class="line">           </span><br><span class="line">        <span class="comment">&lt;!-- 以下演示在JSP中把值存入ActionContext中  --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 存入一个字符串"myName"，key为"myKey"，如下 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:setvalue="%&#123;‘myName‘&#125;"var="myKey"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 使用s:bean标签来创建一个对象，并把它存入ActionContext中，key为myObject，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:beanname="com.example.Person"var="myObject"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 之后就可以用“#”来读取它们，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#myKey"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#myObject"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Struts2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java内存区域]]></title>
      <url>/2017/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="http://ocx5m3vc3.bkt.clouddn.com/JVM_1.jpg" alt=""><br><a id="more"></a></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>&ensp;&ensp;程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。（此内存区域是唯一一个在JAVA虚拟机规范中没有规定任何OME情况的区域）</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>&ensp;&ensp;与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>&ensp;&ensp;本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java（也就是字节码）服务，而本地方法栈则为虚拟机使用的Native方法服务。在虚拟机规范中对本地方法栈中使用的语言、使用方式、与数据结构并没有强制规定，因此具体的虚拟机可以自由的实现它。甚至有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>&ensp;&ensp;对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>&ensp;&ensp;方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个一个别名叫做Non-Heap（非栈），目的应该是与Java堆分开来。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>&ensp;&ensp;运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，已不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用。</p>
<h2 id="虚拟机对象探索"><a href="#虚拟机对象探索" class="headerlink" title="虚拟机对象探索"></a>虚拟机对象探索</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>&ensp;&ensp;虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。<br>&ensp;&ensp;在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后完全可以确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>
<ul>
<li>指针碰撞</li>
<li>空闲列表</li>
</ul>
<p>&ensp;&ensp;内存分配完成后，虚拟机需要将分配到的内存空间都初始化零值。<br>&ensp;&ensp;接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。<br>&ensp;&ensp;在上面工作都完成后，从虚拟机的视角看，一个新的对象已经产生了，但从Java程序的视角来就看，对象创建才刚刚开始—<init>方法还没有执行所有字段都还为零。</init></p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>&ensp;&ensp;对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><ul>
<li>句柄访问</li>
<li>直接指针</li>
</ul>
]]></content>
      
        <categories>
            
            <category> JAVA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[static]]></title>
      <url>/2017/10/18/static/</url>
      <content type="html"><![CDATA[<h1 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用:"></a>static的作用:</h1><h2 id="不考虑类"><a href="#不考虑类" class="headerlink" title="不考虑类"></a>不考虑类</h2><h3 id="第一个作用：隐藏"><a href="#第一个作用：隐藏" class="headerlink" title="第一个作用：隐藏"></a>第一个作用：隐藏</h3><p>&ensp;&ensp;当我们同时编译多个文件时，所有未加static前缀的<strong>全局变量</strong>和<strong>函数</strong>都具有全局可见性。</p>
<p>&ensp;&ensp;如果加了static，就会对其他源文件隐藏，利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。</p>
<hr>
<ul>
<li>static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用<a id="more"></a>
</li>
</ul>
<hr>
<h3 id="第二个作用：默认初始化为0"><a href="#第二个作用：默认初始化为0" class="headerlink" title="第二个作用：默认初始化为0"></a>第二个作用：默认初始化为0</h3><p>&ensp;&ensp;包括未初始化的全局静态变量与局部静态变量。其实未初始化的全局变量也具备这一属性，因为未初始化的全局变量与未初始化的静态变量是存储在同一块区域内的（BBS段）。</p>
<p>&ensp;&ensp;在BBS段中，内存中所有的字节默认值都是0x00，某些时候这一特性可以减少程序员的工作量。</p>
<h3 id="第三个作用：保持局部变量内容的持久"><a href="#第三个作用：保持局部变量内容的持久" class="headerlink" title="第三个作用：保持局部变量内容的持久"></a>第三个作用：保持局部变量内容的持久</h3><p>&ensp;&ensp;函数内的自动（局部）变量，当调用时就存在，退出函数时就消失，当静态局部变量虽然在函数内定义，当静态局部变量始终存在着，也就是说它的生存周期为整个源程序，其特点就是只进行一次初始化且具有“记忆性”。</p>
<p>&ensp;&ensp;静态局部变量的生存期虽然为整个源程序，但是其作用域仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出函数后，尽管该变量还继续存在，但是不能使用它。</p>
<hr>
<h2 id="类中static的作用"><a href="#类中static的作用" class="headerlink" title="类中static的作用"></a>类中static的作用</h2><p>&ensp;&ensp;C++重用了static这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定的对象的变量和函数（和Java中此关键字的含义相同）</p>
<ul>
<li>静态数据成员</li>
<li>静态成员函数</li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[软件]]></title>
      <url>/2017/10/18/%E5%B0%8F%E8%BD%AF%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>各种杂七杂八的软件：</p>
<ul>
<li><a href="http://pan.baidu.com/s/1pLSfj9x" target="_blank" rel="noopener">Windows FX</a></li>
<li><a href="http://pan.baidu.com/s/1hrJVDU8" target="_blank" rel="noopener">Myeclipse</a></li>
<li><a href="http://pan.baidu.com/s/1hrDQbAW" target="_blank" rel="noopener">Kali系统</a></li>
<li><a href="http://pan.baidu.com/s/1dFni0Jv" target="_blank" rel="noopener">JDK压缩包</a></li>
<li><a href="http://pan.baidu.com/s/1i49KJlj" target="_blank" rel="noopener">zookeeper</a></li>
<li><a href="http://pan.baidu.com/s/1kVvJKKv" target="_blank" rel="noopener">tomcat</a></li>
<li></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软件 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[虚函数]]></title>
      <url>/2017/10/18/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>引入原因：为了方便使用多态特性，我们常常需要在基类中定于虚函数。</p>
<p>关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p>
<p><strong>虚函数表</strong><br><a id="more"></a><br>&emsp;&ensp;虚函数是通过一张虚函数表来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p>
<p>这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。<br>假设我们有这样的一个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">Base b;</span><br><span class="line">Fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表地址："</span> &lt;&lt; (<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表 — 第一个函数地址："</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的一点争议的个人看法：</span></span><br><span class="line">原文认为(<span class="keyword">int</span>*)(&amp;b)是虚表的地址，而很多网友都说，（包括我也认为）：(<span class="keyword">int</span> *)*(<span class="keyword">int</span>*)(&amp;b)才是虚表地址</span><br><span class="line">而(<span class="keyword">int</span>*)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)); 才是虚表第一个虚函数的地址。</span><br><span class="line">其实看后面的调用pFun = (Fun)*((int*)*(int*)(&amp;b)); 就可以看出，*((int*)*(int*)(&amp;b));转成函数指针给pFun，然后正确的调用到了虚函数virtual void f()。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke the first virtual function</span></span><br><span class="line">pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b));</span><br><span class="line">pFun();</span><br><span class="line">实际运行经果如下：(Windows XP+VS2003, Linux <span class="number">2.6</span><span class="number">.22</span> + GCC <span class="number">4.1</span><span class="number">.3</span>)</span><br><span class="line">虚函数表地址：<span class="number">0012F</span>ED4</span><br><span class="line">虚函数表 — 第一个函数地址：<span class="number">0044F</span>148</span><br><span class="line">Base::f</span><br><span class="line">通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成<span class="keyword">int</span> *，取得</span><br><span class="line">虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也</span><br><span class="line">就是Base::f()，这在上面的程序中得到了验证（把<span class="keyword">int</span>* 强制转成了函</span><br><span class="line">数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和</span><br><span class="line">Base::h()，其代码如下：</span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>); <span class="comment">// Base::f()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>); <span class="comment">// Base::g()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>); <span class="comment">// Base::h()</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>一般继承（无虚函数覆盖）</strong></p>
<p>下面，让我们来看看继承时的虚函数表示什么样的。假设有如下所以的一个继承关系：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_2.jpg" alt=""></p>
<p>请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：<br>对于实例：Derive d; 的虚函数表如下：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_3.jpg" alt=""></p>
<p>我们可以看到下面几点：</p>
<p>1.虚函数按照其声明顺序放于表中。</p>
<p>2.父类的虚函数在子类的虚函数前面。</p>
<p><strong>一般继承（有虚函数覆盖）</strong></p>
<p>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_4.jpg" alt=""></p>
<p>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_5.jpg" alt=""></p>
<p>我们从表中可以看到下面几点：</p>
<p>1.覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</p>
<p>2.没有被覆盖的函数依旧。</p>
<p><strong>多重继承（无虚函数覆盖）</strong></p>
<p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_6.jpg" alt=""></p>
<p>对于子类实例中的虚函数表，是下面这个样子：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_7.jpg" alt=""></p>
<p>我们可以看到：</p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<p><strong>多重继承（有虚函数覆盖）</strong></p>
<p>下面我们再来看看，如果发生虚函数覆盖的情况。</p>
<p>下图中，我们在子类中覆盖了父类的f()函数。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_8.jpg" alt=""></p>
<p>下面是对于子类实例中的虚函数表的图：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_9.jpg" alt=""></p>
<p>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。</p>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深复制和浅复制]]></title>
      <url>/2017/10/18/%E6%B7%B1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B5%85%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>浅复制：被复制对象的所有变量都含有与原来对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>深复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shallow_copy</span><span class="params">(Test &amp; src,Test &amp; dest)</span></span>&#123;</span><br><span class="line">	dest.ptr = src.ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deep_copy</span><span class="params">(Test &amp; src,Test &amp; dest)</span></span>&#123;</span><br><span class="line">	dest.ptr=<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src.ptr)+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(dest.ptr,src.ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浅复制可能会导致运行时错误，特别是在对象的创建和删除过程中。</p>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存泄露和缓冲区溢出]]></title>
      <url>/2017/10/18/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
      <content type="html"><![CDATA[<p>什么是内存泄露？</p>
<ul>
<li>一般我们常说的内存泄露是指堆内存的泄露。堆内存是指程序从堆中分配的，大小任意的内存块，使用完后必须显示释放的内存。应用程序一般使用malloc、realloc、new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能再被使用，我们就说这块内存泄露了。</li>
</ul>
<hr>
<p>什么是缓冲区溢出？</p>
<ul>
<li>缓冲区溢出是指向缓冲区内填充数据位数超过了缓冲区本身的容量限制，导致溢出的数据覆盖在合法数据上的情况。理想的情况是程序检查数据长度并不允许输出超出缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的存储空间相匹配，这九尾缓冲区溢出埋下了隐患。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC工作流程]]></title>
      <url>/2017/10/18/kuangjia/SpringMVC/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Spring_Running_1.png" alt=""></p>
<a id="more"></a>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Spring_Running_2.png" alt=""></p>
<hr>
<p>SpringMVC工作流程描述：<br>1.用户向服务器发送请求，请求被Spring前端控制Servlet DispatcherServlet捕获；</p>
<p>2.DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象相应的拦截器），最后以HandlerExecutionChain对象的形式返回。</p>
<p>3.DispatcherServlet根据获得Handler，选择一个合适HandlerAdapter。（如果成功获取HandlerAdapter后，此时将开始执行拦截器的PreHandler方法）</p>
<p>4.提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller）。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConveter：将请求消息（如Json、Xml等数据）转化成一个对象，将对象转换成指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>
<li>数据格式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证：验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ul>
<p>5.Handler执行完成后，先DispatcherServlet返回一个ModelAndView对象</p>
<p>6.根据返回的ModelAndView，选择一个合适的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet</p>
<p>7.ViewResolver结合Model和View来渲染视图</p>
<p>8.将渲染结果返回给客户端</p>
<hr>
<p>Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler？</p>
<p>答：符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的是代码可复用性高。如HandlerAdapter可能会被用于处理多种Handler。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP与UDP的区别]]></title>
      <url>/2017/10/17/tcp%E4%B8%8Eudp/</url>
      <content type="html"><![CDATA[<p>1.TCP是面向连接的，在传输数据前需要建立连接；UDP是无连接的，发送数据前不需要建立连接。<br>2.TCP提供<strong>可靠</strong>的传输服务；UDP提供<strong>不可靠</strong>的传输服务。<br>3.TCP发送数据大小会受发送窗口、接收窗口及MSS（最大报文段）限制，所以会多段发送；UDP发送数据大小即为数据本身大小。<br>4.TCP拥有众多反馈机制和附加机制；UDP没有反馈机制。<br>5.TCP传输速度慢；UDP传输速度快。</p>
<p>TCP适合文件下载等传输任务，UDP适合媒体流等看中传输速度的传输任务。</p>
]]></content>
      
        <categories>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java的四种线程池]]></title>
      <url>/2017/10/17/%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>Java通过Executors提供了四种线程池：</p>
<ul>
<li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(index * <span class="number">1000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程.</p>
<ul>
<li>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超过的线程会在队列中等待。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;  </span><br><span class="line">   fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">try</span> &#123;  </span><br><span class="line">      System.out.println(index);  </span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">      e.printStackTrace();  </span><br><span class="line">     &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   &#125;);  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以没两秒打印3个数字。</p>
<ul>
<li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);  </span><br><span class="line">  scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"delay 3 seconds"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;, <span class="number">3</span>, TimeUnit.SECONDS);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>表示延迟3秒执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);  </span><br><span class="line">  scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表示延迟1秒后每3秒执行一次。</p>
<ul>
<li>newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照指定顺序（FIFO，LIFO,优先级）执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;  </span><br><span class="line">   singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">try</span> &#123;  </span><br><span class="line">      System.out.println(index);  </span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">      e.printStackTrace();  </span><br><span class="line">     &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   &#125;);  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>顺序执行每个任务。</p>
]]></content>
      
        <categories>
            
            <category> JAVA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1269 B君的圆锥]]></title>
      <url>/2016/05/27/ACM/51nod1269%20B%E5%90%9B%E7%9A%84%E5%9C%86%E9%94%A5/</url>
      <content type="html"><![CDATA[<p>1629 B君的圆锥<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题<br> 收藏<br> 关注<br>B君要用一个表面积为S的圆锥将白山云包起来。</p>
<p>B君希望包住的白山云体积尽量大，B君想知道体积最大可以是多少。</p>
<p>注意圆锥的表面积包括底面和侧面。<br>Input<br>一行一个整数，表示表面积S。(1 &lt;= S &lt;= 10^9)<br>Output<br>一行一个实数，表示体积。<br>Input示例<br>8<br>Output示例<br>1.504506<br>wwwwodddd (题目提供者)<br>拿到这道题的第一想法就是写出面积体积关系，然后再找关系。<br>大神们说这道题的标准做法是用三分法~可以作为渣渣的我并不会—-以后学了再来补上。<br>不过群巨给了另一种数学建模的思想：<br>  　　 要达成面积/体积最佳比，则模型样式是一致的。可以按比例缩放的。以放大2倍为例：<br>　　   R=r<em>2<br>　　　S=S底+S侧=2^2</em>s底+2^2<em>s底=2^2s<br>　　　V=1/3</em>S底<em>H=1/3</em>2^2s底<em>2</em>h=2^3v<br>~简直奇妙~~又让渣渣我学到一招~<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(n*n*n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s))&#123;</span><br><span class="line">        <span class="keyword">double</span> v;</span><br><span class="line">        v = (<span class="keyword">double</span>)<span class="number">1.504506</span>*<span class="built_in">pow</span>(s/<span class="number">8.0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod 1021 石头归并]]></title>
      <url>/2016/05/16/ACM/51nod%201021%20%E7%9F%B3%E5%A4%B4%E5%BD%92%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p>1021 石子归并<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 20 难度：3级算法题<br> 收藏<br> 关注<br>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。</p>
<p>例如： 1 2 3 4，有不少合并方法<br>1 2 3 4 =&gt; 3 3 4(3) =&gt; 6 4(9) =&gt; 10(19)<br>1 2 3 4 =&gt; 1 5 4(5) =&gt; 1 9(14) =&gt; 10(24)<br>1 2 3 4 =&gt; 1 2 7(7) =&gt; 3 7(10) =&gt; 10(20)</p>
<p>括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。</p>
<p>Input<br>第1行：N（2 &lt;= N &lt;= 100)<br>第2 - N + 1：N堆石子的数量（1 &lt;= A[i] &lt;= 10000)<br>Output<br>输出最小合并代价<br>Input示例<br>4<br>1<br>2<br>3<br>4<br>Output示例<br>19<br>这道题初一看很容易往贪心方向想，后来看了提示才知道是dp，可是并不知道怎么dp。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">int</span> i,len,temp;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;vis[i]);</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(len=<span class="number">1</span>;len&lt;n;len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i+len&lt;=n;i++)&#123;</span><br><span class="line">                dp[i][i + len] = INF;</span><br><span class="line">                temp=sum[i+len]-sum[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;i+len;k++)</span><br><span class="line">                    dp[i][i+len]=min(dp[i][i+len],dp[i][k]+dp[k+<span class="number">1</span>][i+len]+temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1417 天堂里的游戏]]></title>
      <url>/2016/05/09/ACM/51nod1417%20%E5%A4%A9%E5%A0%82%E9%87%8C%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<p>1417 天堂里的游戏<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题<br> 收藏<br> 关注<br>多年后，每当Noder看到吉普赛人，就会想起那个遥远的下午。</p>
<p>Noder躺在草地上漫无目的的张望，二楼的咖啡馆在日光下闪着亮，像是要进化成一颗巨大的咖啡豆。天气稍有些冷，但草还算暖和。不远的地方坐着一个吉普赛姑娘，手里拿着塔罗牌，带着耳机，边上是她的狗。狗看起来有点凶，姑娘却漂亮。Noder开始计算各种搭讪方式的成功概率，然而狗的存在……。</p>
<p>奇怪的事情发生了，姑娘自己走了过来，把耳机戴在Noder的耳朵上，里面播放着：“……Knock-knock-knockin’ on heaven’s door ……”。姑娘冲他诡异的一笑，Noder只觉得自己眼前一阵眩晕，然后就站在了天堂的门口。</p>
<p>正当Noder惊魂未定的时候，走来一个美女，要求和他一起玩个数学游戏。美女提议：“让我们各自亮出硬币的一面，或正或反。如果我们都是正面，那么我给你A元，如果我们都是反面，我给你B元（A + B为偶数）。剩下的情况你给我（A + B） / 2元就可以了。</p>
<p>Noder知道这个游戏他多半要输，可他并不在乎，他只想让自己输的慢一点。</p>
<p>那么你来帮美女计算一下，她选择出正面的概率应该是多少（以最简分数形式输出）？</p>
<p>当Noder输光了钱后从草地上醒来，吉普赛姑娘已经不见了，只留下了这样一张塔罗牌，上面印有那个美女的照片。<br><img src="http://img.51nod.com/upload/000FBECA/08D271A9F742E9BE0000000000000008.jpeg?_=5474275" alt=""></p>
<p>关于样例的解释：</p>
<p>美女采取了(3/8,5/8)这个方案，不论Noder采用什么方案，都是不能改变局面的。如果全部出正面，每次的期望收益是 (3+3+3-2-2-2-2-2)/8=-1/8元；如果全部出反面，每次的期望收益也是(-2-2-2+1+1+1+1+1)/8=-1/8元。而任何策略无非只是上面两种策略的线性组合，所以期望还是-1/8元。</p>
<p>Input<br>第1行：一个数T，表示后面用作输入测试的数的数量（1 &lt;= T &lt;= 20)。<br>第2 - T + 1行：每行2个数A, B中间用空格分隔。(1 &lt;= A, B &lt;= 10^9，且A + B为偶数)。<br>Output<br>输出共T行，对应美女选择正面的概率，以最简分数形式输出，具体请参看输出样例。<br>Input示例<br>2<br>3 1<br>1 3<br>Output示例<br>3/8<br>5/8<br>PS: 给的提示标签是博弈论，结果是个数学问题；<br> 不管是正是反，女的赢的几率都是一样的，所以左边的式子设正面为x，右边的式子设反面为x，写出期望，然后两边相等，就可以列方程了，然后最大公约数用辗转相乘法弄一下就出来了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span> ? a : gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t))&#123;</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            LL a,b;</span><br><span class="line">            LL x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;a,&amp;b);</span><br><span class="line">            x=a+<span class="number">3</span>*b;</span><br><span class="line">            y=<span class="number">4</span>*(a+b);</span><br><span class="line">            LL t=gcd(x,y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%I64d/%I64d\n"</span>,x/t,y/t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1265四点共面]]></title>
      <url>/2016/04/11/ACM/51nod1265%E5%9B%9B%E7%82%B9%E5%85%B1%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>1265 四点共面<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题<br>给出三维空间上的四个点（点与点的位置均不相同），判断这4个点是否在同一个平面内（4点共线也算共面）。如果共面，输出”Yes”，否则输出”No”。<br>Input<br>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)<br>第2 - 4T + 1行：每行4行表示一组数据，每行3个数，x, y, z, 表示该点的位置坐标(-1000 &lt;= x, y, z &lt;= 1000)。<br>Output<br>输出共T行，如果共面输出”Yes”，否则输出”No”。<br>Input示例<br>1<br>1 2 0<br>2 3 0<br>4 0 0<br>0 0 0<br>Output示例<br>Yes<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*利用四点组成构成的三个向量的混合积为0来判断是否共面*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    point a,b,c,d;</span><br><span class="line">    <span class="keyword">double</span> r1,r2,r3,r4,r5,r6,r7,r8,r9;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;a.x,&amp;a.y,&amp;a.z);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;b.x,&amp;b.y,&amp;b.z);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;c.x,&amp;c.y,&amp;c.z);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;d.x,&amp;d.y,&amp;d.z);</span><br><span class="line">        r1=a.x-b.x; r2=a.y-b.y; r3=a.z-b.z;</span><br><span class="line">        r4=a.x-c.x; r5=a.y-c.y; r6=a.z-c.z;</span><br><span class="line">        r7=a.x-d.x; r8=a.y-d.y; r9=a.z-d.z;</span><br><span class="line">        <span class="keyword">double</span> n=r1*r5*r9+r2*r6*r7+r3*r4*r8-r3*r5*r7-r2*r4*r9-r1*r6*r8;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1240莫比乌斯函数]]></title>
      <url>/2016/04/10/ACM/51nod1240%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>莫比乌斯函数，由德国数学家和天文学家莫比乌斯提出。梅滕斯(Mertens)首先使用μ(n)（miu(n)）作为莫比乌斯函数的记号。（据说，高斯(Gauss)比莫比乌斯早三十年就曾考虑过这个函数）。</p>
<p>具体定义如下：<br>如果一个数包含平方因子，那么miu(n) = 0。例如：miu(4), miu(12), miu(18) = 0。<br>如果一个数不包含平方因子，并且有k个不同的质因子，那么miu(n) = (-1)^k。例如：miu(2), miu(3), miu(30) = -1,miu(1), miu(6), miu(10) = 1。<br>给出一个数n, 计算miu(n)。<br>Input<br>输入包括一个数n，(2 &lt;= n &lt;= 10^9)<br>Output<br>输出miu(n)。<br>Input示例<br>5<br>Output示例<br>-1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">miu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,cnt;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                n=n/i;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (num%<span class="number">2</span>==<span class="number">0</span>)?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,miu(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1212无向图最小生成树]]></title>
      <url>/2016/04/10/ACM/51nod1212%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>1212 无向图最小生成树<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题<br> 收藏<br> 关注<br>N个点M条边的无向连通图，每条边有一个权值，求该图的最小生成树。</p>
<p>Input<br>第1行：2个数N,M中间用空格分隔，N为点的数量，M为边的数量。（2 &lt;= N &lt;= 1000, 1 &lt;= M &lt;= 50000)<br>第2 - M + 1行：每行3个数S E W，分别表示M条边的2个顶点及权值。(1 &lt;= S, E &lt;= N，1 &lt;= W &lt;= 10000)<br>Output<br>输出最小生成树的所有边的权值之和。<br>Input示例<br>9 14<br>1 2 4<br>2 3 8<br>3 4 7<br>4 5 9<br>5 6 10<br>6 7 2<br>7 8 1<br>8 9 7<br>2 8 11<br>3 9 2<br>7 9 6<br>3 6 4<br>4 6 14<br>1 8 8<br>Output示例<br>37<br>prim算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> G[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1001</span>],lowc[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> G[][<span class="number">1001</span>],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,minc,res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));<span class="comment">//全部初值为0表示没有访问过；</span></span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        lowc[i]=G[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        minc=inf;</span><br><span class="line">        p=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;lowc[j]&lt;minc)</span><br><span class="line">                &#123;minc=lowc[j];p=j;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inf==minc) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//原图不连通</span></span><br><span class="line">        res+=minc;</span><br><span class="line">        vis[p]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//更新lowc[]</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;lowc[j]&gt;G[p][j])</span><br><span class="line">                lowc[j]=G[p][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(G,inf,<span class="keyword">sizeof</span>(G));</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">            G[x][y]=G[y][x]=w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,prim(G,n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> kruskal算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _min_(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_E 50005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">edge es[MAX_E];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> W[MAX_N][MAX_N];</span><br><span class="line"><span class="keyword">int</span> mincost[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> used[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge e1, edge e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union-find set</span></span><br><span class="line"><span class="keyword">int</span> par[MAX_N];</span><br><span class="line"><span class="keyword">int</span> rank[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_inion_find</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        par[i]=i;</span><br><span class="line">        rank[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x]==x)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> par[x]=find(par[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     x=find(x);</span><br><span class="line">     y=find(y);</span><br><span class="line">     <span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(rank[x]&lt;rank[y])&#123;</span><br><span class="line">         par[x]=y;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          par[y]=x;</span><br><span class="line">          <span class="keyword">if</span>(rank[x]==rank[y])&#123;</span><br><span class="line">              rank[x]++;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> find(x)==find(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// end of union-find set</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;MAX_N;j++)&#123;</span><br><span class="line">            W[i][j]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">        mincost[i]=INF;</span><br><span class="line">        used[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        edge e=es[i];</span><br><span class="line">        <span class="keyword">if</span>(!same(e.u, e.v))&#123;</span><br><span class="line">            unite(e.u, e.v);</span><br><span class="line">            res += e.cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("18_kruskal.txt","r",stdin);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,cost;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;cost);</span><br><span class="line">        es[i].u = u<span class="number">-1</span>;</span><br><span class="line">        es[i].v = v<span class="number">-1</span>;</span><br><span class="line">        es[i].cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(es,es+M,cmp);</span><br><span class="line"></span><br><span class="line">    init_inion_find(N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1256乘法逆元]]></title>
      <url>/2016/04/10/ACM/51nod1256%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
      <content type="html"><![CDATA[<p>1256 乘法逆元</p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 收藏 关注<br>给出2个数M和N(M &lt; N)，且M与N互质，找出一个数K满足0 &lt; K &lt; N且K <em> M % N = 1，如果有多个满足条件的，输出最小的。<br>Input<br>输入2个数M, N中间用空格分隔（1 &lt;= M &lt; N &lt;= 10^9)<br>OutPut<br>输出一个数K，满足0 &lt; K &lt; N且K </em> M % N = 1，如果有多个满足条件的，输出最小的。<br>Input示例<br>2 3<br>Output示例</p>
<p>2</p>
<p>思路：K <em> M % N = 1等价于 K</em>M=N<em>X+1  即 K</em>M+N*(-X)=1 </p>
<p>根据扩展欧几里德算法，求出K和（-X）；</p>
<p>而K是应为正整数，即需要若K为负整数，则需要将之化正，即与负数取模同理，将K加上N，直至K&gt;0为止，所得的数即为最小的乘法逆元；</p>
<p>若K为正整数，则直接输出即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> t=x;x=y;y=t-(a/b)*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,x,y;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n))&#123;</span><br><span class="line">        exgcd(m,n,x,y);</span><br><span class="line">        <span class="keyword">while</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            x+=n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1264线段相交]]></title>
      <url>/2016/04/10/ACM/51nod1264%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4/</url>
      <content type="html"><![CDATA[<p>1264 线段相交<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题<br>给出平面上两条线段的两个端点，判断这两条线段是否相交（有一个公共点或有部分重合认为相交）。 如果相交，输出”Yes”，否则输出”No”。<br>Input<br>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)<br>第2 - T + 1行：每行8个数，x1,y1,x2,y2,x3,y3,x4,y4。(-10^8 &lt;= xi, yi &lt;= 10^8)<br>(直线1的两个端点为x1,y1 | x2, y2,直线2的两个端点为x3,y3 | x4, y4)<br>Output<br>输出共T行，如果相交输出”Yes”，否则输出”No”。<br>Input示例<br>2<br>1 2 2 1 0 0 2 2<br>-1 1 1 1 0 0 1 -1<br>Output示例<br>Yes<br>No<br>做这到题首先要了解叉乘的概念~~<a href="http://blog.csdn.net/hustspy1990/article/details/11082745" target="_blank" rel="noopener">http://blog.csdn.net/hustspy1990/article/details/11082745</a><br>然后还要知道两条线段相交的必要条件 <a href="http://dev.gameres.com/Program/Abstract/Geometry.htm#%E5%88%A4%E6%96%AD%E4%B8%A4%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4" target="_blank" rel="noopener">http://dev.gameres.com/Program/Abstract/Geometry.htm#%E5%88%A4%E6%96%AD%E4%B8%A4%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  (a-c)×(d-c)*(d-c)×(b-c)&gt;=0&amp;&amp;(c-a)×(b-a)*(b-a)×(d-a)&gt;= 0就可以判断ab,cd相交*/</span></span><br><span class="line"><span class="comment">/*  p1×p2 = x1y2 - x2y1 = - p2×p1-----（叉乘公式）*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//struct point a,b,c,d;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mp</span><span class="params">(point a,point b,point c,point d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> C=(a.x-c.x)*(d.y-c.y)-(d.x-c.x)*(a.y-c.y);</span><br><span class="line">    <span class="keyword">double</span> D=(d.x-c.x)*(b.y-c.y)-(b.x-c.x)*(d.y-c.y);</span><br><span class="line">    <span class="keyword">if</span>(C*D&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(point a , point b , point c , point d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mp(a,b,c,d)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!mp(c,d,a,b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        point a,b,c,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf%lf%lf%lf%lf"</span>,&amp;a.x,&amp;a.y,&amp;b.x,&amp;b.y,&amp;c.x,&amp;c.y,&amp;d.x,&amp;d.y);</span><br><span class="line">        <span class="keyword">if</span>(check(a,b,c,d))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1242 斐波那契数列 矩阵快速幂]]></title>
      <url>/2016/04/08/ACM/51nod1242%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%20%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      <content type="html"><![CDATA[<p>斐波那契数列的定义如下：</p>
<p>F(0) = 0<br>F(1) = 1<br>F(n) = F(n - 1) + F(n - 2) (n &gt;= 2)</p>
<p>(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, …)<br>给出n，求F(n)，由于结果很大，输出F(n) % 1000000009的结果即可。</p>
<p>Input<br>输入1个数n(1 &lt;= n &lt;= 10^18)。<br>Output<br>输出F(n) % 1000000009的结果。<br>Input示例<br>11<br>Output示例<br>89</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000009</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125; t;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function">node <span class="title">mul</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//矩阵乘法</span></span><br><span class="line">    node c;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">            c.c[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">                c.c[i][j]+=(a.c[i][k]*b.c[k][j])%mod;</span><br><span class="line">        c.c[i][j]=c.c[i][j]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">kuaisumi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   node res = t;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            res=mul(res,t);</span><br><span class="line">        t=mul(t,t);</span><br><span class="line">        n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n))&#123;</span><br><span class="line">        t.c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        t.c[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        t.c[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        t.c[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        node res=kuaisumi(n<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res.c[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1174区间中最大的数]]></title>
      <url>/2016/04/05/ACM/51nod1174%E5%8C%BA%E9%97%B4%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>1174 区间中最大的数<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 收藏 关注<br>给出一个有N个数的序列，编号0 - N - 1。进行Q次查询，查询编号i至j的所有数中，最大的数是多少。<br>例如: 1 7 6 3 1。i = 1, j = 3，对应的数为7 6 3，最大的数为7。（该问题也被称为RMQ问题）<br>Input<br>第1行：1个数N，表示序列的长度。(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：每行1个数，对应序列中的元素。(0 &lt;= S[i] &lt;= 10^9)<br>第N + 2行：1个数Q，表示查询的数量。(2 &lt;= Q &lt;= 10000)<br>第N + 3 - N + Q + 2行：每行2个数，对应查询的起始编号i和结束编号j。(0 &lt;= i &lt;= j &lt;= N - 1)<br>Output<br>共Q行，对应每一个查询区间的最大值。<br>Input示例<br>5<br>1<br>7<br>6<br>3<br>1<br>3<br>0 1<br>1 3<br>3 4<br>Output示例<br>7<br>7<br>3</p>
<p>自己写的O（n）的也能水过，特地去看了一下RMQ算法~</p>
<p>然后就变成O（logn)了</p>
<p>参考博客<a href="http://blog.csdn.net/liang5630/article/details/7917702" target="_blank" rel="noopener">http://blog.csdn.net/liang5630/article/details/7917702</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10010</span>][<span class="number">30</span>],num[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>]=num[i];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)&lt;n;i++)</span><br><span class="line">        dp[i][j]=max(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>))&lt;=R-L+<span class="number">1</span>) ++k;</span><br><span class="line">    <span class="keyword">return</span> max(dp[L][k],dp[R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">        RMQ_init(n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> L,R;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;L,&amp;R);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,RMQ(L+<span class="number">1</span>,R+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1079中国剩余定理]]></title>
      <url>/2016/03/31/ACM/51nod1089%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2V2/</url>
      <content type="html"><![CDATA[<p>1089 最长回文子串 V2（Manacher算法）<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题<br>回文串是指aba、abba、cccbccc、aaaa这种左右对称的字符串。<br>输入一个字符串Str，输出Str里最长回文子串的长度。</p>
<p>Input<br>输入Str（Str的长度 &lt;= 100000)<br>Output<br>输出最长回文子串的长度L。<br>Input示例<br>daabaac<br>Output示例<br>5</p>
<p>看到这道题才特意去看了下Manacher算法；<br>参考博客：<a href="http://blog.csdn.net/pi9nc/article/details/9251455" target="_blank" rel="noopener">http://blog.csdn.net/pi9nc/article/details/9251455</a><br>　　　　　<a href="http://blog.sina.com.cn/s/blog_70811e1a01014esn.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_70811e1a01014esn.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">200003</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200003</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pk</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;i)</span><br><span class="line">            p[i]=min(p[<span class="number">2</span>*id-i],mx-i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i+p[i]+<span class="number">1</span>]==str[i-p[i]<span class="number">-1</span>])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(p[i]+i&gt;mx)&#123;</span><br><span class="line">            id=i;</span><br><span class="line">            mx=p[i]+id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len,ans=<span class="number">0</span>,i,l=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    str[<span class="number">0</span>]=<span class="string">'$'</span>;</span><br><span class="line">    str[<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        str[l++]=s[i];</span><br><span class="line">        str[l++]=<span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//str[len]='\n';</span></span><br><span class="line">    pk(l);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">        ans=max(ans,p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1134 最长递增子序列]]></title>
      <url>/2016/03/31/ACM/51nod1134%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的）<br>例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。</p>
<p>Input<br>第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9)<br>Output<br>输出最长递增子序列的长度。<br>Input示例<br>8<br>5<br>1<br>6<br>8<br>2<br>4<br>5<br>10<br>Output示例<br>5<br>刚开始我想到的也是动态规划，然后自己写。提交发现超时了=.=<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("C://Users//Administrator//Desktop//duipai2//1.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,i,j,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">50005</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> str[<span class="number">50005</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">50005</span>;i++)</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">   <span class="comment">// memset(dp,1,sizeof(dp));</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;str[i]);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j]&lt;str[i]&amp;&amp;dp[j]&gt;=dp[i])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// for(i=1;i&lt;=n;i++)</span></span><br><span class="line">   <span class="comment">//     printf("%d  ",dp[i]);</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         ans=max(ans,dp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后参考了网上大神的代码也是动态规划=.=但是优化了，所以AC了~~<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"algorithm"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];<span class="comment">//dp[i]表示递增数量i的最小值</span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,len=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    dp[len]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;dp[len])</span><br><span class="line">          dp[++len]=a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos=lower_bound(dp+<span class="number">1</span>,dp+len,a[i])-dp;</span><br><span class="line">            <span class="comment">//在dp[]找第一个&gt;=a[i]下标</span></span><br><span class="line">            dp[pos]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//   for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">      <span class="comment">//printf("%d  ",dp[i]);</span></span><br><span class="line">    <span class="comment">//printf("\n");</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1057N的阶乘]]></title>
      <url>/2016/03/28/ACM/51nod1057N%E7%9A%84%E9%98%B6%E4%B9%98/</url>
      <content type="html"><![CDATA[<p>输入N求N的阶乘的准确值。</p>
<p>Input<br>输入N(1 &lt;= N &lt;= 10000)<br>Output<br>输出N的阶乘<br>Input示例<br>5<br>Output示例<br>120<br>参考博客：blog.csdn.net/qq_33850438/article/details/50631619<br>大数乘法问题~<br>大神代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">9999</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,n,i,c,len,j;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);  </span><br><span class="line">    <span class="keyword">for</span> ( len=<span class="number">1</span>,j=<span class="number">2</span>;j&lt;=n; ++j)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span> (c=<span class="number">0</span>,i=<span class="number">0</span>; i&lt;len;++i)   </span><br><span class="line">        &#123;   </span><br><span class="line">            a[i]= ( c+= a[i]*j ) % <span class="number">100000</span>; c/=<span class="number">100000</span>;   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>((a[i]=c)&gt;<span class="number">0</span>)++len;  </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[--len]);  </span><br><span class="line">    <span class="keyword">for</span>(;len;)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>, a[--len]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1085-----01背包]]></title>
      <url>/2016/03/27/ACM/51nod1085-----01%E8%83%8C%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>],p[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,W,i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;W);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;w[i],&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=W;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;w[i])</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][W]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 背包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1046快速幂取余]]></title>
      <url>/2016/03/26/ACM/51nod1046%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E4%BD%99/</url>
      <content type="html"><![CDATA[<p>给出3个正整数A B C，求A^B Mod C。</p>
<p>例如，3 5 8，3^5 Mod 8 = 3。<br>Input<br>3个正整数A B C，中间用空格分隔。(1 &lt;= A,B,C &lt;= 10^9)<br>Output<br>输出计算结果<br>Input示例<br>3 5 8<br>Output示例<br>3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">quickmod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans=(ans*a)%m;<span class="comment">//这里a是a^(2^i)%m</span></span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">        a=a*a%m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,m;</span><br><span class="line">    <span class="keyword">while</span>(scanf(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;m)!=EOF)&#123;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span>   ans=quickmod(a,b,m);</span><br><span class="line">        printf(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----任务分配问题]]></title>
      <url>/2016/03/21/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>任务执行顺序</p>
<p>有N个任务需要执行，第i个任务计算时占R[i]个空间，而后会释放一部分，最后储存计算结果需要占据O[i]个空间（O[i] &lt; R[i]）。</p>
<p>分析：可以抽象成，从一个整数开始，每次减去a，再加上b (a,b都是正数)，要求每次操作都不产生负数。令a[i] = R[i], b[i] = R[i] – O[i]，O[i] &lt; R[i],有0&lt;b[i]&lt;a[i]。 所以尽管每次有减有加，但是加的没有减的多，总数在不断减小。所以——按照b[i]递增的顺序排序，是最“有利”的。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> r,o;</span><br><span class="line">&#125;p[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(point x,point y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.o&gt;y.o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//p1099t11in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> i,N,sum,ans;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N))&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].r,&amp;p[i].o);</span><br><span class="line">            p[i].o=p[i].r-p[i].o;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(p,p+N,cmp);</span><br><span class="line">        sum=p[<span class="number">0</span>].r;</span><br><span class="line">        ans=p[<span class="number">0</span>].r;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans&lt;p[i].r)&#123;</span><br><span class="line">                sum=sum+p[i].r-ans;</span><br><span class="line">                ans=p[i].r;</span><br><span class="line">            &#125;</span><br><span class="line">                ans=ans-p[i].r+p[i].o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod动态规划-----矩阵取数]]></title>
      <url>/2016/03/21/ACM/51nod%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>一个N<em>N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。<br>例如：3 </em> 3的方格。</p>
<p>1 3 3</p>
<p>2 1 3</p>
<p>2 2 1</p>
<p>能够获得的最大价值为：11。</p>
<a id="more"></a>
<p>Input</p>
<p>第1行：N，N为矩阵的大小。(2 &lt;= N &lt;= 500)</p>
<p>第2 - N + 1行：每行N个数，中间用空格隔开，对应格子中奖励的价值。（1 &lt;= N[i] &lt;= 10000)</p>
<p>OutPut</p>
<p>输出能够获得的最大价值。</p>
<p>Input示例</p>
<p>3</p>
<p>1 3 3</p>
<p>2 1 3</p>
<p>2 2 1</p>
<p>Output示例</p>
<p>11</p>
<p>状态转移方程：f(i,j) = max{f(i+1,j),f(i,j+1)|i&lt;N,j&lt;N}+A[i][j];</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//1.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> N,i,j;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N))&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">505</span>][<span class="number">505</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//不知道为什么这个不能跟前面的map一起定义。。。</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">                dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="built_in">map</span>[i][j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[N<span class="number">-1</span>][N<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----独木舟问题]]></title>
      <url>/2016/03/20/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E7%8B%AC%E6%9C%A8%E8%88%9F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>独木舟问题</p>
<p>n个人，已知每个人体重，独木舟承重固定，每只独木舟最多坐两个人，可以坐一个人或者两个人。显然要求总重量不超过独木舟承重，假设每个人体重也不超过独木舟承重，问最少需要几只独木舟？</p>
<p>分析：按照人的体重排序，最轻的人跟最重的人尽量安排在一条船上，如果超过就安排最重的.<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        j=n<span class="number">-1</span>;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]+a[j]&lt;=m)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==j)</span><br><span class="line">            ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1079中国剩余定理]]></title>
      <url>/2016/03/20/ACM/51nod1079/</url>
      <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *中国剩余定理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LL __int64</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *gcd(a,b)=d;则存在x,y,使d=ax+by</span></span><br><span class="line"><span class="comment"> *extended_euclid(a,b)=ax+by</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LL <span class="title">extended_euclid</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span></span>&#123;<span class="comment">//扩张欧几里的算法</span></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>; y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    d=extended_euclid(b,a%b,y,x);</span><br><span class="line">    y=y-a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *x=b[i](modw[i]) o&lt;i&lt;len</span></span><br><span class="line"><span class="comment"> *w[i]&gt;0,且w[]中任意两个数互质</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LL <span class="title">chinese_remainder</span><span class="params">(<span class="keyword">int</span> b[],<span class="keyword">int</span> w[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    LL res,i,d,x,y,n,m;</span><br><span class="line">    res=<span class="number">0</span>; n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++) n*=w[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        m=n/w[i];</span><br><span class="line">        extended_euclid(w[i],m,x,y);</span><br><span class="line">        res=(res+y*m*b[i])%n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n+res%n)%n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len,b[<span class="number">12</span>],w[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;len)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;chinese_remainder(b,w,len)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----活动安排问题2]]></title>
      <url>/2016/03/17/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%982/</url>
      <content type="html"><![CDATA[<p>题目大意就是给几个活动，问要几个教室能够弄完。</p>
<p>这个题目的想法就是把活动的开始——结束的时间看做是数轴上的一段线段，教室的个数就是在某点的时间厚度，求最大的时间厚度就是所需要的教室个数。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> start;</span><br><span class="line">   <span class="keyword">int</span> end;</span><br><span class="line">&#125;s[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span><span class="comment">//结构体的一级排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(node*)a).start&gt;(*(node*)b).start?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//data.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,i,rooms=<span class="number">0</span>;</span><br><span class="line">     priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; myqueue;<span class="comment">//优先队列类型</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s[i].start,&amp;s[i].end);</span><br><span class="line">    qsort(s,n,<span class="keyword">sizeof</span>(node),cmp);</span><br><span class="line">    myqueue.push(s[<span class="number">0</span>].end);</span><br><span class="line">    rooms=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i].start&lt;myqueue.top())&#123;</span><br><span class="line">            rooms++;</span><br><span class="line">            myqueue.push(s[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            myqueue.pop();</span><br><span class="line">            myqueue.push(s[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rooms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----活动安排问题]]></title>
      <url>/2016/03/05/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>有若干个活动，第i个开始时间和结束时间是[Si,fi)，只有一个教室，活动之间不能交叠，求最多安排多少个活动？</p>
<p>输入</p>
<p>第1行：1个数N，线段的数量(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：每行2个数，线段的起点和终点(-10^9 &lt;= S,E &lt;= 10^9)<br>输出</p>
<a id="more"></a>
<p>输出最多可以选择的线段数量。</p>
<p>输入示例</p>
<p>3<br>1 5<br>2 3<br>3 6</p>
<p>输出示例</p>
<p>2</p>
<p>我们可以知道先安排最早结束的活动可以更多的安排活动。首先就是将所有的活动结束时间按先后顺序给排序；然后以结束时间为线索一路检索下去，判断开始时间是否早于前面一次活动的结束时间。这里可以用结构体或者两个数组来把一个活动的开始时间和结束时间联系起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define max 10001</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,j,temps,tempo;</span><br><span class="line">    <span class="keyword">int</span> start[max],over[max];</span><br><span class="line">    <span class="keyword">while</span>(scanf(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>,t=-<span class="number">1000000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;start[i]&gt;&gt;over[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">       <span class="keyword">for</span>(j=i;j&lt;n;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(over[i]&gt;over[j])&#123;</span><br><span class="line">              tempo=over[i];</span><br><span class="line">              over[i]=over[j];</span><br><span class="line">              over[j]=tempo;</span><br><span class="line">              temps=start[i];</span><br><span class="line">              start[i]=start[j];</span><br><span class="line">              start[j]=temps;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;=start[i])&#123;</span><br><span class="line">            t=over[i];</span><br><span class="line">            sum+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//原本我还考虑了活动时间不能为负数的情况，但是在提交时系统给出的数据中把负数也给算了进去。。。。。</p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----完美字符串]]></title>
      <url>/2016/03/04/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E5%AE%8C%E7%BE%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>约翰认为字符串的完美度等于它里面所有字母的完美度之和。每个字母的完美度可以由你来分配，不同字母的完美度不同，分别对应一个1-26之间的整数。</p>
<p>约翰不在乎字母大小写。（也就是说字母F和f）的完美度相同。给定一个字符串，输出它的最大可能的完美度。例如：dad，你可以将26分配给d，25分配给a，这样整个字符串完美度为77。</p>
<p>//这题水题，只要把每个字母出现的次数统计出来然后再排序一下就OK了。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)&#123;</span><br><span class="line">	<span class="keyword">int</span> sum[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;,len,i,j,a,maxsum=<span class="number">0</span>;</span><br><span class="line">	len=s.size();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">	    a=s[i]-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">	    a&lt;=<span class="number">26</span>?sum[a]++:sum[a<span class="number">-32</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(sum,sum+<span class="number">27</span>);</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">26</span>;j++)&#123;</span><br><span class="line">	    maxsum+=j*sum[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxsum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cd命令]]></title>
      <url>/1900/01/01/Linux/cd/</url>
      <content type="html"><![CDATA[<p>&ensp;&ensp;cd命令可以说是Linux中最基本的命令语句，其他命令要进行操作，都是建立在使用cd命令上的。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>cd [目录名]</p>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>&ensp;&ensp;切换当前目录到dirName<br><a id="more"></a></p>
<h3 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h3><hr>
<h4 id="例1：进入系统根目录"><a href="#例1：进入系统根目录" class="headerlink" title="例1：进入系统根目录"></a>例1：进入系统根目录</h4><p>cd /</p>
<hr>
<h4 id="例2：使用-cd-命令进入当前用户主目录"><a href="#例2：使用-cd-命令进入当前用户主目录" class="headerlink" title="例2：使用 cd 命令进入当前用户主目录"></a>例2：使用 cd 命令进入当前用户主目录</h4><p>&ensp;&ensp;“当前用户主目录”和“系统根目录”是两个不同的概念。进入当前用户主目录有两个方法。<br>1.cd<br>2.cd ~</p>
<hr>
<h4 id="例3：跳转到指定目录"><a href="#例3：跳转到指定目录" class="headerlink" title="例3：跳转到指定目录"></a>例3：跳转到指定目录</h4><p>cd /opt/soft<br>&ensp;&ensp;跳转到指定目录，从根目录开始，目录名称前加 / ,当前目录内的子目录直接写名称即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /opt/soft</span><br><span class="line">[root@localhost soft]# pwd</span><br><span class="line">/opt/soft</span><br><span class="line">[root@localhost soft]# cd jdk1.6.0_16/</span><br><span class="line">[root@localhost jdk1.6.0_16]# pwd</span><br><span class="line">/opt/soft/jdk1.6.0_16</span><br><span class="line">[root@localhost jdk1.6.0_16]#</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="例4：返回进入此目录之前所在的目录"><a href="#例4：返回进入此目录之前所在的目录" class="headerlink" title="例4：返回进入此目录之前所在的目录"></a>例4：返回进入此目录之前所在的目录</h4><p>cd -<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost soft]# pwd</span><br><span class="line">/opt/soft</span><br><span class="line">[root@localhost soft]# cd -</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# pwd</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# cd -</span><br><span class="line">/opt/soft</span><br><span class="line">[root@localhost soft]#</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="例5：把上个命令的参数作为cd参数使用。"><a href="#例5：把上个命令的参数作为cd参数使用。" class="headerlink" title="例5：把上个命令的参数作为cd参数使用。"></a>例5：把上个命令的参数作为cd参数使用。</h4><p>cd !$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost soft]# cd !$</span><br><span class="line">cd -</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# cd !$</span><br><span class="line">cd -</span><br><span class="line">/opt/soft</span><br><span class="line">[root@localhost soft]#</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ls命令]]></title>
      <url>/1900/01/01/Linux/ls/</url>
      <content type="html"><![CDATA[<p>&ensp;&ensp;ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印当前目录的清单，如果你是指定其他目录，那么就会显示指定目录里的文件及文件夹清单。通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限（包括目录、文件夹、文件权限），查看目录信息等等。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>ls 【选项】【目录名】</p>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>&ensp;&ensp;列出目标目录中所有的子目录和文件。<br><a id="more"></a></p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-a , -all 列出，目录下的所有文件，包括以 <strong>.</strong> 开头的隐含文件</li>
<li>-A , 同-a，但不列出“.”（表示当前目录）和“..”（表示当前目录的父目录）</li>
<li>-c 配合 -lt: 根据ctime排序及显示ctime（文件状态最后更改时间）配合 -l: 显示ctime但根据名称排序否则: 根据ctime排序</li>
<li>-C 每栏由上至下列出项目</li>
<li>–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</li>
<li>-d, –directory 将目录象文件一样显示，而不是显示其下的文件。</li>
<li>-D, –dired 产生适合 Emacs 的 dired 模式使用的结果</li>
<li>-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</li>
<li>-g 类似 -l,但不列出所有者</li>
<li>-G, –no-group 不列出任何有关组的信息</li>
<li>-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)</li>
<li>–si 类似 -h,但文件大小取 1000 的次方而不是 1024</li>
<li>-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地</li>
<li>–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</li>
<li>-i, –inode 印出每个文件的 inode 号</li>
<li>-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目</li>
<li>-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。</li>
<li>-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</li>
<li>-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息</li>
<li>-m 所有项目以逗号分隔，并填满整行行宽</li>
<li>-o 类似 -l,显示文件的除组信息外的详细信息。 </li>
<li>-r, –reverse 依相反次序排列</li>
<li>-R, –recursive 同时列出所有子目录层</li>
<li>-s, –size 以块大小为单位列出所有文件的大小</li>
<li>-S 根据文件大小排序</li>
<li>–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：<br>extension -X status -c<br>none -U time -t<br>size -S atime -u<br>time -t access -u<br>version -v use -u</li>
<li>-t 以文件修改时间排序</li>
<li>-u 配合 -lt:显示访问时间而且依访问时间排序<br>配合 -l:显示访问时间但根据名称排序<br>否则：根据访问时间排序</li>
<li>-U 不进行排序;依文件系统原有的次序列出项目</li>
<li>-v 根据版本进行排序</li>
<li>-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值</li>
<li>-x 逐行列出项目而不是逐栏列出</li>
<li>-X 根据扩展名排序</li>
<li>-1 每行只列出一个文件</li>
<li>–help 显示此帮助信息并离开</li>
<li>–version 显示版本信息并离开</li>
</ul>
<h3 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h3><hr>
<h4 id="例一：列出-home-peidachang文件夹下的所有文件和目录的详细资料"><a href="#例一：列出-home-peidachang文件夹下的所有文件和目录的详细资料" class="headerlink" title="例一：列出/home/peidachang文件夹下的所有文件和目录的详细资料"></a>例一：列出/home/peidachang文件夹下的所有文件和目录的详细资料</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -l -R /home/peidachang<br>&ensp;&ensp;在使用 ls 命令时要注意命令的格式：在命令提示符后，首先是命令的关键字，接下来是命令参数，在命令参数之前要有一短横线“-”，所有的命令参数都有特定的作用，自己可以根据需要选用一个或者多个参数，在命令参数的后面是命令的操作对象。在以上这条命令“ ls -l -R /home/peidachang”中，“ls” 是命令关键字，“-l -R”是参数，“ /home/peidachang”是命令的操作对象。在这条命令中，使用到了两个参数，分别为“l”和“R”，当然，你也可以把他们放在一起使用，如下所示：<br>&ensp;&ensp;<strong>命令：</strong> ls -lR /home/peidachang<br>&ensp;&ensp;这种形式和上面的命令形式执行的结果是完全一样的。另外，如果命令的操作对象位于当前目录中，可以直接对操作对象进行操作;如果不在当前目录则需要给出操作对象的完整路径，例如上面的例子中，我的当前文件夹是peidachang文件夹，我想对home文件夹下的peidachang文件进行操作，我可以直接输入 ls -lR peidachang，也可以用 ls -lR /home/peidachang。 </p>
<hr>
<h4 id="例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令："><a href="#例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：" class="headerlink" title="例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令："></a>例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -l t*<br>&ensp;&ensp;可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。</p>
<hr>
<h4 id="例三：只列出文件下的子目录"><a href="#例三：只列出文件下的子目录" class="headerlink" title="例三：只列出文件下的子目录"></a>例三：只列出文件下的子目录</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -F /opt/soft |grep /$<br>&ensp;&ensp;列出 /opt/soft 文件下面的子目录<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]# ls -F /opt/soft |grep /$<br>&ensp;&ensp;&ensp;&ensp;jdk1.6.0_16/<br>&ensp;&ensp;&ensp;&ensp;subversion-1.6.1/<br>&ensp;&ensp;&ensp;&ensp;tomcat6.0.32/</p>
<p>&ensp;&ensp;<strong>命令：</strong> ls -l /opt/soft | grep “^d”<br>&ensp;&ensp;列出 /opt/soft 文件下面的子目录详细情况<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]#  ls -l /opt/soft | grep “^d”<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 16 1016 1016      4096 10-11 03:25 subversion-1.6.1<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x  9 root root      4096 2011-11-01 tomcat6.0.32</p>
<hr>
<h4 id="例四：列出目前工作目录下所有名称是s-开头的档案，愈新的排愈后面，可以使用如下命令："><a href="#例四：列出目前工作目录下所有名称是s-开头的档案，愈新的排愈后面，可以使用如下命令：" class="headerlink" title="例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令："></a>例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令：</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -ltr s<em><br>&ensp;&ensp;可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]# ls -ltr s</em><br>&ensp;&ensp;&ensp;&ensp;src:<br>&ensp;&ensp;&ensp;&ensp;总计 0<br>&ensp;&ensp;&ensp;&ensp;script:<br>&ensp;&ensp;&ensp;&ensp;总计 0<br>&ensp;&ensp;&ensp;&ensp;soft:<br>&ensp;&ensp;&ensp;&ensp;总计 350644<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x  9 root root      4096 2011-11-01 tomcat6.0.32<br>&ensp;&ensp;&ensp;&ensp;-rwxr-xr-x  1 root root  81871260 09-17 18:15 jdk-6u16-linux-x64.bin<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16<br>&ensp;&ensp;&ensp;&ensp;-rw-r–r–  1 root root   5457684 09-21 00:23 tomcat6.0.32.tar.gz</p>
<hr>
<h4 id="例五：列出目前工作目录下所有档案及目录-目录于名称后加”-“-可执行档于名称后加”-”"><a href="#例五：列出目前工作目录下所有档案及目录-目录于名称后加”-“-可执行档于名称后加”-”" class="headerlink" title="例五：列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加”*”"></a>例五：列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加”*”</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -AF<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;ls -l <em> |grep “^-“|wc -l —文件个数<br>&ensp;&ensp;&ensp;&ensp;ls -l </em> |grep “^d”|wc -l    —目录个数</p>
<hr>
<h4 id="例七-在ls中列出文件的绝对路径"><a href="#例七-在ls中列出文件的绝对路径" class="headerlink" title="例七: 在ls中列出文件的绝对路径"></a>例七: 在ls中列出文件的绝对路径</h4><p>&ensp;&ensp;<strong>命令：</strong> ls | sed “s:^:<code>pwd</code>/:”<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]# ls | sed “s:^:<code>pwd</code>/:”<br>&ensp;&ensp;&ensp;&ensp;/opt/log<br>&ensp;&ensp;&ensp;&ensp;/opt/script<br>&ensp;&ensp;&ensp;&ensp;/opt/soft<br>&ensp;&ensp;&ensp;&ensp;/opt/src<br>&ensp;&ensp;&ensp;&ensp;/opt/svndata<br>&ensp;&ensp;&ensp;&ensp;/opt/web</p>
<hr>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p><strong>显示彩色目录列表</strong><br>    打开/etc/bashrc, 加入如下一行:<br>    alias ls=”ls –color”<br>    下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下:</p>
<pre><code>1. 蓝色--&gt;目录
2. 绿色--&gt;可执行文件
3. 红色--&gt;压缩文件
4. 浅蓝色--&gt;链接文件
5. 灰色--&gt;其他文件
</code></pre>]]></content>
      
        
    </entry>
    
  
  
</search>

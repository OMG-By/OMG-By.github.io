<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Go学习之Module介绍]]></title>
      <url>/2020/06/26/new/Go/Go%E5%AD%A6%E4%B9%A0%E4%B9%8BModule%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="最古老的GOPATH"><a href="#最古老的GOPATH" class="headerlink" title="最古老的GOPATH"></a>最古老的GOPATH</h2><p>Go的包管理方式是逐渐演进的，最初所有的包都放在GOPATH中，使用类似命名空间的包路径来区分包。<br>你可以将其理解为工作目录，在这个工作目录下，通常有如下的目录结构：</p>
<ul>
<li>bin：存放编译生成的二进制文件</li>
<li>pkg：存放编译后的.a文件</li>
<li>src：存放项目的源代码，可以是自己写的代码。也可以是go get下载的包</li>
</ul>
<p>在这种模式下，最严重的问题就是<font color="red">版本管理问题</font>，因为GOPATH没有版本的概念，所以可能会遇到以下的问题：</p>
<ul>
<li>无法在项目中使用指定版本的包，因为不同版本的包的导入方法是一样的。</li>
<li>其他人运行你开发的程序时，无法保证他下载的包版本是你所期望的版本。当其他人</li>
<li>本地中，一个包只能保留一个版本，意味着你在本地开发的所有项目都是一个版本的包</li>
</ul>
<a id="more"></a>
<h2 id="vendor模式"><a href="#vendor模式" class="headerlink" title="vendor模式"></a>vendor模式</h2><p>为了解决GOPATH方案下不同项目下无法使用多个版本库的问题，GO1.5开始支持vendor。</p>
<p>以前使用GOPATH的时候，所有项目都共享一个GOPATH，需要导入依赖的时候，都来这里找。在GOPATH模式下，第三方库都只能有一个版本。</p>
<p>解决的思路是：在每个项目下都创建一个vendor目录，每个项目所需要的依赖都只会下载到自己的vendor目录下，项目之间的依赖包互不影响。在编译时，v1.5的GO在设置了开启<code>GO15VENDOREXPERIMENT=1</code>。<br>（注：这个变量在 v1.6 版本默认为1，但是在 v1.7 后，已去掉该环境变量，默认开启 vendor 特性，无需你手动设置）后，会提升 vendor 目录的依赖包搜索路径的优先级（相较于 GOPATH）。</p>
<p>其搜索包的优先顺序为：</p>
<ul>
<li>当前包下的 vendor 目录</li>
<li>向上级目录查找，直到找到 src 下的 vendor 目录</li>
<li>在 GOROOT 目录下查找</li>
<li>在 GOPATH 下面查找依赖包</li>
</ul>
<p>虽然这个方案解决了一些问题，但是解决得并不完美。</p>
<ul>
<li>如果多个项目用到了同一个包的同一个版本，这个包会存在于该机器上的不同目录下，不仅对磁盘空间是一种浪费，而且没法对第三方包进行集中式的管理（分散在各个角落）。</li>
<li>并且如果要分享开源你的项目，你需要将你的所有的依赖包悉数上传，别人使用的时候，除了你的项目源码外，还有所有的依赖包全部下载下来，才能保证别人使用的时候，不会因为版本问题导致项目不能如你预期那样正常运行。</li>
</ul>
<h2 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h2><p>Go Modules在v1.11版本正式推出，在v1.14版本中，官方正式发话，称其已经足够成熟，可以应用于生产上。</p>
<p>从 v1.11 开始，go env 多了个环境变量：GO111MODULE ，这里的 111，其实就是 v1.11 的象征标志， go 里好像很喜欢这样的命名方式，比如当初 vendor 出现的时候，也多了个 GO15VENDOREXPERIMENT环境变量，其中 15，表示的vendor 是在 v1.5 时才诞生的。</p>
<p>GO111MODULE 是一个开关，通过它可以开启或关闭 go mod 模式。它有三个可选值：off、on、auto，默认值是auto。</p>
<ul>
<li>GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。</li>
<li>GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。</li>
<li>GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，自动开启模块支持。</li>
</ul>
<h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h3><p>golang提供<code>go mod</code>命令来管理Modules包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  test go mod</span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line"></span><br><span class="line">Note that support for modules is built into all the go commands,</span><br><span class="line">not just &apos;go mod&apos;. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be done using &apos;go get&apos;.</span><br><span class="line">See &apos;go help modules&apos; for an overview of module functionality.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">	go mod &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">	download    download modules to local cache</span><br><span class="line">	edit        edit go.mod from tools or scripts</span><br><span class="line">	graph       print module requirement graph</span><br><span class="line">	init        initialize new module in current directory</span><br><span class="line">	tidy        add missing and remove unused modules</span><br><span class="line">	vendor      make vendored copy of dependencies</span><br><span class="line">	verify      verify dependencies have expected content</span><br><span class="line">	why         explain why packages or modules are needed</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">download</td>
<td style="text-align:center">下载依赖包</td>
</tr>
<tr>
<td style="text-align:center">edit</td>
<td style="text-align:center">下载依赖包</td>
</tr>
<tr>
<td style="text-align:center">graph</td>
<td style="text-align:center">编辑go.mod</td>
</tr>
<tr>
<td style="text-align:center">init</td>
<td style="text-align:center">打印模块依赖图</td>
</tr>
<tr>
<td style="text-align:center">tidy</td>
<td style="text-align:center">在当前目录初始化mod</td>
</tr>
<tr>
<td style="text-align:center">vendor</td>
<td style="text-align:center">拉取缺少的模块，移除不用的模块</td>
</tr>
<tr>
<td style="text-align:center">verify</td>
<td style="text-align:center">验证依赖是否正确</td>
</tr>
<tr>
<td style="text-align:center">why</td>
<td style="text-align:center">解释为什么需要依赖</td>
</tr>
</tbody>
</table>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="创建一个新项目"><a href="#创建一个新项目" class="headerlink" title="创建一个新项目"></a>创建一个新项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  test go mod init test</span><br><span class="line">go: creating new go.mod: module test</span><br><span class="line">➜  test ls</span><br><span class="line">go.mod</span><br><span class="line">➜  test cat go.mod</span><br><span class="line">module test</span><br></pre></td></tr></table></figure>
<p>go.mod文件一旦创建后，它的内容将会被go toolchain全面掌控。go toolchain会在各类命令执行时，比如go get、go build、go mod等修改和维护go.mod文件。</p>
<p>go.mod 提供了以下四个命令：</p>
<ul>
<li>module 语句指定包的名字（路径）</li>
<li>require 语句指定的依赖项模块</li>
<li>replace 语句可以替换依赖项模块</li>
<li>exclude 语句可以忽略依赖项模块</li>
</ul>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>新建一个 server.go 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	</span><br><span class="line">	&quot;github.com/labstack/echo&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	e := echo.New()</span><br><span class="line">	e.GET(&quot;/&quot;, func(c echo.Context) error &#123;</span><br><span class="line">		return c.String(http.StatusOK, &quot;Hello, World!&quot;)</span><br><span class="line">	&#125;)</span><br><span class="line">	e.Logger.Fatal(e.Start(&quot;:1323&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行<code>go run server.go</code>运行代码会发现 go mod 会自动查找依赖自动下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  test go run server.go</span><br><span class="line">go: finding github.com/labstack/echo v3.3.10+incompatible</span><br><span class="line">go: downloading github.com/labstack/echo v3.3.10+incompatible</span><br><span class="line">go: finding github.com/labstack/gommon/color latest</span><br><span class="line">go: finding github.com/labstack/gommon/log latest</span><br><span class="line">go: finding github.com/labstack/gommon v0.3.0</span><br><span class="line">go: downloading github.com/labstack/gommon v0.3.0</span><br><span class="line">go: finding golang.org/x/crypto/acme/autocert latest</span><br><span class="line">go: finding golang.org/x/crypto/acme latest</span><br><span class="line">go: finding golang.org/x/crypto latest</span><br><span class="line">go: downloading golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9</span><br><span class="line">go: finding github.com/mattn/go-isatty v0.0.9</span><br><span class="line">go: finding github.com/mattn/go-colorable v0.1.2</span><br><span class="line">go: finding github.com/valyala/fasttemplate v1.0.1</span><br><span class="line">go: finding github.com/mattn/go-isatty v0.0.8</span><br><span class="line">go: finding golang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a</span><br><span class="line">go: finding github.com/valyala/bytebufferpool v1.0.0</span><br><span class="line">go: finding golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223</span><br><span class="line">go: downloading github.com/mattn/go-isatty v0.0.9</span><br><span class="line">go: downloading github.com/mattn/go-colorable v0.1.2</span><br><span class="line">go: downloading github.com/valyala/fasttemplate v1.0.1</span><br><span class="line">go: downloading golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3</span><br><span class="line">go: downloading github.com/valyala/bytebufferpool v1.0.0</span><br></pre></td></tr></table></figure></p>
<p>查看目录，发现多了<code>go.sum</code>文件。该文件主要用来记录 dependency tree。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  test ls</span><br><span class="line">go.mod    go.sum    server.go</span><br><span class="line">➜  test cat go.mod</span><br><span class="line">module test</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">	github.com/labstack/echo v3.3.10+incompatible // indirect</span><br><span class="line">	github.com/labstack/gommon v0.3.0 // indirect</span><br><span class="line">	golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9 // indirect</span><br><span class="line">)</span><br><span class="line">➜  test cat go go.sum</span><br><span class="line">cat: go: No such file or directory</span><br><span class="line">github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=</span><br><span class="line">github.com/labstack/echo v3.3.10+incompatible h1:pGRcYk231ExFAyoAjAfD85kQzRJCRI8bbnE7CX5OEgg=</span><br><span class="line">github.com/labstack/echo v3.3.10+incompatible/go.mod h1:0INS7j/VjnFxD4E2wkz67b8cVwCLbBmJyDaka6Cmk1s=</span><br><span class="line">github.com/labstack/gommon v0.3.0 h1:JEeO0bvc78PKdyHxloTKiF8BD5iGrH8T6MSeGvSgob0=</span><br><span class="line">github.com/labstack/gommon v0.3.0/go.mod h1:MULnywXg0yavhxWKc+lOruYdAhDwPK9wf0OL7NoOu+k=</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>当依赖都存在时，就会跳过下载的步骤。<br>可以使用命令<code>go list -m -u all</code>来检查可以升级的package，使用<code>go get -u need-upgrade-package</code>升级后会将新的依赖版本更新到go.mod * 也可以使用<code>go get -u</code>升级所有依赖</p>
<p>现在很少用GO，所以也没了解更深，这篇文章作为记录吧。剩下的后面在使用过程中再补充。。。。。</p>
]]></content>
      
        <categories>
            
            <category> GO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 环境下搭建MySQL 8.0.20 组复制]]></title>
      <url>/2020/06/13/new/MySQL/Docker-%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAMySQL-8-0-20-%E7%BB%84%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>最近在学习MySQL 8.0 新特性，以及MGR。于是想在搭建一套环境来测试。<br>本来在买的阿里云服务器上进行搭建，结果好像是一台机器搭建不了，至少需要三台，于是就放弃了。<br>正好小伙伴分享了docker，于是就利用docker在本地搭建了一套8.0的MGR环境。</p>
<h2 id="准备docker镜像"><a href="#准备docker镜像" class="headerlink" title="准备docker镜像"></a>准备docker镜像</h2><p>运行一个test名称的centos系统镜像<br><code>➜  ~ docker run -d -it --name test centos</code><br>进入容器<br><code>➜  ~ docker exec -it test bash</code><br>在容器内安装MySQL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@c610b533f3dc /]# yum install yum-utils wget -y</span><br><span class="line">[root@c610b533f3dc /]# wget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">[root@c610b533f3dc /]# rpm -ivh mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">[root@c610b533f3dc /]# yum install -y mysql-server</span><br></pre></td></tr></table></figure></p>
<p>安装完后退出容器，并生成镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@c610b533f3dc /]# exit</span><br><span class="line">➜  ~ docker commit 容器ID mysql8.0.20</span><br></pre></td></tr></table></figure></p>
<h2 id="启动MySQL容器"><a href="#启动MySQL容器" class="headerlink" title="启动MySQL容器"></a>启动MySQL容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --privileged --name=mysql-mgr-node1 mysql8.0.20 /usr/sbin/init</span><br><span class="line">docker run -d -it --privileged --name=mysql-mgr-node2 mysql8.0.20 /usr/sbin/init</span><br><span class="line">docker run -d -it --privileged --name=mysql-mgr-node3 mysql8.0.20 /usr/sbin/init</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="配置MGR节点"><a href="#配置MGR节点" class="headerlink" title="配置MGR节点"></a>配置MGR节点</h2><h3 id="修改-etc-hosts文件"><a href="#修改-etc-hosts文件" class="headerlink" title="修改/etc/hosts文件"></a>修改/etc/hosts文件</h3><p>登录每一个容器，查看hosts文件，并进行添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker exec -it mysql-mgr-node1 bash</span><br><span class="line">[root@4af6073b5ee9 /]# cat /etc/hosts</span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">172.17.0.3	4af6073b5ee9  </span><br><span class="line">172.17.0.4	762f16c6d69f</span><br><span class="line">172.17.0.5	927681f0afc0</span><br></pre></td></tr></table></figure></p>
<h3 id="修改-etc-my-cnf文件"><a href="#修改-etc-my-cnf文件" class="headerlink" title="修改/etc/my.cnf文件"></a>修改/etc/my.cnf文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">server_id = 1</span><br><span class="line">gtid_mode = ON</span><br><span class="line">enforce_gtid_consistency = ON</span><br><span class="line">binlog_checksum = NONE</span><br><span class="line"></span><br><span class="line">transaction_write_set_extraction = XXHASH64</span><br><span class="line">loose-group_replication_group_name = &apos;ce9be252-2b71-11e6-b8f4-00212844f856&apos;</span><br><span class="line">loose-group_replication_start_on_boot = off</span><br><span class="line">loose-group_replication_local_address= &quot;172.17.0.3:33061&quot;</span><br><span class="line">loose-group_replication_group_seeds= &quot;172.17.0.3:33061,172.17.0.4:33061,172.17.0.5:33061&quot;</span><br><span class="line">loose-group_replication_bootstrap_group = off</span><br></pre></td></tr></table></figure>
<p>其他两个容器只需要修改<code>server_id</code>和<code>loose-group_replication_local_address</code></p>
<h3 id="重启MySQL"><a href="#重启MySQL" class="headerlink" title="重启MySQL"></a>重启MySQL</h3><p><code>[root@4af6073b5ee9 /]# systemctl restart mysqld</code></p>
<h3 id="修改MySQL密码"><a href="#修改MySQL密码" class="headerlink" title="修改MySQL密码"></a>修改MySQL密码</h3><p>在容器的/var/log/mysqld.log文件中会有MySQL的初始化密码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@4af6073b5ee9 /]# cat /var/log/mysqld.log</span><br><span class="line">2020-06-12T10:15:04.837913Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: gYEdgjDqe0,9</span><br></pre></td></tr></table></figure></p>
<p>登录MySQL<br><code>[root@4af6073b5ee9 /]# mysql -u root -p&quot;gYEdgjDqe0,9&quot;</code></p>
<p>修改密码<br><code>mysql&gt; alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;1qaz@WSX&#39;;</code></p>
<h3 id="初始化组复制插件及用户"><a href="#初始化组复制插件及用户" class="headerlink" title="初始化组复制插件及用户"></a>初始化组复制插件及用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSTALL PLUGIN group_replication SONAME &apos;group_replication.so&apos;;</span><br><span class="line">mysql&gt; SET SQL_LOG_BIN=0;</span><br><span class="line">mysql&gt; CREATE USER repl@&apos;%&apos; IDENTIFIED BY &apos;1qaz@WSX&apos;;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO repl@&apos;%&apos;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">mysql&gt; SET SQL_LOG_BIN=1;</span><br><span class="line">mysql&gt; CHANGE MASTER TO MASTER_USER=&apos;repl&apos;, MASTER_PASSWORD=&apos;1qaz@WSX&apos;FOR CHANNEL &apos;group_replication_recovery&apos;;</span><br></pre></td></tr></table></figure>
<font color="red">以上操作需要在所有容器上执行</font>

<h3 id="配置MGR主节点"><a href="#配置MGR主节点" class="headerlink" title="配置MGR主节点"></a>配置MGR主节点</h3><p>本操作在主节点(mysql-mgr-node1)上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL group_replication_bootstrap_group=ON;</span><br><span class="line">mysql&gt; START GROUP_REPLICATION;</span><br><span class="line">mysql&gt; SET GLOBAL group_replication_bootstrap_group=OFF;</span><br><span class="line"></span><br><span class="line"># 查看组信息</span><br><span class="line">mysql&gt; SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST  | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| group_replication_applier | 95744fa5-ac95-11ea-a21d-0242ac110003 | 4af6073b5ee9 |        3306 | ONLINE       | PRIMARY     | 8.0.20         |</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br></pre></td></tr></table></figure></p>
<h3 id="其他节点加入集群"><a href="#其他节点加入集群" class="headerlink" title="其他节点加入集群"></a>其他节点加入集群</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START GROUP_REPLICATION;</span><br></pre></td></tr></table></figure>
<p>在任意节点上可以查看组复制状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST  | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| group_replication_applier | 95744fa5-ac95-11ea-a21d-0242ac110003 | 4af6073b5ee9 |        3306 | ONLINE       | PRIMARY     | 8.0.20         |</span><br><span class="line">| group_replication_applier | 9bda89f2-ac95-11ea-9c6a-0242ac110004 | 762f16c6d69f |        3306 | ONLINE       | SECONDARY   | 8.0.20         |</span><br><span class="line">| group_replication_applier | 9f569a5e-ac95-11ea-9ffc-0242ac110005 | 927681f0afc0 |        3306 | ONLINE       | SECONDARY   | 8.0.20         |</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br></pre></td></tr></table></figure></p>
<p>至此，在Docker下搭建MySQL MGR完成</p>
<h3 id="MGR多主模式搭建-扩展"><a href="#MGR多主模式搭建-扩展" class="headerlink" title="MGR多主模式搭建(扩展)"></a>MGR多主模式搭建(扩展)</h3><p>在所有MGR节点上停止组复制模式，并配置多主模式参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; stop group_replication;</span><br><span class="line">mysql&gt; set global group_replication_single_primary_mode=OFF;</span><br><span class="line">mysql&gt; set global group_replication_enforce_update_everywhere_checks=ON;</span><br></pre></td></tr></table></figure></p>
<p>选一个节点作为源节点，执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL group_replication_bootstrap_group=ON;</span><br><span class="line">mysql&gt; START GROUP_REPLICATION;</span><br><span class="line">mysql&gt; SET GLOBAL group_replication_bootstrap_group=OFF;</span><br></pre></td></tr></table></figure></p>
<p>其他节点加入集群<br><code>mysql&gt; START GROUP_REPLICATION;</code></p>
<p>查看MGR组状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST  | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| group_replication_applier | 95744fa5-ac95-11ea-a21d-0242ac110003 | 4af6073b5ee9 |        3306 | ONLINE       | PRIMARY     | 8.0.20         |</span><br><span class="line">| group_replication_applier | 9bda89f2-ac95-11ea-9c6a-0242ac110004 | 762f16c6d69f |        3306 | ONLINE       | PRIMARY     | 8.0.20         |</span><br><span class="line">| group_replication_applier | 9f569a5e-ac95-11ea-9ffc-0242ac110005 | 927681f0afc0 |        3306 | ONLINE       | PRIMARY     | 8.0.20         |</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br></pre></td></tr></table></figure></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] Slave I/O for channel &apos;group_replication_recovery&apos;: Got fatal error 1236 from master when</span><br><span class="line">reading data from binary log: &apos;The slave is connecting using CHANGE MASTER TO MASTER_AUTO_POSITION = 1, but the master has</span><br><span class="line">purged binary logs containing GTIDs that the slave requires.&apos;, Error_code: 1236</span><br></pre></td></tr></table></figure>
<p>这是由于主从实例上都产生了gtid，导致冲突报错。<br>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 在主实例上执行show master status\G命令查看gtid</span><br><span class="line">mysql&gt; show master status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">             File: binlog.000002</span><br><span class="line">         Position: 1365</span><br><span class="line">     Binlog_Do_DB:</span><br><span class="line"> Binlog_Ignore_DB:</span><br><span class="line">Executed_Gtid_Set: 95744fa5-ac95-11ea-a21d-0242ac110003:1-2,</span><br><span class="line">ce9be252-2b71-11e6-b8f4-00212844f856:1-2</span><br><span class="line"></span><br><span class="line"># 在从实例上重新设定gtid</span><br><span class="line">mysql&gt; STOP GROUP_REPLICATION;</span><br><span class="line">mysql&gt; reset master; </span><br><span class="line"></span><br><span class="line"># 根据在主节点上执行show master status;得出的gtid。</span><br><span class="line">mysql&gt; set global gtid_purged = &apos;95744fa5-ac95-11ea-a21d-0242ac110003:1-2,ce9be252-2b71-11e6-b8f4-00212844f856:1-2&apos;;</span><br><span class="line"></span><br><span class="line">mysql&gt; START GROUP_REPLICATION;</span><br></pre></td></tr></table></figure></p>
<p>查看状态时，从节点一直处于<code>RECOVERING</code>状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.replication_group_members;</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST  | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br><span class="line">| group_replication_applier | 95744fa5-ac95-11ea-a21d-0242ac110003 | 4af6073b5ee9 |        3306 | ONLINE       | PRIMARY     | 8.0.20         |</span><br><span class="line">| group_replication_applier | 9bda89f2-ac95-11ea-9c6a-0242ac110004 | 762f16c6d69f |        3306 | RECOVERING   | SECONDARY   | 8.0.20         |</span><br><span class="line">| group_replication_applier | 9f569a5e-ac95-11ea-9ffc-0242ac110005 | 927681f0afc0 |        3306 | RECOVERING   | SECONDARY   | 8.0.20         |</span><br><span class="line">+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+</span><br></pre></td></tr></table></figure></p>
<p>这是由于找不到从节点导致。<br>1、首先检查一下<code>/etc/hosts</code>文件，看是否将所有容器信息都给补充了。<br>2、执行以下命令重启一下从节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; stop group_replication;</span><br><span class="line">mysql&gt; set global group_replication_recovery_get_public_key=ON;</span><br><span class="line">mysql&gt; start group_replication;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL8.0 </tag>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL机制之Double Write]]></title>
      <url>/2020/06/07/new/MySQL/MySQL%E6%9C%BA%E5%88%B6%E4%B9%8BDouble-Write/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道MySQL在更新数据的时候，会先写入到内存中的数据页，然后再在一定的时机时，将脏页给刷新到磁盘中。<br>一个数据页默认为16k，但是由于操作系统的限制，每次需要多次才能将数据页给刷新到磁盘；如果在这个过程中发生故障，导致一个数据页并没有完整的给刷新到磁盘中。我们就称为<code>页断裂</code> 。在这种情况下，我们并不知道会出现什么未知的现象。<br>为了在页断裂场景发生时，能够对损坏的数据页进行修复工作。就引入了<code>两次写（Double Write）</code>机制。</p>
<h2 id="什么是两次写"><a href="#什么是两次写" class="headerlink" title="什么是两次写"></a>什么是两次写</h2><p>简单来说，就是在对数据页刷盘操作之前，先将该数据页写到一块独立的物理文件位置(ibdata)中。然后再将数据页进行刷盘操作。这样在宕机时，如果出现物理文件损坏，就能够利用ibdata中的副本文件进行修复行为。</p>
<p>Double Write由两部分组成；一部分是内存中的double write buffer，其大小为2M。另一部分由共享表空间(ibdata)中连续的128页，即2个区组成，大小也是2M。<br>其刷盘流程为：</p>
<ol>
<li>当多个数据页需要进行刷盘时，并不直接写入到磁盘的物理文件中，而是先拷贝到内存中的double write buffer中。</li>
<li>接着从double write buffer中分两次写入到磁盘的共享表空间中(连续存储，顺序写，性能很高)，每次写1M。</li>
<li>等第二步完成后，再将double write buffer中的脏页数据写入到实际的各个表空间中(离散写)</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfio3072ivj30j60dmabz.jpg" alt=""></p>
<a id="more"></a>
<h2 id="如何修复"><a href="#如何修复" class="headerlink" title="如何修复"></a>如何修复</h2><p>在发生故障时，如何进行修复操作？<br>1、如果是写doublewrite buffer本身失败,那么这些数据不会被写到磁盘,InnoDB此时会从磁盘载入原始的数据,然后通过InnoDB的事务日志来计算出正确的数据,重新 写入到doublewrite buffer。<br>2、如果 doublewrite buffer写成功的话,但是写磁盘失败,InnoDB就不用通过事务日志来计算了,而是直接用double write buffer的数据再写一遍。<br>3、在恢复的时候,InnoDB直接比较页面的checksum,如果不对的话,就从硬盘载入原始数据,再由事务日志 开始推演出正确的数据.所以InnoDB的恢复通常需要较长的时间.<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfio31sa8aj30il0bhjsr.jpg" alt=""></p>
<h2 id="5-7优化"><a href="#5-7优化" class="headerlink" title="5.7优化"></a>5.7优化</h2><p>在《MySQL运维内参》一书中，提到了在5.7中，对double write进行了优化<code>批量刷盘</code>。但是我在5.7.18版本中，并没有看到有那个参数<code>innodb_doublewrite_batch_size</code>（为MySQL 8.0.20引入）。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfjtvjy3c0j30fa09k75f.jpg" alt=""></p>
<p>批量刷盘包括两种方式，分别是LRU(Least Recently Used,最近最少使用)方式和LIST方式。当Buffer Pool空间不足时，再载入新的页面就必须要将一些不怎么用到的、旧的页面淘汰出去，此时系统就会从LRU链表中找到最老的页面，进行批量刷盘，将释放的空间加入到空闲空间中去，这种情况就是LRU刷盘。当日志空间不足，或者是后台MASTER线程在定时刷盘时，不需要区分页面的新旧状态，只需要选择LSN最小的那些页面，从前到后刷一批页面到文件中，此时所用的策略就是LIST方式。  </p>
<p>在批量刷盘的两次写中，这两种刷盘方法对应的两次写空间互不干涉。  </p>
<p>从图中可以看出落到最终的每一个shard,其实就是一个batch，对应的参数就是innodb_doublewrite_batch_size。一个shard，有一个数组，长度为innodb_doublewrite_batch_size，与单一页面刷盘的两次写是一样的，只是这个数组只属于一个shard而已。  </p>
<p>假设由于页面淘汰，系统要做一次批量刷盘，这次就是LRU方式的，那么此时系统就需要将当前页面加入到两次写缓存中，首先根据当前页面所在的Instance号及刷盘类型就可以找到对应的shard缓存，找到缓存后，判断当前shard是否已经满了，即是否已经达到innodb_doublewrite_batch_size的大小，如果没有达到，则将当前页面内容追加复制到当前的shard缓存中，这样当前页面的刷盘操作就完成了。这里并不像单一页面那样，先写入缓存空间中，然后写入ibdata文件的两次写空间，最后还需要立即将页面的真实内容刷入表空间，对于批量刷盘来说，只需要写入到shard缓存即可。  </p>
<p>如果当前shard中缓存的页面个数已经达到了innodb_doublewrite_batch_size，则说明当前缓存空间已经满了，此时不得不将当前shard缓存的页面写入两次写文件中，写完之后再将两次写文件FLUSH到磁盘，最后将对应的真实页面刷盘，此时可能是随机写入了，因为对应的两次写缓存中虽然是连续的，但对应的真实页面就不会这样了。这里需要注意的一点就是，表空间页面的刷盘，是异步IO操作，此时需要等待异步IO完成，且整个shard中的页面都刷盘后，刷盘操作才可以继续向后执行，而这个shard也可以再次重新使用了，缓存中的数据也都会被清空。</p>
<p>需要注意的是，上面过程中写入是连续innodb_doublewrite_batch_size 个页面，所以性能会比写入多次而每次写入一个页面的情况好很多。批量刷盘的情况下，有可能每隔innodb_doublewrite_batch_size个页面的刷盘操作，就会出现一次等待操作，且等待时间长短不一定，但这也是在单一页面刷盘的基础上优化过的，做了改进。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="发生页断裂时，理论上通过redo就应该能够进行恢复了，为什么还需要double-write？"><a href="#发生页断裂时，理论上通过redo就应该能够进行恢复了，为什么还需要double-write？" class="headerlink" title="发生页断裂时，理论上通过redo就应该能够进行恢复了，为什么还需要double write？"></a>发生页断裂时，理论上通过redo就应该能够进行恢复了，为什么还需要double write？</h3><p>这个就得从redo log保存的记录格式说起了。<br>redo日志主要采用的是物理日志和逻辑日志两种方式。<br>对于能够唯一确定数据存储在磁盘位置时，使用的是物理日志，通过(group_id,file_id,page_no,offset)4元组来确定位置，并记录数据页变更。在这种记录格式下，能够通过redo log进行问题修复。<br>但是，对于一个操作记录产生的日志跨越了多个数据页时，那么会产生多个物理页面的日志，但对于每个物理页面日志，里面记录则是逻辑信息。在这种情况下，就无法单靠redo log进行问题修复</p>
<h3 id="性能损耗"><a href="#性能损耗" class="headerlink" title="性能损耗"></a>性能损耗</h3><p>如果开启了double write机制。那么每次刷盘都会多一次内存复制和持久化操作。那么会对性能造成多大的影响呢？<br>由于持久化刷盘过程是顺序写，性能很高。据官方介绍，可能会有10%的性能损耗，但是为了数据得到完整性，这点损耗还是很有必要的。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/xuliuzai/p/10290196.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuliuzai/p/10290196.html</a><br><a href="https://mp.weixin.qq.com/s/9GHIpT_YeUoZNJ2X6cS-YQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9GHIpT_YeUoZNJ2X6cS-YQ</a> （推荐）</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL参数之innodb_fast_shutdown、innodb_force_recovery]]></title>
      <url>/2020/06/06/new/MySQL/MySQL%E5%8F%82%E6%95%B0%E4%B9%8Binnodb-fast-shutdown%E3%80%81innodb-force-recovery/</url>
      <content type="html"><![CDATA[<h2 id="innodb-fast-shutdown"><a href="#innodb-fast-shutdown" class="headerlink" title="innodb_fast_shutdown"></a>innodb_fast_shutdown</h2><p>MySQL在平时工作时，会将大量的数据都保存在内存当中。那么在关闭的时候，什么东西需要持久化？什么东西不需要持久化呢？<br>在MySQL中，<code>innodb_fast_shutdown</code>参数控制着关闭行为。它的可取值有0、1、2。</p>
<p>顾名思义，fast_shutdown，0表示不需要快速关闭、1需要快速关闭。</p>
<ul>
<li>0：在关闭时需要将内存与磁盘中数据不一致的数据页都进行刷盘行为。主要包含有：<ul>
<li>删除无用的undo页。</li>
<li>将log buffer中的日志都flush到log files。</li>
<li>merge change buffer。</li>
<li>flush dirty page</li>
</ul>
</li>
<li>1：在关闭时，只进行刷新脏页行为。不需要purge all、merge change buffer。</li>
<li>2：在关闭时，只进行flush log buffer。不需要purge all、merge change buffer、flush dirty。</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>在进行大版本升级时，需要将该参数设置为0</li>
<li>该参数默认值为1</li>
<li>该参数设置为2时，下次重启将会做<code>crash recovery</code>行为</li>
</ol>
<h2 id="innodb-force-recovery"><a href="#innodb-force-recovery" class="headerlink" title="innodb_force_recovery"></a>innodb_force_recovery</h2><p>有的时候由于MySQL在关闭前存在一些重操作行为，导致MySQL启动需要消耗大量的时间，但是我们需要能够尽可能快速的启动MySQL服务。<br>MySQL提供了参数<code>innodb_force_recovery</code>来规定MySQL启动过程中需要做的行为动作。</p>
<p>该参数可选值为0~6，当该参数设置值大于0时，可以对表执行select、create、drop操作，但insert、update或者delete这类操作是不允许的。</p>
<ul>
<li>0：表示恢复时执行所有的恢复操作。</li>
<li>1：（SRV_FORCE_IGNORE_CORRUPT）忽略检查到的corrupt页</li>
<li>2：（SRV_FORCE_NO_BACKGROUND）阻止主线程的运行，如主线程需要执行full purge操作，会导致crash</li>
<li>3：（SRV_FORCE_NO_TRX_UNDO）不执行事务回滚操作</li>
<li>4：（SRV_FORCE_NO_IBUF_MERGE）不执行插入缓冲的合并操作</li>
<li>5：（SRV_FORCE_NO_UNDO_LOG_SCAN）不查看撤销日志（Undo Log），InnoDB存储引擎会将未提交的事务视为已提交</li>
<li>6：（SRV_FORCE_NO_LOG_REDO）不执行前滚的操作</li>
</ul>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL参数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL参数之innodb_autoinc_lock_mode]]></title>
      <url>/2020/06/05/new/MySQL/MySQL%E5%8F%82%E6%95%B0%E4%B9%8Binnodb-autoinc-lock-mode/</url>
      <content type="html"><![CDATA[<h2 id="insert种类"><a href="#insert种类" class="headerlink" title="insert种类"></a>insert种类</h2><p>在讲<code>innodb_autoinc_lock_mode</code>参数之前，我们先来了解下MySQL insert的种类</p>
<ul>
<li>simple insert：插入的记录行数是确定的。比如：insert into、replace</li>
<li>bulk insert：插入的记录行数不能马上确认的。比如：insert…select、replace…select、load data</li>
<li>mixed-mode insert：也是’simple insert’，但是语句插入中存在没指定自增值的行。比如：INSERT INTO t1 (c1,c2) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’)、INSERT … ON DUPLICATE KEY UPDATE</li>
</ul>
<h2 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h2><p>在了解了以上insert种类后。我们来对<code>innodb_autoinc_lock_mode</code>参数设置不同值时的表现进行描述。</p>
<h3 id="传统模式"><a href="#传统模式" class="headerlink" title="传统模式"></a>传统模式</h3><p>innodb_autoinc_lock_mode=0</p>
<p>这种模式性能最差，它会对所有的insert模式操作都去获取一个特殊的<code>table-level auto-inc</code>。这种锁会持续到语句结束，以确保执行的insert语句以可预测且可重复的顺序分配自动递增值。这种模式更多是为了兼容老版本的MySQL运行。</p>
<a id="more"></a>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1 (</span><br><span class="line">  c1 INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  c2 VARCHAR(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (c1)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...</span><br><span class="line">Tx2: INSERT INTO t1 (c2) VALUES (&apos;xxx&apos;);</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，传统模式下，Tx1执行过程中会一直持有auto-inc锁，一直到Tx1执行完。所以Tx2必须等待锁释放。这会导致一个简单insert语句执行得非常慢。严重的影响了并发效率。<br>而在连续锁定模式下，Tx1执行前会预先计算需要插入的函数，在获取到auto-inc锁后立即释放。Tx2不会受到Tx1 auto-inc的影响。</p>
<h3 id="连续锁定模式"><a href="#连续锁定模式" class="headerlink" title="连续锁定模式"></a>连续锁定模式</h3><p>innodb_autoinc_lock_mode=1</p>
<p>在MySQL8.0.3之前，<code>innodb_autoinc_lock_mode</code>参数的默认值是1。也就是连续锁定模式。<br>在这种模式下，普通insert语句，申请到自增锁后就马上释放。bulk insert这样的批量插入数据语句，自增锁还是要等语句结束后才被释放。</p>
<p>在这种模式下，可能会申请多一部分自增键。导致自增键空洞情况的发生。<br>例如，假设 c1 列是表 t1 的 AUTO_INCREMENT 列，且假设最新自动生成的序列号为 100<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t1` (</span><br><span class="line">  `c1` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `c2` char(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`c1`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line">INSERT INTO t1 (c1,c2) VALUES (1,&apos;a&apos;), (NULL,&apos;b&apos;), (5,&apos;c&apos;), (NULL,&apos;d&apos;);</span><br></pre></td></tr></table></figure></p>
<p>在连续模式下执行插入操作后，innodb在处理时分配了4个自增值，但是只使用了两个。所以导致了103和104被丢失了。这就导致了自增键的空洞现象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table t1\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: t1</span><br><span class="line">Create Table: CREATE TABLE `t1` (</span><br><span class="line">  `c1` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `c2` char(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`c1`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=104 DEFAULT CHARSET=utf8</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1 order by c2;</span><br><span class="line">+-----+------+</span><br><span class="line">| c1  | c2   |</span><br><span class="line">+-----+------+</span><br><span class="line">|   1 | a    |</span><br><span class="line">| 100 | b    |</span><br><span class="line">|   5 | c    |</span><br><span class="line">| 101 | d    |</span><br><span class="line">+-----+------+</span><br><span class="line">4 rows in set (0.30 sec)</span><br></pre></td></tr></table></figure></p>
<h3 id="交叉锁定模式"><a href="#交叉锁定模式" class="headerlink" title="交叉锁定模式"></a>交叉锁定模式</h3><p>innodb_autoinc_lock_mode=2</p>
<p>所有的申请自增锁操作都是申请后就立刻释放锁。在这个模式下，已经没有了AUTO-INC锁，所以这个模式下的性能是最好的。<br>这一模式下存在两个问题：<br>1、在这种模式下，如果binlog格式为statement，可能会引起数据不一致。<br>2、对于同一语句来说，它得到的auto_increment值可能不是连续的。</p>
<p>在SBR模式下，如果该值为2可能会引起主从数据不一致：<br>Master上的插入逻辑：</p>
<table>
<thead>
<tr>
<th style="text-align:center">时间点</th>
<th style="text-align:center">session1</th>
<th style="text-align:center">session2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1,A</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">2,AA</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">3,B</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4,C</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
<td style="text-align:center">5,CC</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">6,D</td>
</tr>
</tbody>
</table>
<p>Master结果记录：</p>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">AA</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">CC</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">D</td>
</tr>
</tbody>
</table>
<p>由于session2先执行完，所以slave上的结果为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">AA</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">CC</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">D</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html</a><br><a href="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-auto-increment-handling.html" target="_blank" rel="noopener">https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-auto-increment-handling.html</a><br><a href="https://www.twle.cn/c/yufei/innodb/innodb-basic-auto_increment.html" target="_blank" rel="noopener">https://www.twle.cn/c/yufei/innodb/innodb-basic-auto_increment.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL参数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pt-osc死锁分析记录两则]]></title>
      <url>/2020/06/04/new/MySQL/pt-osc%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95%E4%B8%A4%E5%88%99/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天看到叶老师公众号推送文章《<a href="!https://mp.weixin.qq.com/s/mJ6a-sV2C2ru5pA5QNAAZQ">pt-osc在线重建表导致死锁的分析及对应的优化方案</a>》，让我想起了前段时间同样遇到了pt-osc改表导致的死锁。故此记录一下。</p>
<h2 id="pt-osc"><a href="#pt-osc" class="headerlink" title="pt-osc"></a>pt-osc</h2><p>pt-online-schema-change：PERCONA提供的在线改表工具，避免MySQL在执行改表操作时造成的锁表和主从延迟情况发生。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>1、创建一个跟原表表结构一样的新表。取名为<code>_oldTableNmae_new</code><br>2、修改新表结构<br>3、在原表中创建insert、update、delete三个类型的触发器，用于做增量数据迁移。原表SQL和触发器触发SQL在同一事务当中。<br>4、以一定块大小(chunk-size)从原表拷贝数据到新表<br>5、数据拷贝完后，修改表名：<code>rename table to table_old; rename _table_new to table</code><br>6、删除old表，删除三个触发器</p>
<h3 id="版本变化"><a href="#版本变化" class="headerlink" title="版本变化"></a>版本变化</h3><p>3.0.2之前的update触发器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO `lc`.`_hb_new` (`id`, `ts`, `ts2`, `c1`) VALUES (NEW.`id`, NEW.`ts`, NEW.`ts2`, NEW.`c1`)</span><br></pre></td></tr></table></figure></p>
<p>3.0.2之后的update触发器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    DELETE IGNORE FROM `lc`.`_hb_new` WHERE !(OLD.`id` &lt;=&gt; NEW.`id`) AND `lc`.`_hb_new`.`id` &lt;=&gt; OLD.`id`;</span><br><span class="line">    REPLACE INTO `lc`.`_hb_new` (`id`, `ts`, `ts2`) VALUES (NEW.`id`, NEW.`ts`, NEW.`ts2`);</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="死锁案例一"><a href="#死锁案例一" class="headerlink" title="死锁案例一"></a>死锁案例一</h2><p>pt-osc改表操作与业务insert语句形成死锁，业务insert操作回滚。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>MySQL5.7.26、RC隔离级别、innodb_autoinc_lock_mode=1</p>
<p>表结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;自增主键&apos;,</span><br><span class="line">  `c1` int(11) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;c1&apos;,</span><br><span class="line">  `c2` int(11) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;c2&apos;</span><br><span class="line">  `c3` int(11) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;c3&apos;</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COMMENT=&apos;&apos;;</span><br></pre></td></tr></table></figure></p>
<h3 id="死锁日志"><a href="#死锁日志" class="headerlink" title="死锁日志"></a>死锁日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">2020-04-26T06:24:05.340343+08:00 733947 [Note] InnoDB: Transactions deadlock detected, dumping detailed information.</span><br><span class="line">2020-04-26T06:24:05.341246+08:00 733947 [Note] InnoDB: </span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line"></span><br><span class="line">TRANSACTION 918773485, ACTIVE 0 sec setting auto-inc lock</span><br><span class="line">mysql tables in use 2, locked 2</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 2</span><br><span class="line">MySQL thread id 668554, OS thread handle 139777592952576, query id 2675769996 192.168.1.1 test_user update</span><br><span class="line">REPLACE INTO `test_db`.`_t_new` (`id`, `c1`, `c2`, `c3`) VALUES (NEW.`id`, NEW.`c1`, NEW.`c2`, NEW.`c3`)</span><br><span class="line">2020-04-26T06:24:05.341319+08:00 733947 [Note] InnoDB: *** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"></span><br><span class="line">TABLE LOCK table `test_db`.`_t_new` trx id 918773485 lock mode AUTO-INC waiting</span><br><span class="line"></span><br><span class="line">2020-04-26T06:24:05.341351+08:00 733947 [Note] InnoDB: *** (2) TRANSACTION:</span><br><span class="line"></span><br><span class="line">TRANSACTION 918773482, ACTIVE 1 sec fetching rows</span><br><span class="line">mysql tables in use 2, locked 2</span><br><span class="line">120 lock struct(s), heap size 24784, 8894 row lock(s), undo log entries 8099</span><br><span class="line">MySQL thread id 733947, OS thread handle 139777597007616, query id 2675769985 localhost root Sending data</span><br><span class="line">INSERT LOW_PRIORITY IGNORE INTO `test_db`.`_t_new` (`id`, `c1`, `c2`, `c3`) SELECT `id`, `c1`, `c2`, `c3` FROM </span><br><span class="line">`test_db`.`t` FORCE INDEX(`PRIMARY`) WHERE ((`id` &gt;= &apos;95439963&apos;)) AND ((`id` &lt;= &apos;95448404&apos;)) LOCK IN SHARE MODE </span><br><span class="line">2020-04-26T06:24:05.341398+08:00 733947 [Note] InnoDB: *** (2) HOLDS THE LOCK(S):</span><br><span class="line"></span><br><span class="line">TABLE LOCK table `test_db`.`_t_new` trx id 918773482 lock mode AUTO-INC</span><br><span class="line">2020-04-26T06:24:05.341415+08:00 733947 [Note] InnoDB: *** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"></span><br><span class="line">RECORD LOCKS space id 974 page no 145414 n bits 80 index PRIMARY of table `test_db`.`t` trx id 918773482 lock mode S locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 9 PHYSICAL RECORD: n_fields 27; compact format; info bits 0</span><br><span class="line">0: len 4; hex 85b06d55; asc   mU;; --&apos;5b06d55&apos;从16进制转换为10进制,得到的值为 95448405</span><br><span class="line"></span><br><span class="line">1: len 4; hex 80002712; asc    ;;</span><br><span class="line">2: len 4; hex 800c24d7; asc   $ ;;</span><br><span class="line">3: len 4; hex 80000003; asc     ;;</span><br><span class="line"></span><br><span class="line">2020-04-26T06:24:05.342491+08:00 733947 [Note] InnoDB: *** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure>
<h3 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h3><p>事务：918773482<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当前的SQL语句: </span><br><span class="line">    INSERT LOW_PRIORITY IGNORE INTO `test_db`.`_t_new` (`id`, `c1`, `c2`, `c3`) SELECT `id`, `c1`, `c2`, `c3` FROM </span><br><span class="line">    `test_db`.`t` FORCE INDEX(`PRIMARY`) WHERE ((`id` &gt;= &apos;95439963&apos;)) AND ((`id` &lt;= &apos;95448404&apos;)) LOCK IN SHARE MODE; </span><br><span class="line"></span><br><span class="line">持有的锁信息：</span><br><span class="line">    TABLE LOCK table `test_db`.`_t_new` ... lock mode AUTO-INC --表示持有表_t_new上的自增长锁;</span><br><span class="line"></span><br><span class="line">在等待的锁信息:</span><br><span class="line">     index PRIMARY of table `test_db`.`t` --表示在等的是表t的主键索引上面的锁;</span><br><span class="line">     lock_mode S locks rec but not gap waiting --表示需要加一个共享锁(读锁)，当前的状态是等待中;</span><br><span class="line">     0: len 4; hex 85b06d55; asc   mU;;   --主键字段, 5b06d55的16进制为转换为10进制得到值为: 95448405;   </span><br><span class="line"></span><br><span class="line">通过分析得知：</span><br><span class="line">    TRANSACTION 918773482持有的锁: 表_t_new的自增长锁; </span><br><span class="line">    TRANSACTION 918773482在等待TRANSACTION 918773485的锁: 表t的主键索引primary: record lock: id=95448405。</span><br></pre></td></tr></table></figure></p>
<p>事务：918773485<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">当前的SQL语句: </span><br><span class="line">    REPLACE INTO `test_db`.`_t_new` (`id`, `c1`, `c2`, `c3`) VALUES (NEW.`id`, NEW.`c1`, NEW.`c2`, NEW.`c3`);</span><br><span class="line"></span><br><span class="line">持有的锁信息:</span><br><span class="line">    根据TRANSACTION 918773482在等待TRANSACTION 918773485的锁为 primary: record lock: id=95448405 的行锁，所以推导出TRANSACTION 918773485持有表t主键索引 id=95448405 的行锁;</span><br><span class="line"></span><br><span class="line">在等待的锁信息:</span><br><span class="line">    TABLE LOCK table `test_db`.`_t_new` ... lock mode AUTO-INC waiting --表示在等表_t_new上的自增长锁;</span><br><span class="line"></span><br><span class="line">通过分析得知：    </span><br><span class="line">    TRANSACTION 918773485持有的锁：持有表t主键索引primary id=95448405 的行锁；</span><br><span class="line">    TRANSACTION 918773485在等待TRANSACTION 918773482的锁: 表_t_new上的自增长锁。</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">时间点</th>
<th style="text-align:center">918773482<br>pt-osc改表批量导入语句</th>
<th style="text-align:center">918773485918773485<br>业务正常插入操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">begin</td>
<td style="text-align:center">begin</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">INSERT LOW_PRIORITY IGNORE INTO _t_new (id, c1, c2, c3) SELECT id, c1, c2, c3 FROM test_db.t FORCE INDEX(PRIMARY) WHERE ((id &gt;= ‘95439963’)) AND ((id &lt;= ‘95448404’)) LOCK IN SHARE MODE;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:center">持有的锁: 表_t_new: AUTO-INC</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:center"></td>
<td style="text-align:center">INSERT INTO t (c1, c2, c3) VALUES (0, 0, 0);<br>持有表t主键索引 id=95448405 的行锁(排他X锁)</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:center"></td>
<td style="text-align:center">REPLACE INTO _t_new (id, c1, c2, c3) VALUES (NEW.id, NEW.c1, NEW.c2, NEW.c3);<br>等待的锁: 表_t_new: AUTO-INC</td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:center">等待的锁: 表t: primary: record lock: id=95448405</td>
</tr>
</tbody>
</table>
<p>T3被T1阻塞，T4被T2阻塞，因此锁资源请求形成了环路，进而触发死锁检测，MySQL会把执行代价最小的事务回滚掉，让其它事务得以继续进行;</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ol>
<li>为什么pt-osc会去申请原表t的主键锁呢？<br>因为 id &lt;= 95448404 是范围等值查询并且id=95448404是当前主键索引的最大值 ， 锁的过程实际上是id&lt;=95448404的下一条记录也就是这个索引页的最大记录supremum（如果这个在RC隔离级别下没有被锁，则会立即释放），需要访问到 id=95448405 才会停止下来，所以需要申请 持有 id=95448405 的行锁 ，因此被 T2时刻 的SQL语句阻塞。</li>
</ol>
<p>TRANSACTION 918773482的事务语句是pt-osc拷贝的最后一个chunk-size，并且期间其它事务有对原表做insert操作， 所以才会发生死锁。</p>
<h2 id="死锁案例二"><a href="#死锁案例二" class="headerlink" title="死锁案例二"></a>死锁案例二</h2><p>pt-osc改表操作与业务update语句形成死锁，业务update操作回滚。</p>
<h3 id="环境-1"><a href="#环境-1" class="headerlink" title="环境"></a>环境</h3><p>阿里云MySQL5.6、RC隔离级别</p>
<p>表结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;自增主键&apos;,</span><br><span class="line">  `c1` int(11) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;c1&apos;,</span><br><span class="line">  `c2` int(11) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;c2&apos;</span><br><span class="line">  `c3` int(11) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;c3&apos;</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_c1_c2(`c1`,`c2`)</span><br><span class="line">) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COMMENT=&apos;&apos;;</span><br></pre></td></tr></table></figure></p>
<h3 id="死锁日志-1"><a href="#死锁日志-1" class="headerlink" title="死锁日志"></a>死锁日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">2020-05-11 15:04:22 7f728ebff700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 582527418, ACTIVE 0.002 sec setting auto-inc lock</span><br><span class="line">mysql tables in use 2, locked 2</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1184, 1 row lock(s), undo log entries 2</span><br><span class="line">LOCK BLOCKING MySQL thread id: 34439719 block 17762714</span><br><span class="line">MySQL thread id 17762714, OS thread handle 0x7f728eaba700, query id 323487893 192.168.55.8 test update</span><br><span class="line">REPLACE INTO `test`.`_t_new` (`id`, `c1`, `c2`, `c3`) VALUES (NEW.`id`, NEW.`c1`, NEW.`c2`, NEW.`c3`, NEW.`c4`)</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">TABLE LOCK table `test`.`_t_new` trx id 582527418 lock mode AUTO-INC waiting</span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 582527416, ACTIVE 0.012 sec inserting</span><br><span class="line">mysql tables in use 2, locked 2</span><br><span class="line">9 lock struct(s), heap size 1184, 6 row lock(s), undo log entries 3</span><br><span class="line">MySQL thread id 34439719, OS thread handle 0x7f728ebff700, query id 323487888 192.168.58.10 test update</span><br><span class="line">REPLACE INTO `test`.`_t_new` (`id`, `c1`, `c2`, `c3`) VALUES (NEW.`id`, NEW.`c1`, NEW.`c2`, NEW.`c3`)</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">TABLE LOCK table `test`.`_t_new` trx id 582527416 lock mode AUTO-INC</span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 51 page no 467072 n bits 224 index `idx_c1_c2` of table `test`.`_t_new` trx id 582527416 lock_mode X waiting</span><br><span class="line">Record lock, heap no 154 PHYSICAL RECORD: n_fields 4; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 000000000f97b07e; asc        ~;;</span><br><span class="line"> 1: len 1; hex 08; asc  ;;</span><br><span class="line"> 2: len 1; hex 00; asc  ;;</span><br><span class="line"> 3: len 8; hex 0000000005f1acf1; asc         ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure>
<h3 id="死锁分析-1"><a href="#死锁分析-1" class="headerlink" title="死锁分析"></a>死锁分析</h3><p>事务：582527416<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">原业务语句：</span><br><span class="line">UPDATE t SET c3 = &apos;xx&apos; WHERE c1 = &apos;xx&apos; AND c2 = &apos;xx&apos; LIMIT 1</span><br><span class="line"></span><br><span class="line">经过触发器改写后语句：</span><br><span class="line">begin</span><br><span class="line">UPDATE t SET c3 = &apos;xx&apos; WHERE c1 = &apos;xx&apos; AND c2 = &apos;xx&apos; LIMIT 1</span><br><span class="line">DELETE IGNORE FROM `test`.`_t_new` WHERE !(OLD.`id` &lt;=&gt; NEW.`id`) AND `test`.`_t_new`.`id` &lt;=&gt; OLD.`id`</span><br><span class="line">REPLACE INTO `test`.`_t_new` (`id`, `c1`, `c2`, `c3`) VALUES (NEW.`id`, NEW.`c1`, NEW.`c2`, NEW.`c3`); </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">锁分析：</span><br><span class="line">当前持有  lock mode AUTO-INC 锁（表级别）</span><br><span class="line">由于存在唯一索引，所以在插入的时候会进行唯一性检测，此时需要获取 next-key lock</span><br></pre></td></tr></table></figure></p>
<p>事务：TRANSACTION 582527418<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">原业务语句：</span><br><span class="line">UPDATE t SET c3 = &apos;xx&apos; WHERE c1 = &apos;xx&apos; AND c2 = &apos;xx&apos; LIMIT 1</span><br><span class="line"></span><br><span class="line">经过触发器改写后语句：</span><br><span class="line">begin</span><br><span class="line">UPDATE t SET c3 = &apos;xx&apos; WHERE c1 = &apos;xx&apos; AND c2 = &apos;xx&apos; LIMIT 1</span><br><span class="line">DELETE IGNORE FROM `test`.`_t_new` WHERE !(OLD.`id` &lt;=&gt; NEW.`id`) AND `test`.`_t_new`.`id` &lt;=&gt; OLD.`id`</span><br><span class="line">REPLACE INTO `test`.`_t_new` (`id`, `c1`, `c2`, `c3`) VALUES (NEW.`id`, NEW.`c1`, NEW.`c2`, NEW.`c3`); </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">锁分析：</span><br><span class="line">持有记录的x锁和插入意向锁 等待_t_new表级别的auto-inc 锁</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">时间点</th>
<th style="text-align:center">sesson 1<br>582527416</th>
<th style="text-align:center">session 2<br>582527418</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">begin</td>
<td style="text-align:center">begin</td>
</tr>
<tr>
<td style="text-align:center">T1</td>
<td style="text-align:center">REPLACE INTO <code>test</code>.<code>_t_new</code> (<code>id</code>, <code>c1</code>, <code>c2</code>, <code>c3</code>) VALUES (NEW.<code>id</code>, NEW.<code>c1</code>, NEW.<code>c2</code>, NEW.<code>c3</code>); <br>插入前检查，唯一键上的插入意向锁</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T2</td>
<td style="text-align:center"></td>
<td style="text-align:center">REPLACE INTO <code>test</code>.<code>_t_new</code> (<code>id</code>, <code>c1</code>, <code>c2</code>, <code>c3</code>) VALUES (NEW.<code>id</code>, NEW.<code>c1</code>, NEW.<code>c2</code>, NEW.<code>c3</code>);<br>插入前检查，唯一键上的插入意向锁</td>
</tr>
<tr>
<td style="text-align:center">T3</td>
<td style="text-align:center">执行插入，拥有_t_new的auto-inc锁，等待唯一键插入意向锁释放</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">T4</td>
<td style="text-align:center"></td>
<td style="text-align:center">执行插入，等待_t_new的auto-inc锁</td>
</tr>
</tbody>
</table>
<h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><ol>
<li>为什么平时业务同样的update，但是只有在改表时才会触发死锁呢？<br>因为改表过程中，是增量将数据导入，此时还未导入到update所操作的id上。业务update执行时，触发器转换后的语句在执行时，会申请_t_new表的最大值之间的auto-inc锁。当业务并发大时可能就会造成业务update语句之间的死锁情况。</li>
</ol>
<h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ol>
<li>设置pt-osc的chunk-size为更小的值，可以减少死锁的发生，但是不可能避免死锁的发生。</li>
<li>如果参数innodb_autoinc_lock_mode的值为2，大大降低死锁发生的概率，原因如下：<br>造成本案例死锁的原因之一就是在参数innodb_autoinc_lock_mode=1的环境下，持有的自增锁直到SQL语句结束后才释放；<br>如果参数innodb_autoinc_lock_mode=2，自增锁在申请后就释放，不需要等语句结束，大大缩短了持有自增锁的时间，从而降低了死锁发生的概率。</li>
<li>数据库版本为MySQL 8.0.18或者以上， 事务隔离为RR可重复读则不会出现本案例的死锁，原因如下：<br>8.0.18或者以上的版本中，对加锁规则有一个优化：在RR可重复读级别下，唯一索引上的范围查询，不再需要访问到不满足条件的第一个值为止（即不再需要对不必要的数据上锁）。在叶老师的这篇文章中有说明：<a href="https://mp.weixin.qq.com/s/xDKKuIvVgFNiKp5kt2NIgA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xDKKuIvVgFNiKp5kt2NIgA</a> InnoDB这个将近20年的”bug”修复了；</li>
</ol>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/mJ6a-sV2C2ru5pA5QNAAZQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mJ6a-sV2C2ru5pA5QNAAZQ</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> PT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL机制之index merge]]></title>
      <url>/2020/05/31/new/MySQL/MySQL%E6%9C%BA%E5%88%B6%E4%B9%8Bindex-merge/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>查询时where后面可能会涉及到多个字段，它们之间进行AND或OR。在MySQL 5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。从5.1开始引入了<code>index merge</code>技术。<br><code>index merge</code>技术就是<font color="red">对多个索引分别进行条件扫描，然后将他们各自的结果进行合并</font></p>
<p>该特性主要会体现在以下场景：</p>
<ol>
<li>对OR语句求并集</li>
<li>对AND语句求交集</li>
<li>对AND和OR组合语句求结果</li>
</ol>
<p>在满足index merge条件下的查询计划中会出现<code>type:index_merge</code>。</p>
<h2 id="AND取交集-union"><a href="#AND取交集-union" class="headerlink" title="AND取交集(union)"></a>AND取交集(union)</h2><p>union就是多个索引条件扫描，对得到的结果进行并集运算，显然是多个条件之间进行的是 OR 运算。<br>案例：<code>SELECT * FROM tmp_index_merge where key1_part1 = 2 and key2_part1 = 4\G</code></p>
<h2 id="OR取并集-intersect"><a href="#OR取并集-intersect" class="headerlink" title="OR取并集(intersect)"></a>OR取并集(intersect)</h2><p>intersect就是多个索引条件扫描得到的结果进行交集运算。<br>案例：<code>SELECT * FROM tmp_index_merge where key1_part1 = 2 or key2_part1 = 4\G</code></p>
<h2 id="AND和OR组合取并集-sort-union"><a href="#AND和OR组合取并集-sort-union" class="headerlink" title="AND和OR组合取并集(sort_union)"></a>AND和OR组合取并集(sort_union)</h2><p>多个条件扫描进行 OR 运算，但是不符合 index union merge算法的，此时可能会使用 sort_union算法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key_col1 &lt; 10 OR key_col2 &lt; 20;</span><br><span class="line">SELECT * FROM tbl_name WHERE (key_col1 &gt; 10 OR key_col2 = 20) AND nonkey_col=30;</span><br></pre></td></tr></table></figure></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在MySQL5.6.7之前的版本中，存在<font color="red">range优先原则</font>。只要可以使用Range访问方式，那就不会再使用index merge。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>索引合并机制并不是什么新鲜东西，但是仍然存在很多人认为一条查询只能使用一个索引的观念。本篇文章只是简单的介绍MySQL存在这么一个机制，并未过深的研究。<br>简言之，索引合并会同时利用多个索引进行查询，尽可能得过滤掉不需要的数据行，然后再进行一次统一的回表行为。较少无谓的回表行为。</p>
<blockquote>
<p><a href="http://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html</a><br><a href="https://www.orczhou.com/index.php/2013/01/mysql-source-code-query-optimization-index-merge/" target="_blank" rel="noopener">https://www.orczhou.com/index.php/2013/01/mysql-source-code-query-optimization-index-merge/</a><br><a href="http://www.cnblogs.com/nocode/archive/2013/01/28/2880654.html" target="_blank" rel="noopener">http://www.cnblogs.com/nocode/archive/2013/01/28/2880654.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL机制介绍之NLJ、BNL、BKA]]></title>
      <url>/2020/05/30/new/MySQL/MySQL%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D%E4%B9%8BNLJ%E3%80%81BNL%E3%80%81BKA/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MySQL 5.5版本前，MySQL本身只支持一种表间关联方式，就是嵌套循环(Nested Loop)。如果关联表的数据量很大，则join关联的执行时间会非常长。<br>在5.5版本中，MySQL通过引入Block Nested-Loop Join(BNL)算法来优化嵌套执行。</p>
<h2 id="NLJ"><a href="#NLJ" class="headerlink" title="NLJ"></a>NLJ</h2><p>将驱动表的结果集作为循环基础数据，然后循环从该结果集中每次一条获取数据作为下一个表的过滤条件查询数据，然后合并结果。<br>如果有多表join，则将前面的表的结果集作为循环数据，取到每行再到链接的下一个表循环匹配。</p>
<h3 id="SNLJ"><a href="#SNLJ" class="headerlink" title="SNLJ"></a>SNLJ</h3><p>Simple Nested-Loops Join(SNLJ，简单嵌套循环联接)，该算法比较简单、直接。驱动表中的每一条记录都与被驱动表中的记录进行匹配判断。对于两表连接，驱动表只需要被访问一次，而被驱动表需要访问多次。这个算法的开销非常大，复杂度为笛卡尔积。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9s7d0psuj307406mmxc.jpg" alt=""><br>其实现伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For each row r in R do                         -- 扫描R表（驱动表）</span><br><span class="line">    For each row s in S do                     -- 扫描S表（被驱动表）</span><br><span class="line">        If r and s satisfy the join condition  -- 如果r和s满足join条件</span><br><span class="line">            Then output the tuple &lt;r, s&gt;       -- 返回结果集</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="INLJ"><a href="#INLJ" class="headerlink" title="INLJ"></a>INLJ</h3><p>Index Nested-Loops Join(INLJ，基于索引的嵌套循环联接)，由于SNLJ算法非常粗暴，每次都会扫描全表。所以一般会在被驱动表的相关字段上建立索引，以降低SNLJ的复杂度，这种算法就被称为INLJ。<br>外表中的每条记录通过内表的索引进行访问，就是读取外部表一行数据，然后去内部表索引进行二分查找匹配；而一般B+树的高度为3~4层，也就是说匹配一次的io消耗也就3~4次，因此索引查询的成本是比较固定的，故优化器都倾向于使用记录数少的表作为外表。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9sg65i6yj309n0a33z0.jpg" alt=""><br>其实现为代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For each row r in R do                     -- 扫描R表</span><br><span class="line">    lookup s in S index                    -- 查询S表的索引（固定3~4次IO，B+树高度）</span><br><span class="line">        If find s == r                     -- 如果r匹配了索引s</span><br><span class="line">            Then output the tuple &lt;r, s&gt;   -- 返回结果集</span><br></pre></td></tr></table></figure></p>
<h2 id="BNL"><a href="#BNL" class="headerlink" title="BNL"></a>BNL</h2><p>在SNLJ中，被驱动表需要进行全表扫描多次，由于MySQL的内存有限，所以可能会导致被驱动表中的数据页频繁的被读进内存又刷到磁盘中。<br>能不能有一个办法避免这样的情况发生呢？于是便加入了<code>join buffer</code>的概念。一次性判断多条记录，从而减少全表扫描的次数。<br>这种方式被称为BNL，BNL将外层循环的行/结果集存入到join buffer，然后每次遍历被驱动表都与join buffer中的数据进行比较。以此来减少全表扫描的次数。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9smi9vqzj30a70873z3.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For each tuple r in R do                             -- 扫描外表R</span><br><span class="line">    store used columns as p from R in Join Buffer    -- 将部分或者全部R的记录保存到Join Buffer中，记为p</span><br><span class="line">    For each tuple s in S do                         -- 扫描内表S</span><br><span class="line">        If p and s satisfy the join condition        -- p与s满足join条件</span><br><span class="line">            Then output the tuple                    -- 返回为结果集</span><br></pre></td></tr></table></figure></p>
<p>开启BNL的方式：<code>set optimizer_switch=&#39;block_nested_loop=on&#39;</code></p>
<h3 id="join-buffer"><a href="#join-buffer" class="headerlink" title="join buffer"></a>join buffer</h3><p>在MySQL实例中存在多种join查询的语句时，可通过调整join buffer的大小来减少磁盘访问。<br>但是由于join buffer是会话级别的，所以并不能设置太大，避免出现内存问题。</p>
<ul>
<li>系统变量Join_buffer_size决定了Join Buffer的大小。</li>
<li>Join Buffer可被用于联接是ALL、index、和range的类型。</li>
<li>每次联接使用一个Join Buffer，因此多表的联接可以使用多个Join Buffer。</li>
<li>Join Buffer在联接发生之前进行分配，在SQL语句执行完后进行释放。</li>
<li>Join Buffer只存储要进行查询操作的相关列数据，而不是整行的记录。</li>
</ul>
<h2 id="BKA"><a href="#BKA" class="headerlink" title="BKA"></a>BKA</h2><p>Batched Key Access Join(BKA，批量键访问联接)，MySQL在5.6版本中引入了BKA算法来对INLJ算法进行优化。<br>BKA其实就等价于MRR+INLJ。关于MRR的介绍可以参考<a href="https://omg-by.github.io/2020/05/27/new/MySQL/MySQL%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D%E4%B9%8BMRR/" target="_blank" rel="noopener">MySQL机制介绍之MRR</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gf9t27j1bhj30ki09p75j.jpg" alt=""><br>BKA主要工作流程为：</p>
<ol>
<li>将外部表中相关的列放入Join Buffer中。</li>
<li>批量的将Key（索引键值）发送到Multi-Range Read（MRR）接口。</li>
<li>Multi-Range Read（MRR）通过收到的Key，根据其对应的ROWID进行排序，然后再进行数据的读取操作。</li>
<li>返回结果集给客户端。</li>
</ol>
<p>开启BKA方式：<code>SET optimizer_switch=&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;;</code> </p>
<h2 id="CHJ"><a href="#CHJ" class="headerlink" title="CHJ"></a>CHJ</h2><p>// TODO studing</p>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/27687" target="_blank" rel="noopener">https://yq.aliyun.com/articles/27687</a><br><a href="https://www.cnblogs.com/zuochanzi/p/10409752.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuochanzi/p/10409752.html</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL机制介绍之ICP]]></title>
      <url>/2020/05/28/new/MySQL/MySQL%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D%E4%B9%8BICP/</url>
      <content type="html"><![CDATA[<h2 id="ICP是什么"><a href="#ICP是什么" class="headerlink" title="ICP是什么"></a>ICP是什么</h2><p>Index Condition Pushdown，也称为索引条件下推，体现在执行计划中会出现<code>Using index condition</code>。<br>ICP优化适用于MySQL利用索引从表里检索数据的场景。<br>使用命令<code>set optimizer_switch=&#39;index_condition_pushdown=on&#39;</code>开启</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>索引访问方式是range/ref/eq_ref/ref_or_null，并且需要访问表的完整行记录</li>
<li>InnoDB和MYISAM表，包括分区的表(5.7)</li>
<li>对于InnoDB表，ICP只适用于二级索引。ICP的目标是减少访问表的完整行的读取量从而减少IO操作。</li>
<li>不支持建立在虚拟列上的二级索引</li>
<li>引用子查询、存储函数的条件没法下推</li>
<li>Triggered conditions 也没法下推</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="不使用ICP"><a href="#不使用ICP" class="headerlink" title="不使用ICP"></a>不使用ICP</h3><ol>
<li>用二级索引查找数据的主键</li>
<li>用主键回表读取完整的行记录</li>
<li>引擎层利用where语句的条件对行记录进行过滤<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf83cpvaofj30gw09bq3i.jpg" alt=""></li>
</ol>
<h3 id="使用ICP"><a href="#使用ICP" class="headerlink" title="使用ICP"></a>使用ICP</h3><ol>
<li>用二级索引查找数据的主键</li>
<li>如果where条件中的字段在复合索引中，引擎层对where条件里的字段进行过滤后，返回主键</li>
<li>利用主键回表读取完整的行记录</li>
<li>引擎层用where语句的剩余条件对行记录进行过滤<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf83ct0w3xj30ge09b74t.jpg" alt=""></li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>ICP的优化在引擎层就能够过滤掉大量的数据，这样无疑能够减少了对base table和mysql server的访问次数，提升了性能。</p>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html</a><br><a href="https://yq.aliyun.com/articles/259696" target="_blank" rel="noopener">https://yq.aliyun.com/articles/259696</a><br><a href="https://zhuanlan.zhihu.com/p/73035620" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73035620</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL机制介绍之MRR]]></title>
      <url>/2020/05/27/new/MySQL/MySQL%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D%E4%B9%8BMRR/</url>
      <content type="html"><![CDATA[<h2 id="什么是MRR"><a href="#什么是MRR" class="headerlink" title="什么是MRR"></a>什么是MRR</h2><p>Multi-Range Read Optimization，是优化器将随机IO转换成顺序IO以降低查询过程中IO开销的一种手段。<br>它的好处有：</p>
<ul>
<li>使数据访问由随机变为顺序</li>
<li>减少缓冲池中页被替换的次数</li>
<li>批量处理查询操作</li>
</ul>
<p>可以通过<code>set optimizer_switch=&#39;mrr=on&#39;;</code>命令进行开启。</p>
<h3 id="不使用MRR"><a href="#不使用MRR" class="headerlink" title="不使用MRR"></a>不使用MRR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set optimizer_switch=&apos;mrr=off&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  explain select * from test.t1 where (a between 1 and 10) and (c between 9 and 10) ;</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+------------------------------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key  | key_len | ref  | rows | Extra                              |</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | range | mrrx,xx       | xx   | 5       | NULL |    2 | Using index condition; Using where |</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>在不使用MRR时，优化器需要根据二级索引返回的记录来进行回表，这个过程一般会有较多的随机IO操作。</p>
<h3 id="使用MRR"><a href="#使用MRR" class="headerlink" title="使用MRR"></a>使用MRR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set optimizer_switch=&apos;mrr=on&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  explain select * from test.t1 where (a between 1 and 10) and (c between 9 and 10) ;</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+-----------------------------------------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key  | key_len | ref  | rows | Extra                                         |</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+-----------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t1    | range | mrrx,xx       | xx   | 5       | NULL |    2 | Using index condition; Using where; Using MRR |</span><br><span class="line">+----+-------------+-------+-------+---------------+------+---------+------+------+-----------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>在使用了MRR时，SQL语句的执行过程为：</p>
<ol>
<li>优化器将二级索引查询到的记录放到一块缓冲区中(read_rnd_buffer_size)</li>
<li>如果二级索引扫描到文件末尾或者缓冲区已满，则使用快排对缓冲区中的内容按照主键进行排序</li>
<li>用户线程调用MRR接口获取cluster index，然后根据cluster index获取行数据</li>
<li>当缓冲区中的cluster index取完数据，则继续调用过程2、3，直到扫描结束</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MRR特性就是在查询过程中，先将满足条件的id查询出来并进行排序后，再进行批量查询操作。从而实现随机IO到顺序IO的转换，提升性能。</p>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/mrr-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/mrr-optimization.html</a><br><a href="https://zhuanlan.zhihu.com/p/110154066" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110154066</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis扩展命令实现]]></title>
      <url>/2020/05/17/new/Redis/Redis%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>上周，参加公司后端部门开发的分享。<br>在期间，该开发吐槽Redis好几个使用不便利的地方。</p>
<ol>
<li><font color="red">Redis没有批量设置过期时间的命令</font></li>
<li><font color="red">incr 不存在的key的时候，并不会设置过期时间。导致持久化key的存在</font>

</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gevcwyswasj30uk0l20wd.jpg" alt=""></p>
<a id="more"></a>
<p>作为客户端，解决办法只有使用lua脚本来进行实现：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gevcuiy2fbj30zk09g0v0.jpg" alt=""></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>虽然说使用lua脚本也能够解决这样的问题，但是对用户体验不太友好，同时也增加了编码的复杂度。<br>而且这样的功能实现起来并不算复杂，为什么不可以在Redis服务端去实现这样的功能呢？</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>说干咱就干。<br>利用周末的时间，简单的实现了其中的一个槽点功能:mexpire<br>可能会存在考虑欠缺的地方，但基本功能还是实现了的。</p>
<h3 id="expire-c"><a href="#expire-c" class="headerlink" title="expire.c"></a>expire.c</h3><p><code>expire.c</code>主要是对过期管理的文件。<br>一开始只想实现mexpire功能，结果发现还有<code>expireta</code>、<code>pexpire</code>、<code>pexpirate</code>命令跟<code>expire</code>命令相近，并且底层实现都是同一个函数。<br>于是就一起实现了。</p>
<p>逻辑其实很简单，就是遍历传过来的参数。</p>
<ul>
<li>如果key存在，就设置过期时间。并计数。</li>
<li>如果key不存在，就跳过。</li>
<li>返回成功设置过期时间个数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">void mexpireGenericCommand(client *c, long long basetime, int unit)&#123;</span><br><span class="line"></span><br><span class="line">    if ((c-&gt;argc % 2) == 0)&#123;</span><br><span class="line">        addReplyErrorFormat(c, &quot;wrong number of arguments for %s&quot;, c-&gt;cmd-&gt;name);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int j;</span><br><span class="line">    robj *key, *param;</span><br><span class="line">    long long when;</span><br><span class="line">    int nums = 0;</span><br><span class="line">    for (j = 1; j &lt; c-&gt;argc; j+=2)&#123;</span><br><span class="line">        key = c-&gt;argv[j];</span><br><span class="line">        param = c-&gt;argv[j+1];</span><br><span class="line">        if ((getLongLongFromObject(param, &amp;when) != C_OK) || lookupKeyWrite(c-&gt;db,key) == NULL)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (unit == UNIT_SECONDS) when *= 1000;</span><br><span class="line">        when += basetime;</span><br><span class="line"></span><br><span class="line">        nums++;</span><br><span class="line">        if (when &lt;= mstime() &amp;&amp; !server.loading &amp;&amp; !server.masterhost) &#123;</span><br><span class="line">            int deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c-&gt;db,key) :</span><br><span class="line">                          dbSyncDelete(c-&gt;db,key);</span><br><span class="line">            serverAssertWithInfo(c,key,deleted);</span><br><span class="line">            server.dirty++;</span><br><span class="line"></span><br><span class="line">            signalModifiedKey(c-&gt;db,key);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,key,c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            setExpire(c,c-&gt;db,key,when);</span><br><span class="line">            signalModifiedKey(c-&gt;db,key);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;expire&quot;,key,c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c, nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mexpireCommand(client *c)&#123;</span><br><span class="line">    mexpireGenericCommand(c, mstime(), UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mexpireatCommand(client *c) &#123;</span><br><span class="line">    mexpireGenericCommand(c,0,UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mpexpireCommand(client *c) &#123;</span><br><span class="line">    mexpireGenericCommand(c,mstime(),UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mpexpireatCommand(client *c) &#123;</span><br><span class="line">    mexpireGenericCommand(c,0,UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="server-h"><a href="#server-h" class="headerlink" title="server.h"></a>server.h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void mexpireCommand(client *c);</span><br><span class="line">void mexpireatCommand(client *c);</span><br><span class="line">void mpexpireCommand(client *c);</span><br><span class="line">void mpexpireatCommand(client *c);</span><br></pre></td></tr></table></figure>
<h3 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;mexpire&quot;,mexpireCommand,-3, &quot;write @keyspace&quot;,0,NULL,1,-1,2,0,0,0&#125;,</span><br><span class="line">&#123;&quot;mexpireat&quot;,mexpireatCommand,-3,&quot;write @keyspace&quot;, 0,NULL,1,-1,2,0,0,0&#125;,</span><br><span class="line">&#123;&quot;mpexpire&quot;,mpexpireCommand,-3, &quot;write @keyspace&quot;, 0,NULL,1,-1,2,0,0,0&#125;,</span><br><span class="line">&#123;&quot;mpexpireat&quot;,mpexpireatCommand,-3, &quot;write @keyspace&quot;, 0,NULL,1,-1,2,0,0,0&#125;,</span><br></pre></td></tr></table></figure>
<p>这里有必要说明一下上面配置的解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct redisCommand &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    int arity;</span><br><span class="line">    char *sflags;   /* Flags as string representation, one char per flag. */</span><br><span class="line">    uint64_t flags; /* The actual flags, obtained from the &apos;sflags&apos; field. */</span><br><span class="line">    /* Use a function to determine keys arguments in a command line.</span><br><span class="line">     * Used for Redis Cluster redirect. */</span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    /* What keys should be loaded in background when calling this command? */</span><br><span class="line">    int firstkey; /* The first argument that&apos;s a key (0 = no keys) */</span><br><span class="line">    int lastkey;  /* The last argument that&apos;s a key */</span><br><span class="line">    int keystep;  /* The step between first and last key */</span><br><span class="line">    long long microseconds, calls;</span><br><span class="line">    int id;     /* Command ID. This is a progressive ID starting from 0 that</span><br><span class="line">                   is assigned at runtime, and is used in order to check</span><br><span class="line">                   ACLs. A connection is able to execute a given command if</span><br><span class="line">                   the user associated to the connection has this command</span><br><span class="line">                   bit set in the bitmap of allowed commands. */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>name：命令名称</li>
<li>function：指向函数</li>
<li>arity：参数限制</li>
<li>sflags：命令属性</li>
<li>flags：命令属性掩码，一般为0</li>
<li>get_keys_proc：在复杂参数下，指定那个才是真正的key。一般为NULL</li>
<li>first_key_index：第一个参数所在位置</li>
<li>last_key_index：最后一个参数所在位置</li>
<li>key_step：命令步长</li>
<li>microseconds：命令的度量项，由Redis来设置，并且总是初始化为0。</li>
<li>calls：命令的度量项，由Redis来设置，并且总是初始化为0。</li>
<li>id：命令的权限，由Redis来设置，并且总是初始化为0。</li>
</ul>
<p>只需要修改以上几个文件然后启动就可以了。是不是很简单？<br>PS：前一篇文章中解决哨兵BUG<a href="https://omg-by.github.io/2020/05/17/new/redis_BUG%E8%AE%B0%E5%BD%95%E4%B8%80%E5%88%99/" target="_blank" rel="noopener">《Redis哨兵client-reconfig-script脚本bug记录一则》</a>时，调试就需要重新进行make &amp;&amp; make install操作才行。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>命令使用，跟正常使用其他命令并没有什么太大区别。主要会跟<code>mset</code>命令使用比较相似。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gevdm6iviij30la0e8gsd.jpg" alt=""></p>
<h2 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h2><p>本来还想去github提提issue的，结果发现早就有人跟作者提过这些问题了。我还是too yong to simple呀。<br>但是本着学习的心态，还是提了个issue，问问作者为什么不去实现这些简单又好用的命令。<a href="https://github.com/antirez/redis/issues/7263" target="_blank" rel="noopener">https://github.com/antirez/redis/issues/7263</a><br>后面有时间还是会继续实现其他命令的。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL闪回工具调研]]></title>
      <url>/2020/05/17/new/MySQL/MySQL%E9%97%AA%E5%9B%9E%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>刚入职2个月左右的时候，就遇到了业务误操作，将对测试环境的delete操作，到线上执行了。。。(至于业务为什么有delete权限的账号，俺也不知道)<br>由于公司所有实例都部署在阿里云上，所以只能依赖于阿里云的备份恢复系统来进行数据恢复。但是非常慢，当时是大概花了20分钟才完全恢复（-_-||）。<br>于是乎~工作量又被增加了。领导让我调研数据闪回工具。。。</p>
<p>在工具调研测试过程中，发现了这几个工具存在部分BUG问题，所以给记录一下。避免再次踩坑。</p>
<h2 id="MyFlash"><a href="#MyFlash" class="headerlink" title="MyFlash"></a>MyFlash</h2><p>MyFlash是由美团点评公司技术工程部开发维护的一个回滚DML操作的工具。该工具通过解析v4版本的binlog，完成回滚操作。相对已有的回滚工具，其增加了更多的过滤选项，让回滚更加容易。</p>
<font color="red">通过解析binlog来生成回滚binlog文件。</font>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>多种过滤条件，能够按照需求实现精准过滤</li>
<li>支持离线解析。不会对运行实例造成影响</li>
</ul>
<p>缺点：</p>
<ul>
<li>binlog格式必须为row，并且binlog_row_image=full。</li>
<li>只支持5.6和5.7</li>
<li>只支持DML，不支持DDL</li>
<li>MyFlash不能解析阿里云RDS的binlog</li>
</ul>
<a id="more"></a> 
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 下载源代码</span><br><span class="line">git clone https://github.com/Meituan-Dianping/MyFlash.git</span><br><span class="line"> </span><br><span class="line"># 编译</span><br><span class="line">cd MyFlash</span><br><span class="line">sh build.sh</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node001 binary]# ./flashback --help</span><br><span class="line">Usage:</span><br><span class="line">flashback [OPTION...]</span><br><span class="line"> </span><br><span class="line">Help Options:</span><br><span class="line">-h, --help Show help options</span><br><span class="line"> </span><br><span class="line">Application Options:</span><br><span class="line">--databaseNames databaseName to apply. if multiple, seperate by comma(,) 库名，多个库之间用“，”分割</span><br><span class="line">--tableNames tableName to apply. if multiple, seperate by comma(,) 表名，多个表之间用“，”分割</span><br><span class="line">--start-position start position 开始的位点。如不指定，从文件的开始处回滚。</span><br><span class="line">--stop-position stop position 结束的位点。如不指定，回滚到文件结尾。</span><br><span class="line">--start-datetime start time (format %Y-%m-%d %H:%M:%S) 开始的时间点。如不指定，则不限定时间</span><br><span class="line">--stop-datetime stop time (format %Y-%m-%d %H:%M:%S) 结束的时间点。如不指定，则不限定时间</span><br><span class="line">--sqlTypes sql type to filter . support INSERT, UPDATE ,DELETE. if multiple, seperate by comma(,) 需要回滚的SQL类型，只支持INSERT, UPDATE,DELETE。多个类型之间以“，”分割</span><br><span class="line">--maxSplitSize max file size after split, the uint is M 生成文件分割大小。以M为单位</span><br><span class="line">--binlogFileNames binlog files to process. if multiple, seperate by comma(,) binlog文件名，支持多个文件</span><br><span class="line">--outBinlogFileNameBase output binlog file name base 输出文件名前缀。文件名后缀为：.flashback</span><br><span class="line">--logLevel log level, available option is debug,warning,error</span><br><span class="line">--include-gtids gtids to process 生成的语句包含gtid</span><br><span class="line">--exclude-gtids gtids to skip 跳过gtid</span><br></pre></td></tr></table></figure>
<h2 id="binlog2sql"><a href="#binlog2sql" class="headerlink" title="binlog2sql"></a>binlog2sql</h2><font color="red">通过模拟从库解析数据来生成回滚SQL。</font>

<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>直接生成回滚语句，可读性较好。可根据需求进行选择性回滚</li>
<li>python实现，安装、使用、可扩展性较好</li>
<li>可指定位点、时间、语句类型</li>
<li>支持阿里云、自建实例</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要连接数据库读取binlog，会对线上环境造成一定负载</li>
<li>依赖binlog。如果binlog被清理则无法生成回滚语句</li>
<li>不支持离线解析</li>
<li>解析速度较慢</li>
</ul>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; git clone https://github.com/danfengcao/binlog2sql.git &amp;&amp; cd binlog2sql</span><br><span class="line">shell&gt; pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">用户授权</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">mysql连接配置</span><br><span class="line">-h host; -P port; -u user; -p password</span><br><span class="line"> </span><br><span class="line">解析模式</span><br><span class="line">--stop-never 持续解析binlog。可选。默认False，同步至执行命令时最新的binlog位置。</span><br><span class="line">-K, --no-primary-key 对INSERT语句去除主键。可选。默认False</span><br><span class="line">-B, --flashback 生成回滚SQL，可解析大文件，不受内存限制。可选。默认False。与stop-never或no-primary-key不能同时添加。</span><br><span class="line">--back-interval -B模式下，每打印一千行回滚SQL，加一句SLEEP多少秒，如不想加SLEEP，请设为0。可选。默认1.0。</span><br><span class="line"> </span><br><span class="line">解析范围控制</span><br><span class="line">--start-file 起始解析文件，只需文件名，无需全路径 。必须。</span><br><span class="line">--start-position/--start-pos 起始解析位置。可选。默认为start-file的起始位置。</span><br><span class="line">--stop-file/--end-file 终止解析文件。可选。默认为start-file同一个文件。若解析模式为stop-never，此选项失效。</span><br><span class="line">--stop-position/--end-pos 终止解析位置。可选。默认为stop-file的最末位置；若解析模式为stop-never，此选项失效。</span><br><span class="line">--start-datetime 起始解析时间，格式&apos;%Y-%m-%d %H:%M:%S&apos;。可选。默认不过滤。</span><br><span class="line">--stop-datetime 终止解析时间，格式&apos;%Y-%m-%d %H:%M:%S&apos;。可选。默认不过滤。</span><br><span class="line"> </span><br><span class="line">对象过滤</span><br><span class="line">-d, --databases 只解析目标db的sql，多个库用空格隔开，如-d db1 db2。可选。默认为空。</span><br><span class="line">-t, --tables 只解析目标table的sql，多张表用空格隔开，如-t tbl1 tbl2。可选。默认为空。</span><br><span class="line">--only-dml 只解析dml，忽略ddl。可选。默认False。</span><br><span class="line">--sql-type 只解析指定类型，支持INSERT, UPDATE, DELETE。多个类型用空格隔开，如--sql-type INSERT DELETE。可选。默认为增删改都解析。用了此参数但没填任何类型，则三者都不解析。</span><br></pre></td></tr></table></figure>
<h3 id="发现的问题"><a href="#发现的问题" class="headerlink" title="发现的问题"></a>发现的问题</h3><h4 id="datetime类型恢复错误"><a href="#datetime类型恢复错误" class="headerlink" title="datetime类型恢复错误"></a>datetime类型恢复错误</h4><p>问题描述：</p>
<ul>
<li>存在字段：<code>o_update_time</code> datetime NOT NULL COMMENT</li>
<li>存在值：o_update_time: 0000-00-00 00:00:00</li>
<li>问题一：删除后，binlog2sql生成的insert语句，会将该字段值给设置为NULL。导致插入报错失败。</li>
<li>问题二：阿里云恢复后，数据不一致。</li>
</ul>
<p>删除前数据：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfr3r95zxhj319i0u04ak.jpg" alt=""></p>
<p>binlog2sql生成语句：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfr3sz7dg2j32hc09o79o.jpg" alt=""></p>
<h4 id="varbinary类型字段恢复错误"><a href="#varbinary类型字段恢复错误" class="headerlink" title="varbinary类型字段恢复错误"></a>varbinary类型字段恢复错误</h4><p>现数据库中存在经过加密函数加密后的字段。并存在几条数据。然后删除其中一条语句来测试工具生成回滚语句。<br><code>pwd</code> varbinary(255) NOT NULL COMMENT ‘密码’,<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geurfbnj9fj30jr06c74x.jpg" alt=""></p>
<p>使用binlog2sql生成回滚语句时出错<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1geurfewn49j30ps03b0tc.jpg" alt=""></p>
<h4 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h4><p>在数据类型为decimal、double、float等精度类型时，恢复时会由于精度问题导致恢复数据不一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create table huzb_deci\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: huzb_deci</span><br><span class="line">Create Table: CREATE TABLE `huzb_deci` (</span><br><span class="line">  `id` int(11) NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  `dec` decimal(5,2) DEFAULT NULL,</span><br><span class="line">  `flo` float DEFAULT NULL,</span><br><span class="line">  `dou` double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>插入几条数据后，使用binlog2sql进行恢复。可以发现存在以下问题：</p>
<ol>
<li>double类型在插入时，由于精度问题，插入数据与原数据已经不一致。</li>
<li>float类型数据在使用binlog2sql生成恢复语句时，转换成了double类型，小数点后多了几位精度。</li>
<li>生成的回滚语句执行后，恢复的double类型数据不一致。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into huzb_deci values(1,1.1111111111111111111111111111111,2.22222222,3.333333333333333333333);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; show warnings;</span><br><span class="line">+-------+------+------------------------------------------+</span><br><span class="line">| Level | Code | Message                                  |</span><br><span class="line">+-------+------+------------------------------------------+</span><br><span class="line">| Note  | 1265 | Data truncated for column &apos;dec&apos; at row 1 |</span><br><span class="line">+-------+------+------------------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from huzb_deci;</span><br><span class="line">+----+------+---------+--------------------+</span><br><span class="line">| id | dec  | flo     | dou                |</span><br><span class="line">+----+------+---------+--------------------+</span><br><span class="line">|  1 | 1.11 | 2.22222 | 3.3333333333333335 |</span><br><span class="line">+----+------+---------+--------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 利用binlog2sql生成恢复语句并执行。</span><br><span class="line">mysql&gt; INSERT INTO `huzb`.`huzb_deci`(`id`, `dec`, `flo`, `dou`) VALUES (1, 1.11, 2.22222232818604, 3.33333333333333); #start 260805 end 260989 time 2019-10-30 19:58:48</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from huzb_deci;</span><br><span class="line">+----+------+---------+------------------+</span><br><span class="line">| id | dec  | flo     | dou              |</span><br><span class="line">+----+------+---------+------------------+</span><br><span class="line">|  1 | 1.11 | 2.22222 | 3.33333333333333 |</span><br><span class="line">+----+------+---------+------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><h4 id="日期错误问题修复"><a href="#日期错误问题修复" class="headerlink" title="日期错误问题修复"></a>日期错误问题修复</h4><ol>
<li>按照<a href="https://github.com/noplay/python-mysql-replication/pull/228修改对应的python-mysql-replication包文件(需要修改：binlogstream.py和row_event.py两个文件)" target="_blank" rel="noopener">https://github.com/noplay/python-mysql-replication/pull/228修改对应的python-mysql-replication包文件(需要修改：binlogstream.py和row_event.py两个文件)</a></li>
<li>binlog2sql中修改。增加date_tostr参数</li>
<li>不能直接使用python-mysql-replication的最新依赖包。只能通过修改文件，可能会引起未知问题</li>
<li>如果无NULL值字段，可尝试使用文本替换方式来修改插入语句。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binlog2sql.py 修改：</span><br><span class="line">stream = BinLogStreamReader(connection_settings=self.conn_setting, server_id=self.server_id,</span><br><span class="line">                            log_file=self.start_file, log_pos=self.start_pos, only_schemas=self.only_schemas,</span><br><span class="line">                            only_tables=self.only_tables, resume_stream=True, blocking=True, date_tostr=True)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="二进制流数据导入导出错误问题修复"><a href="#二进制流数据导入导出错误问题修复" class="headerlink" title="二进制流数据导入导出错误问题修复"></a>二进制流数据导入导出错误问题修复</h4><p>根据mysqldump导出二进制数据时的方式，所以有以下修复思路：</p>
<ol>
<li>在生成sql文本时，将二进制流转换成十六进制。</li>
<li>在导入数据时，利用原生的unhex将十六进制转换成二进制。<br>修改binlog2sql_util.py以下位置:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># TODO 改动一：二进制流解析为十六进制</span><br><span class="line">def fix_object(value):</span><br><span class="line">    &quot;&quot;&quot;Fixes python objects so that they can be properly inserted into SQL queries&quot;&quot;&quot;</span><br><span class="line">    if isinstance(value, set):</span><br><span class="line">        value = &apos;,&apos;.join(value)</span><br><span class="line">    if PY3PLUS and isinstance(value, bytes):</span><br><span class="line">        # return value.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;)</span><br><span class="line">        # 将二进制数据转换成十六进制数据，并使用特殊符号包含起来。用于后面转换</span><br><span class="line">        return &quot;----&quot; + bytes.hex(value) + &quot;____&quot;</span><br><span class="line">    elif not PY3PLUS and isinstance(value, unicode):</span><br><span class="line">        return value.encode(&apos;utf-8&apos;)</span><br><span class="line">    else:</span><br><span class="line">        return value</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># TODO 改动二：修改生成sql中的unhex串</span><br><span class="line">unhex_inex = str.find(sql, &quot;&apos;----&quot;)</span><br><span class="line">if unhex_inex != -1:</span><br><span class="line">    sql = str.replace(sql, &quot;&apos;----&quot;, &quot;unhex(&apos;&quot;)</span><br><span class="line">    sql = str.replace(sql, &quot;____&apos;&quot;, &quot;&apos;)&quot;)</span><br><span class="line">sql += &apos; #start %s end %s time %s&apos; % (e_start_pos, binlog_event.packet.log_pos, time)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>题外话：<br>小公司还是各种体系、规范不够完善，要是在上一家公司，早就被业务吊起来diss不知道多少遍了。<br>数据备份恢复是作为DBA最重要的技能点之一，但是由于云化的出现，导致很多人都只会点点点，太过于依赖平台的操作，而忽略了DBA的本质工作。这也是我接下来的工作重点：MySQL、Redis自动化备份恢复系统的建设工作（已完成）。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis哨兵client-reconfig-script脚本bug记录一则]]></title>
      <url>/2020/05/17/new/Redis/redis_BUG%E8%AE%B0%E5%BD%95%E4%B8%80%E5%88%99/</url>
      <content type="html"><![CDATA[<p>前一阵子一直在做自建机房Redis主从的环境搭建。了解到哨兵高可用切换后的会调用<code>client-reconfig-script</code>参数配置的脚本。<br>但是遇到了一个从2.8版本一直存在至今的BUG。我已经提了一个PR给官方，并被meger了。<a href="https://github.com/antirez/redis/pull/7113" target="_blank" rel="noopener">https://github.com/antirez/redis/pull/7113</a><br>特此记录一下。</p>
<h2 id="BUG场景"><a href="#BUG场景" class="headerlink" title="BUG场景"></a>BUG场景</h2><p>手动将主实例kill掉，模拟宕机情况。在某些情况下，<font color="red">哨兵已经触发了高可用切换</font>行为（主从状态、日志均有）。但是并<font color="red">没有调用</font>配置的脚本（非必现，但是落到同一台机器调用时并不会调用）<br>重启该机器上的哨兵节点又恢复正常。（重启大法好）</p>
<a id="more"></a>
<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>根据网上搜索到的脚本也自己编写了一个。大概逻辑就是</p>
<ol>
<li>新主IP等于本机IP触发域名切换、元数据修改等操作，并exit 0;</li>
<li>非本机IP不做任何操作，并exit 1;</li>
</ol>
<p>按道理来说，这个脚本处理逻辑跟网上99%给出的脚本一致，应该问题不大。<br>的确，在前几次或者短时间内触发多次触发高可用切换，脚本都能够正常执行。<br>但是遇到以下几种情况下不会触发。</p>
<ol>
<li>触发2次高可用切换后，本人划水半小时，再来触发，此时脚本不执行。</li>
<li>连续触发10次左右，都正常。总时长在5分钟左右后，脚本不执行。</li>
</ol>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><h3 id="脚本问题？"><a href="#脚本问题？" class="headerlink" title="脚本问题？"></a>脚本问题？</h3><p>首先，由于是第一次接触哨兵调用脚本。所以怀疑是自己写的脚本逻辑不正确。于是在编写脚本中每一个操作前都输出日志，甚至在第一行输出东西；结果仍没有调用！<br>而且轮到其他机器上的哨兵调用脚本时，可能能够调用成功。<br>所以排除脚本问题。</p>
<h3 id="脚本权限问题？"><a href="#脚本权限问题？" class="headerlink" title="脚本权限问题？"></a>脚本权限问题？</h3><p>通过google在Stack Overflow上，以及在Redis交流群中咨询。了解到可能存在脚本权限问题可能会调用失败。<br>于是关注该脚本在每次被调用后的状态，发现并没有什么变化。并且机器为新机器，只有本人在操作。所以认为权限问题不大可能。</p>
<h3 id="发现共性"><a href="#发现共性" class="headerlink" title="发现共性"></a>发现共性</h3><p>在进行多次高可用切换测试后，所有的哨兵切换在执行完高可用切换后，都不再去调用脚本。<br>这个时候，对所有的哨兵节点状态进行查看。发现有一个共性。<code>sentinel_running_scripts</code>值都为16。<br>该参数表示正在执行的脚本。<br>进一步验证，发现：</p>
<ol>
<li>该值小于16时，会正常调用。</li>
<li>该值会进行周期性的增加。</li>
<li>只触发一次高可用时，该值变成9后不再增加。</li>
</ol>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><font color="red">没有什么问题是阅读源码解决不了的</font>

<p>通过分析哨兵节点进行高可用切换段代码。发现在调用<code>client-reconfig-script</code>脚本时，会根据其返回值做不同处理。</p>
<ul>
<li>0：表示脚本执行成功。不重试</li>
<li>1：表示脚本执行失败。进行重试，最多10次</li>
<li>大于1：表示脚本执行失败。不进行重试。</li>
</ul>
<p>bug出现点：</p>
<ul>
<li>当running_scripts &gt;= SENTINEL_SCRIPT_MAX_RUNNING(16)时就不会再进入到调用脚本的逻辑里。</li>
<li>当调用脚本时，running_scripts++</li>
<li>脚本重试也会触发running_scripts++</li>
<li>只有当脚本达到最大重试次数(10次)，或者脚本返回非1值时，才触发一次running_scripts–</li>
</ul>
<p>可以看到，在非新主机器脚本执行时，脚本总会exit 1。所以会重试10次。running_scripts+10-1=9。<br>当遇到两次这样的情况，running_scripts就等于16了。调用脚本逻辑将不再被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">/* Run pending scripts if we are not already at max number of running</span><br><span class="line"> * scripts. */</span><br><span class="line">void sentinelRunPendingScripts(void) &#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    mstime_t now = mstime();</span><br><span class="line"></span><br><span class="line">    /* Find jobs that are not running and run them, from the top to the</span><br><span class="line">     * tail of the queue, so we run older jobs first. */</span><br><span class="line">    // li是script_queue的一个前向迭代器</span><br><span class="line">    listRewind(sentinel.scripts_queue,&amp;li);</span><br><span class="line">    // 开始遍历running_scripts队列</span><br><span class="line">    while (sentinel.running_scripts &lt; SENTINEL_SCRIPT_MAX_RUNNING &amp;&amp;</span><br><span class="line">           (ln = listNext(&amp;li)) != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        sentinelScriptJob *sj = ln-&gt;value;</span><br><span class="line">        pid_t pid;</span><br><span class="line"></span><br><span class="line">        /* Skip if already running. */</span><br><span class="line">        // 跳过正在执行的job</span><br><span class="line">        if (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) continue;</span><br><span class="line"></span><br><span class="line">        /* Skip if it&apos;s a retry, but not enough time has elapsed. */</span><br><span class="line">        // 还没到执行时间，暂时跳过</span><br><span class="line">        if (sj-&gt;start_time &amp;&amp; sj-&gt;start_time &gt; now) continue;</span><br><span class="line"></span><br><span class="line">        sj-&gt;flags |= SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">        sj-&gt;start_time = mstime();</span><br><span class="line">        sj-&gt;retry_num++;</span><br><span class="line">        // fork一个子进程</span><br><span class="line">        pid = fork();</span><br><span class="line"></span><br><span class="line">        // fork子进程失败</span><br><span class="line">        if (pid == -1) &#123;</span><br><span class="line">            /* Parent (fork error).</span><br><span class="line">             * We report fork errors as signal 99, in order to unify the</span><br><span class="line">             * reporting with other kind of errors. */</span><br><span class="line">            sentinelEvent(LL_WARNING,&quot;-script-error&quot;,NULL,</span><br><span class="line">                          &quot;%s %d %d&quot;, sj-&gt;argv[0], 99, 0);</span><br><span class="line">            sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">            sj-&gt;pid = 0;</span><br><span class="line">        &#125; else if (pid == 0) &#123;</span><br><span class="line">            /* Child */</span><br><span class="line">            execve(sj-&gt;argv[0],sj-&gt;argv,environ);</span><br><span class="line">            /* If we are here an error occurred. */</span><br><span class="line">            _exit(2); /* Don&apos;t retry execution. */</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sentinel.running_scripts++;</span><br><span class="line">            sj-&gt;pid = pid;</span><br><span class="line">            sentinelEvent(LL_DEBUG,&quot;+script-child&quot;,NULL,&quot;%ld&quot;,(long)pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Check for scripts that terminated, and remove them from the queue if the</span><br><span class="line"> * script terminated successfully. If instead the script was terminated by</span><br><span class="line"> * a signal, or returned exit code &quot;1&quot;, it is scheduled to run again if</span><br><span class="line"> * the max number of retries did not already elapsed. */</span><br><span class="line">void sentinelCollectTerminatedScripts(void) &#123;</span><br><span class="line">    int statloc;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    while ((pid = wait3(&amp;statloc,WNOHANG,NULL)) &gt; 0) &#123;</span><br><span class="line">        int exitcode = WEXITSTATUS(statloc);</span><br><span class="line">        int bysignal = 0;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        sentinelScriptJob *sj;</span><br><span class="line"></span><br><span class="line">        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</span><br><span class="line">        sentinelEvent(LL_DEBUG,&quot;-script-child&quot;,NULL,&quot;%ld %d %d&quot;,</span><br><span class="line">            (long)pid, exitcode, bysignal);</span><br><span class="line"></span><br><span class="line">        ln = sentinelGetScriptListNodeByPid(pid);</span><br><span class="line">        if (ln == NULL) &#123;</span><br><span class="line">            serverLog(LL_WARNING,&quot;wait3() returned a pid (%ld) we can&apos;t find in our scripts execution queue!&quot;, (long)pid);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        sj = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">        /* If the script was terminated by a signal or returns an</span><br><span class="line">         * exit code of &quot;1&quot; (that means: please retry), we reschedule it</span><br><span class="line">         * if the max number of retries is not already reached. */</span><br><span class="line">        // 如果脚本中断或者退出值为1。则重新进入队列，并增加执行时间</span><br><span class="line">        if ((bysignal || exitcode == 1) &amp;&amp;</span><br><span class="line">            sj-&gt;retry_num != SENTINEL_SCRIPT_MAX_RETRY)</span><br><span class="line">        &#123;</span><br><span class="line">            sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">            sj-&gt;pid = 0;</span><br><span class="line">            sj-&gt;start_time = mstime() +</span><br><span class="line">                             sentinelScriptRetryDelay(sj-&gt;retry_num);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* Otherwise let&apos;s remove the script, but log the event if the</span><br><span class="line">             * execution did not terminated in the best of the ways. */</span><br><span class="line">            // 如果是中断或者不成功，则是因为到达了执行次数上线，打印出错误日志</span><br><span class="line">            if (bysignal || exitcode != 0) &#123;</span><br><span class="line">                sentinelEvent(LL_WARNING,&quot;-script-error&quot;,NULL,</span><br><span class="line">                              &quot;%s %d %d&quot;, sj-&gt;argv[0], bysignal, exitcode);</span><br><span class="line">            &#125;</span><br><span class="line">            // 这个地方只会在成功或者重试了10才执行到。</span><br><span class="line">            listDelNode(sentinel.scripts_queue,ln);</span><br><span class="line">            sentinelReleaseScriptJob(sj);</span><br><span class="line">            sentinel.running_scripts--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="临时解决方案"><a href="#临时解决方案" class="headerlink" title="临时解决方案"></a>临时解决方案</h3><p>脚本不exit 1。exit 2表示失败，即不进行哨兵重试调用脚本行为。</p>
<h3 id="源码修复"><a href="#源码修复" class="headerlink" title="源码修复"></a>源码修复</h3><p>将上面源码中的<code>sentinel.running_scripts--;</code>提到else之外。即使exit 1也需要减一。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis指标说明]]></title>
      <url>/2020/04/26/new/Redis/Redis_INFO/</url>
      <content type="html"><![CDATA[<p>本文基于Redis最新unstable版本下，执行info命令后，返回的各项指标进行解释。并对其中需要特别注意的指标进行指出说明。<br>并会对阿里云info进行简单对比。区分阿里云对info进行了哪些方面的改造。</p>
<a id="more"></a>
<h2 id="info可选命令值"><a href="#info可选命令值" class="headerlink" title="info可选命令值"></a>info可选命令值</h2><p>info这个命令的判断实现是在<code>server.c-&gt;genRedisInfoString(char *section)</code>函数中。根据不同的section返回不同的info信息。<br>section可选值有以下这些：</p>
<ul>
<li>空 or all or default：大部分简要的信息</li>
<li>clients：客户端相关信息</li>
<li>memory：内存使用相关信息</li>
<li>persistence：RDB 和 AOF 的相关信息</li>
<li>stats：一般统计信息</li>
<li>replication：主/从复制信息</li>
<li>cpu：CPU 计算量统计信息</li>
<li>cluster：Redis 集群信息</li>
<li>keyspace：数据库相关的统计信息</li>
<li>commandstats：Redis 命令统计信息</li>
</ul>
<h2 id="info信息介绍"><a href="#info信息介绍" class="headerlink" title="info信息介绍"></a>info信息介绍</h2><h3 id="unstable信息"><a href="#unstable信息" class="headerlink" title="unstable信息"></a>unstable信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"># Server</span><br><span class="line">redis_version:999.999.999           // redi服务器版本</span><br><span class="line">redis_git_sha1:d044e33c             // Git SHA1</span><br><span class="line">redis_git_dirty:1                   // Git dirty flag</span><br><span class="line">redis_build_id:f0892bae2ab3d928     // redis build 版本</span><br><span class="line">redis_mode:standalone               // redis运行模式</span><br><span class="line">os:Darwin 19.4.0 x86_64             // 运行redis服务的操作系统</span><br><span class="line">arch_bits:64                        // 服务器架构，32位or64位</span><br><span class="line">multiplexing_api:kqueue             // redis所使用的事件处理机制</span><br><span class="line">atomicvar_api:atomic-builtin        // 原子处理API</span><br><span class="line">gcc_version:4.2.1                   // 编译Reedis时使用的GCC版本</span><br><span class="line">process_id:87804                    // Redis服务进程PID</span><br><span class="line">run_id:c7373afe697afdd775ab4220091574652e10354b   // Redis服务器的随机标识符</span><br><span class="line">tcp_port:6379                       // TCP/IP端口</span><br><span class="line">uptime_in_seconds:37                // 服务器启动至今的时间，单位秒</span><br><span class="line">uptime_in_days:0                    // 服务器启动至今的时间，单位天</span><br><span class="line">hz:10                               // redis内部调用频率，每秒运行多少次serverCron</span><br><span class="line">configured_hz:10                    // 配置文件设置的频率数</span><br><span class="line">lru_clock:10750326                  // 自增时钟，用于管理LRU管理，每执行一次serverCron更新一次</span><br><span class="line">executable:/Users/hzb/redis_github/redis_debug/cmake-build-debug/src/redis-server // 执行文件</span><br><span class="line">config_file:                        // 配置文件路径</span><br><span class="line"></span><br><span class="line"># Clients</span><br><span class="line">connected_clients:2                 // 连接的客户端数</span><br><span class="line">client_recent_max_input_buffer:2    // 当前客户端连接中，最大的输入缓冲区大小</span><br><span class="line">client_recent_max_output_buffer:0   // 当前客户端连接中，最大的输出缓冲区大小</span><br><span class="line">blocked_clients:0                   // 正在等待你阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端数</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">used_memory:1082368                 // 当前内存使用量，byte为单位</span><br><span class="line">used_memory_human:1.03M             // 以可读方式显示当前内存使用量</span><br><span class="line">used_memory_rss:5779456             // 从操作系统层面，返回redis已分配的内存总量，这个值与ps、top等命令输出的一样</span><br><span class="line">used_memory_rss_human:5.51M         // 可读方式显示已分配总量</span><br><span class="line">used_memory_peak:1082368            // redis内存使用峰值</span><br><span class="line">used_memory_peak_human:1.03M        // 已可读方式显示内存使用峰值</span><br><span class="line">used_memory_peak_perc:100.15%       // (used_memory/ used_memory_peak) *100%</span><br><span class="line">used_memory_overhead:1066024        // Redis为了维护数据集内部机制所需的内存开销，包括客户端输出缓冲区、查询缓冲区、AOF重写缓冲区、backlog等</span><br><span class="line">used_memory_startup:998672          // Redis服务器启动时消耗的内存</span><br><span class="line">used_memory_dataset:16344           // 数据真实使用的内存量。（used_memory—used_memory_overhead）</span><br><span class="line">used_memory_dataset_perc:19.53%     // 数据占用内存占使用内存比。（100%*(used_memory_dataset/(used_memory—used_memory_startup))）</span><br><span class="line">allocator_allocated:1035760         // </span><br><span class="line">allocator_active:5741568</span><br><span class="line">allocator_resident:5741568</span><br><span class="line">total_system_memory:17179869184     // 总系统内存</span><br><span class="line">total_system_memory_human:16.00G</span><br><span class="line">used_memory_lua:37888               // Lua引擎使用内存</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">used_memory_scripts:0                 </span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">maxmemory:0                         // 设置的最大内存使用量。默认为0，表示不限制</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction         // 淘汰策略</span><br><span class="line">allocator_frag_ratio:5.54           // 碎片率</span><br><span class="line">allocator_frag_bytes:4705808        // 碎片大小</span><br><span class="line">allocator_rss_ratio:1.00            // 常驻内存比例</span><br><span class="line">allocator_rss_bytes:0               // 常驻内存大小</span><br><span class="line">rss_overhead_ratio:1.01             // 常驻内存开销比例</span><br><span class="line">rss_overhead_bytes:37888            // 常驻内存开销大小</span><br><span class="line">mem_fragmentation_ratio:5.58        // 碎片率（used_memory_rss/ used_memory） 正常在（1-1.6）之间</span><br><span class="line">mem_fragmentation_bytes:4743696     // 内存碎片大小</span><br><span class="line">mem_not_counted_for_evict:0         // 被驱逐的内存</span><br><span class="line">mem_replication_backlog:0           // Redis复制积压缓冲区内存</span><br><span class="line">mem_clients_slaves:0                // Redis节点客户端消耗内存</span><br><span class="line">mem_clients_normal:66632            // Rediis常规客户端消耗内存</span><br><span class="line">mem_aof_buffer:0                    // AOF使用内存</span><br><span class="line">mem_allocator:libc                  // 内存分配器</span><br><span class="line">active_defrag_running:0             // 碎片整理是否处于活动状态</span><br><span class="line">lazyfree_pending_objects:0          // 0-不存在延迟释放的挂起对象</span><br><span class="line"></span><br><span class="line"># Persistence</span><br><span class="line">loading:0                           // 服务器是否正在载入持久化文件</span><br><span class="line">rdb_changes_since_last_save:0       // 离最近一次成功生成rdb文件，写入命令的个数，即有多少个写入命令没有持久化</span><br><span class="line">rdb_bgsave_in_progress:0            // 服务器是否正在创建rdb文件</span><br><span class="line">rdb_last_save_time:1587808593       // 离最近一次成功创建rdb文件的时间戳。当前时间戳 - rdb_last_save_time=多少秒未成功生成rdb文件</span><br><span class="line">rdb_last_bgsave_status:ok           // 最近一次rdb持久化是否成功</span><br><span class="line">rdb_last_bgsave_time_sec:-1         // 最近一次成功生成rdb文件耗时秒数</span><br><span class="line">rdb_current_bgsave_time_sec:-1      // 如果服务器正在创建rdb文件，那么这个域记录的就是当前的创建操作已经耗费的秒数</span><br><span class="line">rdb_last_cow_size:0                 // RDB过程中父进程与子进程相比执行了多少修改(包括读缓冲区，写缓冲区，数据修改等)。</span><br><span class="line">aof_enabled:0                       // 是否开启了aof</span><br><span class="line">aof_rewrite_in_progress:0           // 标识aof的rewrite操作是否在进行中</span><br><span class="line">aof_rewrite_scheduled:0             // 正在等待执行rewrite任务个数</span><br><span class="line">aof_last_rewrite_time_sec:-1        // 最近一次aof rewrite耗费的时长</span><br><span class="line">aof_current_rewrite_time_sec:-1     // 如果rewrite操作正在进行，则记录所使用的时间，单位秒</span><br><span class="line">aof_last_bgrewrite_status:ok        // 上次bgrewriteaof操作的状态</span><br><span class="line">aof_last_write_status:ok            // 上次aof写入状态</span><br><span class="line">aof_last_cow_size:0                 // AOF过程中父进程与子进程相比执行了多少修改(包括读缓冲区，写缓冲区，数据修改等)。</span><br><span class="line"></span><br><span class="line"># Stats</span><br><span class="line">total_connections_received:2        // 新创建连接的个数</span><br><span class="line">total_commands_processed:3          // redis处理命令总数</span><br><span class="line">instantaneous_ops_per_sec:0         // redis当前的QPS</span><br><span class="line">total_net_input_bytes:62            // redis网络入口流量字节数</span><br><span class="line">total_net_output_bytes:39355        // redis网络出口流量字节数</span><br><span class="line">instantaneous_input_kbps:0.00       // redis网络入口kps</span><br><span class="line">instantaneous_output_kbps:0.00      // redis网络出口kps</span><br><span class="line">rejected_connections:0              // 拒绝的连接个数</span><br><span class="line">sync_full:0                         // 主从完全同步成功次数</span><br><span class="line">sync_partial_ok:0                   // 主从部分同步成功次数</span><br><span class="line">sync_partial_err:0                  // 主从部分同步失败次数</span><br><span class="line">expired_keys:0                      // 运行以来过期的key的数量</span><br><span class="line">expired_stale_perc:0.00             // 过期的比率</span><br><span class="line">expired_time_cap_reached_count:0    // 过期计数</span><br><span class="line">evicted_keys:0                      // 运行以来剔除(超过了maxmemory后)的key的数量</span><br><span class="line">keyspace_hits:0                     // 命中次数</span><br><span class="line">keyspace_misses:0                   // 没命中次数</span><br><span class="line">pubsub_channels:0                   // 当前使用中的频道数量</span><br><span class="line">pubsub_patterns:0                   // 当前使用的模式的数量</span><br><span class="line">latest_fork_usec:0                  // 最近一次fork操作阻塞redis进程的耗时数，单位微秒</span><br><span class="line">migrate_cached_sockets:0            // 是否已经缓存了到该地址的连接</span><br><span class="line">slave_expires_tracked_keys:0        // 从实例到期key数量</span><br><span class="line">active_defrag_hits:0                // 主动碎片整理命中次数</span><br><span class="line">active_defrag_misses:0              // 主动碎片整理未命中次数</span><br><span class="line">active_defrag_key_hits:0            // 主动碎片整理key命中次数</span><br><span class="line">active_defrag_key_misses:0          // 主动碎片整理key未命中次数</span><br><span class="line"></span><br><span class="line"># Replication</span><br><span class="line">role:master                         // 实例角色</span><br><span class="line">connected_slaves:0                  // 连接的slave实例个数</span><br><span class="line">master_replid:59e5c4b387f62e131a284ca4a144152cbc38dd2b    // 主实例启动随机字符串</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000   // 主实例启动随机字符串2</span><br><span class="line">master_repl_offset:0                // 主从同步偏移量</span><br><span class="line">second_repl_offset:-1               // 主从同步偏移量2,此值如果和上面的offset相同说明主从一致没延迟</span><br><span class="line">repl_backlog_active:0               // 复制积压缓冲区是否开启</span><br><span class="line">repl_backlog_size:1048576           // 复制积压缓冲大小</span><br><span class="line">repl_backlog_first_byte_offset:0    // 复制缓冲区里偏移量的大小</span><br><span class="line">repl_backlog_histlen:0              // 此值等于 master_repl_offset - repl_backlog_first_byte_offset,该值不会超过repl_backlog_size的大小</span><br><span class="line"></span><br><span class="line"># CPU</span><br><span class="line">used_cpu_sys:0.023950               // 所有redis主进程在核心态所占用的CPU时求和累计起来</span><br><span class="line">used_cpu_user:0.021295              // 所有redis主进程在用户态所占用的CPU时求和累计起来</span><br><span class="line">used_cpu_sys_children:0.000000      // 后台进程在核心态所占用的CPU时求和累计起来</span><br><span class="line">used_cpu_user_children:0.000000     // 后台进程在用户态所占用的CPU时求和累计起来</span><br><span class="line"></span><br><span class="line"># Cluster</span><br><span class="line">cluster_enabled:0                   // 是否开启了集群模式</span><br><span class="line"></span><br><span class="line"># Keyspace</span><br><span class="line">db0:keys=14,expires=0,avg_ttl=0     // key的数量,以及带有生存期的key的数,平均存活时间</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; info commandstats</span><br><span class="line"># Commandstats</span><br><span class="line">cmdstat_get:calls=1,usec=16,usec_per_call=16.00       // 命令：调用次数，消耗的时间（微秒），消耗时间平均值（微秒）</span><br><span class="line">cmdstat_info:calls=1,usec=45,usec_per_call=45.00</span><br><span class="line">cmdstat_command:calls=1,usec=1454,usec_per_call=1454.00</span><br></pre></td></tr></table></figure>
<h3 id="阿里云信息"><a href="#阿里云信息" class="headerlink" title="阿里云信息"></a>阿里云信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">r-2ze48c70febc6e34.redis.rds.aliyuncs.com:6379&gt; info</span><br><span class="line"># Server</span><br><span class="line">redis_version:4.0.11</span><br><span class="line">redis_git_sha1:0b2746f2</span><br><span class="line">redis_git_dirty:1</span><br><span class="line">redis_build_id:5cfe6fcdd30f0fbc</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux  </span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">atomicvar_api:atomic-builtin</span><br><span class="line">gcc_version:0.0.0</span><br><span class="line">process_id:48004</span><br><span class="line">run_id:d61d98f1f9489bbc0f790d5a7cee510c62aa6614</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:648333</span><br><span class="line">uptime_in_days:7</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:10767429</span><br><span class="line">executable:</span><br><span class="line">config_file:</span><br><span class="line"></span><br><span class="line"># Clients</span><br><span class="line">connected_clients:18</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:14</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"># Memory</span><br><span class="line">used_memory:249353384</span><br><span class="line">used_memory_human:237.80M</span><br><span class="line">used_memory_rss:283426816</span><br><span class="line">used_memory_rss_human:270.30M</span><br><span class="line">used_memory_peak:279685640</span><br><span class="line">used_memory_peak_human:266.73M</span><br><span class="line">used_memory_peak_perc:89.15%</span><br><span class="line">used_memory_overhead:145987838</span><br><span class="line">used_memory_startup:7985288</span><br><span class="line">used_memory_dataset:103365546</span><br><span class="line">used_memory_dataset_perc:42.82%</span><br><span class="line">used_memory_lua:44032</span><br><span class="line">used_memory_lua_human:43.00K</span><br><span class="line">used_memory_scripts:488</span><br><span class="line">used_memory_scripts_human:488B</span><br><span class="line">number_of_cached_scripts:1</span><br><span class="line">maxmemory:1073741824</span><br><span class="line">maxmemory_human:1.00G</span><br><span class="line">maxmemory_policy:volatile-lru</span><br><span class="line">mem_fragmentation_ratio:1.14</span><br><span class="line">mem_allocator:jemalloc-5.1.0</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br><span class="line">oom_err_count:0</span><br><span class="line"></span><br><span class="line"># Stats</span><br><span class="line">total_connections_received:858268</span><br><span class="line">total_commands_processed:336711164</span><br><span class="line">instantaneous_ops_per_sec:774</span><br><span class="line">total_net_input_bytes:17239795209</span><br><span class="line">total_net_output_bytes:49608006979</span><br><span class="line">instantaneous_input_kbps:33.74</span><br><span class="line">instantaneous_output_kbps:201.54</span><br><span class="line">rejected_connections:0</span><br><span class="line">rejected_connections_status:0</span><br><span class="line">sync_full:4</span><br><span class="line">sync_partial_ok:1</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:9241799</span><br><span class="line">expired_stale_perc:11.51</span><br><span class="line">expired_time_cap_reached_count:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">evicted_keys_per_sec:0</span><br><span class="line">keyspace_hits:106766672</span><br><span class="line">keyspace_misses:205934497</span><br><span class="line">hits_per_sec:405.50</span><br><span class="line">misses_per_sec:338.25</span><br><span class="line">hit_rate_percentage:54.52</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:11205</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line">slave_expires_tracked_keys:0</span><br><span class="line">active_defrag_hits:0</span><br><span class="line">active_defrag_misses:0</span><br><span class="line">active_defrag_key_hits:0</span><br><span class="line">active_defrag_key_misses:0</span><br><span class="line">traffic_control_input:0</span><br><span class="line">traffic_control_input_status:0</span><br><span class="line">traffic_control_output:0</span><br><span class="line">traffic_control_output_status:0</span><br><span class="line">total_bigkeys:0</span><br><span class="line">bigkeys_status:0</span><br><span class="line">stat_avg_rt:2</span><br><span class="line">stat_max_rt:428</span><br><span class="line">pacluster_migrate_sum_rt:0</span><br><span class="line">pacluster_migrate_max_rt:0</span><br><span class="line">pacluster_migrate_qps:0</span><br><span class="line">pacluster_import_sum_rt:0</span><br><span class="line">pacluster_import_max_rt:0</span><br><span class="line">pacluster_import_qps:0</span><br><span class="line">pacluster_migrate_start_time:0</span><br><span class="line">pacluster_importing_start_time:0</span><br><span class="line"></span><br><span class="line"># CPU</span><br><span class="line">used_cpu_sys:4143.00</span><br><span class="line">used_cpu_user:3553.77</span><br><span class="line">used_cpu_sys_children:2.71</span><br><span class="line">used_cpu_user_children:26.16</span><br><span class="line"></span><br><span class="line"># Cluster</span><br><span class="line">cluster_enabled:0</span><br><span class="line">databases:256</span><br><span class="line">nodecount:1</span><br><span class="line"></span><br><span class="line"># paCluster</span><br><span class="line">pacluster_enabled:0</span><br><span class="line"></span><br><span class="line"># Keyspace</span><br><span class="line">db0:keys=1790098,expires=319664,avg_ttl=9670198</span><br></pre></td></tr></table></figure>
<h3 id="阿里云改造"><a href="#阿里云改造" class="headerlink" title="阿里云改造"></a>阿里云改造</h3><p>通过对比，可以看到阿里云对info中的部分信息进行改造。<br>主要有：</p>
<ol>
<li>隐藏了Persistence持久话信息。这对我们排查问题时，无法确认是否因为持久化造成。</li>
<li>隐藏了Replication主从复制信息。</li>
<li><p>Stats状态中的统计信息增加了以下统计信息。主要包含（bigkeys统计、rt信息、集群相关的一些信息）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">total_bigkeys:0</span><br><span class="line">bigkeys_status:0</span><br><span class="line">stat_avg_rt:2</span><br><span class="line">stat_max_rt:428</span><br><span class="line">pacluster_migrate_sum_rt:0</span><br><span class="line">pacluster_migrate_max_rt:0</span><br><span class="line">pacluster_migrate_qps:0</span><br><span class="line">pacluster_import_sum_rt:0</span><br><span class="line">pacluster_import_max_rt:0</span><br><span class="line">pacluster_import_qps:0</span><br><span class="line">pacluster_migrate_start_time:0</span><br><span class="line">pacluster_importing_start_time:0</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增了paCluster</p>
</li>
<li>Cluster中的信息进行改造</li>
<li>版本区别，Redis新版本中。将client_longest_output_list、client_biggest_input_buf修改成了client_recent_max_input_buffer、client_recent_max_output_buffer</li>
<li>info commandstats增加了其他指标</li>
</ol>
<h2 id="需要监控的参数"><a href="#需要监控的参数" class="headerlink" title="需要监控的参数"></a>需要监控的参数</h2><ul>
<li>connected_clients: 当前连接客户端数</li>
<li>client_longest_output_list：客户端中最长的输出缓冲区大小</li>
<li>client_biggest_input_buf：最大的输入缓冲区大小</li>
<li>used_memory：当前使用内存量</li>
<li>used_memory_peak：内存使用峰值</li>
<li>used_memory_overhead：维护消耗内存</li>
<li>maxmemory：允许使用最大内存</li>
<li>mem_fragmentation_ratio：内存碎片率</li>
<li>mem_replication_backlog：复制积压缓冲区大小</li>
<li>mem_clients_slaves：节点消耗内存量</li>
<li>mem_clients_normal：常规客户端消耗内存量</li>
<li>rdb_last_save_time：最近一次rdb持久化时间</li>
<li>rdb_last_bgsave_status：最近一次rdb持久化状态</li>
<li>rdb_last_bgsave_time_sec：最近一次rdb持久化消耗时间</li>
<li>rdb_last_cow_size：rdb持久化时cow消耗内存</li>
<li>total_connections_received：新创建连接数（取差值）</li>
<li>instantaneous_ops_per_sec：OPS</li>
<li>instantaneous_input_kbps：输入带宽</li>
<li>instantaneous_output_kbps：输出带宽</li>
<li>expired_keys：已过期的key（取差值）</li>
<li>evicted_keys：剔除的key（取差值）</li>
<li>keyspace_hits：命中数（取比例）</li>
<li>keyspace_misses：未命中数。（取比例）</li>
<li>connected_slaves：当前连接slave个数</li>
<li>master_repl_offset-second_repl_offset：主从延迟</li>
<li>Keyspace：各DBkey信息</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《向上管理的艺术》小结]]></title>
      <url>/2020/04/19/new/other/%E3%80%8A%E7%BA%BF%E4%B8%8A%E7%AE%A1%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>20%的向上管理，决定了80%的工作效率和工作成果。</p>
<p>在之前的一篇博客<a href="https://omg-by.github.io/2020/01/05/new/other/%E5%90%AC%E3%80%8A%E5%B7%A5%E4%BD%9C%E4%B8%89%E5%B9%B4%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E3%80%8B%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">听《工作三年我学到了什么》总结</a>提到的音频中，讨论者推荐了《向上管理的艺术》这本书。于是便买了（我才不会告诉你是凑单），利用了一周的睡前时间把它给读完，在读的过程中，回想自己这一年半的工作经历，的确是在无意间触犯到了好几条禁忌行为。。。感谢领导的包容和支持。<br>利用周末空余时间将这本书做个简单的总结，尽量从自身层面优化。不仅是与领导沟通，在生活中也处处需要注意。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdz9w4eciyj31dv0u07g4.jpg" alt=""></p>
<p>一个人的汇报反馈机制，往往能影响到上司对你的态度和看法。上司也有自己的事要做，并不会时时刻刻的盯着你；<br>领导负责下发任务，如果没有反馈，那么他将无法掌控任务的进度，甚至最终因没有反馈而导致任务失败，则会大大降低领导对你的看法。<br>领导的经验摆在那，有很多在我们看来比较困难的事，也许领导几句话、一个想法、一个电话就能轻松的解决。<font color="red">领导在一定意义上，也是我们的资源</font>。</p>
<p>领导也是一个人，也会有各种各样的性格和情绪。<font color="red">如何在合适时机、选择合适方式才式获取到到正反馈信息？</font>这不仅仅跟领导反馈，在生活中，这也是一门需要时时需要注意的地方。<br>毕竟是有求于人，往往就是那么一个不经意的小点，导致了事情的失败，影响的只会是自己，徒增非常多的人力物力。</p>
<p><font color="red">多站在别人的角度上思考</font>，别人是怎么看待这件事，需要我做什么，希望我怎么做。才能以更好的姿势、更快的效率去做好一件事。</p>
]]></content>
      
        <categories>
            
            <category> 生活杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis RDB文件存储格式]]></title>
      <url>/2020/01/14/new/Redis/Redis-RDB%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>Redis存在两种数据文件：RDB和AOF。<br>AOF文件的结构比较简单，就不做说明。主要是简介RDB数据文件的结构</p>
<p>*.rdb文件是表示Redis瞬间快照的一个二进制文件。根据这个快照文件，可以将Redis恢复到Redis当时的状态。<br>rdb文件针对读写进行了优化操作。尽可能的会使用LZF压缩算法来减少文件的大小。</p>
<p>在命令行下我们可以通过<code>od -x rdb.rdb | less</code>和<code>od -c rdb.rdb | less</code>命令查看16进制和字符模式下的rdb文件。<br>注意：使用<code>od -x</code>命令查出来的16进制是逆序的。</p>
<h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gan46keebgj30r806z3z8.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">----------------------------# RDB文件是二进制的，所以并不存在回车换行来分隔一行一行.</span><br><span class="line">52 45 44 49 53              # 以字符串 &quot;REDIS&quot; 开头</span><br><span class="line">30 30 30 36                 # RDB 的版本号，大端存储，比如左边这个表示版本号为0006</span><br><span class="line">----------------------------</span><br><span class="line">FE 00                       # FE = FE表示数据库编号，Redis支持多个库，以数字编号，这里00表示第0个数据库</span><br><span class="line">----------------------------# Key-Value 对存储开始了</span><br><span class="line">FD $length-encoding         # FD 表示过期时间，过期时间是用 length encoding 编码存储的，后面会讲到</span><br><span class="line">$value-type                 # 1 个字节用于表示value的类型，比如set,hash,list,zset等</span><br><span class="line">$string-encoded-key         # Key 值，通过string encoding 编码，同样后面会讲到</span><br><span class="line">$encoded-value              # Value值，根据不同的Value类型采用不同的编码方式</span><br><span class="line">----------------------------</span><br><span class="line">FC $length-encoding         # FC 表示毫秒级的过期时间，后面的具体时间用length encoding编码存储</span><br><span class="line">$value-type                 # 同上，也是一个字节的value类型</span><br><span class="line">$string-encoded-key         # 同样是以 string encoding 编码的 Key值</span><br><span class="line">$encoded-value              # 同样是以对应的数据类型编码的 Value 值</span><br><span class="line">----------------------------</span><br><span class="line">$value-type                 # 下面是没有过期时间设置的 Key-Value对，为防止冲突，数据类型不会以 FD, FC, FE, FF 开头</span><br><span class="line">$string-encoded-key</span><br><span class="line">$encoded-value</span><br><span class="line">----------------------------</span><br><span class="line">FE $length-encoding         # 下一个库开始，库的编号用 length encoding 编码</span><br><span class="line">----------------------------</span><br><span class="line">...                         # 继续存储这个数据库的 Key-Value 对</span><br><span class="line">FF                          ## FF：RDB文件结束的标志</span><br><span class="line">8 byte checksum             ## 8位校验码                  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">od -x rdb.rdb | head -n 10</span><br><span class="line">0000000 4552 4944 3053 3030 fe36 fc1e ae47 2160</span><br><span class="line">0000020 016e 0000 2800 6c65 7361 6974 5f63 3036</span><br><span class="line">0000040 3930 3562 6432 3139 3962 3233 3134 3138</span><br><span class="line">0000060 6338 3031 3338 6166 6233 3163 6264 5d4e</span><br><span class="line">0000100 8b1f 0008 0000 0000 ff00 9bcc 535b 595a</span><br><span class="line">0000120 c79b 66fb e7ae a42b 1db8 7585 7bde dea7</span><br><span class="line">0000140 a779 eb62 7264 3500 e931 2a1c 2165 116c</span><br><span class="line">0000160 6082 1838 27b5 1855 8b4d fb67 d18d 6344</span><br><span class="line">0000200 3a62 6231 51b7 6dd3 6247 bb50 9aac b9ab</span><br><span class="line">0000220 8f9c d610 7366 af95 b530 cd01 d906 8104</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">od -c rdb.rdb | head -n 10</span><br><span class="line">0000000   R   E   D   I   S   0   0   0   6 376 036 374   G 256   `   !</span><br><span class="line">0000020   n 001  \0  \0  \0   (   e   l   a   s   t   i   c   _   6   0</span><br><span class="line">0000040   0   9   b   5   2   d   9   1   b   9   3   2   4   1   8   1</span><br><span class="line">0000060   8   c   1   0   8   3   f   a   3   b   c   1   d   b   N   ]</span><br><span class="line">0000100 037 213  \b  \0  \0  \0  \0  \0  \0 377 314 233   [   S   Z   Y</span><br><span class="line">0000120 233 307 373   f 256 347   + 244 270 035 205   u 336   &#123; 247 336</span><br><span class="line">0000140   y 247   b 353   d   r  \0   5   1 351 034   *   e   !   l 021</span><br><span class="line">0000160 202   `   8 030 265   &apos;   U 030   M 213   g 373 215 321   D   c</span><br><span class="line">0000200   b   :   1   b 267   Q 323   m   G   b   P 273 254 232 253 271</span><br><span class="line">0000220 234 217 020 326   f   s 225 257   0 265 001 315 006 331 004 201</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>rdb文件固定以魔术字符串”REDIS”开头，表示这个rdb文件时Redis数据文件。<br><code>52 45 44 49 53 # &quot;REDIS&quot;</code></p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>接下来固定4个字节保存rdb格式的的版本号。<br><code>30 30 30 36 # Version = 6</code></p>
<h3 id="数据库编号"><a href="#数据库编号" class="headerlink" title="数据库编号"></a>数据库编号</h3><p>一个字节<code>0xfe</code>表示开始选择数据库；在这个字节之后，一个可变长度字段表示数据库编号。具体部分参考<b>长度编码</b>部分<br><code>1e</code>表示十进制的30，代表是30数据库</p>
<h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><p>在选择数据库后，就是具体的一些键值对记录。每个键值对包含4个部分</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>RDB_OPCODE_EXPIRETIME_MS</td>
<td>1byte</td>
<td>0xfc/0xfd(252/253)，说明是带过期时间的键值对</td>
</tr>
<tr>
<td>ms</td>
<td>8bytes</td>
<td>时间戳</td>
</tr>
<tr>
<td>TYPE</td>
<td>1byte</td>
<td>键值对类型</td>
</tr>
<tr>
<td>key</td>
<td>—-</td>
<td>键</td>
</tr>
<tr>
<td>value</td>
<td>—-</td>
<td>值</td>
</tr>
</tbody>
</table>
<h4 id="过期标记和过期时间戳"><a href="#过期标记和过期时间戳" class="headerlink" title="过期标记和过期时间戳"></a>过期标记和过期时间戳</h4><p>一个字节。<code>0xFD</code>表示过期时间戳以秒为单位，<code>0xFC</code>表示过期时间戳以毫秒为单位。<br>如果设置了过期时间，那么接下来的8个字节就表示具体的过期时间。<br>在导入RDB文件的时候，会将已经过期的key进行丢弃。</p>
<p>如果没有设置过期时间，则没有这两个字段。</p>
<h4 id="key类型"><a href="#key类型" class="headerlink" title="key类型"></a>key类型</h4><p>一个字节，表示保存键值对value的具体编码。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gan531wxo8j30ly0dqt9u.jpg" alt=""></p>
<ul>
<li>0表示是一个简单字符串</li>
<li>当值为9-13时，该值被包装到字符串中，读取字符串后，会对其进行进一步解析。</li>
<li>当值为1-4时，该值是一个字符串序列，此字符串序列用于构造列表、集合、集合或哈希表等复杂数据类型。</li>
</ul>
<h4 id="键值对-1"><a href="#键值对-1" class="headerlink" title="键值对"></a>键值对</h4><p>key固定为字符串编码保存。<br>value取决于编码，不同的编码有不同的保存格式。<br>后面会有详细介绍。</p>
<h2 id="长度编码"><a href="#长度编码" class="headerlink" title="长度编码"></a>长度编码</h2><p>长度编码用于存储下一个对象的长度，长度编码是一种可变长字节编码，目的在于使用更少的字节来表示内容。<br>从数据流中取出一个字节，前面两个bit可能存在以下几种情况：</p>
<ul>
<li>00：接下来6位表示长度</li>
<li>01：取出下一个字节，组合的14位表示长度</li>
<li>10：剩余6位舍弃，取出4个字节表示长度</li>
<li>11：表示下一个对象以特殊格式编码。其余6位表示格式。</li>
</ul>
<p>63的数字只需要一个字节进行存储<br>64 – 16383 的数字只需要两个字节进行存储<br>16383 - 2^32 -1 的数字只需要用5个字节（1个字节的标识加4个字节的值）进行存储</p>
<h2 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h2><p>Redis字符串是二进制安全的，这意味着可以在其中存储任何内容。它没有任何特殊的字符串结尾标记。最好将Redis字符串视为字节数组。</p>
<p>在RDB文件中有三种类型的字符串：</p>
<ol>
<li>简单字符串</li>
<li>8、16、32位的整数</li>
<li>一个经过LZF压缩的支付串</li>
</ol>
<h3 id="简单字符串"><a href="#简单字符串" class="headerlink" title="简单字符串"></a>简单字符串</h3><p>简单字符串编码非常简单，就是 字符串长度+具体的字符串<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ganb8w8bbzj31is03g74g.jpg" alt=""></p>
<h3 id="整数字符串"><a href="#整数字符串" class="headerlink" title="整数字符串"></a>整数字符串</h3><p>在长度编码为<code>11</code>的时候，读取后续的6位。如果后续的6位为：</p>
<ul>
<li>0表示跟随的是8位整数</li>
<li>1表示跟随的是16位整数</li>
<li>2表示跟随的是32位整数</li>
</ul>
<h3 id="压缩字符串"><a href="#压缩字符串" class="headerlink" title="压缩字符串"></a>压缩字符串</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ganbdubpn0j31i603mwey.jpg" alt=""><br>在长度编码为<code>11</code>的时候，读取后续的6位。如果后续的6位为<code>3</code>表示后面跟随着的是压缩字符串。具体步骤为下：</p>
<ol>
<li>使用长度编码方式从c_len中读取出压缩的长度</li>
<li>使用长度编码方式从o_len中读取出压缩前的长度</li>
<li>读取出压缩后的字符串</li>
<li>使用LZF算法解压缩</li>
</ol>
<h3 id="List编码和Set编码"><a href="#List编码和Set编码" class="headerlink" title="List编码和Set编码"></a>List编码和Set编码</h3><p>一个Redis list表示为一序列字符串</p>
<ol>
<li>首先，从流中读取list的大小，按照长度编码的方式读取出<code>size</code>大小值。</li>
<li>按照字符串编码方式从流中读取出size个字符串</li>
<li>使用这些字符串重新构建list</li>
</ol>
<h3 id="Hash编码"><a href="#Hash编码" class="headerlink" title="Hash编码"></a>Hash编码</h3><ol>
<li>从流中按照长度编码的方式读取出hash表的大小size</li>
<li>从流中按照字符串编码方式读取出2*size个字符串对象</li>
<li>键值对交替出现</li>
</ol>
<h3 id="Ziplist编码"><a href="#Ziplist编码" class="headerlink" title="Ziplist编码"></a>Ziplist编码</h3><p>一个Ziplist编码本质上是一个list类型的字符串，借助于标记(flag)和偏移量(offset)来达到双向遍历。<br>为解析一个ziplist，首先从流中按照字符串编码读取一个字符串，这个字符串就是ziplist的封装。<br>结构如下：</p>
<ol>
<li>zlbytes ：这是一个 4 字节无符号整数，表示 ziplist 的总字节数。这 4 字节是 little endian 格式－－最先出现的是最低有效位组</li>
<li>zltail：这是一个 4 字节无符号整数，little endian 格式。它表示到 ziplist 的尾条目（tail entry）的偏移。</li>
<li>zllen：这是一个 2 字节无符号整数，little endian 格式。它表示 ziplist 的条目的数量</li>
<li>entry：一个条目表示 ziplist 的元素。细节在下面</li>
<li>zlend：总是等于 255。它表示 ziplist 的结束</li>
</ol>
<p>ziplist的每个entry都是以下这样的格式： <code>&lt;length-prev-entry&gt;&lt;special-flag&gt;&lt;raw-bytes-of-entry&gt;</code><br>具体参考Redis中ziplist的实现方式。</p>
<h2 id="CRC校验和"><a href="#CRC校验和" class="headerlink" title="CRC校验和"></a>CRC校验和</h2><p>从Redis5开始启动参数控制是否将8字节的校验和添加到文件末尾，可以通过修改参数关闭该功能。<br>当禁用校验和的时候，此字段为0</p>
<blockquote>
<p><a href="https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_File_Format.textile" target="_blank" rel="noopener">https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_File_Format.textile</a><br><a href="https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_Version_History.textile" target="_blank" rel="noopener">https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_Version_History.textile</a><br><a href="https://github.com/wen866595/open-doc/blob/master/redis-doc/Redis-RDB-Dump-File-Format-cn.md" target="_blank" rel="noopener">https://github.com/wen866595/open-doc/blob/master/redis-doc/Redis-RDB-Dump-File-Format-cn.md</a><br><a href="https://blog.csdn.net/guiqulaxi920/article/details/51177307" target="_blank" rel="noopener">https://blog.csdn.net/guiqulaxi920/article/details/51177307</a><br><a href="http://ascii.911cha.com/" target="_blank" rel="noopener">http://ascii.911cha.com/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pika学习之同步篇]]></title>
      <url>/2020/01/05/new/pika/pika%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<ul>
<li>pika支持m-s的复制方式，跟redis主从复制命令一样，通过slave执行slaveof命令来触发。</li>
<li>slave的trysync线程向master发起trysync，同时将同步位点信息发送给master</li>
<li>master处理trysync命令，发起对slave的同步过程，从同步点开始顺序发送binlog或进行全同步</li>
</ul>
<h1 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h1><p>pika在需要进行全量同步的时候，会将数据文件进行dump后通过rsync的deamon模式发送给slave。</p>
<h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><ol>
<li>slave在trysnc前启动rsync进程启动rsync服务</li>
<li>master发现需要全同步时，判断是否有备份文件可用，如果没有先dump一份</li>
<li>master通过rsync向slave发送dump出的文件</li>
<li>slave用收到的文件替换自己的db</li>
<li>slave用最新的偏移量再次发起trysnc</li>
<li>完成同步 </li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0g8e1iij30oq09q0th.jpg" alt=""></p>
<center>slave同步流程</center>

<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0gae0huj30me08qt99.jpg" alt=""></p>
<center>master同步流程</center>

<a id="more"></a>
<p>slave连接状态：</p>
<ul>
<li>No Connect：不尝试成为任何其他节点的slave</li>
<li>Connect：Slaveof后尝试成为某个节点的slave，发送trysnc命令和同步点</li>
<li>Connecting：收到master回复可以slaveof，尝试跟master建立心跳</li>
<li>Connected: 心跳建立成功</li>
<li>WaitSync：不断检测是否DBSync完成，完成后更新DB并发起新的slaveof<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0h9q8ulj30hn0dr0tm.jpg" alt=""></li>
</ul>
<h1 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h1><p>Pika的主从同步是通过Binlog来完成的，在一主多从的结构中，master节点也可以给多个slave复用一个Binlog，不同的slave拥有不同的偏移量。</p>
<h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><ol>
<li>当WorkerThread接收到客户端的命令，按照执行顺序，添加到Binlog里</li>
<li>BinglogSenderThread判断它所负责的从节点在主节点的Binlog里是否有需要同步的命令，若有则发送给从节点</li>
<li>BinglogReceiverModule模块则做以下三件事情：接收主节点的BinlogSenderThread发送过来的同步命令；把接收到的命令应用到本地的数据上；把接收到的命令添加到本地Binlog里 至此，一条命令从主节点到从节点的同步过程完成<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0spmbugj30i20en75l.jpg" alt=""></li>
</ol>
<ul>
<li>WorkerThread：接受和处理用户的命令</li>
<li>BinlogSenderThread：负责顺序地向对应的从节点发送在需要同步的命令</li>
<li>BinlogReceiverModule: 负责接受主节点发送过来的同步命令</li>
<li>Binglog：用于顺序的记录需要同步的命令</li>
</ul>
<p>上图中的<code>BinLogReceiverModule</code>是为了更好的说明方便而抽象出来的一个对象，从图中可以看出<code>BinLogReceiverModule</code>是由一个<code>BinlogReceiverThread</code>和多个<code>BinlogBGWorker</code>组成。</p>
<ul>
<li>BinlogReceiverThread: 负责接受由主节点传送过来的命令，并分发给各个BinlogBGWorker，若当前的节点是只读状态（不能接受客户端的同步命令），则在这个阶段写Binlog</li>
<li>BinlogBGWorker：负责执行同步命令；若该节点不是只读状态（还能接受客户端的同步命令），则在这个阶段写Binlog（在命令执行之前写）</li>
</ul>
<p>BinlogReceiverThread接收到一个同步命令后，它会给这个命令赋予一个唯一的序列号（这个序列号是递增的），并把它分发给一个BinlogBGWorker；而各个BinlogBGWorker则会根据各个命令的所对应的序列号的顺序来执行各个命令，这样也就保证了命令执行的顺序和主节点执行的顺序一致了 之所以这么设计主要原因是：</p>
<ol>
<li>配备多个BinlogBGWorker是可以提高主从同步的效率，减少主从同步的滞后延迟</li>
<li>BinlogBGWorker在执行执行之前写Binlog可以提高命令执行的并行度</li>
<li>在当前节点是非只读状态，让BinglogReceiverThread来写Binlog，是为了让Binglog里保存的命令顺序和命令的执行顺序保持一致</li>
</ol>
<h2 id="Binlog结构"><a href="#Binlog结构" class="headerlink" title="Binlog结构"></a>Binlog结构</h2><p>由于主从偏移量一样，所以一旦发生网络或节点故障需要重连主从时，slave只需要将当前的偏移量发送给master，master找到后从该偏移量开始同步后续命令。<br>理论上命令不做处理一条一条追加到Binlog文件中，这也就意味着如果文件写错一个字节就会导致整个文件不可用，所以pika采用了类似leveldb log的格式来进行存储。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gam0rxhp2rj30i20att9m.jpg" alt=""></p>
<h3 id="leveldb-log"><a href="#leveldb-log" class="headerlink" title="leveldb log"></a>leveldb log</h3><p>在leveldb中，所有的写操作都必须先成功的append到操作日志中，然后再更新内存memtable</p>
<ol>
<li>可以将随机的写IO变成append，极大的提高写磁盘速度</li>
<li>防止在节点down机导致内存数据丢失，造成数据丢失<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">The log file contents are a sequence of 32KB blocks.  The only</span><br><span class="line">exception is that the tail of the file may contain a partial block.</span><br><span class="line"></span><br><span class="line">Each block consists of a sequence of records:</span><br><span class="line">   block := record* trailer?</span><br><span class="line">   record :=</span><br><span class="line">    checksum: uint32    // crc32c of type and data[] ; little-endian</span><br><span class="line">    length: uint16      // little-endian</span><br><span class="line">    type: uint8     // One of FULL, FIRST, MIDDLE, LAST</span><br><span class="line">    data: uint8[length]</span><br><span class="line"></span><br><span class="line">A record never starts within the last six bytes of a block (since it</span><br><span class="line">won&apos;t fit).  Any leftover bytes here form the trailer, which must</span><br><span class="line">consist entirely of zero bytes and must be skipped by readers.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>日志文件由连续的大小为32KB的block组成，block又由连续的record组成，record的格式为 | CRC(4 byte) | Length(2 byte) | type(1 byte) | data |</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/223f0c73ddc2" target="_blank" rel="noopener">LevelDB 功能与架构</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Pika </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Pika </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[何为IO多路复用]]></title>
      <url>/2020/01/05/new/Redis/%E4%BD%95%E4%B8%BAIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="网络编程概念"><a href="#网络编程概念" class="headerlink" title="网络编程概念"></a>网络编程概念</h2><p>在网络当中，数据的传输是基于HTTP/TCP协议簇来实现的。TCP协议仅仅是把这些数据看做是一串二进制流来进行处理。<br>所以：<b>客户端和服务器是通过在建立的连接上发送字节流来进行通信</b></p>
<p>一个连接由它两端的套接字地址唯一确定，结构为<code>(客户端地址:客户端端口号，服务端地址:服务端端口号)</code>。有了通信双方的连接地址信息后，就可以进行数据传输了。</p>
<p>在Unix系统中，实现了一套套接字接口来描述和规范双方通信的整个过程。<br>创建-&gt;连接-&gt;绑定-&gt;监听-&gt;响应<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1galrpl667mj30hs0dzwfp.jpg" alt=""></p>
<blockquote>
<ul>
<li>socket()：创建一个套接字描述符</li>
<li>connect()：客户端通过调用connect函数来建立和服务器的连接</li>
<li>bind()：告诉内核将socket()创建的套接字与某个服务端地址与端口连接起来，后续会对这个地址和端口进行监听</li>
<li>listen()：告诉内核，将这个套接字当成服务器这种被动实体来看待(服务器是等待客户端连接的被动实体，而内核认为socket()创建的套接字默认是主动实体，所以才需要listen()函数，告诉内核进行主动到被动实体的转换)</li>
<li>accept()：等待客户端的连接请求并返回一个新的已连接描述符</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="最简单的单进程服务器"><a href="#最简单的单进程服务器" class="headerlink" title="最简单的单进程服务器"></a>最简单的单进程服务器</h2><p>由于Unix的历史遗留问题，原始的套接字接口对地址和端口等数据封装并不简洁。<br>在最初的服务器中，一个服务器进程只能同时处理一个客户端连接与相关的读写操作。<br>在读写的过程中，整个进程被该客户端独占，当前服务器进程只能处理该客户端连接的读写操作，无法对其他客户端连接请求进行处理。</p>
<h2 id="IO并发提升"><a href="#IO并发提升" class="headerlink" title="IO并发提升"></a>IO并发提升</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>如果去优化单进程？<br>一个进程不行，那就搞多个进程来同时处理不就得了。</p>
<p>由于一个客户端的connect对应着一个服务端的accept，那么每次客户端过来时，都使用fork()来进行accept的系统调用。</p>
<p>缺点：</p>
<ul>
<li>进程创建的数量随连接请求的增加而增加。</li>
<li>fork等系统调用会使得进程的上下文进行切换，效率很低。</li>
<li>进程与进程之间的地址空间私有。使得进程之间的数据共享比较困难。</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>线程是运行在进程上下文的逻辑流。一个进程可以包含多个线程，多个线程运行在单一的进程上下文中，因此共享这个进程的地址空间的所有内容，解决了进程与进程之间通信难的问题。同时，由于一个线程的上下文要比一个进程的上下文小得多，所以线程的上下文切换，要比进程的上下文切换效率高得多。线程是轻量级的进程，解决了进程上下文切换效率低的问题。</p>
<h3 id="基于单进程的IO多路复用"><a href="#基于单进程的IO多路复用" class="headerlink" title="基于单进程的IO多路复用"></a>基于单进程的IO多路复用</h3><p>前面谈到的都是通过增加进程和线程的数量来同时处理多个套接字。而IO多路复用只需要一个进程就能够处理多个套接字。</p>
<p>其本质是：<b>一个服务端进程可以同时处理多个套接字描述符</b></p>
<p>在之前的讲述中，一个服务端进程，只能同时处理一个连接。如果想同时处理多个客户端连接，需要多进程或者多线程的帮助，免不了上下文切换的开销。IO多路复用技术就解决了上下文切换的问题。IO多路复用技术的发展可以分为select-&gt;poll-&gt;epoll三个阶段。</p>
<p>IO多路复用的核心就是添加了一个<b>套接字集合管理员</b>，它可以同时监听多个套接字。由于客户端连接以及读写事件到来的随机性，我们需要这个管理员在单进程内部对多个套接字的事件进行合理的调度。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select()函数会在某个或某些套接字的状态从不可读变为可读、或不可写变为可写的时候通知服务器主进程。所以select()本身的调用是阻塞的。但是具体哪一个套接字或哪些套接字变为可读或可写我们是不知道的，所以我们需要遍历所有select()返回的套接字来判断哪些套接字可以进行处理了。</p>
<p>但是，select()函数本身的调用阻塞的。因为select()需要一直等到有状态变化的套接字之后（比如监听套接字或者连接套接字的状态由不可读变为可读），才能解除select()本身的阻塞，继续对读写就绪的套接字进行处理。虽然这里是阻塞的，但是它能够同时返回多个就绪的套接字，而不是之前单进程中只能够处理一个套接字，大大提升了效率</p>
<p>优点：</p>
<ul>
<li>实现了对多个套接字的同时、集中管理</li>
<li>通过遍历所有的套接字集合，能够获取所有已就绪的套接字，对这些就绪的套接字进行操作不会阻塞</li>
</ul>
<p>缺点：</p>
<ul>
<li>select管理的套接字描述符们存在数量限制。在Unix中，一个进程最多同时监听1024个套接字描述符</li>
<li>select返回的时候，并不知道具体是哪个套接字描述符已经就绪，所以需要遍历所有套接字来判断哪个已经就绪，可以继续进行读写</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><b>poll解决了select带来的套接字描述符的最大数量限制问题</b></p>
<p>poll的fds参数集合了select的read、write和exception套接字数组，合三为一。poll中的fds没有了1024个的数量限制。当有些描述符状态发生变化并就绪之后，poll同select一样会返回。但是遗憾的是，我们同样不知道具体是哪个或哪些套接字已经就绪，我们仍需要遍历套接字集合去判断究竟是哪个套接字已经就绪，这一点并没有解决刚才提到select的第二个问题。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是最先进的套接字管理员，解决了上述select和poll中所存在的问题。它将一个阻塞的select、poll系统调用拆分成了三个步骤。一次select或poll可以看作是由一次 epoll_create、若干次 epoll_ctl、若干次 epoll_wait构成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>epoll_create()：创建一个epoll实例。后续操作会使用</li>
<li>epoll_ctl()：对套接字描述符集合进行增删改操作，并告诉内核需要监听套接字描述符的什么事件</li>
<li>epoll_wait()：等待监听列表中的连接事件（监听套接字描述符才会发生）或读写事件（连接套接字描述符才会发生）。如果有某个或某些套接字事件已经准备就绪，就会返回这些已就绪的套接字们</li>
</ul>
<p>我们调用epoll_wait()等待连接或读写等事件，在某个套接字描述符上准备就绪。当有事件准备就绪之后，会存到第二个参数epoll_event结构体中。通过访问这个结构体就可以得到所有已经准备好事件的套接字描述符。这里就不用再像之前select和poll那样，遍历所有的套接字描述符之后才能知道究竟是哪个描述符已经准备就绪了，这样减少了一次O(n)的遍历，大大提高了效率。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[提问的智慧]]></title>
      <url>/2020/01/05/new/other/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/</url>
      <content type="html"><![CDATA[<h1 id="在你提问之前"><a href="#在你提问之前" class="headerlink" title="在你提问之前"></a>在你提问之前</h1><ul>
<li>尝试在你准备提问的论坛的旧文章中搜索答案</li>
<li>尝试上网搜索以找到答案</li>
<li>尝试阅读手册以找到答案</li>
<li>尝试阅读常见问题文件（FAQ）以找到答案</li>
<li>尝试自己检查或试验以找到答案</li>
<li>向你身边的强者朋友打听以找到答案</li>
<li>如果你是程序开发者，请尝试阅读源代码以找到答案</li>
</ul>
<h1 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h1><ul>
<li>慎选提问的论坛</li>
<li>Stack Overflow</li>
<li>网站和 IRC 论坛</li>
<li>第二步，使用项目邮件列表</li>
<li>使用有意义且描述明确的标题</li>
<li>使问题容易回复</li>
<li>用清晰、正确、精准并合法语法的语句</li>
<li>使用易于读取且标准的文件格式发送问题</li>
<li>精确地描述问题并言之有物</li>
<li>话不在多而在精</li>
<li>别动辄声称找到 Bug</li>
<li>低声下气不能代替你的功课</li>
<li>描述问题症状而非你的猜测</li>
<li>按发生时间先后列出问题症状</li>
<li>描述目标而不是过程</li>
<li>别要求使用私人电邮回复</li>
<li>清楚明确的表达你的问题以及需求</li>
<li>询问有关代码的问题时</li>
<li>别把自己家庭作业的问题贴上来</li>
<li>去掉无意义的提问句</li>
<li>即使你很急也不要在标题写紧急</li>
<li>礼多人不怪，而且有时还很有帮助</li>
<li>问题解决后，加个简短的补充说明</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1galmxel3nqj30u00vk43j.jpg" alt=""></p>
<blockquote>
<p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 生活杂记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[听《工作三年我学到了什么》总结]]></title>
      <url>/2020/01/05/new/other/%E5%90%AC%E3%80%8A%E5%B7%A5%E4%BD%9C%E4%B8%89%E5%B9%B4%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E3%80%8B%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近听到一篇文章，觉得其中很多的点给了我很多收获。所以反复听了很多遍，并做了大概的总结。关键词：沟通、尝试、上升、思考、落地。</p>
<ul>
<li>不要把自己局限于某一个位置，试着多尝试不同的东西，“管理”好自己,“管理”好身边的人。</li>
<li>你的技术能力决定了你能多快去完成目标。而你的非技术能力决定了你在朝哪个方向努力。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakzw4xmkcj30u00ubn5h.jpg" alt=""></p>
<a id="more"></a>
<p>总的来说，就是站在不同角色的角度来看待事情，思他人之所思。(领导、依赖人、客户、被求助者、被依赖人)</p>
<h2 id="向上管理"><a href="#向上管理" class="headerlink" title="向上管理"></a>向上管理</h2><p>在工作当中，我们经常都是领导分配什么任务，我们就去努力完成任务。<br>而没有去思考这个任务到底能不能胜任，有没有更适合去做这个任务的人，以及更适合自己的任务却被分配给了其他的人。<br><b>领导是一个统筹管理的角色</b>，他大多时候只会关注总体任务是否完成。而没在意谁完成，怎么完成。</p>
<p><font color="red">我们应该站在领导的角度上去思考整个项目任务</font>当我们遇到不合理任务时，及时表达自己的想法和看法，看是否存在更好解决方案。<br>一个适合自己的任务，不仅能够节省大量完成任务的时间，还能保证完成的质量。</p>
<p>当然，在更多时候人手并不是很充足，所以并不是说一味的去拒绝任务；完成任务仍然是第一优先级，只有在完成任务的基础上，才能去发表和实现自己的想法。</p>
<h2 id="沟通先行"><a href="#沟通先行" class="headerlink" title="沟通先行"></a>沟通先行</h2><p>在整个项目流程当中，我们会遇到很多依赖别人的点。我们尽量在到达这个点之间就提前跟相关依赖人沟通，确定资源，而不是在需要的时候才去申请资源。</p>
<h2 id="高效会议"><a href="#高效会议" class="headerlink" title="高效会议"></a>高效会议</h2><p>在参加会议前，我们需要明确自己在其中的角色、需要了解、表达的东西。明确需要沟通的相关人员及其负责部分。<br>在会议当中，我们需要准确的提出自己的问题以及看法，避免形成沟通黑洞。<br>会议之后，需要及时记录会议记录，避免忘记。不同紧急程度的任务可以采用不同的方式去联系相关人员。</p>
<h2 id="上升意识"><a href="#上升意识" class="headerlink" title="上升意识"></a>上升意识</h2><p>不要将自己的角色给限制死，需要时常的跳出去，从不同的维度发展自己。不断的去尝试边界，并尝试突破。<br>主动的去发现项目的风险点、改进点。多从其他人手中争取锻炼自己的机会。</p>
<blockquote>
<p><a href="https://pythonhunter.org/episodes/sp02" target="_blank" rel="noopener">原文：https://pythonhunter.org/episodes/sp02</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 生活杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JB全家桶激活教程]]></title>
      <url>/2020/01/04/new/other/JB%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<ul>
<li>本教程适用于jetbrains全家桶开发工具（Pycharm、Idea、WebStorm、phpstorm、CLion、RubyMine、AppCode、DataGrid）</li>
<li>本教程适用于所有版本</li>
<li>软件直接从官网下载即可</li>
<li>不需要修改host</li>
</ul>
<h2 id="激活教程"><a href="#激活教程" class="headerlink" title="激活教程"></a>激活教程</h2><h3 id="1-下载破解补丁"><a href="#1-下载破解补丁" class="headerlink" title="1. 下载破解补丁"></a>1. 下载破解补丁</h3><p>下载补丁文件：<a href="https://pan.baidu.com/s/1Kc-byjcH_pvrN4CTgfKSFA" target="_blank" rel="noopener">jetbrains-agent.jar</a><br>文件保存位置可以任意，建议放置到软件安装路径的bin目录下。避免误删文件。</p>
<a id="more"></a>
<h3 id="2-点击试用"><a href="#2-点击试用" class="headerlink" title="2. 点击试用"></a>2. 点击试用</h3><p>如果你是刚下载的IDEA，则需要点击激活窗口的“Evaluate for free”免费试用，然后再创建一个空项目，这样就可以进入到IDEA的工作页面<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaketkrmc0j30su0aigmp.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeuydlulj30zw0u0ahk.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakev1f4tcj314a0qojty.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakev6d8cxj314a0qo0ux.jpg" alt=""></p>
<h3 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3. 修改配置文件"></a>3. 修改配置文件</h3><p><font color="red"> 配置文件修改已经不在bin目录下直接修改，而是通过IDEA修改</font><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakexpa10mj31100qs0uc.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakextkszmj31c60u0jvx.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakexxczvlj31c60u076b.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeyew4ilj31c60u0tb5.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeyicahmj31hc0sktcn.jpg" alt=""></p>
<p>进入到项目界面后，点击IDEA最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options …”<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakeyw6muqj31gf0u0n2b.jpg" alt=""></p>
<p>如果提示是否要创建文件，请点”Yes”。</p>
<p>在打开的vmoptions编辑窗口末行添加：<font color="red"> -javaagent:你IDEA的安装目录\jetbrains-agent.jar</font> 请仔细检查补丁路径是否正确，如果错误则会出现IDEA打不开的情况。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakezxp1tij31hc0tsq8e.jpg" alt=""><br><b>修改完配置文件之后切记重启IDEA软件</b></p>
<p>如果修改完打不开软件，或者提示没有jdk等问题，这时候可以删除用户目录下的IDEA文件夹，注意这个文件夹是隐藏目录！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windwos：C:\Users\用户名\</span><br><span class="line">macos：~/Library/Preferences/</span><br><span class="line">ubuntu：~/.</span><br></pre></td></tr></table></figure></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf0tyctij31gd0u046p.jpg" alt=""></p>
<h3 id="4-输入激活码"><a href="#4-输入激活码" class="headerlink" title="4. 输入激活码"></a>4. 输入激活码</h3><p>修改完配置文件之后重启IDEA，点击菜单栏中的 “Help” -&gt; “Register …”<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf1mhjaaj31ga0u0jyg.jpg" alt=""></p>
<p>选择最后一种License server激活方式，地址填入：<a href="http://jetbrains-license-server" target="_blank" rel="noopener">http://jetbrains-license-server</a> （应该会自动填上），或者点击按钮：”Discover Server”来自动填充地址，完成激活。</p>
<p>注意：服务器激活需要联网！<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf2mn7tdj31hc0tr438.jpg" alt=""></p>
<p>如果服务器激活方式无法激活，还可以选择Activation code方式激活，复制下面激活码即可<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf3hatfwj314a0qogrb.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JQE11SV0BR-eyJsaWNlbnNlSWQiOiJKUUUxMVNWMEJSIiwibGljZW5zZWVOYW1lIjoicGlnNiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-khgsQrnDiglknF0m+yyoYGJXX4vFE3IIVaoMd0bkpfAlMiYM4FUK1JM7uMnVSN0NBC7qtZjYlNzPscEyKE8634uGuY/uToFQnIOCtyUfBxB6j0wF/DcCjhKMNDbnJ1RKZ2VaALuC9B6d6lhtEKm9+urXWTBq7h2VfIBv5wk1Ul9T/m9Dwkz/LccTqnxO0PP288fF13ZbmcLI1/D0dqp/QxYshW6CLR+2Tvk6QCPoaOTKDU/eL1AssD7/mO1g2ZJA+k//8qfRMLgdLmLrMdyiaIhrsM/jJk2qDfTaMcCNylkWXLgKwSvEQG95IhitLN9+GQ4pBW3gOTNl82Gem7jEkA==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure></p>
<h3 id="5-查看有效期"><a href="#5-查看有效期" class="headerlink" title="5. 查看有效期"></a>5. 查看有效期</h3><p>当你激活完毕后，IDEA右下角会有个Registration小长条提示框，大致的内容为：You copy is Licensed to XXX意思就会告诉你：兄弟，你已经激活成功了，激活码的许可来源是：XXX。<br>查看有效期的步骤为点击：Help-&gt;About这里可以看到你的IDEA的版本号、许可来源、有效期、以及一些环境<br>服务器激活是没有期限的，即为永久有效<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakf4dn7abj31hc0th44m.jpg" alt=""></p>
<blockquote>
<p>资源来源：<br><a href="https://zhile.io/" target="_blank" rel="noopener">https://zhile.io/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 软件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 破解教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pika学习之数据结构篇]]></title>
      <url>/2019/12/29/new/pika/pika%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>pika的持久化存储模块称为nemo存储引擎，其本质上是对rocksDB(只支持KV存储)的改造和封装。使其支持多数据结构的存储。<br>pika作为类redis数据库，所以肯定得兼容redis最基本的五种数据结构：string、hash、list、set、zset。 </p>
<h2 id="KV存储"><a href="#KV存储" class="headerlink" title="KV存储"></a>KV存储</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae07se7opj30k204tq33.jpg" alt=""><br>KV存储作为rocksDB原生支持的存储方式，所以并没有做太多的处理。仅仅只是在value的结尾加上8个字节的附加信息(前4个字节表示version，后4个字节表示ttl)。<br>version字段用于对该键值对进行标记，以便后续处理，如删除一个键值对时，可以在该version进行标记，后续再进行真正的删除，这样可以减少删除操作造成的服务阻塞时间。</p>
<h2 id="Hash存储"><a href="#Hash存储" class="headerlink" title="Hash存储"></a>Hash存储</h2><p>对于每一个Hash结构，它都包含hash键(key)、域名(field)、值(value)。<br>nome的存储方式是将key和field组合成为一个新的key，将这个新生成的key与要存储的value组成最终落盘的kv键值对。<br>对于每一个hash键，nome还为它添加了一个存储元数据信息的落盘kv，它保存的是对应hash键下的所有域值对的个数。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae07pcssxj30jx04y0t0.jpg" alt=""></p>
<ul>
<li>左图字段保存的是hash键的对象，它由标记位+key+version+ttl组成</li>
<li>右图字段仅仅只保存一个数字，表示该hash下field的数量</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae0docgmtj30rg06iq3b.jpg" alt=""><br>上图表示nome对传统hash结构转换成kv结构的拆分存储模式。</p>
<ul>
<li>k结构部分由标记位+长度+key+field组成。size表示的是hash键key的长度。</li>
<li>v结构部分就由具体的value+version+ttl组成。<a id="more"></a>
</li>
</ul>
<h2 id="List存储"><a href="#List存储" class="headerlink" title="List存储"></a>List存储</h2><p>每个List结构的底层存储也是采用链表结构来完成，对于每个List键，它的每个元素都落盘成一个kv键值对。<br>和Hash结构一样，每个List也需要拥有一个它的元素信息结构。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae0oa3gxuj30m806mjrq.jpg" alt=""></p>
<ul>
<li>List的key存储和hash的一样，只有标记位不一样而已。</li>
<li>value则存储了List的元数据信息，它有四个字段，从前到后分别为该List键内的元素个数、最左边元素节点的sequence(表头)、最右边元素节点的sequence(表尾)、下一个插入元素节点应该使用的sequence。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae0oe8d2tj30qx06mq3b.jpg" alt=""></p>
<ul>
<li>k结构部分由标记位+长度+key+sequence组成。size表示的是hash键key的长度。</li>
<li>v结构部分由前一个元素的sequence+后一个元素的sequence+value+version+ttl组成。从而实现了一个双向链表的结构。</li>
</ul>
<h2 id="Set存储"><a href="#Set存储" class="headerlink" title="Set存储"></a>Set存储</h2><p>Set，本质上就是一个value值为nil的Hash结构。在Java和Redis中，都是利用hashtable来实现的。nome并没有做什么特殊处理，只是在存储value时，只保存了version和ttl结构。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae10jcgjdj30lw06oglt.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae10oq2i8j30kw06mq35.jpg" alt=""></p>
<h2 id="Zset存储"><a href="#Zset存储" class="headerlink" title="Zset存储"></a>Zset存储</h2><p>Zset就是一个有序的Set结构，所以对于每个元素，增加了一个scope值。把该元素对应的score值整合进去，这样便于依据Score值进行排序（因为从rocksdb内拿出的数据时按键排序的）<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae13azcgrj30ii068q33.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae13e4n73j30oa068wep.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gae13hlow6j30oa068wep.jpg" alt=""><br>score是从double类型转变过来的int64_t类型，这样做是为了可以让原来的浮点型的score直接参与到字符串的排序当中（浮点型的存储格式与字符串的比较方式不兼容）。</p>
]]></content>
      
        <categories>
            
            <category> Pika </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Pika </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis复制过程演变]]></title>
      <url>/2019/12/29/new/Redis/redis%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E6%BC%94%E5%8F%98/</url>
      <content type="html"><![CDATA[<p>Redis的主从复制主要经历以下的几个阶段：</p>
<ol>
<li>2.8版本以下—-sync</li>
<li>2.8-4.0版本—-psync</li>
<li>4.0版本+ —-psync2</li>
</ol>
<p>下面我就来简单的讲讲Redis主从复制的演变过程。</p>
<h2 id="Redis主从复制过程"><a href="#Redis主从复制过程" class="headerlink" title="Redis主从复制过程"></a>Redis主从复制过程</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadwq7etd2j31r50u0464.jpg" alt=""></p>
<ul>
<li>客户端发送slaveof命令给Redis实例</li>
<li>准备阶段函数为<code>replicationSetMaster</code>，这个函数主要会做一些复制之前的数据和状态清理工作。</li>
<li>更新server.master</li>
<li>将实例状态修改为REPL_STATE_CONNECT<a id="more"></a>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadwqm9ps9j31pc0u045z.jpg" alt=""><br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadxodwcpuj31pf0u0dns.jpg" alt=""><br>Redis每秒会调用一次<code>replicationCron</code>定时任务。根据Redis当前所处状态来决定下一步操作。</li>
<li>当Redis状态为<code>REPL_STATE_CONNECT</code>时会调用<code>connectWithMaster</code>创建连接master事件。该函数会将Redis状态修改为<code>REPL_STATE_CONNECTING</code></li>
<li>接下来进行心跳检查、权限校验等操作</li>
<li>master接收到slave的复制命令后，就会触发一次rdb全备，并记录下全备期间的命令。</li>
<li>master将全备文件发送给slave后，将增量命令发送给slave。</li>
<li>心跳维持和持续复制</li>
</ul>
<h2 id="主从复制的演变"><a href="#主从复制的演变" class="headerlink" title="主从复制的演变"></a>主从复制的演变</h2><p>在2.8之前的版本中，如果由于网络等原因导致主从复制断开。那么就会将从节点状态修改为<code>REPL_STATE_CONNECTING</code>。进而会重新进行全量同步流程。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadxz7g5aoj31rq0gcju1.jpg" alt=""><br>在2.8版本中，Redis增加了psync命令，并且增加了一个复制积压缓冲区的数据结构（默认为1M）。<br>复制积压缓冲区是一个环形的结构，保存了最近可用的写命令数据。<br>在<code>replicationCron</code>定时任务中每秒发送一个<code>REPLCONF ACK OFFSET</code>命令将自身的偏移量信息发送给master，如果offset的命令在复制积压缓冲区中，那么说明增量数据是可用的。就没必要进行全量同步，直接将复制积压缓冲区中的增量数据发送给slave就可以了。</p>
<p>在redis4.0+版本中又引进了psync2命令来避免一些特殊场景(主从架构、级联架构)下发生主从切换后不必要的全量同步操作。<br>将一组replid和offset给增加成为两组。主要用来记录上一次复制中主实例的runid值。然后在slaveof时判断是否有必要进行全量同步操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">replid1：</span><br><span class="line">主节点：自身的replid和offset</span><br><span class="line">从节点：主节点的replid和offset</span><br><span class="line"></span><br><span class="line">replid2:</span><br><span class="line">上一次主实例的replid和offset</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析GeoHash]]></title>
      <url>/2019/12/26/new/Redis/%E6%B5%85%E6%9E%90GeoHash/</url>
      <content type="html"><![CDATA[<p>GeoHash算法能够将二维的经纬度转换成字符串。主要有以下几个特性:</p>
<ol>
<li>每一个字符串代表了某一矩形区域.</li>
<li>字符串的长度越长，所表示的位置越精确。</li>
<li>字符串越相近的表示的举例越接近.</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>GeoHash将经纬度转换为hash字符串主要分为三步：</p>
<ol>
<li>将纬度(-90, 90)平均分成两个区间(-90, 0)、(0, 90)，如果坐标位置的纬度值在第一区间，则编码是0，否则编码为1</li>
<li>经纬度的编码合并，从0开始，奇数为是纬度，偶数为是经度</li>
<li>对经纬度合并后的编码，进行base32编码</li>
</ol>
<p>大概过程如下图，不断的对经纬度进行切割，直到精准度达到要求。<br><img src="https://user-gold-cdn.xitu.io/2018/7/4/1646397a223e2019?imageslim" alt="IMAGE"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>将经纬度转换成二进制编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void convert(double min, double max, double value, List&lt;Character&gt; list) &#123;</span><br><span class="line">        if (list.size() &gt; (length - 1)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        double mid = (max + min) / 2;</span><br><span class="line">        if (value &lt; mid) &#123;</span><br><span class="line">            list.add(&apos;0&apos;);</span><br><span class="line">            convert(min, mid, value, list);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            list.add(&apos;1&apos;);</span><br><span class="line">            convert(mid, max, value, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>合并经纬度的二进制编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Character&gt; latList = new ArrayList&lt;Character&gt;();</span><br><span class="line">List&lt;Character&gt; lngList = new ArrayList&lt;Character&gt;();</span><br><span class="line">convert(Min_Lat, Max_Lat, lat, latList);</span><br><span class="line">convert(Min_Lng, Max_Lng, lng, lngList);</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">for (int index = 0; index &lt; latList.size(); index++) &#123;</span><br><span class="line">    sb.append(lngList.get(index)).append(latList.get(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>base32编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private final String[] base32Lookup =</span><br><span class="line">            &#123;&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;,</span><br><span class="line">                    &quot;j&quot;, &quot;k&quot;, &quot;m&quot;, &quot;n&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;&#125;;</span><br><span class="line">    private String base32Encode(final String str) &#123;</span><br><span class="line">        String unit = &quot;&quot;;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int start = 0; start &lt; str.length(); start = start + 5) &#123;</span><br><span class="line">            unit = str.substring(start, start + 5);</span><br><span class="line">            sb.append(base32Lookup[convertToIndex(unit.split(&quot;&quot;))]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    private int convertToIndex(String str) &#123;</span><br><span class="line">        int length = str.length();</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int index = 0; index &lt; length; index++) &#123;</span><br><span class="line">            result += str.charAt(index) == &apos;0&apos; ? 0 : 1 &lt;&lt; (length - 1 - index);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="Redis中的Geo使用"><a href="#Redis中的Geo使用" class="headerlink" title="Redis中的Geo使用"></a>Redis中的Geo使用</h2><p>在Redis中，Geo的内部结构实际上是一个zset。<br>Redis提供给Geo指定只有6个，但是它可以使用zset的所有指令。</p>
<h3 id="增加-geoadd"><a href="#增加-geoadd" class="headerlink" title="增加-geoadd"></a>增加-geoadd</h3><p>geoadd指令传入多个经纬度名称三元组，Redis内存会调用函数计算出相应的geohash字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd company 116.48105 39.996794 juejin</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.514203 39.905409 ireader</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.489033 40.007669 meituan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p>
<h3 id="距离-geodist"><a href="#距离-geodist" class="headerlink" title="距离-geodist"></a>距离-geodist</h3><p>geodist 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist company juejin ireader km</span><br><span class="line">&quot;10.5501&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin meituan km</span><br><span class="line">&quot;1.3878&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin jd km</span><br><span class="line">&quot;24.2739&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin xiaomi km</span><br><span class="line">&quot;12.9606&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin juejin km</span><br><span class="line">&quot;0.0000&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="获取元素位置-geopos"><a href="#获取元素位置-geopos" class="headerlink" title="获取元素位置-geopos"></a>获取元素位置-geopos</h3><p>geopos 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos company juejin</span><br><span class="line">1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">   2) &quot;39.99679348858259686&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company ireader</span><br><span class="line">1) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">   2) &quot;39.90540918662494363&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company juejin ireader</span><br><span class="line">1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">   2) &quot;39.99679348858259686&quot;</span><br><span class="line">2) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">   2) &quot;39.90540918662494363&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="获取元素的-hash-值-geohash"><a href="#获取元素的-hash-值-geohash" class="headerlink" title="获取元素的 hash 值-geohash"></a>获取元素的 hash 值-geohash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash company ireader</span><br><span class="line">1) &quot;wx4g52e1ce0&quot;</span><br><span class="line">127.0.0.1:6379&gt; geohash company juejin</span><br><span class="line">1) &quot;wx4gd94yjn0&quot;</span><br></pre></td></tr></table></figure>
<h3 id="附近元素-georadiusbymember"><a href="#附近元素-georadiusbymember" class="headerlink" title="附近元素-georadiusbymember"></a>附近元素-georadiusbymember</h3><p>georadiusbymember 指令是最为关键的指令，它可以用来查询指定元素附近的其它元素，它的参数非常复杂。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 范围 20 公里以内最多 3 个元素按距离正排，它不会排除自身</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 asc</span><br><span class="line">1) &quot;ireader&quot;</span><br><span class="line">2) &quot;juejin&quot;</span><br><span class="line">3) &quot;meituan&quot;</span><br><span class="line"># 范围 20 公里以内最多 3 个元素按距离倒排</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km count 3 desc</span><br><span class="line">1) &quot;jd&quot;</span><br><span class="line">2) &quot;meituan&quot;</span><br><span class="line">3) &quot;juejin&quot;</span><br><span class="line"># 三个可选参数 withcoord withdist withhash 用来携带附加参数</span><br><span class="line"># withdist 很有用，它可以用来显示距离</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember company ireader 20 km withcoord withdist withhash count 3 asc</span><br><span class="line">1) 1) &quot;ireader&quot;</span><br><span class="line">   2) &quot;0.0000&quot;</span><br><span class="line">   3) (integer) 4069886008361398</span><br><span class="line">   4) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">      2) &quot;39.90540918662494363&quot;</span><br><span class="line">2) 1) &quot;juejin&quot;</span><br><span class="line">   2) &quot;10.5501&quot;</span><br><span class="line">   3) (integer) 4069887154388167</span><br><span class="line">   4) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">      2) &quot;39.99679348858259686&quot;</span><br><span class="line">3) 1) &quot;meituan&quot;</span><br><span class="line">   2) &quot;11.5748&quot;</span><br><span class="line">   3) (integer) 4069887179083478</span><br><span class="line">   4) 1) &quot;116.48903220891952515&quot;</span><br><span class="line">      2) &quot;40.00766997707732031&quot;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis4.0的大key发现和删除]]></title>
      <url>/2019/12/19/new/Redis/Redis4.0%E7%9A%84%E5%A4%A7key%E5%8F%91%E7%8E%B0%E5%92%8C%E5%88%A0%E9%99%A4/</url>
      <content type="html"><![CDATA[<p>Redis4.0版本之后引入了memory usage命令和lazyfree机制。不管是对大key的发现，还是解决删除大key造成的阻塞问题都有了很大的提升。</p>
<h3 id="大key发现"><a href="#大key发现" class="headerlink" title="大key发现"></a>大key发现</h3><p>memory usage的实现主要在<code>object.c-&gt;memoryCommand</code>方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;memory&quot;,memoryCommand,-2,</span><br><span class="line">     &quot;random read-only&quot;,</span><br><span class="line">     0,NULL,0,0,0,0,0,0&#125;,</span><br><span class="line">     </span><br><span class="line">else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;usage&quot;) &amp;&amp; c-&gt;argc &gt;= 3) &#123;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;</span><br><span class="line">        for (int j = 3; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">            if (!strcasecmp(c-&gt;argv[j]-&gt;ptr,&quot;samples&quot;) &amp;&amp;</span><br><span class="line">                j+1 &lt; c-&gt;argc)</span><br><span class="line">            &#123;</span><br><span class="line">                if (getLongLongFromObjectOrReply(c,c-&gt;argv[j+1],&amp;samples,NULL)</span><br><span class="line">                     == C_ERR) return;</span><br><span class="line">                if (samples &lt; 0) &#123;</span><br><span class="line">                    addReply(c,shared.syntaxerr);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (samples == 0) samples = LLONG_MAX;;</span><br><span class="line">                j++; /* skip option argument. */</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                addReply(c,shared.syntaxerr);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((de = dictFind(c-&gt;db-&gt;dict,c-&gt;argv[2]-&gt;ptr)) == NULL) &#123;</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        size_t usage = objectComputeSize(dictGetVal(de),samples);</span><br><span class="line">        usage += sdsAllocSize(dictGetKey(de));</span><br><span class="line">        usage += sizeof(dictEntry);</span><br><span class="line">        addReplyLongLong(c,usage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>我们可以看到计算使用内存大小核心逻辑是在<code>objectComputeSize</code>函数中，对不同类型的键值计算方式不一样，这里以hash类型举例。<br>在使用<code>memory usage</code>命令时可以指定一个抽样元素个数。默认为5，决定了内存计算的准确性和计算成本。<br>这个值越大，循环次数越多，计算结果越精准，性能损耗也越高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*...代码对数据类型进行了分类，此处只取hash类型说明*/</span><br><span class="line">    /*...*/</span><br><span class="line">        /*循环抽样个field，累加获取抽样样本内存值，默认抽样样本为5*/</span><br><span class="line">        while((de = dictNext(di)) != NULL &amp;&amp; samples &lt; sample_size) &#123;</span><br><span class="line">            ele = dictGetKey(de);</span><br><span class="line">            ele2 = dictGetVal(de);</span><br><span class="line">            elesize += sdsAllocSize(ele) + sdsAllocSize(ele2);</span><br><span class="line">            elesize += sizeof(struct dictEntry);</span><br><span class="line">            samples++;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        /*根据上一步计算的抽样样本内存值除以样本量，再乘以总的filed个数计算总内存值*/</span><br><span class="line">        if (samples) asize += (double)elesize/samples*dictSize(d);</span><br><span class="line">    /*...*/</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lazyfree"><a href="#lazyfree" class="headerlink" title="lazyfree"></a>lazyfree</h3><p>在Redis4.0版本中，新增了一个删除命令<code>unlink</code>。实现了懒删除方式，减少了在删除大key时引起的阻塞影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;unlink&quot;,unlinkCommand,-2,</span><br><span class="line">     &quot;write fast @keyspace&quot;,</span><br><span class="line">     0,NULL,1,-1,1,0,0,0&#125;,</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">void unlinkCommand(client *c) &#123;</span><br><span class="line">    delGenericCommand(c,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* This command implements DEL and LAZYDEL. */</span><br><span class="line">void delGenericCommand(client *c, int lazy) &#123;</span><br><span class="line">    int numdel = 0, j;</span><br><span class="line"></span><br><span class="line">    for (j = 1; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        int deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        if (deleted) &#123;</span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                &quot;del&quot;,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看出，<code>del</code>和<code>unlink</code>命令调用的都是<code>delGenericCommand</code>方法。区别主要在于第二个参数，是否为懒删除标记。<br>如果是懒删除，调用的是异步删除方法<code>dbAsyncDelete</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/* Delete a key, value, and associated expiration entry if any, from the DB.</span><br><span class="line"> * If there are enough allocations to free the value object may be put into</span><br><span class="line"> * a lazy free list instead of being freed synchronously. The lazy free list</span><br><span class="line"> * will be reclaimed in a different bio.c thread. */</span><br><span class="line">#define LAZYFREE_THRESHOLD 64</span><br><span class="line">int dbAsyncDelete(redisDb *db, robj *key) &#123;</span><br><span class="line">    /* Deleting an entry from the expires dict will not free the sds of</span><br><span class="line">     * the key, because it is shared with the main dictionary. */</span><br><span class="line">    if (dictSize(db-&gt;expires) &gt; 0) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    /* If the value is composed of a few allocations, to free in a lazy way</span><br><span class="line">     * is actually just slower... So under a certain limit we just free</span><br><span class="line">     * the object synchronously. */</span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        /*lazyfreeGetFreeEffort来获取val对象所包含的元素个数*/</span><br><span class="line">        size_t free_effort = lazyfreeGetFreeEffort(val);</span><br><span class="line"></span><br><span class="line">        /* If releasing the object is too much work, do it in the background</span><br><span class="line">         * by adding the object to the lazy free list.</span><br><span class="line">         * Note that if the object is shared, to reclaim it now it is not</span><br><span class="line">         * possible. This rarely happens, however sometimes the implementation</span><br><span class="line">         * of parts of the Redis core may call incrRefCount() to protect</span><br><span class="line">         * objects, and then call dbDelete(). In this case we&apos;ll fall</span><br><span class="line">         * through and reach the dictFreeUnlinkedEntry() call, that will be</span><br><span class="line">         * equivalent to just calling decrRefCount(). */</span><br><span class="line">        /* 对删除key进行判断，满足阈值条件时进行后台删除 */</span><br><span class="line">        if (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == 1) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,1);</span><br><span class="line">            /*将删除对象放入BIO_LAZY_FREE后台线程任务队列*/</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,NULL,NULL);</span><br><span class="line">            /*将第一步获取到的val值设置为null*/</span><br><span class="line">            dictSetVal(db-&gt;dict,de,NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Release the key-val pair, or just the key if we set the val</span><br><span class="line">     * field to NULL in order to lazy free it later. */</span><br><span class="line">    if (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        if (server.cluster_enabled) slotToKeyDel(key);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从函数实现中可以看出，Redis并不是单纯的将所有懒删除操作都放后台线程中进行。而是会先对需要懒删除的key进行判断，不满足条件的key将会直接进行删除操作。<br>只有满足条件的key才放入到后台线程任务处理队列中。并且立即将其value设置为NULL，避免造成脏读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">else if (type == BIO_LAZY_FREE) &#123;</span><br><span class="line">           /* What we free changes depending on what arguments are set:</span><br><span class="line">            * arg1 -&gt; free the object at pointer.</span><br><span class="line">            * arg2 &amp; arg3 -&gt; free two dictionaries (a Redis DB).</span><br><span class="line">            * only arg3 -&gt; free the skiplist. */</span><br><span class="line">           if (job-&gt;arg1)</span><br><span class="line">               lazyfreeFreeObjectFromBioThread(job-&gt;arg1);</span><br><span class="line">           else if (job-&gt;arg2 &amp;&amp; job-&gt;arg3)</span><br><span class="line">               lazyfreeFreeDatabaseFromBioThread(job-&gt;arg2,job-&gt;arg3);</span><br><span class="line">           else if (job-&gt;arg3)</span><br><span class="line">               lazyfreeFreeSlotsMapFromBioThread(job-&gt;arg3);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis初始化启动过程]]></title>
      <url>/2019/12/15/new/Redis/Redis%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>这篇博文将基于Redis5.0 unstable版本介绍其在启动过程中所做的主要操作以及相关流程函数方法。<br>在此，先放上一张Redis初始化流程的大意图。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wqij4tmaj30a008edfz.jpg" alt=""></p>
<a id="more"></a>
<p>Redis的启动函数位于<code>server.c</code>文件main方法下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    int j;</span><br><span class="line">#ifdef REDIS_TEST</span><br><span class="line">    if (argc == 3 &amp;&amp; !strcasecmp(argv[1], &quot;test&quot;)) &#123;</span><br><span class="line">        if (!strcasecmp(argv[2], &quot;ziplist&quot;)) &#123;</span><br><span class="line">            return ziplistTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;quicklist&quot;)) &#123;</span><br><span class="line">            quicklistTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;intset&quot;)) &#123;</span><br><span class="line">            return intsetTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;zipmap&quot;)) &#123;</span><br><span class="line">            return zipmapTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;sha1test&quot;)) &#123;</span><br><span class="line">            return sha1Test(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;util&quot;)) &#123;</span><br><span class="line">            return utilTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;sds&quot;)) &#123;</span><br><span class="line">            return sdsTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;endianconv&quot;)) &#123;</span><br><span class="line">            return endianconvTest(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;crc64&quot;)) &#123;</span><br><span class="line">            return crc64Test(argc, argv);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[2], &quot;zmalloc&quot;)) &#123;</span><br><span class="line">            return zmalloc_test(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1; /* test not found */</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* We need to initialize our libraries, and the server configuration. */</span><br><span class="line">#ifdef INIT_SETPROCTITLE_REPLACEMENT</span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line">#endif</span><br><span class="line">    setlocale(LC_COLLATE,&quot;&quot;);</span><br><span class="line">    tzset(); /* Populates &apos;timezone&apos; global. */</span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(NULL)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,NULL);</span><br><span class="line"></span><br><span class="line">    char hashseed[16];</span><br><span class="line">    getRandomHexChars(hashseed,sizeof(hashseed));</span><br><span class="line">    dictSetHashFunctionSeed((uint8_t*)hashseed);</span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">    initServerConfig();</span><br><span class="line">    ACLInit(); /* The ACL subsystem must be initialized ASAP because the</span><br><span class="line">                  basic networking code and client creation depends on it. */</span><br><span class="line">    moduleInitModulesSystem();</span><br><span class="line"></span><br><span class="line">    /* Store the executable path and arguments in a safe place in order</span><br><span class="line">     * to be able to restart the server later. */</span><br><span class="line">    server.executable = getAbsolutePath(argv[0]);</span><br><span class="line">    server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</span><br><span class="line">    server.exec_argv[argc] = NULL;</span><br><span class="line">    for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br><span class="line"></span><br><span class="line">    /* We need to init sentinel right now as parsing the configuration file</span><br><span class="line">     * in sentinel mode will have the effect of populating the sentinel</span><br><span class="line">     * data structures with master nodes to monitor. */</span><br><span class="line">    if (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig();</span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Check if we need to start in redis-check-rdb/aof mode. We just execute</span><br><span class="line">     * the program main. However the program is part of the Redis executable</span><br><span class="line">     * so that we can easily execute an RDB check on loading errors. */</span><br><span class="line">    if (strstr(argv[0],&quot;redis-check-rdb&quot;) != NULL)</span><br><span class="line">        redis_check_rdb_main(argc,argv,NULL);</span><br><span class="line">    else if (strstr(argv[0],&quot;redis-check-aof&quot;) != NULL)</span><br><span class="line">        redis_check_aof_main(argc,argv);</span><br><span class="line"></span><br><span class="line">    if (argc &gt;= 2) &#123;</span><br><span class="line">        j = 1; /* First option to parse in argv[] */</span><br><span class="line">        sds options = sdsempty();</span><br><span class="line">        char *configfile = NULL;</span><br><span class="line"></span><br><span class="line">        /* Handle special options --help and --version */</span><br><span class="line">        if (strcmp(argv[1], &quot;-v&quot;) == 0 ||</span><br><span class="line">            strcmp(argv[1], &quot;--version&quot;) == 0) version();</span><br><span class="line">        if (strcmp(argv[1], &quot;--help&quot;) == 0 ||</span><br><span class="line">            strcmp(argv[1], &quot;-h&quot;) == 0) usage();</span><br><span class="line">        if (strcmp(argv[1], &quot;--test-memory&quot;) == 0) &#123;</span><br><span class="line">            if (argc == 3) &#123;</span><br><span class="line">                memtest(atoi(argv[2]),50);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fprintf(stderr,&quot;Please specify the amount of memory to test in megabytes.\n&quot;);</span><br><span class="line">                fprintf(stderr,&quot;Example: ./redis-server --test-memory 4096\n\n&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* First argument is the config file name? */</span><br><span class="line">        if (argv[j][0] != &apos;-&apos; || argv[j][1] != &apos;-&apos;) &#123;</span><br><span class="line">            configfile = argv[j];</span><br><span class="line">            server.configfile = getAbsolutePath(configfile);</span><br><span class="line">            /* Replace the config file in server.exec_argv with</span><br><span class="line">             * its absolute path. */</span><br><span class="line">            zfree(server.exec_argv[j]);</span><br><span class="line">            server.exec_argv[j] = zstrdup(server.configfile);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* All the other options are parsed and conceptually appended to the</span><br><span class="line">         * configuration file. For instance --port 6380 will generate the</span><br><span class="line">         * string &quot;port 6380\n&quot; to be parsed after the actual file name</span><br><span class="line">         * is parsed, if any. */</span><br><span class="line">        while(j != argc) &#123;</span><br><span class="line">            if (argv[j][0] == &apos;-&apos; &amp;&amp; argv[j][1] == &apos;-&apos;) &#123;</span><br><span class="line">                /* Option name */</span><br><span class="line">                if (!strcmp(argv[j], &quot;--check-rdb&quot;)) &#123;</span><br><span class="line">                    /* Argument has no options, need to skip for parsing. */</span><br><span class="line">                    j++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (sdslen(options)) options = sdscat(options,&quot;\n&quot;);</span><br><span class="line">                options = sdscat(options,argv[j]+2);</span><br><span class="line">                options = sdscat(options,&quot; &quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* Option argument */</span><br><span class="line">                options = sdscatrepr(options,argv[j],strlen(argv[j]));</span><br><span class="line">                options = sdscat(options,&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == &apos;-&apos;) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Sentinel config from STDIN not allowed.&quot;);</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Sentinel needs config file on disk to save state.  Exiting...&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        resetServerSaveParams();</span><br><span class="line">        loadServerConfig(configfile,options);</span><br><span class="line">        sdsfree(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_WARNING, &quot;oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo&quot;);</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        &quot;Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started&quot;,</span><br><span class="line">            REDIS_VERSION,</span><br><span class="line">            (sizeof(long) == 8) ? 64 : 32,</span><br><span class="line">            redisGitSHA1(),</span><br><span class="line">            strtol(redisGitDirty(),NULL,10) &gt; 0,</span><br><span class="line">            (int)getpid());</span><br><span class="line"></span><br><span class="line">    if (argc == 1) &#123;</span><br><span class="line">        serverLog(LL_WARNING, &quot;Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf&quot;, argv[0], server.sentinel_mode ? &quot;sentinel&quot; : &quot;redis&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        serverLog(LL_WARNING, &quot;Configuration loaded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line">    int background = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line">    if (background) daemonize();</span><br><span class="line"></span><br><span class="line">    initServer();</span><br><span class="line">    if (background || server.pidfile) createPidFile();</span><br><span class="line">    redisSetProcTitle(argv[0]);</span><br><span class="line">    redisAsciiArt();</span><br><span class="line">    checkTcpBacklogSettings();</span><br><span class="line"></span><br><span class="line">    if (!server.sentinel_mode) &#123;</span><br><span class="line">        /* Things not needed when running in Sentinel mode. */</span><br><span class="line">        serverLog(LL_WARNING,&quot;Server initialized&quot;);</span><br><span class="line">    #ifdef __linux__</span><br><span class="line">        linuxMemoryWarnings();</span><br><span class="line">    #endif</span><br><span class="line">        moduleLoadFromQueue();</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        if (server.cluster_enabled) &#123;</span><br><span class="line">            if (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    &quot;You can&apos;t have keys in a DB different than DB 0 when in &quot;</span><br><span class="line">                    &quot;Cluster mode. Exiting.&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (server.ipfd_count &gt; 0)</span><br><span class="line">            serverLog(LL_NOTICE,&quot;Ready to accept connections&quot;);</span><br><span class="line">        if (server.sofd &gt; 0)</span><br><span class="line">            serverLog(LL_NOTICE,&quot;The server is now ready to accept connections at %s&quot;, server.unixsocket);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Warning the user about suspicious maxmemory setting. */</span><br><span class="line">    if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) &#123;</span><br><span class="line">        serverLog(LL_WARNING,&quot;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&quot;, server.maxmemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">    aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化默认状态"><a href="#初始化默认状态" class="headerlink" title="初始化默认状态"></a>初始化默认状态</h2><p>我们可以看到在main方法中，进行的第一步操作就是初始化默认配置<code>initServerConfig</code>。有很多初始化操作都需要设置了一些默认配置后才能够继续进行的。</p>
<p>在这一阶段中进行初始化的主要有：</p>
<ul>
<li>Redis server的状态默认值</li>
<li>Redis服务运行的默认参数配置</li>
<li>复制参数配置</li>
<li>客户端输入输出缓冲区设置</li>
<li>部分命令参数初始化</li>
<li>slow log初始化</li>
</ul>
<p>为什么需要先对部分命令进行初始化：<br>因为这一部分命令是Redis对外提供服务之前时，就需要先调用的，所以必须先进行初始化。而其他非必须的命令此时仍未进行初始化。</p>
<h2 id="权限初始化"><a href="#权限初始化" class="headerlink" title="权限初始化"></a>权限初始化</h2><p>用户这个概念，是Redis在6.0版本中提出的。虽然还未正式投入线上使用，但是已经在unstable版本中开始投入开发。<br><code>ACLInit()</code>这个方法非常简单，只会初始化一个拥有所有权限的默认用户。</p>
<h2 id="初始化模块系统"><a href="#初始化模块系统" class="headerlink" title="初始化模块系统"></a>初始化模块系统</h2><p>模块系统，是Redis4.0版本中推出的一个新特性，它允许用户自己编写适合于自己的模块，并以插件的形式导入到Redis当中。<br>通过<code>moduleInitModulesSystem()</code>方法，创建模块系统所需要数据结构和资源。</p>
<h2 id="解析命令行参数以及读取配置"><a href="#解析命令行参数以及读取配置" class="headerlink" title="解析命令行参数以及读取配置"></a>解析命令行参数以及读取配置</h2><p>在启动Redis的时候，是允许用户在命令行中指定Redis运行的模式和参数。<br>将配置文件和运行时参数等信息通过遍历的方式确认后，调用<code>loadServerConfig</code>方法，将运行时参数写入到配置文件中。如果没有指定配置文件，就会使用默认的配置文件来运行服务。</p>
<p>最终会通过<code>initServer</code>方法来初始化参数配置。<br>这个方法主要会做以下的一些初始化操作：</p>
<ul>
<li>初始化共享对象<code>createSharedObjects</code></li>
<li>检查系统参数配置<code>adjustOpenFilesLimit</code></li>
<li>开启端口监听</li>
<li>创建事件监听和时间监听文件句柄</li>
<li>创建数据库并初始化状态<br>在这个方法中创建创建文件驱动和时间驱动的监听句柄。并且会进行以下的一些初始数据的初始化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (server.cluster_enabled) clusterInit();</span><br><span class="line">replicationScriptCacheInit();</span><br><span class="line">scriptingInit(1);</span><br><span class="line">slowlogInit();</span><br><span class="line">latencyMonitorInit();</span><br><span class="line">bioInit();</span><br><span class="line">server.initial_memory_usage = zmalloc_used_memory();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模块文件、用户权限、数据导入"><a href="#模块文件、用户权限、数据导入" class="headerlink" title="模块文件、用户权限、数据导入"></a>模块文件、用户权限、数据导入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moduleLoadFromQueue();</span><br><span class="line">ACLLoadUsersAtStartup();</span><br><span class="line">loadDataFromDisk();</span><br></pre></td></tr></table></figure>
<p>如果数据文件中有数据，则需要进行数据的初始化操作。<br>如果开启了AOF，那么会优先从AOF文件中进行数据导入操作。如果没有开启AOF文件，才会去查找RDB文件。<code>loadDataFromDisk</code></p>
<h2 id="循环监听时间"><a href="#循环监听时间" class="headerlink" title="循环监听时间"></a>循环监听时间</h2><p>Redis服务主要运行函数为<code>aeMain()</code>。在函数中，是一个死循环操作。一旦监听的文件事件存在了可操作事件，就会进行处理逻辑流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line">aeMain(server.el);</span><br><span class="line">aeDeleteEventLoop(server.el);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[缓存雪崩穿透击穿介绍]]></title>
      <url>/2019/12/15/new/Redis/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>看到这个标题，你肯定在想：什么是雪崩？什么是穿透？什么是击穿？怎么感觉都是一个意思，都是缓存失效导致的数据库压力问题。</p>
<p>这三个问题的确都会导致数据库压力问题，但是出现的场景还是存在区别滴。在处理手段上也有很大的区别。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>需要使用的热点数据都做了缓存，但是为了保证Redis的内存够用，所以会对一些数据进行设置过期时间操作。一般情况下存在定时任务去刷新缓存信息，这个时候就存在一个隐患的问题：假设在定时任务中设置的过期时间都一样，那么在某一个时间点时，大量的key同时过期。本来缓存抵挡住了大量的请求，key过期后，这些压力全部同时打到了数据库中，数据库可能就扛不住。直接被打挂了，重启数据库后，立马又被新的流量打挂了。这就是缓存雪崩。<br>(注：这里还有个隐患，Redis可能会频繁的处理过期key，从而导致Redis性能降低)<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wq4egoo5j30er0a6aao.jpg" alt=""></p>
<p>处理缓存雪崩主要有以下几个思路：</p>
<ol>
<li>分散过期时间。把每个key的过期时间都加上一个随机的过期值。保证数据不会在同一时间大面积失效。</li>
<li>设置过期标志更新缓存。给每一个缓存数据都增加一个相应的缓存标记，记录缓存是否失效。如果缓存失效，则更新数据缓存。这样虽然在缓存首次失效时，仍会带来数据库压力问题。但是能够在一定程度上缓解后续被新流量打挂以及所有服务不可用的情况。</li>
<li>在代码层面上设定一定策略，比如加锁等待、减慢请求速度。给数据库留下启动和重建缓存的机会。</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透就是指客户端不断的查询缓存和数据库都没有的数据。相当于进行了两次无用的查询。降低缓存的命中率，增加数据库的压力。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9wq4nqarcj30dx0ak751.jpg" alt=""></p>
<p>解决手段：</p>
<ol>
<li>客户端进行校验，先将明显不符合的key给过滤掉。</li>
<li>对于查询不到的数据，直接赋值一个null给它。</li>
<li>使用布隆过滤器来对不存在数据进行过滤掉。</li>
<li>限流。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿和缓存雪崩有点像。但是又不一样，缓存雪崩是大面积的缓存同时失效，打崩了DB。而缓存击穿是指一个key非常热点，在不停的扛着大并发，当这个key失效的瞬间，持续的大并发就击穿缓存，直接请求数据库。</p>
<p>解决手段:<br>主要场景是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。<br>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 概念介绍 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring boot整合SpringTask实现定时任务]]></title>
      <url>/2019/07/26/SpringBoot/Spring-boot%E6%95%B4%E5%90%88SpringTask%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>SpringTask是Spring自主研发的一个定时任务工具，不需要引入其他依赖就可以使用。</p>
<h2 id="SpringTask-Cron语法"><a href="#SpringTask-Cron语法" class="headerlink" title="SpringTask Cron语法"></a>SpringTask Cron语法</h2><p>类似于shell中的<code>crontab</code>，只不过最前面多了一个<code>Seconds</code>秒级别。<br>Seconds Minutes Hours DayofMonth Month DayofWeek</p>
<table>
<thead>
<tr>
<th>时间元素</th>
<th>可出现的字符</th>
<th>数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>Seconds</td>
<td>,-*/</td>
<td>0-59</td>
</tr>
<tr>
<td>Minutes</td>
<td>,-*/</td>
<td>0-59</td>
</tr>
<tr>
<td>Hours</td>
<td>,-*/</td>
<td>0-23</td>
</tr>
<tr>
<td>Day of Month</td>
<td>,-*/?LW</td>
<td>0-31</td>
</tr>
<tr>
<td>Month</td>
<td>,-*/</td>
<td>1-12</td>
</tr>
<tr>
<td>Day of Week</td>
<td>,-*/?L#</td>
<td>1-7</td>
</tr>
</tbody>
</table>
<ul>
<li>“,” 列出枚举值</li>
<li>“-“ 触发范围</li>
<li>“*” 任意值</li>
<li>“/“ 每隔一段时间执行</li>
<li>“?” 任意值</li>
<li>“#” 确定第几个星期几</li>
<li>“L” 表示最后的有效值</li>
<li>“W” 表示有效工作日<a id="more"></a>
<h2 id="整合使用SpringTask"><a href="#整合使用SpringTask" class="headerlink" title="整合使用SpringTask"></a>整合使用SpringTask</h2>因为SpringTask已经存在于Spring框架中，所有不需要引入任何依赖。<br>只需要在配置类中添加一个<code>@EnableScheduling</code>注解就可以开启SpringTask的定时任务功能。<br>然后可以通过在方法上增加<code>@Scheduled</code>注解配置定时任务。或者通过代码动态创建定时任务。</li>
</ul>
<h3 id="通过spring-boot注解实现"><a href="#通过spring-boot注解实现" class="headerlink" title="通过spring boot注解实现"></a>通过spring boot注解实现</h3><p>在Spring boot的主类或者配置类中加入<code>@EnableScheduling</code>注解，启动定时任务的配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class SpringbootApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建定时任务实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SpringTaskDemo &#123;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron = &quot;0/1 * * * * ?&quot;)</span><br><span class="line">    public void printHello()&#123;</span><br><span class="line">        System.out.println(&quot;scheduled is running.........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="动态创建定时任务"><a href="#动态创建定时任务" class="headerlink" title="动态创建定时任务"></a>动态创建定时任务</h3><p>使用注解的方式，无法实现动态的修改、添加、关闭定时任务。这个时候就需要使用编程的方式进行任务的更新操作了。可以使用<code>ThreadPoolTaskScheduler</code>或<code>SchedulingConfigurer</code>接口来创建自定义定时任务。</p>
<p><strong>SchedulingConfigurer</strong><br>通过实现<code>SchedulingConfigurer</code>接口，重写<code>configureTasks</code>方法添加定时任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ScheduleConfig implements SchedulingConfigurer &#123;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line">		taskRegistrar.setTaskScheduler(taskScheduler());</span><br><span class="line">		</span><br><span class="line">		taskRegistrar.getScheduler().schedule(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + &quot;|SchedulingConfigurer cron task01&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, new CronTrigger(&quot;0/3 * * * * ?&quot;));</span><br><span class="line">		</span><br><span class="line">		taskRegistrar.addCronTask(new CronTask(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + &quot;|SchedulingConfigurer cron task02&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, new CronTrigger(&quot;0/2 * * * * ?&quot;)));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Bean</span><br><span class="line">	public TaskScheduler taskScheduler() &#123;</span><br><span class="line">		ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();</span><br><span class="line">		taskScheduler.setPoolSize(10);</span><br><span class="line">		taskScheduler.setThreadNamePrefix(&quot;spring-task-scheduler-thread-&quot;);</span><br><span class="line">		taskScheduler.setAwaitTerminationSeconds(60);</span><br><span class="line">		taskScheduler.setWaitForTasksToCompleteOnShutdown(true);</span><br><span class="line">		taskScheduler.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">		return taskScheduler;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><code>ThreadPoolTaskScheduler</code>是Spring Task的核心实现类，该类提供了大量的重载方法进行任务调度。首先配置一个自定义任务调度线程池<code>ThreadPoolTaskScheduler</code>，然后调用<code>schedule</code>等方法对定时任务进行动态管理操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/task&quot;)</span><br><span class="line">public class SpringTaskDemo&#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private ThreadPoolTaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    private ScheduledFuture&lt;?&gt; scheduledFuture;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;timing-task.cron1&#125;&quot;)</span><br><span class="line">    private String cronStr1;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;timing-task.cron2&#125;&quot;)</span><br><span class="line">    private String cronStr2;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/start&quot;)</span><br><span class="line">    public String startTask() &#123;</span><br><span class="line">        scheduledFuture = taskScheduler.schedule(new RunTask01(), new Trigger() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Date nextExecutionTime(TriggerContext triggerContext) &#123;</span><br><span class="line">                return new CronTrigger(cronStr1).nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(&quot;start timed task success ..&quot;);</span><br><span class="line">        return &quot;start task suceess&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/stop&quot;)</span><br><span class="line">    public String stopTask() &#123;</span><br><span class="line">        Boolean result = null;</span><br><span class="line">        if (scheduledFuture != null) &#123;</span><br><span class="line">            result = scheduledFuture.cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;stop timed task result: &quot; + result);</span><br><span class="line">        return &quot;stop task result: &quot; + result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/modify&quot;)</span><br><span class="line">    public String modifyTask() &#123;</span><br><span class="line">        Boolean stopResult = null;</span><br><span class="line">        // 停止定时任务</span><br><span class="line">        if (scheduledFuture != null) &#123;</span><br><span class="line">            stopResult = scheduledFuture.cancel(true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;modify task error -&gt; scheduledFuture is null&quot;);</span><br><span class="line">            return &quot;error&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 更换cron重新开启定时任务</span><br><span class="line">        if (stopResult) &#123;</span><br><span class="line">            scheduledFuture = taskScheduler.schedule(new RunTask01(), new Trigger() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Date nextExecutionTime(TriggerContext triggerContext) &#123;</span><br><span class="line">                    return new CronTrigger(cronStr2).nextExecutionTime(triggerContext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            log.info(&quot;modify task success ..&quot;);</span><br><span class="line">            return &quot;success&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;modify task failed ..&quot;);</span><br><span class="line">        return &quot;failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class RunTask01 implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            log.info(Thread.currentThread().getName() + &quot;|schedule task01&quot; + &quot;|&quot; + new Date().toLocaleString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class RunTask02 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            log.info(Thread.currentThread().getName() + &quot;|schedule task02&quot; + &quot;|&quot; + new Date().toLocaleString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Spring Boot </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[java实现快排]]></title>
      <url>/2019/07/24/java%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8E%92/</url>
      <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>在数组中选出一个元素做为中枢值，把所有比它小的元素都移动到它的左边，比它大的元素都移动到它的右边。直到数组有序。<br><img src="https://img-blog.csdnimg.cn/20190723124826723.gif" alt=""></p>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static void qSort(int[] a,int left,int right)&#123;</span><br><span class="line">    if(left &lt; right)&#123;</span><br><span class="line">        int mid = divide(a,left,right);</span><br><span class="line">        qSort(a,left,mid);</span><br><span class="line">        qSort(a,mid+1,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int divide(int[] a,int left,int right)&#123;</span><br><span class="line">    int mid = left;</span><br><span class="line"></span><br><span class="line">    while(left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; a[right] &gt;= a[mid]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        while (left &lt; right &amp;&amp; a[left] &lt; a[mid]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left &lt; right) &#123;</span><br><span class="line">            swap(a, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] a, int left, int right) &#123;</span><br><span class="line">    int tmp = a[left];</span><br><span class="line">    a[left] = a[right];</span><br><span class="line">    a[right] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体流程：</p>
<ol>
<li>定义两个指针<code>left</code>和<code>right</code>代表两个初始化位置，分别表示需要排序数组的最左和最右。</li>
<li>一直遍历，right向左移动，直到找到小于中枢值的位置。</li>
<li>一直遍历，left向右移动，直到找到大于中枢值的位置。</li>
<li>如果left&lt;right，交换这两个元素。</li>
<li>重复上面步骤。</li>
<li>使用递归再对两边子数组进行排序。</li>
</ol>
<h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//    非递归实现快排</span><br><span class="line">    private static void qSort2(int[] a,int left,int right)&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();</span><br><span class="line">        s.push(left);</span><br><span class="line">        s.push(right);</span><br><span class="line"></span><br><span class="line">        while(!s.isEmpty())&#123;</span><br><span class="line">            int r = s.pop();</span><br><span class="line">            int l = s.pop();</span><br><span class="line">            int mid = divide(a,l,r);</span><br><span class="line">            if(l &lt; mid)&#123;</span><br><span class="line">                s.push(l);</span><br><span class="line">                s.push(mid);</span><br><span class="line">            &#125;</span><br><span class="line">            if(mid + 1 &lt; right)&#123;</span><br><span class="line">                s.push(mid+1);</span><br><span class="line">                s.push(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对需要排序的数组的左指针和右指针l、r记录起来，压入到栈中，每次循环都会弹出一对l、r。<br>当栈为空时，说明都已经排序了。接收循环。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令之sort]]></title>
      <url>/2019/07/23/Linux/Linux%E5%91%BD%E4%BB%A4%E4%B9%8Bsort/</url>
      <content type="html"><![CDATA[<p>Linux自带排序命令：<code>sort</code><br>在一些临时性排序需求的时候，使用该命令可以快速的处理。小巧的工具使我们使用非常便捷。<br>语法：<code>sort [-bcCdfghiRMmnrsuVz] [-k field1[,field2]] [-S memsize] [-T dir] [-t char] [-o output] [file ...]</code></p>
<h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-b 忽略每行前面开始出的空格字符。</span><br><span class="line">-c 检查文件是否已经按照顺序排序。</span><br><span class="line">-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</span><br><span class="line">-f 排序时，将小写字母视为大写字母。</span><br><span class="line">-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</span><br><span class="line">-k：以哪个区间 (field) 来进行排序</span><br><span class="line">-m：将几个排序好的文件进行合并，只是单纯合并，不做排序</span><br><span class="line">-M：将前面3个字母依照月份的缩写进行排序</span><br><span class="line">-n：依照数值的大小排序</span><br><span class="line">-o&lt;输出文件&gt;：将排序后的结果存入指定的文件</span><br><span class="line">-r：降序</span><br><span class="line">-R: 乱序</span><br><span class="line">-u：忽略相同行</span><br><span class="line">-t&lt;分隔字符&gt;：指定分隔符，默认的分隔符为空白字符和非空白字符之间的空字符</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ cat sort.log</span><br><span class="line">[@huzhibindeMacBook-Pro:tmp]$ cat sort.log</span><br><span class="line">a	mac	2000    500 2K</span><br><span class="line">d	winxp	4000    300 3G</span><br><span class="line">e	bsd	1000    600 4M</span><br><span class="line">b	linux	1000	200 5K</span><br><span class="line">f	SUSE	4000    300 6M</span><br><span class="line">g	winxp	500     300 3G</span><br><span class="line">c	win7	2000    100 7G</span><br><span class="line">c	Debian	600     200 8K</span><br></pre></td></tr></table></figure>
<h3 id="打印从哪列开始是乱序"><a href="#打印从哪列开始是乱序" class="headerlink" title="打印从哪列开始是乱序"></a>打印从哪列开始是乱序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -c sort.log</span><br><span class="line">sort: sort.log:4: disorder: b   linux   1000    200 5K</span><br></pre></td></tr></table></figure>
<h3 id="指定列排序"><a href="#指定列排序" class="headerlink" title="指定列排序"></a>指定列排序</h3><p>默认按照字符排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3 sort.log</span><br><span class="line">b	linux	1000	200	5K</span><br><span class="line">e	bsd	1000	600	4M</span><br><span class="line">c	win7	2000	100	7G</span><br><span class="line">a	mac	2000	500	2K</span><br><span class="line">d	winxp	4000	300	3G</span><br><span class="line">f	SUSE	4000	300	6M</span><br><span class="line">g	winxp	500	300	3G</span><br><span class="line">c	Debian	600	200	8K</span><br></pre></td></tr></table></figure></p>
<p>按照数字排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n sort.log</span><br><span class="line">g	winxp	500	300	3G</span><br><span class="line">c	Debian	600	200	8K</span><br><span class="line">b	linux	1000	200	5K</span><br><span class="line">e	bsd	1000	600	4M</span><br><span class="line">a	mac	2000	500	2K</span><br><span class="line">c	win7	2000	100	7G</span><br><span class="line">d	winxp	4000	300	3G</span><br><span class="line">f	SUSE	4000	300	6M</span><br></pre></td></tr></table></figure></p>
<h3 id="u和uniq的区别"><a href="#u和uniq的区别" class="headerlink" title="-u和uniq的区别"></a>-u和uniq的区别</h3><p>在指定<code>-k</code>的时候，<code>-u</code>是会按照指定的列来忽略重复，<code>uniq</code>是按照整行来去重<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n -u  sort.log</span><br><span class="line">g	winxp	500	300	3G</span><br><span class="line">c	Debian	600	200	8K</span><br><span class="line">e	bsd	1000	600	4M</span><br><span class="line">a	mac	2000	500	2K</span><br><span class="line">d	winxp	4000	300	3G</span><br><span class="line">[@huzhibindeMacBook-Pro:tmp]$ sort -k 3n   sort.log  | uniq</span><br><span class="line">g	winxp	500	300	3G</span><br><span class="line">c	Debian	600	200	8K</span><br><span class="line">b	linux	1000	200	5K</span><br><span class="line">e	bsd	1000	600	4M</span><br><span class="line">a	mac	2000	500	2K</span><br><span class="line">c	win7	2000	100	7G</span><br><span class="line">d	winxp	4000	300	3G</span><br><span class="line">f	SUSE	4000	300	6M</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot整合Redis]]></title>
      <url>/2019/07/21/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Redis/</url>
      <content type="html"><![CDATA[<h1 id="Spring-boot中使用Redis"><a href="#Spring-boot中使用Redis" class="headerlink" title="Spring boot中使用Redis"></a>Spring boot中使用Redis</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=0</span><br><span class="line"></span><br><span class="line">## Redis自定义key配置选项</span><br></pre></td></tr></table></figure>
<h2 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringApplicationConfiguration(Application.class)</span><br><span class="line">public class ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		// 保存字符串</span><br><span class="line">		stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;);</span><br><span class="line">		Assert.assertEquals(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot整合Swagger2]]></title>
      <url>/2019/07/21/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Swagger2/</url>
      <content type="html"><![CDATA[<h1 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a>Swagger2</h1><p>Swagger2用于解决前后端开发人员之间的api对接，减少与其他团队开发期间的沟通成本。Swagger2可以轻松的整合到Spring boot中，并与SpringMVC程序配合组织处强大的Restful API文档。即可以减少我们创建文档的工作量，同时说明内容整合到实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。<br>另外，Swagger2也提供了强大的页面测试功能来调试每个Restful API</p>
<h2 id="添加Swagger2依赖"><a href="#添加Swagger2依赖" class="headerlink" title="添加Swagger2依赖"></a>添加Swagger2依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="创建Swagger2配置类"><a href="#创建Swagger2配置类" class="headerlink" title="创建Swagger2配置类"></a>创建Swagger2配置类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket CreateRestApi()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.hoo.springboot&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo()&#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如以上代码，通过<code>@Configuration</code>注解，让Spring来加载该类配置。再通过<code>@EnabledSwagger2</code>注解来启用Swagger2。</p>
<p>再通过<code>createRestApi</code>函数创建<code>Docket</code>的Bean之后，<code>apiInfo()</code>用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。<code>select()</code>函数返回一个<code>ApiSelectorBuilder</code>实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被<code>@ApiIgnore</code>指定的请求）。</p>
<h2 id="添加文档内容"><a href="#添加文档内容" class="headerlink" title="添加文档内容"></a>添加文档内容</h2><p>在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过<code>@ApiOperation</code>注解来给API增加说明、通过<code>@ApiImplicitParams</code>、<code>@ApiImplicitParam</code>注解来给参数增加说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(value = &quot;/users&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  创建一个线程安全的Map模拟数据用户信息</span><br><span class="line">     */</span><br><span class="line">    static Map&lt;Integer, User&gt; userMap = Collections.synchronizedMap(new HashMap&lt;Integer,User&gt;());</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&quot;,method = RequestMethod.GET)</span><br><span class="line">    public List&lt;User&gt; getUserList()&#123;</span><br><span class="line">        List&lt;User&gt; r = new ArrayList&lt;User&gt;(userMap.values());</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&quot;,method = RequestMethod.POST)</span><br><span class="line">    public String postUser(@ModelAttribute User user)&#123;</span><br><span class="line">        userMap.put(user.getId(),user);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.GET)</span><br><span class="line">    public User getUser(@PathVariable Integer id)&#123;</span><br><span class="line"></span><br><span class="line">        return userMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.PUT)</span><br><span class="line">    public String putUser(@PathVariable Integer id,@ModelAttribute User user)&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        User u = userMap.get(id);</span><br><span class="line">        u.setAge(user.getAge());</span><br><span class="line">        u.setName(user.getName());</span><br><span class="line"></span><br><span class="line">        userMap.put(id,u);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除对象&quot;)</span><br><span class="line">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Integer&quot;)</span><br><span class="line">    @RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span><br><span class="line">    public String deleteUser(@PathVariable Integer id)&#123;</span><br><span class="line"></span><br><span class="line">        userMap.remove(id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成上述代码添加上，启动Spring Boot程序，访问：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a><br><a href="https://imgchr.com/i/eCParT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/21/eCParT.md.jpg" alt="eCParT.md.jpg"></a></p>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
            <category> mall </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring boot整合MyBatis逆向工程]]></title>
      <url>/2019/07/18/SpringBoot/Spring-boot%E6%95%B4%E5%90%88MyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="pom-xml中添加依赖"><a href="#pom-xml中添加依赖" class="headerlink" title="pom.xml中添加依赖"></a>pom.xml中添加依赖</h2><p>在这里引入了<code>pagehelper</code>，<code>pagehelper</code>是MyBatis的分页插件，通过几行简单的代码就是实现分页功能；在与Spring boot整合的时候，只要整合了<code>pagehelper</code>就自动整合了MyBatis。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- spring boot健康检查、审计、统计、监控--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--MyBatis分页插件--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- MyBatis 生成器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h2 id="修改Spring-boot配置文件"><a href="#修改Spring-boot配置文件" class="headerlink" title="修改Spring boot配置文件"></a>修改Spring boot配置文件</h2><p>在<code>application.yml</code>中添加数据源配置和MyBatis的mapper.xml的路径配置。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:13307/spring</span><br><span class="line">    password: hoo</span><br><span class="line">    username: hoo</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mapper/*.xml</span><br><span class="line">    - classpath*:com/**/mapper/*.xml</span><br></pre></td></tr></table></figure>
<h2 id="修改Mybatis-generator配置文件"><a href="#修改Mybatis-generator配置文件" class="headerlink" title="修改Mybatis generator配置文件"></a>修改Mybatis generator配置文件</h2><p>主要是修改数据库连接配置，MyBatis generator生成的model、mapper接口、mapper.xml文件的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;properties resource=&quot;generator.properties&quot;/&gt;</span><br><span class="line">    &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">        &lt;!-- 为模型生成序列化方法--&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 为生成的Java模型创建一个toString方法 --&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 数据库资源配置 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">                        connectionURL=&quot;jdbc:mysql://127.0.0.1:13307/spring&quot;</span><br><span class="line">                        userId=&quot;hoo&quot;</span><br><span class="line">                        password=&quot;hoo&quot;&gt;</span><br><span class="line">            &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt;</span><br><span class="line">            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!-- 生成的model放置路径 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.hoo.springboot.mbg.model&quot; targetProject=&quot;./src/main/java&quot;/&gt;</span><br><span class="line">        &lt;!-- 生成的mapper接口放置路径 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.hoo.springboot.mbg.mapper&quot; targetProject=&quot;./src/main/resources&quot;/&gt;</span><br><span class="line">        &lt;!-- 生成的mapper配置文件放置路径 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.hoo.springboot.mbg.mapper&quot;</span><br><span class="line">                             targetProject=&quot;./src/main/java&quot;/&gt;</span><br><span class="line">        &lt;!--生成全部表tableName设为%--&gt;</span><br><span class="line">        &lt;table tableName=&quot;%&quot;&gt;</span><br><span class="line">            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行Generator的main函数生成代码"><a href="#运行Generator的main函数生成代码" class="headerlink" title="运行Generator的main函数生成代码"></a>运行Generator的main函数生成代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Generator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //MBG 执行过程中的警告信息</span><br><span class="line">        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">        //当生成的代码重复时，覆盖原代码</span><br><span class="line">        boolean overwrite = true;</span><br><span class="line">        //读取我们的 MBG 配置文件</span><br><span class="line">        InputStream is = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;);</span><br><span class="line">        ConfigurationParser cp = new ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(is);</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">        /* 创建 MBG */</span><br><span class="line">        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        //执行生成代码</span><br><span class="line">        myBatisGenerator.generate(null);</span><br><span class="line">        //输出警告信息</span><br><span class="line">        for (String warning : warnings) &#123;</span><br><span class="line">            System.out.println(warning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> SpringBoot </category>
            
            <category> mall </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java类加载机制]]></title>
      <url>/2019/07/16/Java/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>类的加载是指将类的<code>.class</code>文件中的<strong>二进制数据读入到内存</strong>中，将其放在运行时数据区的方法区，然后在Java堆中创建一个java.lang.Class对象(类也是对象)，用来封装类在方法区内的数据结构。<br>类加载的最终产物是位于堆中的Class对象，该Class对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。<br><a href="https://imgchr.com/i/ZqjkUs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjkUs.jpg" alt="ZqjkUs.jpg"></a></p>
<p>类加载器不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用的时候就预先加载，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器必须在程序<font color="red">首次主动使用该类</font>时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p><a href="https://imgchr.com/i/ZqjPbQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjPbQ.jpg" alt="ZqjPbQ.jpg"></a></p>
<p>类的生命周期主要包含<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>、<code>使用</code>、<code>卸载</code>。<br>在加载过程中的五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>初始化</code>发生的顺序是一定的，而<code>解析</code>在某些情况下可以在<code>初始化</code>阶段之后执行。这是为了支持Java语言的运行时绑定。<br>另外需要注意的是：这几个阶段是按照顺序开始，而不是按照顺序进行或完成，因为这些阶段通常是相互交叉混合进行的，通常在一个阶段执行的过程中需要调用或激活另一个阶段。<br><a id="more"></a></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>查找并加载类的二进制数据是类加载过程的第一个阶段，在这个阶段，虚拟机需要完成以下事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流</li>
<li>将这个字节流代表的静态存储结构转化成方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口</li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，连接阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全。</p>
<p>在验证阶段，主要是完成以下的校验动作：</p>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>验证字节流是否符合Class文件格式的规范。例如：是否以<code>OxCAFEBASE</code>开头、主版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p>
<h3 id="元数据校验"><a href="#元数据校验" class="headerlink" title="元数据校验"></a>元数据校验</h3><p>对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求；列如：这个类是否有父类，除了<code>java.lang.Object</code></p>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>确保解析动作能正确执行</p>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为类的<code>静态变量</code>分配内存，并将其初始化为默认值</p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区分配。</p>
<ul>
<li>这个阶段进行内存分配的<font color="red">仅包括类变量(static)</font>，不包括实例变量；实例变量会在对象实例化时随着实例一块分配在Java堆中。</li>
<li>这个阶段设置的初始值通常是数据类型的默认值，而不是在Java程序中被显式赋予的值。</li>
<li>如果是同时被final和static修饰的属性，这在准备阶段会被初始化为定义的值。</li>
</ul>
<blockquote>
<p>假设有一个变量public static int value = 3<br>那么变量value在准备阶段过后的初始值是0，而不是3，因为这个时候还没开始执行任何Java方法，把value赋值为3的public static指令是在程序编译后，存放在类构造器<clinit>()方法中，所以value赋值为3的动作在初始化阶段才会执行。</clinit></p>
</blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。<br>解析动作主要是针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号类型进行，</p>
<ul>
<li>符号引用：用一组符号描述目标，可以是任何字面量</li>
<li>直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
<h3 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h3><ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<h3 id="类初始化情况"><a href="#类初始化情况" class="headerlink" title="类初始化情况"></a>类初始化情况</h3><ul>
<li>使用new创建类的实例</li>
<li>第一次访问某个类或接口的静态变量，或者对静态变量赋值</li>
<li>第一次调用类的静态方法</li>
<li>使用反射加载类(Class.forName(“xxx.xxx”))</li>
<li>初始化某个类的子类，其父类也会被初始化</li>
<li>Java虚拟机启动的时候标明启动的类(Java Test)，直接使用<code>java.exe</code>运行某个主类。</li>
</ul>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>JVM预定义了三种类加载器，当一个JVM启动的时候，Java会默认使用类加载器进行类加载。</p>
<ul>
<li>启动类加载器:负责加载存放在<code>JDK\jre\lib</code>下或被<code>-Xbootclasspath</code>指定路径中的类库。</li>
<li>扩展类加载器:负责加载<code>JDK\jre\lib\ext</code>或由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库。</li>
<li>引用类加载器:负责加载用户类路径（ClassPath）所指定的类。程序默认的类加载器。<br><a href="https://imgchr.com/i/ZqjFEj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/17/ZqjFEj.jpg" alt="ZqjFEj.jpg"></a></li>
</ul>
<blockquote>
<p>注：父类加载器并不是通过继承关系实现的，而是采用组合的方式<br>启动类加载器是C++实现，属于虚拟机的一部分；其他类加载器都是由启动类加载器加载到内存中的。</p>
</blockquote>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><ul>
<li>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li>双亲委派：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li>缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ul>
<h2 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h2><ul>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过Class.forName()方法动态加载</li>
<li>通过ClassLoader.loadClass()方法动态加载</li>
</ul>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Arrays.sort和Collections.sort实现原理]]></title>
      <url>/2019/07/16/Java/Arrays-sort%E5%92%8CCollections-sort%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>事实上，在使用<code>Collections.sort(list)</code>的时候，就调用list.sort()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;</span><br><span class="line">        list.sort(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在深入进去后，发现其实调用的就是Array.sort()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">    default void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">        Object[] a = this.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = this.listIterator();</span><br><span class="line">        for (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>而在Array.sort中，会根据该对象是否能够通过归并排序来选择不同的排序方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            else</span><br><span class="line">                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>legacyMergeSort：归并排序</li>
<li><a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">TimSort</a><br>：结合归并排序和插入排序的一种排序算法</li>
</ul>
<blockquote>
<p>TimSort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。排序的输入的单位不是一个个单独的数字，而是一个个的块-分区。其中每一个分区叫一个run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run合并到只剩一个 run 为止。这时这个仅剩的 run 便是排好序的结果。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java线程池解析]]></title>
      <url>/2019/07/15/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p><strong>线程池</strong>：可以根据字面意思简单的理解，一个管理线程的池子。</p>
<ul>
<li>帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。</li>
<li>提高响应速度。</li>
<li>重复利用。</li>
</ul>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize：线程池核心线程数最大值</li>
<li>maximumPoolSize： 线程池最大线程数大小</li>
<li>keepAliveTime： 线程池中非核心线程空闲的存活时间大小</li>
<li>unit： 线程空闲存活时间单位</li>
<li>workQueue： 存放任务的阻塞队列</li>
<li>threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li>
<li>handler：  线城池的饱和策略事件，主要有四种类型。</li>
</ul>
<h1 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h1><p>线程池执行流程，对应<code>execute()</code>方法。<br><a href="https://imgchr.com/i/Z7iOzt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7iOzt.md.jpg" alt="Z7iOzt.md.jpg"></a><br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        /*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">         * start a new thread with the given command as its first</span><br><span class="line">         * task.  The call to addWorker atomically checks runState and</span><br><span class="line">         * workerCount, and so prevents false alarms that would add</span><br><span class="line">         * threads when it shouldn&apos;t, by returning false.</span><br><span class="line">         *</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need</span><br><span class="line">         * to double-check whether we should have added a thread</span><br><span class="line">         * (because existing ones died since last checking) or that</span><br><span class="line">         * the pool shut down since entry into this method. So we</span><br><span class="line">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">         * stopped, or start a new thread if there are none.</span><br><span class="line">         *</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">         * and so reject the task.</span><br><span class="line">         */</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            else if (workerCountOf(recheck) == 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从execute代码注释中可以看出，任务执行流程主要是以下几步：</p>
<ul>
<li>提交任务，如果线程池里存活的核心线程数小于线程数<code>corePoolSize</code>时，线程池就会创建一个核心线程去处理提交的任务</li>
<li>如果线程池核心线程数满了，那么新提交的任务就会被放进任务队列<code>workQueue</code>中排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于<code>corePoolSize</code>，并且任务队列<code>workQueue</code>也满了，判断线程数是否达到<code>maximumPoolSize</code>，如果没有达到，创建一个非核心线程执行提交的任务。</li>
<li>如果当前线程数达到了<code>maximumPoolSize</code>，那么直接采取拒绝策略处理。</li>
</ul>
<h1 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h1><ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>DelayQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue(有界队列)是一个用数组实现的有界阻塞队列，按照FIFO排序。</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue(可设置容量队列)基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，就是一个没有边界的阻塞队列，最大长度为Integer.MAX_VALUE。</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue(延迟队列)是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后顺序排序。</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PriorityBlockingQueue(优先阻塞队列)具有优先级的无界阻塞队列。</p>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue(同步队列)一个不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移除操作，否则插入操作一直处于阻塞状态。</p>
<h1 id="几种常用的线程池"><a href="#几种常用的线程池" class="headerlink" title="几种常用的线程池"></a>几种常用的线程池</h1><h2 id="newSingleThreadPool"><a href="#newSingleThreadPool" class="headerlink" title="newSingleThreadPool"></a>newSingleThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>这个线程池只有一个核心线程在工作，也就是相当于单线程串化执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。阻塞队列使用的是<code>LinkedBlockingQueue</code><br><a href="https://imgchr.com/i/Z7i4sK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7i4sK.jpg" alt="Z7i4sK.jpg"></a></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于串行执行任务的场景，一个任务一个任务地执行。<br><!-- more --></p>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>这个线程池的大小(核心线程)是固定的。每次提交一个任务就创建一个线程，直到线程数达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，会将后面的任务加入到阻塞队列。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。使用的阻塞队列是<code>LinkedBlockingQueue</code><br><a href="https://imgchr.com/i/Z7ihM6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7ihM6.md.jpg" alt="Z7ihM6.md.jpg"></a></p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>适用于处理CPU密集型任务，确保CPU在长期被工作线程使用的情况下，尽可能少的分配线程，适用于执行长期的任务。</p>
<h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">     return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                   60L, TimeUnit.SECONDS,</span><br><span class="line">                                   new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>创建一个可缓存的线程池(即核心线程数为0)，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲(60s不执行任务)的线程，当任务数增加时，此线程池又可以智能的添加新的线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统能够创建的最大线程大小。阻塞队列使用的是<code>SynchronousQueue</code><br><a href="https://imgchr.com/i/Z7iWxx" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/Z7iWxx.md.jpg" alt="Z7iWxx.md.jpg"></a></p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>用于并发执行大量短期的小任务</p>
<h2 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>创建一个大小为<code>Integer.MAX_VALUE</code>的线程池，此线程池支持定时以及周期性执行任务的需求。阻塞队列使用的是<code>DelayedWorkQueue</code></p>
<ol>
<li>添加一个任务</li>
<li>线程池中的线程从DelayQueue中取任务</li>
<li>线程从DelayQueue中获取time大于等于当前时间的task</li>
<li>执行完后修改这个task的time为下一次被执行的时间</li>
<li>这个task返回到DelayQueue队列中</li>
</ol>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要周期性执行任务的场景，需要限制线程数量的场景</p>
<blockquote>
<p><a href="https://juejin.im/post/5d1882b1f265da1ba84aa676?utm_source=gold_browser_extension#heading-37" target="_blank" rel="noopener">https://juejin.im/post/5d1882b1f265da1ba84aa676?utm_source=gold_browser_extension#heading-37</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> JAVA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bitmap、Bloom Filter、Cuckoo Filter]]></title>
      <url>/2019/07/15/Bitmap%E3%80%81Bloom-Filter%E3%80%81Cuckoo-Filter/</url>
      <content type="html"><![CDATA[<p>昨天，在跟同学&amp;同事谈人生谈理想的时候。他告诉我他学长面试头条，其中一道题是如何判断一个整数在不在40亿整数集中；他说他学长竟然不知道<code>bitmap</code>(<a href="https://mp.weixin.qq.com/s/pUq213AJDpTGdGw4ywIS7g" target="_blank" rel="noopener">原题链接</a>)!!!然后我又给他科普了一下<code>布隆过滤器</code>和<code>布谷鸟过滤器</code>。<br>所以借此文章来记录一下这些知识，并巩固一下。</p>
<h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><p>Bitmap，直译就叫位图。可以理解为通过一个bit数组存储特定数据的一种数据结构；由于bit是数据的最小单位，所以这种数据结构往往是非常节省存储空间的。在Java和Redis中都存在同名实现结构。<br>在一个记录只有两种状态，是或不是的场景下，如果使用其他数据结构存储则会存在大量空间空间的浪费。即使存在海量的数据，我们也只需要为每个数据分配<code>1byte</code>的空间就可以记录了。比如：用户画像<br>Bitmap可以<font color="red">节省大量的存储空间</font>，所以可以很容易的倍一次性加载到内存中。Bitmap结构还有一个很重要的特点:<font color="red">可以很方便的进行位运算</font><br>比如我们需要统计用户满足以下条件的用户：程序员、带眼镜、长头发。。。。那么我们可以将对相应条件的用户画像的<code>Bitmap</code>结构做<code>AND</code>操作，就可以方便的过滤出满足条件的对象了。</p>
<h2 id="Bitmap的优化"><a href="#Bitmap的优化" class="headerlink" title="Bitmap的优化"></a>Bitmap的优化</h2><a id="more"></a>
<p>假如一个Bitmap中只有稀疏的那个几个1，那么其他空间是不是就被浪费了呢？</p>
<p>谷歌开发的EWAHComressedBitmap对Bitmap存储空间做了一定的优化操作。</p>
<p>EWAH把Bitmap存储在一个long数组中，long数组的每一个元素都可以当做64位的二进制数，也就是整个Bitmap的子集，称为<code>Word</code>。<br>当创建一个空的Bitmap时，只有4个<code>Word</code>，也就是只有4个long数组，随着数据的不断插入，<code>Word</code>数组会随着进行扩容。<br><code>Word</code>节点分为两种，直接存储数据的叫做<code>Literal Word</code>，简称LW。存储跨度信息的叫<code>Running Length Word</code>，简称RLW。<br>每一个RLW分为两部分，低32位表示当前Word横跨了多少个空Word，高32位表示当前RLW后面又多少个连续的LW。这样即使存在很多个0的位置，也能进行合并，减少浪费。<br><a href="https://imgchr.com/i/ZoGNon" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGNon.md.jpg" alt="ZoGNon.md.jpg"></a></p>
<h1 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h1><p>Bitmap适合处理<font color="red">按顺序字段映射</font>，如ID。但是当遇到其他情况时就无能为力了，比如判断一个单词是否存在于单词集中，这个时候如果需要映射的话，只能够对该单词进行相应的<code>hash</code>计算后映射到Bitmap上，But！绝大情况下会存在hash冲突，无法确认是不是。</p>
<p>于是便引入了<font color="red">布隆过滤器</font>。布隆过滤器也不能完全的消除误差。只能说大大的减少了误差率。</p>
<p>布隆过滤器的原理就是<font color="red">将需要判断的对象进行多次不同的hash计算后，同时判断那几位是否都为1</font>，由此可见，布隆过滤器的误差率取决于hash函数的选取。<br><a href="https://imgchr.com/i/ZoGYZj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGYZj.md.jpg" alt="ZoGYZj.md.jpg"></a></p>
<h1 id="Cuckoo-Filter"><a href="#Cuckoo-Filter" class="headerlink" title="Cuckoo Filter"></a>Cuckoo Filter</h1><p>布隆过滤器存在一个致命的缺点，那就是已经置为1的位不能再重置为0。这是因为你并不能判断该位具体被多少个对象映射了。只能在你认为误差率已经不能接受时进行重建。</p>
<p>我也是最近才了解到有<code>布谷鸟过滤器</code>的存在。</p>
<h2 id="布谷鸟哈希"><a href="#布谷鸟哈希" class="headerlink" title="布谷鸟哈希"></a>布谷鸟哈希</h2><p>最简单的布谷鸟哈希结构时一维数组结构，会有两个hash算法将新来的元素映射到数组的两个位置。如果两个位置中有一个位置为空，那么就可以把元素放进去；但是如果这两个位置都满了，那么会随机踢走一个，然后自己霸占这个位置。<br>被踢走的那个元素会寻找其他位置，重复上面的行为。知道所有的元素都找到了对应的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = hash1(x) % l</span><br><span class="line">p2 = hash2(x) % l</span><br></pre></td></tr></table></figure></p>
<p>布谷鸟算法为了避免重复踢的这个过程执行次数过多，会设置一个阈值，如果执行次数超过这个值，那么就会进行扩容操作，重新放置所有的元素。<br><a href="https://imgchr.com/i/ZoGGLQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoGGLQ.md.jpg" alt="ZoGGLQ.md.jpg"></a><br><a href="https://imgchr.com/i/ZoG8sg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/15/ZoG8sg.md.jpg" alt="ZoG8sg.md.jpg"></a></p>
<h2 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h2><p>布谷鸟过滤器和布谷鸟哈希结构一样，也是一维数组，但是不同于布谷鸟哈希的是，布谷鸟哈希会存储整个元素，而布谷鸟过滤器只会储存元素的指纹信息（只有几个bit，类似于布隆过滤器）。</p>
<p>首先布谷鸟过滤器还是只会选用两个 hash 函数，但是每个位置可以放置多个座位。这两个 hash 函数选择的比较特殊，因为过滤器中只能存储指纹信息。当这个位置上的指纹被挤兑之后，它需要计算出另一个对偶位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fp = fingerprint(x)</span><br><span class="line">p1 = hash(x)</span><br><span class="line">p2 = p1 ^ hash(fp)  // 异或</span><br></pre></td></tr></table></figure></p>
<p>我们可以看出p1和p2具有<code>对偶性</code>。所以我们根本不需要知道当前的位置是 p1 还是 p2，只需要将当前的位置和 hash(fp) 进行异或计算就可以得到对偶位置。而且只需要确保 hash(fp) != 0 就可以确保 p1 != p2，如此就不会出现自己踢自己导致死循环的问题。</p>
<p>由于布谷鸟过滤器保证了一个byte只被一个元素映射，所以允许删除操作，但是会存在误删的情况。</p>
<blockquote>
<p><a href="http://blog.talkingdata.net/?p=2493" target="_blank" rel="noopener">http://blog.talkingdata.net/?p=2493</a><br><a href="https://juejin.im/post/5c4fd2af51882525da267385" target="_blank" rel="noopener">https://juejin.im/post/5c4fd2af51882525da267385</a><br><a href="https://cloud.tencent.com/developer/article/1447177" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1447177</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 一些奇淫技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小技巧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac安装多版本JDK]]></title>
      <url>/2019/07/13/mac%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACJDK/</url>
      <content type="html"><![CDATA[<p>随着JDK版本的快速迭代，作为优秀(kubi)的Java拥护者，为了跟随时代的潮流，也开始使用1.8版本。</p>
<p>但是，某一天。。。。苦逼的事情发生了，一个项目原本是好好的，突然报错起不来了。最终查到的原因是某个项目的Jar包使用的JDK为1.7….于是就有了这篇记录。</p>
<p>在终端下面使用<code>java -version</code>查看就可以查看使用的JDK版本了。<br>使用<code>/usr/libexec/java_home -V</code>可以查看本地已经安装的JDK</p>
<p>关于JDK1.x for mac的安装略过，网上有大把的教程。<br>我这里以安装3个版本1.6/1.7/1.8为例。</p>
<p>一、编辑.bash_profile<br><code>vim ~/.bash_profile</code></p>
<p>二、在.bash_profile中添加下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`</span><br><span class="line">export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7`</span><br><span class="line">export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`</span><br><span class="line"></span><br><span class="line">#默认设为JDK1.7</span><br><span class="line">export JAVA_HOME=$JAVA_7_HOME</span><br><span class="line"></span><br><span class="line">#alias命令动态切换JDK版本</span><br><span class="line">alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot;</span><br><span class="line">alias jdk7=&quot;export JAVA_HOME=$JAVA_7_HOME&quot;</span><br><span class="line">alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;</span><br></pre></td></tr></table></figure></p>
<p>三、刷新环境<br><code>source ~/.bash_profile</code></p>
<p>四、测试<br>执行：<code>jdk8</code>，再执行<code>java -version</code>，看看是不是1.8版本？<br>执行：<code>jdk6</code>，再执行<code>java -version</code>，看看是不是1.6版本？</p>
]]></content>
      
        <categories>
            
            <category> 一些奇淫技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小技巧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cloneable接口实现原理]]></title>
      <url>/2019/06/04/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Cloneable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例当中。</p>
<p>在开发过程中，如果一个类中的字段比较多，而我们如果采用在客户端中逐字段复制的方法来进行拷贝操作的话，将不可避免的造成客户端代码繁杂，而且也无法对类中的私有对象进行复制，而如果让需要具备拷贝功能的类实现<code>Cloneable</code>接口，并重写<code>clone()</code>方法的方式来简洁地实现实例拷贝功能。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><code>private class Demo implements Cloneable{}</code><br>我们创建一个Demo类，并让他实现Cloneable接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Cloneable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们发现<code>Cloneable</code>几口里面并没有定义任何接口方法。<br>这是因为在<code>Object</code>类中已经将<code>clone()</code>方法定义为所有类都应该具有的基本功能，只是将该方法声明为了<code>protected</code>类型。它是一个<code>native</code>本地方法。</p>
<p>如果一个类不实现该接口就直接调用<code>clone()</code>方法的话，就会抛出“不支持拷贝”异常。<br>所以如果要让一个类具有拷贝实例的功能，那么除了要重写<code>Object</code>类中<code>clone()</code>方法外，还必须实现Cloneable接口。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单例模式]]></title>
      <url>/2019/06/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h2 id="单例模式多种写法"><a href="#单例模式多种写法" class="headerlink" title="单例模式多种写法"></a>单例模式多种写法</h2><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>这种方式在类加载时就完成了初始化，所以类加载比较慢，但是获取对象的速度快。这种方式基于类加载机制避免了多线程的同步问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="懒汉模式（线程不安全）"><a href="#懒汉模式（线程不安全）" class="headerlink" title="懒汉模式（线程不安全）"></a>懒汉模式（线程不安全）</h3><p>懒汉模式声明了一个静态对象，在用户第一次调用时进行初始化，虽然节约了资源，但第一次加载时需要实例化，反应稍微慢一点，而且在多线程下不能工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="懒汉模式（线程安全）"><a href="#懒汉模式（线程安全）" class="headerlink" title="懒汉模式（线程安全）"></a>懒汉模式（线程安全）</h3><p>这种写法能够在多线程中很好的工作，但是每次调用getSingleton时都需要同步，造成不必要的同步开销，而且大部分时候我们都是用不到同步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="双重检查模式（DCL）"><a href="#双重检查模式（DCL）" class="headerlink" title="双重检查模式（DCL）"></a>双重检查模式（DCL）</h3><p>这种写法对singleton进行了两次的判空操作，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。这里用到了volatile关键字，或多或少还是会影响性能，但是考虑到程序的正确性，牺牲这点性能还是值得的。</p>
<h4 id="PS：这里为什么要用volatile关键字？"><a href="#PS：这里为什么要用volatile关键字？" class="headerlink" title="PS：这里为什么要用volatile关键字？"></a>PS：这里为什么要用volatile关键字？</h4><p>这个地方使用volatile关键字是很有必要的，因为new一个新的对象其实是分了三步执行：</p>
<ol>
<li>为该对象分配内存空间</li>
<li>初始化对象</li>
<li>将对象指向分配的内存地址</li>
</ol>
<p>由于JVM指令重排的特性，执行顺序可能会变成1-&gt;3-&gt;2；在单线程环境下不会有问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。比如：</p>
<ol>
<li>线程1执行了1、3</li>
<li>线程2调用方法，发现该实例不为空，因此返回该实例。但此时实例还没被初始化。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static  Singleton getSingleton() &#123;</span><br><span class="line">        if(singleton == null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if(singleton == null)&#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    public Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line">        private static final Singleton sInstance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，上述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。</p>
<p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     public void doSomeThing() &#123;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用容器实现单例模式"><a href="#使用容器实现单例模式" class="headerlink" title="使用容器实现单例模式"></a>使用容器实现单例模式</h3><p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonManager &#123; </span><br><span class="line">　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();</span><br><span class="line">　　private Singleton() &#123; </span><br><span class="line">　　&#125;</span><br><span class="line">　　public static void registerService(String key, Objectinstance) &#123;</span><br><span class="line">　　　　if (!objMap.containsKey(key) ) &#123;</span><br><span class="line">　　　　　　objMap.put(key, instance) ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　public static ObjectgetService(String key) &#123;</span><br><span class="line">　　　　return objMap.get(key) ;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 编程思想 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap详解]]></title>
      <url>/2019/06/02/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/HashMap%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="什么是HashMap"><a href="#什么是HashMap" class="headerlink" title="什么是HashMap"></a>什么是HashMap</h2><p>HashMap一个用于存储Key-Value键值对的集合，每一个键值对称之为<code>Entry</code>分散存储在一个数组中。这个数组每一个元首初始值都是Null。</p>
<p>HashMap的常用操作就是<b>GET</b>和<b>PUT</b></p>
<h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>我们在调用put方法的时候，会利用一个哈希函数来确定<code>Entry</code>的插入位置。为了解决哈希冲突的问题，HashMap采用<font color="red">链表法</font>来解决这个问题。<br><code>注意：位置0上存放的一定是Null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">modCount++;</span><br><span class="line">addEntry(hash, key, value, i);</span><br><span class="line">return null;</span><br></pre></td></tr></table></figure></p>
<p>在遇到Hash冲突的时候，就将<code>Entry</code>以链表的形式给插入到相应的位置，这里需要注意的是：HashMap采用的是<font color="red">头插法</font>的形式。这是因为设计者认为最新加入的<code>Entry</code>更有可能被访问。<br>此时HashMap的结构为<b>数组加链表</b><br><img src="https://s2.ax1x.com/2019/06/16/V7M7nO.jpg" alt=""></p>
<a id="more"></a>
<p>当HashMap中有大量的元素都存放在同一个位置的时候，这个位置就有存在一条很长的链表；这个时候的HashMap相当于一个单链表。<br>于是在<b>JDK1.8</b>中引入了<font color="red">红黑树</font>来优化这个问题。当某一个位置上的<font color="red">链表长度大于等于8</font>的时就使用红黑树来进行存储。<br>在元素值小于6的时候就将红黑树又转换成链表形式。<br>此时HashMap的结构为<b>数组加链表加红黑树</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//一个桶的树化阈值</span><br><span class="line">//当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点</span><br><span class="line">//这个值必须为 8，要不然频繁转换效率也不高</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"> </span><br><span class="line">//一个树的链表还原阈值</span><br><span class="line">//当扩容时，桶中元素个数小于这个值，就会把树形的桶元素 还原（切分）为链表结构</span><br><span class="line">//这个值应该比上面那个小，至少为 6，避免频繁转换</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"> </span><br><span class="line">//哈希表的最小树形化容量</span><br><span class="line">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span><br><span class="line">//否则桶内元素太多时会扩容，而不是树形化</span><br><span class="line">//为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure></p>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>在HashMap的GET函数中，首先会通过计算键值的哈希值获取到<code>Entry</code>所在的位置，然后通过遍历链表或红黑树中的<code>Entry</code>来确定是否是我们需要的值。</p>
<p>HashMap在遍历链表比较时使用的Java对象的equals()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != null;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>通过这段代码，我们也可以看出：HashMap是可以存放键为Null的对象</code></p>
<h4 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line">        while (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + next.getKey() + &quot; value=&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(&quot;key=&quot; + key + &quot; value=&quot; + map.get(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>推荐使用第一种方式，第一种方式会将KV同时取出，而第二种方式还需要通过key取一次value，效率比较低。</p>
<h2 id="HashMap默认初始化长度"><a href="#HashMap默认初始化长度" class="headerlink" title="HashMap默认初始化长度"></a>HashMap默认初始化长度</h2><p>首先，我们要明确的一点就是：<font color="red">HashMap的默认初始化长度是16</font>，并且每次扩容和缩容后的长度大小都是2的幂。</p>
<p>为什么会有以上的限制呢？<br>这是因为需要实现尽可能分布均匀的Hash函数。HashMap中使用了<font color="red">位取模</font>的方式来计算哈希值。<br><code>index =  HashCode（Key） &amp;  （Length - 1）</code></p>
<p>这样做不但效果上等同于取模，而且大大提升了性能。<br>使用<code>位运算</code>的方式，相当于只取hash函数的后几位，分布情况取决于hash函数。<br>而使用其他方式，如<code>取模</code>，则可能会导致某些index结果出现的几率大大提升;此外，如果length不是2的幂的话，有些index的结果可能永远不会出现。</p>
<h2 id="Hash的Rehash"><a href="#Hash的Rehash" class="headerlink" title="Hash的Rehash"></a>Hash的Rehash</h2><p>HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。<br>这个时候的HashMap会需要进行扩容行为了。</p>
<p>影响HashMap扩容的因素有两个：</p>
<ul>
<li>Capacity：当前长度</li>
<li>LoadFactor：负载因子，默认是0.75f</li>
</ul>
<p><code>HashMap.Size   &gt;=  Capacity * LoadFactor时就会进行扩容操作了</code></p>
<p>HashMap的扩容操作分两步：</p>
<ol>
<li>创建一个新的数组，大小是原来数组的2倍。</li>
<li>遍历原数组，将原数组的所有元素重新Hash到新数组。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Transfers all entries from current table to newTable.</span><br><span class="line"> */</span><br><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap每次扩容或缩容都是以2的倍数进行的。<br>这是因为在这样的流程中，HashMap中的<code>Entry</code>需要迁移的只有一半，大大的节省了扩缩容的消耗。</p>
<h2 id="高并发下的HashMap"><a href="#高并发下的HashMap" class="headerlink" title="高并发下的HashMap"></a>高并发下的HashMap</h2><p>HashMap并不是线程安全的，在多线程操作下可能会导致很多意想不到的情况发生。比如死循环。</p>
<p>比如在上一小节中讲的Rehash，如果有多个线程同时进行扩容操作就会出现问题。<br>假设一个HashMap已经到了Resize的临界点。此时有两个线程A和B，在同一时刻对HashMap进行Put操作：<br><img src="https://s2.ax1x.com/2019/06/16/V7MbHe.jpg" alt="-w564"><br><img src="https://s2.ax1x.com/2019/06/16/V7MONd.jpg" alt="-w496"><br>此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：<br><img src="https://s2.ax1x.com/2019/06/16/V7MLAH.jpg" alt="-w748"><br>这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：<br><img src="https://s2.ax1x.com/2019/06/16/V7MHBD.jpg" alt=""><br>假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p>
<p>这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）：<br><img src="https://s2.ax1x.com/2019/06/16/V7MX4A.jpg" alt="-w778"><br>直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p>
<p><img src="https://s2.ax1x.com/2019/06/16/V7MzgP.jpg" alt=""><br>当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。<br><img src="https://s2.ax1x.com/2019/06/16/V7Mv9I.jpg" alt=""><br>我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且e指向了Entry2。此时e和next的指向如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry2</span><br><span class="line">next = Entry2</span><br></pre></td></tr></table></figure></p>
<p>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QPHg.jpg" alt="-w702"><br>接着是新一轮循环，又执行到红框内的代码行：<br><img src="https://s2.ax1x.com/2019/06/16/V7Mx3t.jpg" alt=""><br>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QSjf.jpg" alt="-w762"><br>接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：<br><img src="https://s2.ax1x.com/2019/06/16/V7Q9u8.jpg" alt=""><br>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QCDS.jpg" alt="-w746"><br>第三次循环开始，又执行到红框的代码：<br><img src="https://s2.ax1x.com/2019/06/16/V7QkNj.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = Entry3</span><br><span class="line">next = Entry3.next = null</span><br></pre></td></tr></table></figure></p>
<p>最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：<br><img src="https://s2.ax1x.com/2019/06/16/V7QFEQ.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = Entry2</span><br><span class="line">e = Entry3</span><br><span class="line">Entry2.next = Entry3</span><br><span class="line">Entry3.next = Entry2</span><br></pre></td></tr></table></figure></p>
<p>链表出现了环形！</p>
<p>整体情况如图所示：<br><img src="https://s2.ax1x.com/2019/06/16/V7QA4s.jpg" alt="-w751"><br>此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！</p>
]]></content>
      
        <categories>
            
            <category> JAVA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Object的常用方法]]></title>
      <url>/2019/06/01/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Object%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Object类常见方法"><a href="#Object类常见方法" class="headerlink" title="Object类常见方法"></a>Object类常见方法</h1><p>Object是一个特殊的类，所有的类都会隐式的继承Object类。Object中主要有以下11个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">注：native方法：使用这个关键字说明这个方法是原生方法，底层使用C/C++实现，并且被编译成了DLL，由Java调用。函数实现在DLL中，JDK源码并不包含。</span><br><span class="line"></span><br><span class="line">public final native Class&lt;?&gt; getClass()</span><br><span class="line">用于返回当前运行时对象的Class对象，使用final关键字修饰，不允许子类重写。</span><br><span class="line"></span><br><span class="line">public native int hashCode()</span><br><span class="line">用于返回对象的哈希码，主要使用在哈希表中。</span><br><span class="line"></span><br><span class="line">public boolean equals(Object obj)</span><br><span class="line">用于比较2个对象的内存地址是否相等，String类对该方法进行了重写。</span><br><span class="line"></span><br><span class="line">protected native Object clone() throws CloneNotSupportedException</span><br><span class="line">用于创建当前对象的一份拷贝。Object本身并没有实现Cloneable接口，所以不重写clone方法并且进行调用就会发生CloneNotSupportedException异常。</span><br><span class="line"></span><br><span class="line">public String toString()</span><br><span class="line">默认返回类的名字@实例的哈希码的16进制的字符串，建议所有子类都重写该方法。</span><br><span class="line"></span><br><span class="line">public final native void notify()</span><br><span class="line">final方法，用于唤醒一个在此对象监视器上等待的线程。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="line"></span><br><span class="line">public final native void notifyAll()</span><br><span class="line">用于唤醒该对象上所有的等待线程。</span><br><span class="line"></span><br><span class="line">public final native void wait(long timeout) throws InterruptedException</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException</span><br><span class="line">public final void wait() throws InterruptedException</span><br><span class="line">暂停线程的执行，第二个超时时间需要增加nanos毫秒，第三个没有超时时间。</span><br><span class="line"></span><br><span class="line">protected void finalize() throws Throwable &#123; &#125;</span><br><span class="line">实例被垃圾回收器回收的时候触发的操作。</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> JAVA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GET和POST的区别]]></title>
      <url>/2019/04/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h1><p>GET和POST是HTTP请求的两种发送方式，其本质上并没有多大区别。HTTP的底层是TCP/IP协议，所以GET和POST底层实现也是TCP/IP协议，也就是GET和POST都是TCP连接，GET和POST做的事情都是一样的。如果在GET上加上<code>request body</code>，POST上加上<code>url</code>在技术上完全是可行的。</p>
<p>但是GET和POST在一些表现上还是有区别的。主要体现在以下几个方面：</p>
<ul>
<li>GET请求在URL中传送的参数是有长度限制的，POST没有</li>
<li>GET会将参数直接显示在URL上，所以POST更为安全</li>
<li>GET参数传递通过URL，POST参数传递通过request body</li>
<li>GET请求参数记录会被保留在浏览器记录中，POST不会</li>
<li>POST支持多种编码方式</li>
<li>POST在回退的时候会再次提交数据，GET不会</li>
<li>在某些浏览器下，GET只会发送一次数据包，而POST需要发送两次</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三次握手和四次挥手]]></title>
      <url>/2019/04/04/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      <content type="html"><![CDATA[<h2 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">客户端-&gt;服务端: SYNC=1,seq=x</span><br><span class="line">Note left of 客户端: SYCN_SEND</span><br><span class="line">服务端--&gt;客户端: SYNC=1,ACK=1,seq=y,ack=x+1</span><br><span class="line">Note right of 服务端: SYNC_RECV</span><br><span class="line">客户端-&gt;服务端: ACK=1,seq=x+1,ack=y+1</span><br><span class="line">Note left of 客户端: ESTAB-LISHED</span><br><span class="line">Note right of 服务端: ESTAB-LISHED</span><br></pre></td></tr></table></figure>
<p>第一次握手：建立连接时，客户端发送sync包(syn=x)到服务器，并进入SYN_SENT状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，发送确认号(ack=x+1)，同时自己也发送一个syn包(syn=y)，即ACK+SYN包；服务器进入SYN_RECV状态。</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)；发送完毕后，客户端和服务端都进入ESTABLISHED状态完成三次握手。</p>
<a id="more"></a>
<h2 id="四次挥手流程"><a href="#四次挥手流程" class="headerlink" title="四次挥手流程"></a>四次挥手流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端-&gt;服务端: FIN=1,seq=u</span><br><span class="line">Note left of 客户端: FIN_WAIT_1</span><br><span class="line">服务端--&gt;客户端: ACK=1,seq=v,ack=u+1</span><br><span class="line">Note right of 服务端: CLOSE_WAIT</span><br><span class="line">服务端--&gt;客户端: FIN=1,ACK=1,seq=w,ack=u+1</span><br><span class="line">Note right of 服务端: LAST_ACK</span><br><span class="line">客户端-&gt;服务端: ACK=1,seq=u+1,ack=w+1</span><br><span class="line">Note right of 服务端: CLOSED</span><br><span class="line">Note left of 客户端: 等待2MSL后，进入CLOSED</span><br></pre></td></tr></table></figure>
<p>1、 客户端进程发送连接释放报文，并且停止发送数据。报文中带<code>FIN=1</code>标记。并且其序列号<code>seq=u</code>（等于前面已经传送过来的数据的最后一个字节的序号+1）。客户端进入<code>FIN-WAIT=1</code>状态。</p>
<p>2、服务器接收到连接释放报文后，发送确认报文<code>ACK=1，ack=u+1</code>，并带上自己的序列号<code>seq=v</code>，此时，服务端进入<code>CLOSE-WAIT</code>状态。这个时候处于半关闭状态；表示客户端不再发送数据，服务端不再接收数据；服务端若要发送数据，客户端依然要接收。</p>
<p>3、 客户端手抖服务端的确认请求后，进入<code>FIN-WAIT-2</code>状态，等待服务器发送连接释放报文。</p>
<p>4、 服务器将数据发送完毕后，就向客户端发送连接释放报文，<code>FIN=1,ack=u+1,seq=w</code>。此时服务端进入<code>LAST-ACK</code>状态，等待客户端的确认。</p>
<p>5、 客户端收到服务端的连接释放报文后，必须发出确认。<code>ACK=1,ack=w+1，seq=u+1</code>，客户端进入<code>TIME-WAIT</code>状态。此时TCP连接还没有释放，必须经过2*MSL的时间后，才进入<code>CLOSED</code>状态。</p>
<p>6、 服务端接收到客户端发出的确认后，立即进入<code>CLOSED</code>状态。</p>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol>
<li><p>为什么连接的时候是三次握手，关闭的时候却是四次挥手？<br> 当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p>
<p> 在关闭连接的时候，服务端接收到FIN报文后，很可能不会立即关闭SOCKET，所以先回复一个ACK报文，告诉客户端“你的FIN报文我收到了”。只有当服务端的报文都发送完，才发送FIN报文给客户端。</p>
</li>
<li><p>为什么TIME_WAIT状态需要经过2MSL才进入CLOSED状态？<br> 虽然按道理，四个报文都发送完毕后，就可以直接进入CLOSED状态了，但是我们必须假设网络是不可靠的，有可能最后一个ACK丢失。</p>
<p> 由于网络原因，导致服务端没有收到客户端的ACK报文，不断的发送FIN给客户端。所以需要留下一段时间来处理这种情况，发送ACK报文给服务端。如果知道2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被服务端成功接收，结束TCP连接。</p>
</li>
<li><p>为什么不能只用两次握手进行连接？<br> 三次握手主要是完成两个重要功能：</p>
<ul>
<li>双方都已经做好了发送数据的准备工作</li>
<li><p>协商算法初始序列号，这个序列号在握手过程中发送和确认。</p>
<p>我们假设只进行两次握手；客户端发送连接请求给客户端，客户端收到后返回确认给客户端。<br>按照两次握手的约定，这个时候服务端已经认为成功的建立了连接，一直处于等待客户端发送消息的状态。<br>而客户端再丢失了服务端发送过来的确认报文，不知道是否建立成功，以及不知道服务端的序号状态。在这种情况下，客户端将认为连接没有建立成功，忽略客户端发送过来的任何数据报文，只等待应答报文。而服务端在发出数据报文超时后，不断的重复发送同样的数据。</p>
</li>
</ul>
</li>
<li><p>如果已经建立连接后，客户端发生了故障怎么办？<br> TCP设有一个计时器，服务器每收到一个客户端请求后都会重新复位这个计时器，如果在规定时间内还没有收到客户端的任何数据，服务器就会发送一个探测报文，每隔75s发送一次。如果连续10次都没有反应，服务端就认为客户端发生了故障，关闭连接。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 计算机基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL机制介绍之Change Buffer]]></title>
      <url>/2019/04/03/new/MySQL/MySQL%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D%E4%B9%8BChange-Buffer/</url>
      <content type="html"><![CDATA[<h1 id="MySQL的偷懒行为之Change-Buffer"><a href="#MySQL的偷懒行为之Change-Buffer" class="headerlink" title="MySQL的偷懒行为之Change Buffer"></a>MySQL的偷懒行为之Change Buffer</h1><p>在使用MySQL的时候，只要MySQL服务给你返回成功信息后，得到你需要的结果，你并不关注MySQL的行为；但是其实在MySQL内部，其实有很多的特性和机制来延迟真正的持久化等耗时耗资源行为。下面我将为你介绍其中的一个特性：change buffer</p>
<h2 id="简介-What"><a href="#简介-What" class="headerlink" title="简介(What)"></a>简介(What)</h2><p>The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool. The buffered changes, which may result from INSERT, UPDATE, or DELETE operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.</p>
<p>当需要改变<font color="red">二级索引</font>的数据，并且该<font color="red">数据页不在内存缓冲池中</font>；这个时候会直接向客户端返回修改成功的信息。MySQL并不实时的去更新磁盘数据，而是在之后一定条件下触发更新操作。这就是<font color="red">change buffer</font>在作祟。</p>
<p>change buffer在MySQL5.5版本之前，只支持insert操作，所以最初被称为insert buffer。在之后的版本中，支持了更多的修改操作，所以后面改称为change buffer。</p>
<a id="more"></a>
<h2 id="为什么需要change-buffer-Why"><a href="#为什么需要change-buffer-Why" class="headerlink" title="为什么需要change buffer(Why)"></a>为什么需要change buffer(Why)</h2><p>首先，你要明白<font color="red">二级索引的数据页在磁盘上存储得很散乱</font>，读取的时候需要消耗大量的资源去做寻址等操作。这里涉及到了操作系统知识，并不在本文的科普范围。</p>
<p>其次，一般情况下，二级索引的数据访问的并不是很频繁，作为冷数据的存在，<font color="red">即使读取到了内存当中，很快也会被挤出内存缓冲池</font>。如果每次更新操作都读取进来，那也是一笔很大的开销，所以MySQL会将多次更新给合并到一块去更新。（这里涉及到了LRU的淘汰知识，后续会有专门的文章讲解，这里你只需要知道有这个东西就行了）</p>
<p>所以，change buffer的主要作用有以下两点：</p>
<ol>
<li>减少了MySQL<font color="red">随机</font>读取磁盘的次数</li>
<li>将<font color="red">多次的随机写</font>磁盘操作，合并成了<font color="red">一次的顺序写</font>磁盘操作</li>
</ol>
<p>这里再介绍一下change buffer的限制条件：<font color="red">非唯一的辅助索引</font></p>
<p>前面我们说过二级索引的数据在磁盘上分布的很散乱，但是聚簇索引就不会这样；我们都知道Innodb的数据都存储在聚簇索引的叶子节点，Innodb为了保证能够更快的读取数据，会<font color="red">将聚簇索引的数据页尽可能在物理上顺序放在一起</font>。</p>
<p>此外，在修改聚簇索引和唯一辅助索引上的数据时，为了<font color="red">保证数据的唯一性</font>，总是会在进行修改操作前进行一次查询操作，这个时候已经将该数据页读取到内存缓存池中了。直接修改内存中数据页上的数据信息更快，完全没有必要使用change buffer。</p>
<h2 id="change-buffer干了什么-DO）"><a href="#change-buffer干了什么-DO）" class="headerlink" title="change buffer干了什么(DO）"></a>change buffer干了什么(DO）</h2><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>下面我们来看change buffer的执行过程：</p>
<ol>
<li>如果需要修改的数据页在内存中，则直接修改内存数据并返回</li>
<li>如果需要修改的数据页不在内存中，则向change buffer中添加一条记录（修改数据页的记录)</li>
<li>在redo log中添加一条记录（change buffer页的修改记录）<br><a href="https://imgchr.com/i/V7JVC4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JVC4.jpg" alt="V7JVC4.jpg"></a></li>
</ol>
<p>从change buffer的执行过程中，我们可以看到，如果需要修改的数据页page 2不在内存中时，Innodb并不会去磁盘中读取，而是在change buffer中记录了page 2中的数据变更。</p>
<p>系统会周期性的将change buffer的数据写入到系统表空间中。所以不需要担心change buffer的数据丢失问题。</p>
<h3 id="什么时候进行合并操作"><a href="#什么时候进行合并操作" class="headerlink" title="什么时候进行合并操作"></a>什么时候进行合并操作</h3><ul>
<li>二级索引页被读取到buffer pool中，在页面可用之前，会先进行合并缓存操作</li>
<li>change buffer bitmap页追踪到该辅助索引页无可用空间时</li>
<li>Master Thread定时任务</li>
<li>在崩溃恢复时，索引页被读入到缓冲池时，会将存在系统表空间的change buffer应用到二级索引的叶子节点</li>
<li>当–innodb-fast-shutdown=0时，数据库实例关闭时会强制将change buffer合并到数据页中并刷盘。</li>
</ul>
<h3 id="change-buffer的存储"><a href="#change-buffer的存储" class="headerlink" title="change buffer的存储"></a>change buffer的存储</h3><p><a href="https://imgchr.com/i/V7J9uq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7J9uq.md.jpg" alt="V7J9uq.md.jpg"></a></p>
<p>change buffer在物理上是以一个普通的btree存储。根页是存储在系统表空间的固定页中（涉及innodb的数据存储结构，太高深了~还没到那个层次，就看个热闹)</p>
<p>上图是一条ibuf记录的存储格式，通过（space id, page no , counter）三列作为主键来唯一决定一条记录，其中counter是一个递增值，目的是为了维持不同操作的有序性。可以通过counter来保证merge时执行时的顺序和用户操作的顺序一致。</p>
<p>在插入时，会先将counter的值设置成0xFFFF；然后将定位到小于等于(space id, page no, 0xFFFF)的位置，再将counter为当前记录counter值加1。(这样做的原因是为了合并的时候能够更方便的找到同一数据页的缓存，并保证有序)</p>
<p><a href="https://imgchr.com/i/V7JSvn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JSvn.md.jpg" alt="V7JSvn.md.jpg"></a><br>因为ibuf缓存是针对具体的数据页的，因此在缓存操作的时候需要避免空页和满页的缓存操作。(满页：即将分裂的页，并不一定是所有空闲空间用完的页，一个数据页会有1/16的空隙)</p>
<ol>
<li>针对空页情况，在准备插入IBUF_OP_DELETE类型的操作缓存时，会预估执行完此操作后该page中还存在多少记录，如果只剩下一条记录，则走正常流程，将数据页读取到内存中。</li>
<li>针对满页情况，则是通过ibuf_bitmap页记录，该页存在于每个ibd的固定位置；ibuf_bitmap中记录了每个数据页的缓存状态和空闲空间大小。<br>在执行IBUF_OP_INSERT类型的操作前，会将该page的IBUF_BITMAP_BUFFERED设置为true。<br>通过IBUF_BITMAP_FREE来记录该page的空闲空间；在插入前，会去找到该page的空闲空间大小，如果本次操作超出限制，则会触发一次异步ibuf merge。</li>
</ol>
<h3 id="merge过程"><a href="#merge过程" class="headerlink" title="merge过程"></a>merge过程</h3><ol>
<li>一个磁盘上的数据页被读取到内存缓冲池中</li>
<li>到ibuf_bitmap中判断该数据页是否有缓存行为</li>
<li>如果存在缓存，则从ibuf的btree树中读取该数据页的缓存操作；并应用到该内存数据页上</li>
<li>只有当应用缓存完成，才能提供给用户查询等操作行为</li>
<li>在一定情况下执行刷盘操作，持久化到磁盘</li>
</ol>
<h3 id="merge触发情况"><a href="#merge触发情况" class="headerlink" title="merge触发情况"></a>merge触发情况</h3><ol>
<li>二级索引页被读入到内存中</li>
<li>插入ibuf操作时，遇到满页，会造成页分裂操作时，触发一次异步的merge</li>
<li>当前ibuf tree size&gt;max_size + 10时，会执行一次同步的merge</li>
<li>本次插入ibuf操作可能会导致ibuf tree索引分裂时，根据ibuf size的大小情况会触发不同情况的merge</li>
<li>master定时任务会合并相应数量的buffer</li>
<li>对某个表执行flush table时，会强制对该表的page进行merge</li>
<li>数据库关闭时，根据innodb_fast_shutdown来决定是否进行merge</li>
</ol>
<h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><ol>
<li><p>innodb_change_buffering<br>innodb_change_buffering参数可以控制什么操作会使用change buffer。默认是all</p>
<p> |||<br> | — | — |<br> | all | The default value: buffer inserts, delete-marking operations, and purges. |<br> | none | Do not buffer any operations. |<br> | inserts | Buffer insert operations. |<br> | deletes | Buffer delete-marking operations. |<br> | changes | Buffer both inserts and delete-marking operations. |<br> | purges | Buffer physical deletion operations that happen in the background. |</p>
</li>
<li><p>innodb_change_buffer_max_size<br>innodb_change_buffer_max_size参数控制change buffer占buffer pool的百分比。默认25%，最大50%</p>
</li>
<li><p>查看change buffer的使用情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SHOW ENGINE INNODB STATUS \G</span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">56</span>, seg <span class="keyword">size</span> <span class="number">58</span>, <span class="number">517693</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">560451</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Ibuf表示当前缓冲区中change buffer的页使用情况<br>size表示已使用的页数，free list len表示空闲的页，seg size表示总共的页数（等于size + free list len + 1)，merges合并数<br>merged operations表示change buffer中每个操作的次数。<br>insert表示Insert Buffer，delete mark表示Delete Buffer，delete表示Purge Buffer。<br>discarded operations表示当change buffer发生merge操作时，表已经被删除，此时不再需要将记录合并到辅助索引中去。</p>
<p>从上面的信息可以看出这个数据库实例的change buffer效果并不明显（通过insert/merges计算)。change buffer适用于存在大量修改二级索引页的DML活动中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>change buffer将随机IO转换成顺序IO，避免了IO带来的性能损耗，减少了随机读磁盘的次数，提高了数据库的写性能。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html</a><br><a href="https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/faqs-innodb-change-buffer.html</a><br><a href="http://mysql.taobao.org/monthly/2015/07/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2015/07/01/</a><br><a href="https://blog.csdn.net/bohu83/article/details/81837872" target="_blank" rel="noopener">https://blog.csdn.net/bohu83/article/details/81837872</a></p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL忘记密码怎么办]]></title>
      <url>/2019/04/02/MySQL/MySQL%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
      <content type="html"><![CDATA[<h1 id="MySQL忘记密码怎么办？"><a href="#MySQL忘记密码怎么办？" class="headerlink" title="MySQL忘记密码怎么办？"></a>MySQL忘记密码怎么办？</h1><p>有的时候搭建MySQL后，由于密码没有保存好、忘记密码、密码过期等原因，导致登录不上数据库。这个时候该怎么办？</p>
<p>如果数据库使用人员，那还是乖乖的找数据库管理人员修改密码吧！<br>如果是数据库管理人员，能够登录到MySQL实例所在服务器的话。下面将介绍两种方式进行修改密码操作。</p>
<h2 id="skip-grant-tables"><a href="#skip-grant-tables" class="headerlink" title="skip-grant-tables"></a>skip-grant-tables</h2><p>第一种方式就是网上介绍最多的通过配置skip-grant-tables参数来跳过MySQL登录校验后，进行修改密码。</p>
<p>步骤就是：</p>
<ol>
<li>需要关闭MySQL实例。</li>
<li>配置参数。这里有两种方式：第一种就是在启动的使用，启动命令添加–skip-grant-tables；第二种就是通过修改配置文件，在[mysqld]下添加skip-grant-tables。</li>
<li>启动数据库</li>
<li>通过alter mysql.user set authentication_string=password(‘newpass’) where XXX@XXX;</li>
<li>去掉skip-grant-tables配置后重新启动。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">MySQL5.6的密码参数列为：password</span><br><span class="line">MySQL5.7的密码参数列为：authentication_string</span><br><span class="line"></span><br><span class="line">MySQL的账号是以`用户名`@`主机地址`计算的。同一用户名不同主机地址视为不同账号。</span><br></pre></td></tr></table></figure>
<p>这种方法的缺点很明显：</p>
<ol>
<li>数据库必须有一段时间不能提供服务。</li>
<li>开启跳过权限检查的参数后，安全性无法得到保障。所有人都能登录，即使没有改账号也能登录成功。<a id="more"></a>
</li>
</ol>
<h2 id="利用MyISAM表的特性"><a href="#利用MyISAM表的特性" class="headerlink" title="利用MyISAM表的特性"></a>利用MyISAM表的特性</h2><p>在MySQL8.0之前，mysql.user表都是MyISAM表，可以利用MyISAM表的特性进行修改密码操作。MySQL8.0后，放弃了MyISAM表，所以这个方法对8.0后的版本没有用。</p>
<p>这个方法需要有一个临时的数据库。<br>假设我们当前有两个数据库，一个3307，一个3309；3307实例的密码忘记了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@vdb_172_16_123_101 /root]# ps aux | grep mysql</span><br><span class="line">mysql     2792  0.3 10.3 1067856 184220 pts/0  Sl   19:46   0:00 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3307/my.cnf</span><br><span class="line">mysql     2822  0.4 10.5 1067856 186072 pts/0  Sl   19:46   0:00 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3309/my.cnf</span><br><span class="line">root      2869  0.0  0.0 112648   960 pts/0    R+   19:47   0:00 grep --color=auto mysql</span><br></pre></td></tr></table></figure></p>
<p>第一步：我们首先登录3309实例，并创建一个临时库testdb(库名可以指定定)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; create database testdb;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>第二步：将3307实例下的mysql库下的user*文件都拷贝到第一步创建的3309实例的testdb库下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# cp -a /data/mysql/mysql_3307/data/mysql/user.* /data/mysql/mysql_3309/data/testdb/</span><br><span class="line">[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3309.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 6</span><br><span class="line">Server version: 5.7.17-log MySQL Community Server (GPL)</span><br><span class="line"> </span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> </span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"> </span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; use testdb;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"> </span><br><span class="line">Database changed</span><br><span class="line">root@localhost:mysql_3309.sock [testdb]&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_testdb |</span><br><span class="line">+------------------+</span><br><span class="line">| user             |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>第三步：在3309实例下修改testdb库下user表的密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3309.sock -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 7</span><br><span class="line">Server version: 5.7.17-log MySQL Community Server (GPL)</span><br><span class="line"> </span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> </span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"> </span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; select user,host,authentication_string from testdb.user;</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">| user      | host      | authentication_string                     |</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">| root      | localhost | *527F89C205EA0A51A7537FFA7B6090D91A7D77AE |</span><br><span class="line">| mysql.sys | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |</span><br><span class="line">+-----------+-----------+-------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; update testdb.user set authentication_string=password(&apos;newpass&apos;) where user=&apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 1</span><br><span class="line"> </span><br><span class="line">root@localhost:mysql_3309.sock [(none)]&gt; exit</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure></p>
<p>第四步：将user*文件拷贝回3307的mysql库下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# cp -a /data/mysql/mysql_3309/data/testdb/user.* /data/mysql/mysql_3307/data/mysql</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.frm’? y</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.MYD’? y</span><br><span class="line">cp: overwrite ‘/data/mysql/mysql_3307/data/mysql/user.MYI’? y</span><br></pre></td></tr></table></figure></p>
<p>第五步：给一个HUP信号给3307，重新加载配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vdb_172_16_123_101 /root]# ps aux | grep mysqld</span><br><span class="line">mysql     2792  0.0 10.7 1067856 189960 pts/0  Sl   19:46   0:01 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3307/my.cnf</span><br><span class="line">mysql     2822  0.0 11.6 1067856 206352 pts/0  Sl   19:46   0:01 /usr/local/mysql/bin/mysqld --defaults-file=/data/mysql/mysql_3309/my.cnf</span><br><span class="line">root      2912  0.0  0.0 112648   964 pts/0    S+   20:07   0:00 grep --color=auto mysqld</span><br><span class="line">[root@vdb_172_16_123_101 /root]# kill -HUP 2792</span><br></pre></td></tr></table></figure></p>
<p>第六步：用新密码登录3307实例</p>
<pre><code>[root@vdb_172_16_123_101 /root]# mysql -S /tmp/mysql_3307.sock -p&apos;newpass&apos;
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 5
Server version: 5.7.17-log MySQL Community Server (GPL)

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.

root@localhost:mysql_3307.sock [(none)]&gt; 
</code></pre><p>这种方法是利用MyISAM表拷贝即可使用的特性，在一个临时实例中修改后替换。可以不用重启数据库，不会对业务造成影响。<br>为了安全起见，在操作前还是需要对原文件进行备份。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[InnoDB整体架构]]></title>
      <url>/2019/03/03/MySQL/InnoDB%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="InnoDB整体架构"><a href="#InnoDB整体架构" class="headerlink" title="InnoDB整体架构"></a>InnoDB整体架构</h1><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><ul>
<li>Master Thread<br>Master Thread具有最高的线程优先级别，内部由多个循环（每秒/每10秒）组成。<ol>
<li>每秒的操作<ul>
<li>刷新日志缓冲到磁盘（总是）</li>
<li>合并插入缓冲</li>
<li>刷新脏页到磁盘（至多100个）</li>
<li>切换到后台进程</li>
</ul>
</li>
<li>每10秒的操作<ul>
<li>删除无用的undo页（总是）</li>
<li>合并20个插入缓冲（总是）</li>
<li>调回主循环（总是）</li>
</ul>
</li>
</ol>
</li>
<li>IO Thread</li>
<li>purge Thread</li>
<li>Page cleaner Thread</li>
</ul>
<a id="more"></a>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><ul>
<li><p>Change buffer（Insert buffer、Delete buffer、Purge buffer）<br>在对非唯一索引的插入和更新操作过程中，如果该数据页在内存中，则直接对数据页进行修改。如果该数据页不在内存中，Innodb并不会马上到磁盘上将该数据页读入内存中，而是先将修改存入到Change buffer中，再按照一定的频率将修改合并到数据页中。</p>
<ol>
<li>为什么是需要在非唯一索引的<br>如果是对唯一索引上的数据进行修改，那么在修改前需要进行唯一性校验，这个时候会对该数据页进行查询操作，此时已经将该数据页读取到了内存当中，所以Change buffer的优化对唯一索引并没有什么效果。</li>
<li>如果宕机是否会导致数据的丢失？<br>Change buffer中数据，不仅会保存在内存当中，还会持久化到磁盘（系统表空间）当中。（持久化机制？）</li>
<li>什么情况下会合并？<ul>
<li>当对该数据页进行查询操作时，会将该数据页读取到内存当中。此时，会进行Change buffer的合并操作，将Change buffer中对该数据页的修改应用到该数据页。</li>
<li>Insert buffer Bitmap页追踪到该辅助索引页中已无可用空间</li>
<li>Master Thread</li>
</ul>
</li>
<li>合并流程怎样？<ul>
<li>从磁盘中读取数据页到内存（老版本）</li>
<li>从Change buffer中读取这个数据页的修改引用到内存中的数据页</li>
<li>写redo log。记录了内存也和Change buffer的变更。（此时内存中的数据页属于脏页）<br><a href="https://imgchr.com/i/Zhzndf" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/Zhzndf.md.jpg" alt="Zhzndf.md.jpg"></a></li>
</ul>
</li>
</ol>
</li>
<li><p>redo buffer<br>redo log中记录的是数据页的物理修改。在事务执行过程中不断的写入到redo buffer中。<br>redo buffer在以下情况会持久化到磁盘。</p>
<ul>
<li>Master Thread每秒的定时任务</li>
<li>每个事务提交时</li>
<li>写入量过大，导致redo buffer不足是<br>由innodb_flush_log_at_trx_commit控制刷盘策略</li>
<li>0代表当事务提交时刷盘，只由Master Thread每秒定时任务执行刷盘</li>
<li>1代表在执行commit时将重做日志缓冲同步到写到磁盘</li>
<li>2异步刷盘，直接写到文件系统的缓存中，不保证commit执行时肯定会刷盘</li>
</ul>
</li>
<li>数据页和索引页<br>数据都是存储在磁盘上的，当需要访问时才会从磁盘中将该数据所在的页读取到内存当中，并以一定的策略进行淘汰策略和刷盘策略。</li>
<li>哈希信息页</li>
<li>元数据信息页</li>
</ul>
<h3 id="Innodb机制"><a href="#Innodb机制" class="headerlink" title="Innodb机制"></a>Innodb机制</h3><ul>
<li>checkpoint<br>在一定条件下，将内存中的脏页持久化到磁盘，并记录数据页刷新的位点信息(LSN)的一种机制。<ol>
<li>缩短数据库的恢复时间（数据库关闭时将所有的脏页刷新到磁盘/Sharp Checkpoint）</li>
<li>缓冲池不够用时，刷新部分脏页（为了保证缓冲池中有足够可用的数据页，Innodb会强制进行Checkpoint/Dirty Page too much Checkpoint)</li>
<li>重做日志不可用时，刷新部分脏页（redo log是一个循环文件，如果redo log的写入量特别大，导致此时redo log几乎写满，Innodb会先将部分脏页先刷新到磁盘，释放redo log空间，此时会触发Checkpoint。/Async/Sync Flush Checkpoint）</li>
<li>Master Thread每秒任务，刷新部分脏页</li>
<li>LRU列表空闲页不足时，刷新部分脏页（Innodb会保证LRU列表中有一定数量空闲页可使用，如果LRU列表中没有这么多空闲页，那么Innodb会将LRU列表尾端的页移除，如果其中存在脏页，那么此时会进行Checkpoint操作/FLUSH_LRU_LIST Checkpoint）</li>
</ol>
</li>
<li><p>两次写（Double write）<br>在写数据之前，先把这个数据页写到一块独立物理位置后，再写到数据页中。<br>由两部分组成，一部分是Innodb内存中的double write buffer；另一部分是物理磁盘上的ibdata系统表空间的大小为2M，共128个连续的page。<br>在对缓冲池中的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer分两次，每次1M顺序地写入到共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘。<br><a href="https://imgchr.com/i/ZhzmeP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhzmeP.md.jpg" alt="ZhzmeP.md.jpg"></a></p>
</li>
<li><p>WAL（write ahead log)</p>
<pre><code>1. 先记录undo/redo log,确保日志刷到磁盘上持久存储。
2. 更新内存数据页，并&lt;font color=&quot;red&quot;&gt;异步刷盘&lt;/font&gt;。
3. 事务日志持久化到binlog，&lt;font color=&quot;red&quot;&gt;此时返回给客户端事务已提交&lt;/font&gt;。
4. 提交事务，在redo log中写入到commit记录。
</code></pre></li>
<li><p>两阶段提交<br>我们可以看到对于更新数据的操作，MySQL的处理逻辑是先将内存中的数据页更新，然后写入redolog(prepare阶段），写入binglog，redo log(commit阶段)<br><a href="https://imgchr.com/i/ZhzEQA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhzEQA.md.jpg" alt="ZhzEQA.md.jpg"></a></p>
<p>在两阶段不同时刻宕机，会发生什么情况？<br>innodb发现redolog中没有commit，就会拿着XA号去binlog中寻找是否存在</p>
<ul>
<li>在时刻A宕机，此时是不存在的，所以事务回滚。</li>
<li>在时刻B宕机，此时Binlog中存在该XA号，所以会恢复该事务。</li>
</ul>
</li>
<li><p>MVCC(多版本并发控制）<br>事务在开启的时候会获取一个一致性快照，每个事务都有一个唯一的事务ID，叫做transaction ID。<br>每行数据也有多个版本，每次事务更新数据的时候都会生成一个新的数据版本，并且将transaction ID赋值给这个数据版本的事务ID。<br>图中的虚线代表的就是undo log,V1、V2、V3并不物理真实存在，需要获取V2则需要从V4依次应用U3、U2。<br>一个数据版本，对于一个事务视图来说，除了自己更新的总是可见以外：</p>
<ol>
<li>版本未提交，不可见</li>
<li>版本已提交，但是是在视图创建后提交的，不可见</li>
<li>版本已提交，而且是在视图创建前提交的，可见<br><a href="https://imgchr.com/i/Zhzuo8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/Zhzuo8.md.jpg" alt="Zhzuo8.md.jpg"></a></li>
</ol>
</li>
<li><p>自适应哈希</p>
</li>
<li>异步IO</li>
<li>刷新临近页</li>
<li>组提交<h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3></li>
</ul>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL体系结构]]></title>
      <url>/2019/03/02/MySQL/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h1><p><a href="https://imgchr.com/i/ZhxoZV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhxoZV.md.jpg" alt="ZhxoZV.md.jpg"></a></p>
<ul>
<li>连接器<br>连接器负责跟客户端建立连接、获取权限、维持和管理连接。<br>在这个阶段，连接器会对用户输入的账号密码进行判断。并判断用户连接和数据库连接是否都到了最大限制。以及后续对超时连接进行清理操作。<ol>
<li>在连接之前，不管用户名密码是够正确，权限如何，连接器会先对连接数进行检查。</li>
<li>权限会存在两份，一份在数据库中持久化存储，一份保存在内存当中。flush privileges操作就是将内存中的信息给清空，并从数据库中重新加载到内存中。</li>
<li>在执行grant和revoke操作时，会先将磁盘中的信息修改，然后同步到内存中。但是如果是直接修改的mysql.user表，此时不会主动去更新内存。</li>
<li>连接器只会到内存中读取用户信息以及权限。连接器只会在进行连接的时候才对用户账号密码进行校验，这意味着，如果一个用户已经连接上，修改密码并不会影响此连接。</li>
<li>对于全局权限是实时从内存中获取，这代表如果进行权限修改会马上生效。但是对库的权限修改稍微有点区别，虽然也是实时同步到内存，但是如果该连接已经使用了use database进入某库，那么该连接会将该库的权限保存到当前会话变量中，对该库操作权限仍是进入时的状态。</li>
</ol>
</li>
<li>缓存器<br>缓存器会将之前执行过的语句以key-value的形式缓存在内存当中，key是执行的语句,value是该语句执行的结果。如果能够直接获取到，那么会将结果直接返回。（返回结果前还会进行一次权限校验）<br>但是，如果对该表存在更新等数据修改操作，那么这个表上所有的缓存将会清空以保证读取数据的一致性。</li>
<li>分析器<br>对sql进行词法和语法分析，此时会生成一颗解析树。此时会将sql语句转化成数据库能够看懂的形式，如将字符串’T’识别成’表名T’。此时会去读取库表结构，判断该表是否存在，该字段是够存在。</li>
<li>优化器<br>根据自身的信息采集、以往执行计划分析等选择自认为最优的执行计划、选择相应的索引。<br>MySQL有一整套规则来判断SQL语句的最优方案，但是该方案不一定是最快的。<br>可以人为的对优化器进行控制，使其选择相应的方案。如force index/ignore index/STRAIGHT_JOIN等。</li>
<li>执行器<br>根据优化器生成的执行计划来调用存储引擎的接口获取数据并对数据进行处理返回给客户端。</li>
<li>存储引擎</li>
</ul>
<h1 id="MySQL内存结构"><a href="#MySQL内存结构" class="headerlink" title="MySQL内存结构"></a>MySQL内存结构</h1><p><a href="https://imgchr.com/i/ZhxTaT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/07/13/ZhxTaT.md.jpg" alt="ZhxTaT.md.jpg"></a></p>
<h2 id="全局内存"><a href="#全局内存" class="headerlink" title="全局内存"></a>全局内存</h2><ul>
<li>innodb_buffer_pool_size  innodb缓冲池大小</li>
<li>innodb_log_buffer_size   redo日志缓冲</li>
<li>key_buffer_size          MyISAM索引缓冲</li>
<li>table_definition_cache   表定义文件描述缓存</li>
<li>table_open_cache         表空间文件描述缓存</li>
<li>max_heap_table_size      memory、heap表的最大容量</li>
</ul>
<h2 id="线程内存"><a href="#线程内存" class="headerlink" title="线程内存"></a>线程内存</h2><ul>
<li>read_buffer_size</li>
<li>read_rnd_buffer_size</li>
<li>sort_buffer_size</li>
<li>join_buffer_size</li>
<li>binlog_cache_size</li>
<li>tmp_table_size</li>
<li>thread_stack</li>
<li>thread_chche_size</li>
<li>net_buffer_length</li>
</ul>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis的内存管理和优化]]></title>
      <url>/2019/01/25/new/Redis/Redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>Redis中的内存使用主要是数据使用内存+客户端连接使用内存+内存碎片。<br>其中数据内存占用的最多，优化的常用手段是合理的控制对象的生命周期以及正确的使用数据结构。客户端使用内存主要包含输出缓冲区等一些数据传输缓存。</p>
<h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><p>只有熟悉的了解数据结构的组成、特性、性能、边界条件等因素后，我们还能更好的分析该数据结构的使用场景和资源消耗情况。</p>
<p>在Redis当中，所有的对象都是通过（redisObject+具体的对象）形式存在的，所有的对象都被封装在redisObject中，redisObject有五个成员：对象类型（type）、底层编码（encoding)、lru（最近访问时间）、refcount（引用数）、*ptr（指向具体对象的指针）。该结构一共会占用16字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<p>Redis一共有五种基本类型（其他的特殊类型都是此基础上形成的）string、list、hash、set、zset。<br><a href="https://imgchr.com/i/V7Jart" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7Jart.md.jpg" alt="V7Jart.md.jpg"></a></p>
<p>每一种数据类型在底层的存储实现存在多种选择，根据实际情况选择合适的编码类型。在效率和资源之间做出合适的权衡。<br><a href="https://imgchr.com/i/V7JtxA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JtxA.md.jpg" alt="V7JtxA.md.jpg"></a></p>
<a id="more"></a>
<h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>String类型是redis中使用最为广泛的一个类型，所有的key都是字符串类型；它使用的是redis自己设计的SDS结构：包含len、free以及字符串数组。可以O(1)获取字符串长度和空闲空间。<br>通过buf数组存储数据可以保证二进制安全，以及SDS的预分配机制可以避免频繁的进行数组扩容行为。<br>在创建的字符串长度小于等于39（3.2版本后为44）的时候，Redis会使用embstr编码来存储字符串；在这种编码下，只会进行一次内存分配，会把redisObject和sds一起分配；所以embstr编码的字符串是不能改变的，如果对该字符串进行修改，则该编码会直接变成raw。<br>此外，如果是整型字符串的话，String会使用int格式，直接将整数的值赋值给指针对象。这样就省去了sds的开销。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    int len;</span><br><span class="line">    int free;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://imgchr.com/i/V7JY2d" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JY2d.md.jpg" alt="V7JY2d.md.jpg"></a></p>
<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>压缩列表是将所有的元素紧凑的连接在一起，相当于把所有的成员都叠在一起，没有额外的数据结构，空间占用比较小。缺点就是在读写的时候需要修改整个压缩列表，所以在数据量比较小的时候才使用，一般能够达到5-10倍的压缩比。</p>
<ul>
<li>ziplist：记录了整个压缩列表所占用的内存直接数</li>
<li>ziplist：记录压缩表尾节点举例压缩列表起始地址的字节偏移量，通过这个偏移量可以直接确定表尾节点的地址</li>
<li>zllen：记录了压缩列表包含的节点数量</li>
<li>entryX：节点列表，压缩列表包含的各个节点，里面记录了前一个节点的长度、本节点的长度、编码等信息。可以方便的实现逆序遍历。</li>
<li>zlend：特殊值，用于标记压缩列表的末尾。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zlentry &#123;</span><br><span class="line">    unsigned int prevrawlensize, prevrawlen;</span><br><span class="line">    unsigned int lensize, len;</span><br><span class="line">    unsigned int headersize;</span><br><span class="line">    unsigned char encoding;</span><br><span class="line">    unsigned char *p;</span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://imgchr.com/i/V7JJ8H" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JJ8H.md.jpg" alt="V7JJ8H.md.jpg"></a></p>
<h2 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h2><p>在Redis启动的时候，就直接创建了10000个redisObject，代表1-10000的整型，这些整型会一直保存在内存当中，当其他对象需要用到时，就会共享使用这些整型。这也意味着这些整型LRU成员没有用，后续不会有其他的一些开销。</p>
<h2 id="键值对管理"><a href="#键值对管理" class="headerlink" title="键值对管理"></a>键值对管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    dict *dict;                 /* The keyspace for this DB */</span><br><span class="line">    dict *expires;              /* Timeout of keys with a timeout set */</span><br><span class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */</span><br><span class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</span><br><span class="line">    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */</span><br><span class="line">    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */</span><br><span class="line">    int id;                     /* Database ID */</span><br><span class="line">    long long avg_ttl;          /* Average TTL, just for stats */</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<p>在redis当中使用redisDb表示一个数据库结构，单个redis可以设置16个这样的DB；通过select命令进行选择，不同DB之间互不影响。</p>
<h3 id="过期Key清理"><a href="#过期Key清理" class="headerlink" title="过期Key清理"></a>过期Key清理</h3><p>通过一个dict结构(dict)来存储具体键值对对象；一个dict结构(expires)来记录redis中设置了过期时间的键值对，这个结构会复用dict中的Key、Value对象，所以并不会造成额外的内存开销。</p>
<p>在Key过期的时候，redis会自动执行一个del操作对过期的Key进行清理操作。这个行为并不是立即去执行的，而是会在几个条件下触发。一般只会在必要或者CPU空闲的时候做过期清理动作；如访问Key的时候、事件循环结束进入事件侦听前、后台定期任务。</p>
<p>Redis后台清理任务默认1s执行10次，也就是100ms一次。相当于如果没有其他操作，全部用来做后台任务的话，一次后台任务可以执行100ms；其中最高25%的时间用来删除过期Key的操作，即100ms中有25ms可以用来做Key清理。其他时间用来做Redis管理的任务。</p>
<p>过期Key清理算法：</p>
<ol>
<li>依次遍历所有的DB</li>
<li>从DB中随机取20个键值对，判断是否过期，如果过期，则删除。</li>
<li>如果取出的键值对中有大于5个过期，则重复上一步；否则遍历下一个DB</li>
<li>在清理过程中，如果达到了时间限制，退出清理过程。</li>
</ol>
<p>//TODO<br>redis的过期Key清理是在redis.c/activeExpireCycle()函数实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">void activeExpireCycle(int type) &#123;</span><br><span class="line">    /* This function has some global state in order to continue the work</span><br><span class="line">     * incrementally across calls. */</span><br><span class="line">    // 静态变量，用来累积函数连续执行时的数据</span><br><span class="line">    static unsigned int current_db = 0; /* Last DB tested. */</span><br><span class="line">    static int timelimit_exit = 0;      /* Time limit hit in previous call? */</span><br><span class="line">    static long long last_fast_cycle = 0; /* When last fast cycle ran. */</span><br><span class="line"></span><br><span class="line">    unsigned int j, iteration = 0;</span><br><span class="line">    // 默认每次处理的数据库数量</span><br><span class="line">    unsigned int dbs_per_call = REDIS_DBCRON_DBS_PER_CALL;</span><br><span class="line">    // 函数开始的时间</span><br><span class="line">    long long start = ustime(), timelimit;</span><br><span class="line"></span><br><span class="line">    // 快速模式</span><br><span class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        /* Don&apos;t start a fast cycle if the previous cycle did not exited</span><br><span class="line">         * for time limt. Also don&apos;t repeat a fast cycle for the same period</span><br><span class="line">         * as the fast cycle total duration itself. */</span><br><span class="line">        // 如果上次函数没有触发 timelimit_exit ，那么不执行处理</span><br><span class="line">        if (!timelimit_exit) return;</span><br><span class="line">        // 如果距离上次执行未够一定时间，那么不执行处理</span><br><span class="line">        if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;</span><br><span class="line">        // 运行到这里，说明执行快速处理，记录当前时间</span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We usually should test REDIS_DBCRON_DBS_PER_CALL per iteration, with</span><br><span class="line">     * two exceptions:</span><br><span class="line">     *</span><br><span class="line">     * 一般情况下，函数只处理 REDIS_DBCRON_DBS_PER_CALL 个数据库，</span><br><span class="line">     * 除非：</span><br><span class="line">     *</span><br><span class="line">     * 1) Don&apos;t test more DBs than we have.</span><br><span class="line">     *    当前数据库的数量小于 REDIS_DBCRON_DBS_PER_CALL</span><br><span class="line">     * 2) If last time we hit the time limit, we want to scan all DBs</span><br><span class="line">     * in this iteration, as there is work to do in some DB and we don&apos;t want</span><br><span class="line">     * expired keys to use memory for too much time. </span><br><span class="line">     *     如果上次处理遇到了时间上限，那么这次需要对所有数据库进行扫描，</span><br><span class="line">     *     这可以避免过多的过期键占用空间</span><br><span class="line">     */</span><br><span class="line">    if (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line"></span><br><span class="line">    /* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time</span><br><span class="line">     * per iteration. Since this function gets called with a frequency of</span><br><span class="line">     * server.hz times per second, the following is the max amount of</span><br><span class="line">     * microseconds we can spend in this function. */</span><br><span class="line">    // 函数处理的微秒时间上限</span><br><span class="line">    // ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 默认为 25 ，也即是 25 % 的 CPU 时间</span><br><span class="line">    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;</span><br><span class="line">    timelimit_exit = 0;</span><br><span class="line">    if (timelimit &lt;= 0) timelimit = 1;</span><br><span class="line"></span><br><span class="line">    // 如果是运行在快速模式之下</span><br><span class="line">    // 那么最多只能运行 FAST_DURATION 微秒 </span><br><span class="line">    // 默认值为 1000 （微秒）</span><br><span class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */</span><br><span class="line"></span><br><span class="line">    // 遍历数据库</span><br><span class="line">    for (j = 0; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">        int expired;</span><br><span class="line">        // 指向要处理的数据库</span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"></span><br><span class="line">        /* Increment the DB now so we are sure if we run out of time</span><br><span class="line">         * in the current DB we&apos;ll restart from the next. This allows to</span><br><span class="line">         * distribute the time evenly across DBs. */</span><br><span class="line">        // 为 DB 计数器加一，如果进入 do 循环之后因为超时而跳出</span><br><span class="line">        // 那么下次会直接从下个 DB 开始处理</span><br><span class="line">        current_db++;</span><br><span class="line"></span><br><span class="line">        /* Continue to expire if at the end of the cycle more than 25%</span><br><span class="line">         * of the keys were expired. */</span><br><span class="line">        do &#123;</span><br><span class="line">            unsigned long num, slots;</span><br><span class="line">            long long now, ttl_sum;</span><br><span class="line">            int ttl_samples;</span><br><span class="line"></span><br><span class="line">            /* If there is nothing to expire try next DB ASAP. */</span><br><span class="line">            // 获取数据库中带过期时间的键的数量</span><br><span class="line">            // 如果该数量为 0 ，直接跳过这个数据库</span><br><span class="line">            if ((num = dictSize(db-&gt;expires)) == 0) &#123;</span><br><span class="line">                db-&gt;avg_ttl = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取数据库中键值对的数量</span><br><span class="line">            slots = dictSlots(db-&gt;expires);</span><br><span class="line">            // 当前时间</span><br><span class="line">            now = mstime();</span><br><span class="line"></span><br><span class="line">            /* When there are less than 1% filled slots getting random</span><br><span class="line">             * keys is expensive, so stop here waiting for better times...</span><br><span class="line">             * The dictionary will be resized asap. */</span><br><span class="line">            // 这个数据库的使用率低于 1% ，扫描起来太费力了（大部分都会 MISS）</span><br><span class="line">            // 跳过，等待字典收缩程序运行</span><br><span class="line">            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*100/slots &lt; 1)) break;</span><br><span class="line"></span><br><span class="line">            /* The main collection cycle. Sample random keys among keys</span><br><span class="line">             * with an expire set, checking for expired ones. </span><br><span class="line">             *</span><br><span class="line">             * 样本计数器</span><br><span class="line">             */</span><br><span class="line">            // 已处理过期键计数器</span><br><span class="line">            expired = 0;</span><br><span class="line">            // 键的总 TTL 计数器</span><br><span class="line">            ttl_sum = 0;</span><br><span class="line">            // 总共处理的键计数器</span><br><span class="line">            ttl_samples = 0;</span><br><span class="line"></span><br><span class="line">            // 每次最多只能检查 LOOKUPS_PER_LOOP 个键</span><br><span class="line">            if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line"></span><br><span class="line">            // 开始遍历数据库</span><br><span class="line">            while (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                long long ttl;</span><br><span class="line"></span><br><span class="line">                // 从 expires 中随机取出一个带过期时间的键</span><br><span class="line">                if ((de = dictGetRandomKey(db-&gt;expires)) == NULL) break;</span><br><span class="line">                // 计算 TTL</span><br><span class="line">                ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                // 如果键已经过期，那么删除它，并将 expired 计数器增一</span><br><span class="line">                if (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                if (ttl &lt; 0) ttl = 0;</span><br><span class="line">                // 累积键的 TTL</span><br><span class="line">                ttl_sum += ttl;</span><br><span class="line">                // 累积处理键的个数</span><br><span class="line">                ttl_samples++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* Update the average TTL stats for this database. */</span><br><span class="line">            // 为这个数据库更新平均 TTL 统计数据</span><br><span class="line">            if (ttl_samples) &#123;</span><br><span class="line">                // 计算当前平均值</span><br><span class="line">                long long avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line">                </span><br><span class="line">                // 如果这是第一次设置数据库平均 TTL ，那么进行初始化</span><br><span class="line">                if (db-&gt;avg_ttl == 0) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                /* Smooth the value averaging with the previous one. */</span><br><span class="line">                // 取数据库的上次平均 TTL 和今次平均 TTL 的平均值</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl+avg_ttl)/2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* We can&apos;t block forever here even if there are many keys to</span><br><span class="line">             * expire. So after a given amount of milliseconds return to the</span><br><span class="line">             * caller waiting for the other active expire cycle. */</span><br><span class="line">            // 我们不能用太长时间处理过期键，</span><br><span class="line">            // 所以这个函数执行一定时间之后就要返回</span><br><span class="line"></span><br><span class="line">            // 更新遍历次数</span><br><span class="line">            iteration++;</span><br><span class="line"></span><br><span class="line">            // 每遍历 16 次执行一次</span><br><span class="line">            if ((iteration &amp; 0xf) == 0 &amp;&amp; /* check once every 16 iterations. */</span><br><span class="line">                (ustime()-start) &gt; timelimit)</span><br><span class="line">            &#123;</span><br><span class="line">                // 如果遍历次数正好是 16 的倍数</span><br><span class="line">                // 并且遍历的时间超过了 timelimit</span><br><span class="line">                // 那么断开 timelimit_exit</span><br><span class="line">                timelimit_exit = 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 已经超时了，返回</span><br><span class="line">            if (timelimit_exit) return;</span><br><span class="line"></span><br><span class="line">            /* We don&apos;t repeat the cycle if there are less than 25% of keys</span><br><span class="line">             * found expired in the current DB. */</span><br><span class="line">            // 如果已删除的过期键占当前总数据库带过期时间的键数量的 25 %</span><br><span class="line">            // 那么不再遍历</span><br><span class="line">        &#125; while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设想在一个大型的Redis实例中所有的Key在同一时间过期了会出现什么样的结果？</p>
<p>答案就是：会导致线上读写请求出现明显的卡顿现象。<br>首先，Redis会持续扫描过期字典（多次循环），直到过期字典中的Key变得稀疏才会减缓清理的节奏。另外一个原因就是内存管理器需要频繁的回收内存页，会产生一定的CPU消耗。</p>
<p>当客户端请求到来时，服务器如果正好过期扫描，客户端的请求将会等待至少25ms后才会进行处理，如果客户端将超时时间设置的比较短，比如10ms，那么就会出现大量的链接因为超时而关闭，业务端就会出现很多异常。<br>并且这时还无法从Redis的slowlog中看到慢查询记录，因为慢查询指的是逻辑处理过程慢，不包含等待时间。</p>
<p>所以业务开发人员一定要注意过期时间，如果有大批量的key过期，要给过期时间设置一个随机范围，分散过期处理的压力。</p>
<p>##淘汰机制<br>实例的内存是有上限的，当使用的内存超过了允许的最大内存时，Redis会按照设定的淘汰策略清理内存，以保证实例的正常运行。</p>
<ul>
<li>volatile-lru：从<strong>已设置过期时间</strong>的数据中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从<strong>已设置过期时间</strong>的数据中挑选将要过期的数据淘汰</li>
<li>volatile-random：从<strong>已设置过期时间</strong>的数据集中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集中任意选择数据淘汰</li>
<li>no-enviction：禁止淘汰数据</li>
</ul>
<p>淘汰算法：</p>
<ol>
<li>遍历所有DB</li>
<li>按照设置的淘汰策略挑选一个Key进行淘汰</li>
<li>若策略是lru或ttl，采用近似算法随机取n个样本(默认为5，可配置)，从中挑选出最佳值进行淘汰</li>
<li>计算内存是否超过允许值，若是，重复1~3</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>最佳实践就是平时遇到的一些好案例，或者从前面的原理导出的一些结论。首先，最重要的就是选择正确的数据类型，主要以满足业务，性能和场景为优先考虑。一般数据量不大的业务，没必要花太大的精力；但是对于一些主要业务，就需要做比较细致的优化。如String类型对象可以考虑使用整数，浮点型可以改成整数。对于数据量比较大，比较重要的业务，可以深入优化，根据业务场景对字符串类型进行合理的拆分，以符合使用压缩列表的(可以适当的对压缩列表的转换条件进行放宽)。</p>
<p><a href="https://imgchr.com/i/V7JUKI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V7JUKI.md.jpg" alt="V7JUKI.md.jpg"></a><br>这是官网上的一个例子，在4存Key-Value的时候，以object后面加一个整数作为ID，整个数据库可能都是这种类型，数据量又特别大，想对它优化的时候，比较通用的优化方法就是取模，相同前缀的Key单独做hash。整个db空间相当于一个大的哈希表，这样就把本来分配给整个db空间的Key，按照不同的前缀分成小的哈希表，每个哈希表里面保证数据比较小，那这个哈希表就会用压缩列表来保存。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Binlog格式]]></title>
      <url>/2019/01/23/MySQL/Binlog%E6%A0%BC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="Binlog日志格式"><a href="#Binlog日志格式" class="headerlink" title="Binlog日志格式"></a>Binlog日志格式</h1><p>binlog_format是规定binlog日志文件记录语句方式的参数，可以动态修改，支持session和global级别，可选项有row、statement、mixed。</p>
<ul>
<li>row：以修改前后的数据信息，能够清晰的展现出数据变更，便于解析binlog文件后开发闪回功能。缺点是会产生大量的日志，在某些情况下会占用大量的IO资源。</li>
<li>statement：语句格式；仅记录执行的语句，在特定情况下会可能会导致数据的不一致；优点很明显，减少了binlog日志量，减少IO。</li>
<li>mixed：以上两种模式的混合使用，一般情况下使用statement保存，在可能会导致数据不一致的情况使用row保存</li>
</ul>
<a id="more"></a>
<h2 id="row格式"><a href="#row格式" class="headerlink" title="row格式"></a>row格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># at 860</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 925 CRC32 0x1fcb13d6  GTID    last_committed=2        sequence_number=3</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;a81311dd-448f-11e9-be56-06d4d400045d:113&apos;/*!*/;</span><br><span class="line"># at 925</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 996 CRC32 0x106b145e  Query   thread_id=210   exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1555398441/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 996</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1055 CRC32 0x2920f8d2         Rows_query</span><br><span class="line"># update t set age = 24 where id = 15</span><br><span class="line"># at 1055</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1102 CRC32 0x07a1009c         Table_map: `hoo`.`t` mapped to number 223</span><br><span class="line"># at 1102</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1162 CRC32 0xef28b2a8         Update_rows: table id 223 flags: STMT_END_F</span><br><span class="line">### UPDATE `hoo`.`t`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=15 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&apos;xx&apos; /* VARSTRING(40) meta=40 nullable=1 is_null=0 */</span><br><span class="line">###   @3=22 /* INT meta=0 nullable=1 is_null=0 */</span><br><span class="line">### SET</span><br><span class="line">###   @1=15 /* INT meta=0 nullable=0 is_null=0 */</span><br><span class="line">###   @2=&apos;xx&apos; /* VARSTRING(40) meta=40 nullable=1 is_null=0 */</span><br><span class="line">###   @3=24 /* INT meta=0 nullable=1 is_null=0 */</span><br><span class="line"># at 1162</span><br><span class="line">#190416 15:07:21 server id 219235804  end_log_pos 1193 CRC32 0x90bc6f89         Xid = 2975</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;AUTOMATIC&apos; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure>
<p>在执行正式的SQL语句前会先去执行SET @@SESSION.GTID_NEXT和SET TIMESTAMP两个命令。这意味着即使事务回滚，他所申请的gtid也不会再被复用。</p>
<p>我们可以看到binlog文件中专门有一段(Update_rows)用来记录受影响的行在修改前后的记录。</p>
<p>此外，row格式的binlog记录还会受另一个参数的影响：binlog_row_image；<br>binlog_row_image是5.6版本出现的参数，控制在binlog_format=row情况下的binlog日志记录格式；可选项有full、minimal、noblob，默认值是full，可以动态修改，支持session和global级别。</p>
<ul>
<li>full：记录所有列的信息</li>
<li>minimal：仅仅记录被更改以及能够唯一识别数据行的列值（如：主键列）</li>
<li>noblob：记录所有的列值信息，但是BLOB和TEXT列除外（如未修改）</li>
</ul>
<h2 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># at 1193</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1258 CRC32 0x518fd71a         GTID    last_committed=3        sequence_number=4</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;a81311dd-448f-11e9-be56-06d4d400045d:114&apos;/*!*/;</span><br><span class="line"># at 1258</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1335 CRC32 0xc276a08b         Query   thread_id=210   exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1555398636/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 1335</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1442 CRC32 0xf4c40dce         Query   thread_id=210   exec_time=0     error_code=0</span><br><span class="line">use `hoo`/*!*/;</span><br><span class="line">SET TIMESTAMP=1555398636/*!*/;</span><br><span class="line">update t set age = 24 where id = 14</span><br><span class="line">/*!*/;</span><br><span class="line"># at 1442</span><br><span class="line">#190416 15:10:36 server id 219235804  end_log_pos 1473 CRC32 0xdf3eeac5         Xid = 2978</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &apos;AUTOMATIC&apos; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>我们看到在statement格式下，binlog记录了库名、事务开启时的时间戳、具体执行的语句。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[当执行-single-transaction做逻辑备份时，遇到DDL]]></title>
      <url>/2019/01/22/MySQL/mysqldump%E9%81%87%E5%88%B0DDL/</url>
      <content type="html"><![CDATA[<p>当使用-single-transaction做逻辑备份的时候，遇到一个DDL语句会怎样？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；</span><br><span class="line">/* other tables */</span><br><span class="line">Q3:SAVEPOINT sp;</span><br><span class="line">/* 时刻 1 */</span><br><span class="line">Q4:show create table `t1`;</span><br><span class="line">/* 时刻 2 */</span><br><span class="line">Q5:SELECT * FROM `t1`;</span><br><span class="line">/* 时刻 3 */</span><br><span class="line">Q6:ROLLBACK TO SAVEPOINT sp;</span><br><span class="line">/* 时刻 4 */</span><br><span class="line">/* other tables */</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在备份开始的时候，为了确保RR隔离级别，再设置一次RR隔离级别（Q1）</p>
<p>启动事务，使用WITH CONSISTENT SNAPSHOP确保语句执行完得到一个一致性视图（Q2）</p>
<p>设置一个保存点，这个很重要（Q3）</p>
<p>show create是为了拿到表结构（Q4），然后正式导数据（Q5），回滚到SAVEPOINT sp，作用是释放t1的MDL锁。</p>
<p>按照DDL执行的时间不同，效果不同。</p>
<ol>
<li>如果在Q4语句执行之前到达，现象：没有影响，备份拿到的是DDL后的表结构。</li>
<li>如果在“时刻2”到达，则表结构被改过，Q5执行的时候，报Table definition has changed，please retry transaction，现象：mysqldump终止。</li>
<li>如果在“时刻2”和“时刻3”之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，现象：主从延迟，知道Q6执行完成。</li>
<li>从“时刻4”开始，mysqldump释放MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MYSQL45讲 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[索引]]></title>
      <url>/2019/01/21/MySQL/%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<font color="red">索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</font>

<h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>索引的出现时为了提高查询效率，但是实现索引的方式有很多种，所以这里也就引入了索引模型的概念。可以用来提高读写操作的数据结构有很多，这里先介绍比较简单的数据结构：哈希表和搜索树。</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表是一种以K-V存储的数据结构，我们只要输入待查找的值，就可以找到其对应的值。哈希的思路很简单，把值放在数组里，用一个哈希函数把Key换算成一个确认的位置，然后把value放在数组的这个位置。遇到同一个位置上有很多value时，就用一个链表串起来。</p>
<p>哈希链表适用于只有等值查询的场景</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。查询的平均复杂度是O(log(N))。<br><a id="more"></a></p>
<h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>在InnoDB中，表都是根据主键的顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB使用B+树索引模型。每一个索引再InnoDB里面对应一颗B+树。</p>
<p>假设我们有一个主键列为ID的表，表中有字段k，并且k上有索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure></p>
<p>表中R1~R5的（ID、k）值分别为（100，1）、（200，2）、（300，3）、（500，5）、（600、6）<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/Ei9YpCJeczWr9VO8*BgWLIHjUz30q5UyxUldf8Sp*g4!/b/dL4AAAAAAAAA&amp;bo=WgXyAwAAAAADB4w!&amp;rf=viewer_4" alt=""><br>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。<br>主键索引的叶子节点存的是整行数据。非主键索引的叶子节点的内容是主键的值。<br>1、如果语句是select <em> from T where ID=500，即主键查询方式，则只需要搜索ID这颗B+树；<br>2、如果语句是select </em> from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID值为500，再到ID索引树搜索一次。这个过程称为回表。</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+树为了维护索引的有序性，在插入新值得时候需要做必要的维护。<br>插入：</p>
<ul>
<li>当叶子节点未满时，将记录插入对应的叶子节点。</li>
<li>当叶子节点已满，索引页未满时；拆分中间的节点放入索引页，小于中间节点的放在左边节点，大于等于中间节点的放右边</li>
<li>当叶子页已满，索引页已满时；逐层拆分，直到所有节点都满足</li>
<li>当叶子节点的兄弟页未满，索引页已满时；不急于拆分节点，而是做旋转操作，减少页的拆分。<br>删除：<br>B+树使用填充因子来控制树的删除变化，填充因子是指数据填充的百分比。</li>
<li>当删除节点后，对应的叶子页大于填充因子时；直接删除节点，不做合并页操作。</li>
<li>当删除节点后，对应的叶子页大于填充因子，但是该节点也是索引节点；直接删除节点，将右边节点更新到对应的索引页。</li>
<li>当删除节点后，对应的叶子页小于填充因子时；合并页节点及其兄弟页节点。</li>
<li>当删除节点后，对应的叶子页小于填充因子，该节点也是索引节点；合并页节点及其兄弟页节点，更新索引页。</li>
<li>当删除节点后，该节点也是索引节点，并且删除该节点索引页也小于填充因子。逐层合并，直到满足条件。</li>
</ul>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果需要查询的值已经在非主键索引中可以完全获取，那么就可以不需要再去主键索引中进行回表操作了。<br><b>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</b></p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>B+树这种索引结构，可以利用索引的”最左前缀”来定位记录。<br>为了直观的说明这个概念，我们用（name，age）这个联合索引来分析。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/jMYONpHYjMYo6BaqToUtBg8my7ZjOad9c32kC9kHzN4!/b/dLgAAAAAAAAA&amp;bo=VAW6AwAAAAADB8o!&amp;rf=viewer_4" alt=""><br>可以看到，索引项是按照索引里面定义出现的先后顺序排序的。<br>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p>
<p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MySQL45讲 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[事务隔离]]></title>
      <url>/2019/01/16/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
      <content type="html"><![CDATA[<p>简单来说：事务就是保证一组数据库操作，要么全部成功，要么全部是失败。在MySQL中，事务支持是在引擎层实现的。MySQL是一个支持多引擎的系统，并不是所有的引擎都支持事务。比如MySQL原生的MyISAM引擎就不支持事务。</p>
<h3 id="隔离性和隔离级别"><a href="#隔离性和隔离级别" class="headerlink" title="隔离性和隔离级别"></a>隔离性和隔离级别</h3><p>提到事务，肯定会想到ACID（即原子性、一致性、隔离性、持久性），这里就讨论一下隔离性。<br>当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<ul>
<li>读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读已提交：一个事务提交后，它做的变更才会被其他事务看到</li>
<li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li>
<li>串行化：后访问的事务必须等前一个事务完成后，才能继续执行。</li>
</ul>
<p>假设数据表T中只有一列，其中一行的值为1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://m.qpic.cn/psb?/V140pON30woojR/N34*jAP61rjm0uHLDCigAi2GlkgbvdMqoW4J9gqGBok!/b/dL8AAAAAAAAA&amp;bo=OAT.BAAAAAADB.Q!&amp;rf=viewer_4" alt=""><br><a id="more"></a><br>我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图中的V1、V2、V3的返回值分别是什么。</p>
<ul>
<li>若隔离级别是“读未提交”，这V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此V2、V3也都是2。</li>
<li>若隔离级别是“读提交”，这V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以，V3的值也是2。</li>
<li>若隔离级别是“可重复读”，则V1、V2是1，V3是2.之所以V2是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li>
<li>若隔离级别是“串行化”。则在事务B执行将1改成2的时候，就会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看，V1、V2、V3的值是2。</li>
</ul>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个事务是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接使用加锁的方式来避免并行访问。</p>
<p>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。</p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面都会有类似下面的记录：<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/pyWktvOA4ggEJYuVgTtFYnCH.Id5ReNQfprJmpwT1.8!/b/dMIAAAAAAAAA&amp;bo=TAVIAwAAAAADByA!&amp;rf=viewer_4" alt=""><br>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-riew。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有的回滚操作等到。</p>
<p>回滚日志不可能一直保留；在不需要的时候就会被删除，也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志就会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</p>
<p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p>
<p>长事务意味着系统会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在MySQL5.5以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何避免长事务的出现？<br><b>从开发端来看：</b></p>
<ol>
<li>确认是否使用了set autocommit=0。建议将这个值设置成1</li>
<li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用begin/commit框起来。</li>
<li>业务连接数据库的时候，根据业务本身的预估，通过set max_execution_time命令来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li>
</ol>
<p><b>从数据库端看：</b></p>
<ol>
<li>监控Information_schema.innodb_trx表，设置长事务阈值，超过就报警。</li>
<li>在业务功能测试阶段要求输出所欲的general_log，分析日志行为提前发现问题。</li>
<li>如果使用的是MySQL5.6或更新版本，把innodb_undo_tablespaces设置为2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MySQL实战45讲 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一条更新语句的执行过程]]></title>
      <url>/2019/01/14/MySQL/%E4%B8%80%E4%B8%AA%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>下面我们以下面这个表和更新语句来进行分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table T(ID int primary key, c int);</span><br><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p>
<p>对于更新语句，查询语句的那一套流程，更新语句同样是会走一遍。</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>如果每一次更新操作都要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新；整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL采用了WAL技术来提升更新效率。WAL的全称是write-Ahead Logging。它的关键点在于<font color="red">先写日志，再写磁盘</font>。</p>
<p>具体来说，就是当有一条记录需要更新的时候，innodb引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，innodb引擎会在适当的时候，将这个操作记录更新到次磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>innodb的redo log是固定大小的，比如可以配置为一组4个文件，每个文件大小是1GB，那么redo log总共就可以记录4GB的操作，从头开始写，写到末尾就又回到开头循环写。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/cO8DivjlNOs4*4J.jc9sWkTtPIM5APzdpDE8aPjQews!/b/dLYAAAAAAAAA&amp;bo=hAUyAwAAAAADB5I!&amp;rf=viewer_4" alt=""><br><a id="more"></a><br>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos和checkpoint之间的部分是用来记录新的操作。如果write pos追上checkpoint，那么表示redo log写满了，得先停下来擦掉一些记录，把checkpoint推进一点后才能够继续写入。</p>
<p>有了redo log，innodb就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称作crash-safe。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>MySQL从整体来说，其实有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。redo log是innodb引擎特有的日志，Server层也有自己的日志，称为binlog（归档日志）<br>最开始MySQL里并没有innodb引擎，MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而innodb是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力，所以innodb使用另一套日志系统（redo log）来实现crash-safe能力。</p>
<p>redo log 和 binlog主要有以下三点不同:</p>
<ol>
<li>redo log是innodb引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑。</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。</li>
</ol>
<p>我们回过头来看执行器和innodb引擎在执行这个简单的update语句时的内部流程。</p>
<ol>
<li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎的给的行数据，把这个值加上1，等到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。<br><img src="https://m.qpic.cn/psb?/V140pON30woojR/7vc6Wi5rjgpfIRIhIttNcrFLh7FmB1heWy5NCCPr8to!/b/dFIBAAAAAAAA&amp;bo=OASgBQAAAAADB7s!&amp;rf=viewer_4" alt=""><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3>binlog会记录所有的逻辑操作，并且采用的是“追加写”的形式。当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，可以这样做：</li>
</ol>
<ul>
<li>首先找到最近一次的全年备份</li>
<li>然后从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li>
<li>将表数据从临时库中取出来，按需要恢复到线上库去。</li>
</ul>
<p>说完数据恢复过程，我们来说说为什么日志需要“两阶段提交”。<br>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，那么就是先写完redo log再写binlog或者放过来。</p>
<ol>
<li><b>先写redo log后写binlog</b>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过，redo log写完后，系统及时崩溃，仍然能够将数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写就crash了，这时候binlog是没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要这个binlog恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0。造成了数据不一致。（主从情况也是一样的）</li>
<li><b>先写binlog后写 redo log</b>。如果binlog写完后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binglog里面已经记录了“把c从0改成1”这个日子。所以binlog恢复后就多了一个事务。</li>
</ol>
<p>可以看到，如果不使用两阶段提交，那么数据库的状态与应用它日子的其他数据库数据不一致。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>redo log用来宝成crash-safe能力，innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都会直接持久化到磁盘。<br>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MySQL实战45讲 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一条查询语句的执行过程]]></title>
      <url>/2019/01/13/MySQL/MySQL%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="MySQL基本架构"><a href="#MySQL基本架构" class="headerlink" title="MySQL基本架构"></a>MySQL基本架构</h2><p><img src="https://m.qpic.cn/psb?/V140pON30woojR/ussYTDB3vJmBbUYn8*kQP.aOU4fUXs6XhkExUtrBwWA!/b/dMMAAAAAAAAA&amp;bo=oAU4BAAAAAARB6k!&amp;rf=viewer_4" alt=""><br>MySQL基本架构可以分为Server层和存储引擎层两部分。</p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，覆盖MySQL大多数核心服务功能，以及<font color="red">所有的内置函数</font>（如日期、时间、数学等），所有的跨存储引擎的功能都在这一层实现，如存储过程、触发器、视图等。<br><a id="more"></a><br>下面以select * from T where ID=10；这条语句做讲解。</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器负责和客户端建立连接、获取权限、维持和管理连接。<br>使用mysql客户端工具来跟服务端进行建立连接。在完成经典的TCP握手后，连接器就要验证用户身份。</p>
<ul>
<li>如果用户名或密码不对，会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认真通过，连接器会到权限表里面查出你拥有的权限。在此连接后续过程中进行的权限判断逻辑都依赖于此时读取到的权限。</li>
</ul>
<p>这意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限进行了修改，也不会影响到已经存在连接的权限。</p>
<p>连接完成后，如果没有后续动作，这个连接就处于空闲状态；如果处于空闲状态太久没有进行操作，连接器就会自动将它断开。如果在连接端口后，客户端再发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query。这时候会进行重连才能够执行请求了。</p>
<p>有时候会发现MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。但是由于长连接积累一直不释放，导致内存占用太大，被系统强行杀掉（OOM），从现象来看就是MySQL异常重启了。<br>怎么解决这个问题呢？</p>
<ol>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>如果使用的是MySQL5.7以上版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
</ol>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接建立完成后，就可以开始执行命令了。那么在进行查询语句时，会先到缓存中去查询缓存，之前是不是执行过这条语句。之前执行过的语句和结果可能会以键值对的形式被直接缓存在内存中。key是查询的语句，value是查询的结果。如果能够在缓存中找到查询的语句，那么就会直接返回value值给客户端。</p>
<p><b>但是大多数情况下，建议是不要使用查询缓存</b><br>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存就会被清空。对于更新压力大的数据库来说，查询缓存的命中率非常低。出给你的业务就是一张静态表，很长时间才更新一次。<br>你可以将参数query_cache_type设置为DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select SQL_CACHE * from T where ID=10;</span><br></pre></td></tr></table></figure></p>
<p>MySQL8.0版本直接将查询缓存的整块功能给删掉了。</p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果没有命中缓存，就要开始真正执行语句了。首先MySQL需要知道你要做什么，所以需要对SQL语句进行解析。</p>
<p>分析器先会做“词法解析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。<br>MySQL从输入的“select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。<br>做完识别后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，将会收到“you hava an error in your SQL syntax”的错处提醒。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL就知道你要做什么了。在正式开始执行前，还要经过优化器的处理。<br>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联的时候，决定各个表的连接顺序。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL知道了你要做什么，该怎么做后就开始执行了。<br>开始执行的时候，要先判断一下你对这个表T有没有执行权限，如果没有，就会返回没有权限的错误。<br>如果有权限，就打开表继续执行。打开表的时候，执行器会根据表的引擎定义，去使用这个引擎提供的接口。<br>比如我们例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<pre><code>1. 调用InnodDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中。
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，知道取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
</code></pre><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口。<br>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。<br>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描函数跟rows_examined并不是完全相同的。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果表中没有字段k，而执行select * from T where k=1;肯定会报“不存在列”错误，这个错误是在哪个阶段报出来的？<br>答案：分析器，MySQL设计受Oracle影响，会在分析判断语句是否正确，表是否存在，列是否存在。<br>《高性能MySQL》里提到解析器处理语法和解析查询，会生成一颗对应的解析树</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MySQL实战45讲 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次磁盘空间不足]]></title>
      <url>/2018/12/29/Linux/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%EF%BC%8C%E6%89%BE%E4%B8%8D%E5%88%B0%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>在一台虚拟机机器上发现磁盘空间不足的情况，通过登录上去查看，发现是挂载盘占用磁盘资源太多，通过df命令查看，但是并找不到具体是哪个文件占用过多。<br>通过以下查找大文件命令也没有找到相应的大文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size +100M</span><br></pre></td></tr></table></figure></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>文件被删除后，并没有及时的释放磁盘资源，导致磁盘空间不足的情况。<br>通过以下命令，查看已经标记为删除但是没有释放的文件。对相应程序进行重启后解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof|grep -i delete|less</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL问答]]></title>
      <url>/2018/11/29/MySQL/MySQL%E9%97%AE%E7%AD%94/</url>
      <content type="html"><![CDATA[<h2 id="导致主从不一致的原因"><a href="#导致主从不一致的原因" class="headerlink" title="导致主从不一致的原因"></a>导致主从不一致的原因</h2><ol>
<li>人为原因（从库写入）</li>
<li>主库异常宕机</li>
<li>设置了ignore/do/rewrite等replication等规则</li>
<li>binlog使用了非row格式</li>
<li>从库中断</li>
<li>从库启用了存储过程</li>
<li>主从数据库版本不一致</li>
<li>重做时，mysqldump备份没有指定参数</li>
<li>主从sql_mode不一致</li>
<li>采用5.6的after_commit方式半同步，主库宕机可能会引起主从不一致。</li>
<li>启用了增强半同步，但是从库延迟超时自动切换成了异步复制</li>
</ol>
<h3 id="预防和解决的方案"><a href="#预防和解决的方案" class="headerlink" title="预防和解决的方案"></a>预防和解决的方案</h3><ol>
<li>master:innodb_flush_log_at_trx_commit=1&amp;sync_binlog=1</li>
<li>slave:master_info_repository=”TABLE”&amp;relay_log_info_repository=”TABLE”&amp;relay_log_recovery=1</li>
<li>设置从库库为只读模式</li>
<li>可以使用5.7增强半同步避免数据丢失等</li>
<li>binlog row格式</li>
<li>必须引定期的数据校验机制</li>
<li>当使用延迟复制的时候，此时主从数据也是不一致的（计划内），但在切换中，不要把延迟从提升为主库哦~</li>
<li>mha在主从切换的过程中，因主库系统宕机，可能造成主从不一致（mha本身机制导致这个问题）</li>
</ol>
<a id="more"></a>
<h2 id="为什么决定使用分库分表"><a href="#为什么决定使用分库分表" class="headerlink" title="为什么决定使用分库分表"></a>为什么决定使用分库分表</h2><ol>
<li>根据业务类型和业务容量评估</li>
<li>当前数据库本身具有的能力、压力评估</li>
<li>数据库的物理隔离，如：减少锁的争夺，资源的消耗和隔离</li>
<li>热点表较多，并且数据量大，可能会引起锁增强，性能下降</li>
<li>数据库的高并发，数据库读写压力大，可能会导致数据库或启动宕机</li>
<li>数据库（5.7以下）连接数过高，会增加系统压力</li>
<li>单表数据量大，如SQL使用不当，导致IO随机读写比例高；查询慢</li>
<li>备份和恢复时间比较长</li>
</ol>
<h3 id="会有什么问题"><a href="#会有什么问题" class="headerlink" title="会有什么问题"></a>会有什么问题</h3><ol>
<li>全局pk（主键和唯一索引）的冲突检测不准确，全局的自增主键支持不够好</li>
<li>分片键的选择</li>
<li>分布式事务</li>
<li>开发方面：需要进行业务的拆分。部分SQL不兼容。跨库查询、join。</li>
</ol>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ol>
<li>使用全局分号器。或者使用全局唯一id。</li>
<li>应用层来判断唯一索引</li>
<li>配合应用选择合适的分片键，并加上索引</li>
<li>配合应用，配合开发，对不兼容SQL进行整改</li>
</ol>
<h2 id="MySQL高可用架构应该考虑什么？"><a href="#MySQL高可用架构应该考虑什么？" class="headerlink" title="MySQL高可用架构应该考虑什么？"></a>MySQL高可用架构应该考虑什么？</h2><ol>
<li>对业务有一定了解，需要考虑业务对数据库一致性要求的敏感程度，切换过程中是否有事务丢失。</li>
<li>对于基础设施有一定了解，需要了解基础设施的高可用架构。</li>
<li>对于数据库故障时间掌握，业务方最多能容忍时间范围</li>
<li>需要了解主流的高可用的优缺点</li>
<li>考虑多机房多副本分布<h3 id="如何设计？"><a href="#如何设计？" class="headerlink" title="如何设计？"></a>如何设计？</h3></li>
<li>基础层和基础运维部门配合，了解和避免网络/硬盘/电源等是否会出现单点故障</li>
<li>应用层和开发配合，在关键日志中记录SQL日志，可以做到即使切换出现丢事务的情况，也可以通过手工补的方式保证数据一致性。</li>
<li>根据不同的应用制定合理的高可用策略</li>
<li>单机多实例</li>
<li>在数据库不可用，可以把已提交的事务先存储到队列或者其他位置，等数据库恢复，重新应用。</li>
</ol>
<h2 id="xtrabackup和mysqldump备份造成的锁等待"><a href="#xtrabackup和mysqldump备份造成的锁等待" class="headerlink" title="xtrabackup和mysqldump备份造成的锁等待"></a>xtrabackup和mysqldump备份造成的锁等待</h2><ol>
<li>xtrabackup在备份非innodb表时会有短暂的全局读锁FTWL</li>
<li>mysqldump获取一致性快照时会进行锁表</li>
<li>xtrabackup在备份时会在/tmp目录下生成一个临时文件，如果在备份过程中修改了/tmp的权限，这会造成xtrabackup hang住，正在备份的表不能正常释放锁，会造成锁等待。</li>
</ol>
<h2 id="为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？"><a href="#为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？" class="headerlink" title="为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？"></a>为什么说pt-osc可能会引起主从延迟，有什么好办法解决或规避吗？</h2><ol>
<li>若复制中binlog使用row格式，对大表使用ps-osc把数据从旧表拷贝到临时表，期间会产生大量的binlog，从而导致延时</li>
<li>pt-osc在搬数据过程中insert..select是有行锁的，会降低事务并行度；且pt-osc搬数据过程中生成的binlog不是并行的，所以在slave不能并行回放。</li>
<li>可以通过设定参数–chunk-size、–chunk-time控制每次拷贝数据大小，也可以设定–max-log、check-interval、check-slave-lag等参数控制主从复制延迟程度（但这样可能会造成pt-osc工作耗时太久，需要执行权衡）</li>
</ol>
<h2 id="哪些原因会造成MySQL异步复制延迟"><a href="#哪些原因会造成MySQL异步复制延迟" class="headerlink" title="哪些原因会造成MySQL异步复制延迟"></a>哪些原因会造成MySQL异步复制延迟</h2><ol>
<li>master上多为并发事务，slave上则多为单线程回放（5.7起，支持真正的并行回放）</li>
<li>异步复制，本身就是有一定的延迟</li>
<li>有时为了节省机器资源，会在slave上运行多个实例</li>
<li>表结构设计不合理</li>
<li>slave上运行了大量只读低效率的SQL</li>
<li>大量大事务，也会造成slave无法并行回放</li>
<li>业务设计缺陷，或网络延迟等</li>
</ol>
<h2 id="MySQL每天产生了多大容量的binlog，可以查到吗"><a href="#MySQL每天产生了多大容量的binlog，可以查到吗" class="headerlink" title="MySQL每天产生了多大容量的binlog，可以查到吗"></a>MySQL每天产生了多大容量的binlog，可以查到吗</h2><p>binlog并不会自动的每天切分统计，所以需要人为这执行flush binlog logs再结合系统层命令完成。</p>
<h2 id="明明有索引，但是执行的时候没有选中是什么原因？"><a href="#明明有索引，但是执行的时候没有选中是什么原因？" class="headerlink" title="明明有索引，但是执行的时候没有选中是什么原因？"></a>明明有索引，但是执行的时候没有选中是什么原因？</h2><ol>
<li>隐式转换</li>
<li>表碎片，表碎片率过高</li>
<li>根据索引读取到的数据在整个表中的数据占比超过30%</li>
<li>统计信息没有及时更新</li>
</ol>
<h2 id="主从复制正常，但是主从延迟过高是什么原因"><a href="#主从复制正常，但是主从延迟过高是什么原因" class="headerlink" title="主从复制正常，但是主从延迟过高是什么原因"></a>主从复制正常，但是主从延迟过高是什么原因</h2><ol>
<li>sync_relay_log值过低，导致slave频繁刷新relay_log文件，使slave硬盘资源消耗过高。</li>
<li>Master/Slave压力过大</li>
<li>网络丢包严重</li>
<li>Master和Slave网络链接已经断开，但是slave_net_timeout值等于0（表示完全禁用心跳）或者slave_net_timeout和Slave_heart_period非常大（表示检测主从心跳的时间）</li>
<li>Master的binlog非常大，io线程的file很长时间在读同一个。</li>
</ol>
<h2 id="MySQL-hang的原因有哪些？"><a href="#MySQL-hang的原因有哪些？" class="headerlink" title="MySQL hang的原因有哪些？"></a>MySQL hang的原因有哪些？</h2><ol>
<li>MySQL使用资源过高导致服务器太累扛不住。</li>
<li>磁盘无可用空间</li>
<li>MySQL频繁的创建和销毁连接。</li>
<li>MySQL使用的最大文件打开数和连接数，超过了操作系统的限制。</li>
<li>MySQL的锁不能有效的释放。例如持有行锁或者表锁，造成MDL等待。</li>
<li>MySQL的bug导致的</li>
</ol>
<h2 id="MySQL中如果发现乱码该怎么处理？"><a href="#MySQL中如果发现乱码该怎么处理？" class="headerlink" title="MySQL中如果发现乱码该怎么处理？"></a>MySQL中如果发现乱码该怎么处理？</h2><ol>
<li>直接修改法，alter或者pt-osc等工具直接对工具进行修改。</li>
<li>备份修改法，利用mysqldump等其他逻辑备份进行备份，备份的结果集再利用iconv进行转换。</li>
<li>跳过字符集备份，–skip-set-charset</li>
</ol>
<h2 id="MySQL的表中有唯一索引，设置unique-check为0时，能否写入重复值"><a href="#MySQL的表中有唯一索引，设置unique-check为0时，能否写入重复值" class="headerlink" title="MySQL的表中有唯一索引，设置unique_check为0时，能否写入重复值"></a>MySQL的表中有唯一索引，设置unique_check为0时，能否写入重复值</h2><p>首先，即便设置unique_checks=0，也无法往唯一索引中写入重复值。</p>
<p>其次，设置unique_checks=0的作用在于，批量导入数据（例如load data）时，在确保导入数据中无重复值时，无需再次检查其唯一性，加快导入速度。</p>
<p>所以，unique_checks=0并不是允许唯一约束失效，而是再批量导数据时不再逐行检查唯一性。</p>
<h2 id="在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗-？"><a href="#在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗-？" class="headerlink" title="在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗 ？"></a>在大表执行ddl的过程中，若临时中断，会发生什么状况，需要特别处理吗 ？</h2><p>前提说明：MySQL5.7.23、innodb表、“双1” </p>
<p>1、添加/删除列，采用copy的方式 </p>
<p>1.1、ctrl+c。在当前session中，手动执行ctrl+c。无影响，并且会自动删除产生的临时文件。 </p>
<p>1.2、kill -9。在执行ddl的时候，服务器发生意外宕机或者手动执行kill -9。待MySQL启动后，则会自动执行InnoDB Recovered流程。并且不会删除产生的临时文件，需要手工处理。 </p>
<p>2、添加/删除索引，采用INPLACE方式 </p>
<p>2.1、ctrl+c，同1.1 </p>
<p>2.2、kill -9。不会删除临时文件，也不会执行InnoDB Recovered流程并且报错 Operating system error number 2 in a file operation ….OS error: 71 </p>
<p>在开始执行alter table的过程中，在没有结束的时候，并不会写入到binglog文件中。</p>
<h2 id="MySQL线上实例insert慢常见原因有哪些？"><a href="#MySQL线上实例insert慢常见原因有哪些？" class="headerlink" title="MySQL线上实例insert慢常见原因有哪些？"></a>MySQL线上实例insert慢常见原因有哪些？</h2><ol>
<li>锁等待：SQL产生的间隙锁、自增锁、死锁、MDL锁、外键检查锁，锁等待时间</li>
<li>iops达到瓶颈：例如备份任务、高频binlog redolog等文件写入</li>
<li>semi-sync：因为网络抖动，MySQL半同步、增强半同步导致语句卡住</li>
<li>高并发：高并发场景下，导致系统资源达到瓶颈，从而SQL执行慢</li>
<li>大字段：当前表索引过多，或者写入大量的text类型数据</li>
<li>硬件故障：因为磁盘、raid卡、内存等物理硬件故障导致写入慢</li>
<li>磁盘资源耗尽：操作系统的磁盘、inode资源耗尽</li>
<li>文件系统故障：MySQL data目录的所在挂在的不可写、或者被设置为只读</li>
<li>binlog group commit等待 </li>
<li>参数配置：innodb_buffer、redo_buffer过小 </li>
<li>autocommit：事物非自动提交，等待程序提交。</li>
</ol>
<h2 id="虽然命中索引，但SQL效率仍然慢，可能有哪些原因？"><a href="#虽然命中索引，但SQL效率仍然慢，可能有哪些原因？" class="headerlink" title="虽然命中索引，但SQL效率仍然慢，可能有哪些原因？"></a>虽然命中索引，但SQL效率仍然慢，可能有哪些原因？</h2><ol>
<li>索引字段重复值或者空值太多。 </li>
<li>查询条件范围太广返回结果数太多，全索引扫描 </li>
<li>没有利用到覆盖索引，造成大量回表 </li>
<li>查询字段过多，并且包含大字段</li>
<li>索引字段数据分布太随机，回表不多也会引起大量随机io </li>
<li>统计信息不准 </li>
<li>表的单行数据值很大，需要较多io </li>
<li>表中包含多个索引， 命中的索引不是最优的索引。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码阅读(启动过程)]]></title>
      <url>/2018/11/15/Redis/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB(%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B)/</url>
      <content type="html"><![CDATA[<p>Redis的启动函数main()在redis.c文件中。 </p>
<h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>在启动时会使用initServerConfig()函数进行初始化服务器配置工作，redisServer(redis.h)作为保存服务器配置的结构。 redisServer包含以下的一些Redis服务器的信息：  </p>
<ul>
<li>一般服务器状态。</li>
<li>一些服务器统计信息。</li>
<li>各种链表结构，如保存客户端的链表等。</li>
<li>配置文件及启动参数中的配置。</li>
<li>主从复制的状态。</li>
<li>持久化文件的参数和状态。</li>
</ul>
<p><img src="https://i.imgur.com/IXG8CwE.png" alt=""><br><a id="more"></a></p>
<h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><p>在initServer中会进行初始化服务器所需要的一些数据结构信息</p>
<ul>
<li>共享对象</li>
<li>事件循环</li>
<li>数据库结构</li>
<li>TCP套接字</li>
<li>服务器cron</li>
<li>事件循环</li>
<li>打开AOF</li>
</ul>
<h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p>如果开启了AOF持久化，那么加载AOF文件；否则加载RDB文件。   </p>
<p><font color="red">如果开启AOF，但是没有AOF文件的话也不会去读取RDB文件，这样会造成数据的丢失！！！</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void loadDataFromDisk(void) &#123;</span><br><span class="line">    // 记录开始时间</span><br><span class="line">    long long start = ustime();</span><br><span class="line"></span><br><span class="line">    // AOF 持久化已打开？</span><br><span class="line">    if (server.aof_state == REDIS_AOF_ON) &#123;</span><br><span class="line">        // 尝试载入 AOF 文件</span><br><span class="line">        if (loadAppendOnlyFile(server.aof_filename) == REDIS_OK)</span><br><span class="line">            // 打印载入信息，并计算载入耗时长度</span><br><span class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from append only file: %.3f seconds&quot;,(float)(ustime()-start)/1000000);</span><br><span class="line">    // AOF 持久化未打开</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 尝试载入 RDB 文件</span><br><span class="line">        if (rdbLoad(server.rdb_filename) == REDIS_OK) &#123;</span><br><span class="line">            // 打印载入信息，并计算载入耗时长度</span><br><span class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from disk: %.3f seconds&quot;,</span><br><span class="line">                (float)(ustime()-start)/1000000);</span><br><span class="line">        &#125; else if (errno != ENOENT) &#123;</span><br><span class="line">            redisLog(REDIS_WARNING,&quot;Fatal error loading the DB: %s. Exiting.&quot;,strerror(errno));</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="运行事件处理器"><a href="#运行事件处理器" class="headerlink" title="运行事件处理器"></a>运行事件处理器</h3><p>Redis在每次进入事件循环时都会想调用函数beforeSleep()。<br>beforeSleep()会做两件事：  </p>
<ol>
<li>如果启用了虚拟内存系统，将会去刷新AOF到磁盘，由flushAppendOnlyFile()函数处理。  </li>
<li>该函数封装了关于刷新缓冲区的一些复杂的逻辑，该缓冲区保存了AOF的写入缓存。  </li>
</ol>
<h4 id="进入事件循环"><a href="#进入事件循环" class="headerlink" title="进入事件循环"></a>进入事件循环</h4><p>Redis通过aeMain()进入主事件循环server.el。通过aeProcessEvents()处理所有已到达的时间事件和所有已就绪的文件事件。</p>
<h3 id="处理请求并返回响应"><a href="#处理请求并返回响应" class="headerlink" title="处理请求并返回响应"></a>处理请求并返回响应</h3><p>经过上面的启动过程后，Redis已经处于主事件轮询循环中，监听端口并等待客户端连接。<br><img src="https://i.imgur.com/J2YEVoo.png" alt=""></p>
<h4 id="处理新连接"><a href="#处理新连接" class="headerlink" title="处理新连接"></a>处理新连接</h4><p>在initServer()中，Redis注册acceptHandler()，当IO事件发生时被调用。acceptHandler()会创建一个客户端对象RedisClient。</p>
<h4 id="从客户端读取命令"><a href="#从客户端读取命令" class="headerlink" title="从客户端读取命令"></a>从客户端读取命令</h4><p>当客户端发送命令请求时，主事件循环调用readQueryFromClient()函数，它会尽可能多的读取（最多1024个字节）到临时缓冲区。<br>然后调用processInputBuffer()函数将客户端对象作为参数传递。processInputBuffer()将客户端的原始查询解析为执行Redis命令的参数，并解析每个参数的Redis字符串对象，并将它存储在客户端对象的数组中。然后调用processCommand()客户端对象来实际执行客户端发送的命令。<br>processCommand()从客户端获取命令的参数并执行。在执行前会进行许多的检查，如果检查失败，会向客户端对象附加一个错误消息并返回。</p>
<h4 id="执行命令并响应"><a href="#执行命令并响应" class="headerlink" title="执行命令并响应"></a>执行命令并响应</h4><p>call()函数，从客户端对象中获取具体执行命令的指针所指向的函数对象，并调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void call(redisClient *c, struct redisCommand *cmd) &#123;</span><br><span class="line">    long long dirty;</span><br><span class="line"></span><br><span class="line">    dirty = server.dirty;</span><br><span class="line">    cmd-&gt;proc(c);</span><br><span class="line">    dirty = server.dirty-dirty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis对象结构]]></title>
      <url>/2018/11/10/Redis/Redis%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="object-c"><a href="#object-c" class="headerlink" title="object.c"></a>object.c</h1><p>object.c文件主要记录了Redis对象的创建和释放方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">robj *createEmbeddedStringObject(char *ptr, size_t len) &#123;</span><br><span class="line">    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr)+len+1);</span><br><span class="line">    struct sdshdr *sh = (void*)(o+1);</span><br><span class="line"></span><br><span class="line">    o-&gt;type = REDIS_STRING;</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh+1;</span><br><span class="line">    o-&gt;refcount = 1;</span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;free = 0;</span><br><span class="line">    if (ptr) &#123;</span><br><span class="line">        memcpy(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = &apos;\0&apos;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        memset(sh-&gt;buf,0,len+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这个函数中，我们可以看出Redis在创建一个REDIS_ENCODING_EMBSTR编码的字符串对象时，是SDS连同redisObject一同创建的。也就是说这个字符串是不可以修改的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">robj *createStringObjectFromLongLong(long long value) &#123;</span><br><span class="line"></span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    // value 的大小符合 REDIS 共享整数的范围</span><br><span class="line">    // 那么返回一个共享对象</span><br><span class="line">    if (value &gt;= 0 &amp;&amp; value &lt; REDIS_SHARED_INTEGERS) &#123;</span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        o = shared.integers[value];</span><br><span class="line"></span><br><span class="line">    // 不符合共享范围，创建一个新的整数对象</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 值可以用 long 类型保存，</span><br><span class="line">        // 创建一个 REDIS_ENCODING_INT 编码的字符串对象</span><br><span class="line">        if (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</span><br><span class="line">            o = createObject(REDIS_STRING, NULL);</span><br><span class="line">            o-&gt;encoding = REDIS_ENCODING_INT;</span><br><span class="line">            o-&gt;ptr = (void*)((long)value);</span><br><span class="line"></span><br><span class="line">        // 值不能用 long 类型保存（long long 类型），将值转换为字符串，</span><br><span class="line">        // 并创建一个 REDIS_ENCODING_RAW 的字符串对象来保存值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            o = createObject(REDIS_STRING,sdsfromlonglong(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是根据传入的整数值来创建一个字符串对象。从这里可以看到主要有三个判断：</p>
<ol>
<li>如果设置的值符合Redis共享整数对象的范围时，是直接复用共享对象，并不会去创建一个新的对象。</li>
<li>如果传入的值是long类型的，这创建一个REDIS_ENCODING_INT编码类型的字符串对象。</li>
<li>如果传入的值为long long类型的，则创建REDIS_ENCODING_RAW编码类型的字符串对象。</li>
</ol>
<p>debug命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* Object command allows to inspect the internals of an Redis Object.</span><br><span class="line"> * Usage: OBJECT &lt;verb&gt; ... arguments ... */</span><br><span class="line">void objectCommand(redisClient *c) &#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    // 返回对戏哪个的引用计数</span><br><span class="line">    if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;refcount&quot;) &amp;&amp; c-&gt;argc == 3) &#123;</span><br><span class="line">        if ((o = objectCommandLookupOrReply(c,c-&gt;argv[2],shared.nullbulk))</span><br><span class="line">                == NULL) return;</span><br><span class="line">        addReplyLongLong(c,o-&gt;refcount);</span><br><span class="line"></span><br><span class="line">    // 返回对象的编码</span><br><span class="line">    &#125; else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;encoding&quot;) &amp;&amp; c-&gt;argc == 3) &#123;</span><br><span class="line">        if ((o = objectCommandLookupOrReply(c,c-&gt;argv[2],shared.nullbulk))</span><br><span class="line">                == NULL) return;</span><br><span class="line">        addReplyBulkCString(c,strEncoding(o-&gt;encoding));</span><br><span class="line">    </span><br><span class="line">    // 返回对象的空闲时间</span><br><span class="line">    &#125; else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;idletime&quot;) &amp;&amp; c-&gt;argc == 3) &#123;</span><br><span class="line">        if ((o = objectCommandLookupOrReply(c,c-&gt;argv[2],shared.nullbulk))</span><br><span class="line">                == NULL) return;</span><br><span class="line">        addReplyLongLong(c,estimateObjectIdleTime(o)/1000);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addReplyError(c,&quot;Syntax error. Try OBJECT (refcount|encoding|idletime)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----主从复制]]></title>
      <url>/2018/10/26/Redis/Redis%E5%8E%9F%E7%90%86----%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>很多企业都没有使用到Redis的集群，但是至少都做了主从。有了主从，当master挂掉的时候，运维让从库过来接管，服务就可以继续，否则master需要经过数据恢复和重启的过程，这就可能会拖很长时间，影响线上业务的持续服务。  </p>
<p>在了解Redis主从复制之前，让我们先来理解一下现代分布式系统的理论基石–CAP原理。</p>
<h2 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h2><p>CAP原理就好比分布式领域的牛顿定律，它是分布式存储的理论基石。自打CAP的论文发表之后，分布式存储中间件犹如雨后春笋一个一个涌现出来。  </p>
<ul>
<li>C-Consistent 一致性</li>
<li>A-Availability 可用性</li>
<li>P-Partition tolerance 分区容忍性</li>
</ul>
<p>分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着「网络分区」。</p>
<a id="more"></a>
<p>在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的「一致性」将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲「可用性」，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。<br><img src="https://i.imgur.com/owNDznt.jpg" alt=""><br>一句话概括CAP原理就是–<b>网络分区发生时，一致性和可用性两难全。</b>  </p>
<p>Redis的主从数据是异步同步的，所以分布式的Redis系统并不满足[一致性]要求。当客户端在Redis的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主从节点依旧可以正常对外提供服务，所以Redis满足[可用性]。  </p>
<p>Redis保证[最终一致性]，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态保持一致。如果网络断开，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续经历保持和主节点一致。  </p>
<h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><p>Redis同步支持主从同步和从从同步，从从同步功能是Redis后续版本增加的功能，为了减轻主库的同步负担。<br><img src="https://i.imgur.com/1IiirbA.jpg" alt="">  </p>
<h2 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h2><p>Redis同步的是指令流，主节点会将那些对自己状态产生修改性影响的指令记录在本地的内存buffer中，然后异步将buffer中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一边向主节点反馈自己同步的偏移量。  </p>
<p>因为内存的buffer（复制积压缓冲区）是有限的，所以Redis主库不能将所有的指令都记录在内存buffer中。Redis的复制内存buffer是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。<br><img src="https://i.imgur.com/I9g0mo3.jpg" alt=""><br>如果因为网络状况不好，从节点在短时间内无法和主节点进行同步，那么在网络状况恢复时，Redis的主节点中那些没有同步的指令在buffer中有可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这个时候就需要用到更加复杂的同步机制–快照同步。  </p>
<h2 id="快照同步"><a href="#快照同步" class="headerlink" title="快照同步"></a>快照同步</h2><p>快照同步是一个非常耗费资源的操作，它首先需要在主库上进行一次bgsave将当前内存中的数据全部快照到磁盘文件中，然后再将快照文件的传送给从节点。从节点在接收完毕后，立即执行一次全量加载，加载之前会将内存中的数据清空。加载完毕后通知主节点继续进行增量同步。  </p>
<p>在整个快照同步执行的过程中，主节点的复制buffer还在不停的往前移动，如果快照同步的时间过长或者复制buffer太小，都会导致同步期间的增量指令在复制buffer中被覆盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如果极有可能陷入无限的死循环，从而影响主节点的正常服务。<br><img src="https://i.imgur.com/aw8EZAS.jpg" alt=""><br><b>请务必设置一个合适复制buffer大小参数，避免这种情况的发生。</b>  </p>
<h2 id="无盘复制"><a href="#无盘复制" class="headerlink" title="无盘复制"></a>无盘复制</h2><p>主节点在进行快照同步时，会进行很重的文件IO操作，特别是对于非SSD磁盘存储时，快照会对系统的负载产生较大影响。特别是当系统正在进行AOF的fsync操作时如果发生快照，fsync将会被推迟执行，这就会严重影响主节点的服务效率。  </p>
<p>所以从Redis2.8.18版开始支持无盘复制。所谓无盘复制就是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内容，一边将序列化的内容发送给从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。  </p>
<h2 id="Wait指令"><a href="#Wait指令" class="headerlink" title="Wait指令"></a>Wait指令</h2><p>Redis的复制是异步进行的，wait指令可以让异步复制变身同步复制，确保系统的强一致性（不严格）。wait指令时Redis3.0版本以后出现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;set key value  </span><br><span class="line">OK  </span><br><span class="line">&gt;wait 1 0  </span><br><span class="line">(interge) 1</span><br></pre></td></tr></table></figure></p>
<p>wait提供两个参数，第一个参数是从库的数量N，第二个参数是时间t，以毫秒为单位。它表示等待wait指令之前的所有写操作同步到N个从库（也就是确保N个从库的同步没有滞后），最多等待时间t。如果时间t=0，代表无限等待知道N个从库同步完成达到一致。  </p>
<p>假设此时出现了网络分区，wait指令第二个参数时间t=0，主从同步无法继续进行，wait指令会永远阻塞，Redis服务器将丧失可用性。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>主从复制是Redis分布式的基础，Redis的高可用离开了朱重构复制将无法进行。  </p>
<p>如果你将Redis只用作缓存，跟memcache一样对待，也就唔需要从库做备份，挂掉了重新启动一下就行了。但是只要你使用了Redis的持久化功能，就必须认真对待主从复制，它是系统数据安全的基础保障。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----事务]]></title>
      <url>/2018/10/25/Redis/Redis%E5%8E%9F%E7%90%86----%E4%BA%8B%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>为了确保连续多个操作的原子性，一个成熟的数据库通常都会有事务支持，Redis也不例外。Redis的事务使用非常简单，不同于关系数据库，我们无需理解那么多复杂的事务模型了，就可以直接使用。不过也正是因为这种简单性，它的事务模型很不严格，这要求我们不能像使用关系数据库的事务一样使用Redis。</p>
<h2 id="Redis事务的基本使用"><a href="#Redis事务的基本使用" class="headerlink" title="Redis事务的基本使用"></a>Redis事务的基本使用</h2><p>每个事务的操作都有begin、commit、和rollback、begin指示事务的开始，commit指示事务的提交，rollback指示事务的回滚。</p>
<p>Redis与其差不多，对应的分别是multi/exec/discard。multi指示事务的开始，exec指示事务的执行，discard指示事务的丢弃。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;multi  </span><br><span class="line">OK  </span><br><span class="line">&gt;incr books  </span><br><span class="line">QUEUED  </span><br><span class="line">&gt;incr books  </span><br><span class="line">QUEUED  </span><br><span class="line">&gt;exec  </span><br><span class="line">(integer) 1</span><br><span class="line">(integer）2</span><br></pre></td></tr></table></figure>
<p>上面的指令演示了一个完整的事务过程，所有的指令在exec之前不执行，而是<font color="red">缓存在服务器的一个事务队列中</font>，服务器一旦受到exec指令，就开始执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。因为Redis的单线程特性，它不用担心自己在执行队列的时候被其他指令打搅，可以保证他们得到的[原子性]执行。<br><img src="https://i.imgur.com/l8Awrjs.jpg" alt=""><br>上图显示了以上事务过程完整的交互结果。QUEUED是一个简单字符串，同OK是一个形式，它表示指令已经被服务器缓存到队列里了。<br><a id="more"></a></p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>事务的原子性是指要么事务全部成功，要么全部失败，那么Redis事务的执行时原子性的么？  </p>
<p>下面我们来看一个特别的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;multi  </span><br><span class="line">OK  </span><br><span class="line">&gt;set books iamstring  </span><br><span class="line">QUEUED  </span><br><span class="line">&gt;incr books  </span><br><span class="line">QUEUED  </span><br><span class="line">&gt;set poorman iamdesperate  </span><br><span class="line">QUEUED  </span><br><span class="line">&gt;exec  </span><br><span class="line">1) OK  </span><br><span class="line">2) (error)ERR value is not an integer or out of range  </span><br><span class="line">3) OK  </span><br><span class="line">&gt;get books  </span><br><span class="line">&quot;iamstring&quot;  </span><br><span class="line">&gt;get poorman  </span><br><span class="line">&quot;iamdesperate&quot;</span><br></pre></td></tr></table></figure>
<p>上面的例子是事务执行到中间遇到失败了，因为我们不能对一个字符串进行数学运算，事务在遇到指令执行失败后，后面的指令还继续执行，所以poorman的值能继续得到设置。  </p>
<p>到这里，应该明白Redis的事务根本不能算[原子性]，而仅仅是满足了事务的[隔离性]，隔离性中的串行化–当前执行的事务有着不被其他事务打断的权利。</p>
<h2 id="discard-丢弃"><a href="#discard-丢弃" class="headerlink" title="discard(丢弃)"></a>discard(丢弃)</h2><p>Redis为事务提供了一个discard指令，用于丢弃事务缓存队列中的所有指令，在exec执行之前。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面Redis事务在发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部的指令较多时，需要的网络IO时间也会线性增长。所以通常Redis的客户端在执行事务时都会结合pipeline一起使用，这样可以将多次IO操作压缩为单次IO操作。</p>
<h2 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h2><p>考虑到一个业务场景，Redis存储了我们的账户余额数据，它是一个整数。现在有两个并发的客户端要对账户余额进行修改操作，这个修改不是简单的incrby指令，而是要对余额乘以一个倍数。Redis可没有提供multiplyby这样的指令。我们需要先取出余额然后在内存里乘以倍数，再将结果写回到Redis。  </p>
<p>这就会出现并发问题，因为有多个客户端会并发进行操作。我们可以通过Redis的分布式锁来避免冲突，这是一个很好的解决方案。<b>分布式锁是一种悲观锁，那是不是可以使用悲观锁的方式来解决冲突呢？</b>  </p>
<p>Redis提供了watch的机制，它就是一种悲观锁。有了watch我们又多了一种可以用来解决并发修改的方法。watch的使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while True:  </span><br><span class="line">	do_watch()  </span><br><span class="line">	commands()  </span><br><span class="line">	multi()  </span><br><span class="line">	send_commands()  </span><br><span class="line">	try:  </span><br><span class="line">		exec()  </span><br><span class="line">		break  </span><br><span class="line">	except WatchError:  </span><br><span class="line">		continue</span><br></pre></td></tr></table></figure></p>
<p>watch会在事务开始之前盯住一个或多个关键变量，当事务执行时，也就是服务受到exec指令要顺序执行缓存的事务队列时，Redis会检查关键变量只watch之后，是否被修改了（包括当前事务所在客户端）。如果关键变量被人动过了，exec指令就会返回null回复告知客户端事务执行失败，这个时候客户端一般会想着重试。  </p>
<pre><code>&gt;watch books  
OK  
&gt;incr books  #被修改了  
(integer) 1  
&gt;multi  
OK  
&gt;incr books  
QUEUED  
&gt;exec  #事务执行失败  
(nil)  
</code></pre><p>当服务器给exec指令返回一个null回复时，客户端知道了事务执行是失败的，通常客户端(redis-py)都会抛出一个WatchError这种错误，不过也有些语言(jedis)不会抛出异常，而是通过在exec方法里返回一个null，这样客户端需要检查一下返回结果是否为null来确定事务是否执行失败。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Redis禁止在multi和exec之间执行watch指令，而必须在multi之前做好盯住关键变量，否则会出错。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----管道]]></title>
      <url>/2018/10/24/Redis/Redis%E5%8E%9F%E7%90%86----%E7%AE%A1%E9%81%93/</url>
      <content type="html"><![CDATA[<p>大多数人一直对Redis管道有一个误解，他们以为这是Redis服务器提供的一种特别的技术，有了这种技术就可以加速Redis的存取效率。但是实际上Redis管道（Pipeline）本身并不是Redis服务器直接提供的技术，这个技术本质上是由客户端提供的，跟服务器没有什么直接的关系。</p>
<h2 id="Redis的消息交互"><a href="#Redis的消息交互" class="headerlink" title="Redis的消息交互"></a>Redis的消息交互</h2><p>当我们使用客户端对Redis进行一次操作时，如下图所示，客户端将请求传送给服务器，服务器处理完毕后，再将响应回复给客户端。这要花费一个网络数据包的来回时间。  </p>
<p><img src="https://i.imgur.com/ulCYBhP.jpg" alt=""><br><a id="more"></a><br>如果连续执行多条指令，那就会花费多个网络数据包来回的时间。如下图所示。  </p>
<p><img src="https://i.imgur.com/zxGuLwE.jpg" alt="">  </p>
<p>回到客户端代码层面，客户端是经历了写-读-写-读四个操作才完整的执行了两条指令。  </p>
<p><img src="https://i.imgur.com/kW9apz0.jpg" alt="">  </p>
<p>现在如果我们调整读写顺序，改成写-写-读-读，这两个指令同样可以正常完成。  </p>
<p><img src="https://i.imgur.com/V6yvFoA.jpg" alt=""><br>两个连续的写操作和两个连续的读操作总共只会花费一次网络来回，就好比连续的write操作合并了，连续的read操作也合并了一样。</p>
<p><img src="https://i.imgur.com/qvHYXje.jpg" alt="">    </p>
<p>这便是管道操作的本质，服务器根本没有任何区别对待，还是收到一条消息，执行一条消息，回复一条消息的正常流程。客户端通过对管道中的指令列表改变读写顺序就可以大幅度节省IO时间，管道中指令越多，效果越好。  </p>
<h2 id="深入理解管道本质"><a href="#深入理解管道本质" class="headerlink" title="深入理解管道本质"></a>深入理解管道本质</h2><p>接下来我们深入分析一个请求交互的流程，真实的情况是它很复杂，因为要经过网络协议栈，这个就得深入内核了。  </p>
<p><img src="https://i.imgur.com/Ub6GJ4Z.jpg" alt="">  </p>
<p>上图就是一个完整的请求交互图。  </p>
<ol>
<li>客户端进程挑用write将消息写到操作系统内核为套接字分配的发送缓冲send buffer。  </li>
<li>客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过[网际路由]送到服务器的网卡。  </li>
<li>服务器操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲recv buffer。  </li>
<li>服务器进程调用read从接收缓冲中取出消息进行处理。  </li>
<li>服务器进程调用write将响应消息写到内核为套接字分配的发送缓冲send buffer。  </li>
<li>服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过[网际路由]送到客户端网卡。  </li>
<li>客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲recv buffer。  </li>
<li>客户端进程调用read从接收缓冲中取出消息返回给上层业务逻辑进行处理。  </li>
<li>结束。  </li>
</ol>
<p>其中步骤5-8和1-4是一样的，只不过方向是反过来的，一个是请求，一个是响应。  </p>
<p>我们开始以为write操作是要等到对方收到消息才会返回，但实际上不是这样的。write操作只负责将数据写到本地操作系统内核的发送缓冲然后就返回了。剩下的事交给操作系统内核异步将数据送到目标机器。但是如果发送缓冲满了，那么就需要等待缓冲空出空间来，这个就是写IO操作的真正耗时。  </p>
<p>我们开始以为read操作是从目标机器拉取数据，但实际上不是这样的。read操作只负责将数据从本地操作系统内核的接收缓冲中取出来。但是如果缓冲是空的，那么就需要等待数据到来，这个就是读IO操作的真正耗时。  </p>
<p>所以对于value = redis.get(key)这样一个简单的请求来说，write操作几乎没有耗时，直接写到发送缓冲就返回，而read就比较耗时了，因为他要等待消息经过网际路由到目标机器处理后的响应消息，再回送到当前的内核读缓冲才可以返回。<b>这是才是一个网络来回的真正开销。</b>  </p>
<p>而对于管道来说，连续的write操作根本没有耗时，之后第一个read操作会等待一个网络的来回开销，然后所有的响应消息就都已经回送到内核的读缓存了，后续的read操作直接就可以从缓冲拿到结果，瞬间就返回了。  </p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----持久化]]></title>
      <url>/2018/10/22/Redis/Redis%E5%8E%9F%E7%90%86----%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>Redis的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证Redis的数据不会因为故障而丢失，这种机制就是Redis的持久化机制。  </p>
<p>Redis的持久化机制有两种，第一种就是快照（RDB文件），第二种就是AOF日志。快照是一次全量备份，AOF日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而AOF日志记录的是内存数据修改的指令记录文本。AOF日志在长期的运行过程中会变得非常大，数据库重启时需要加载AOF日志进行指令重放，这个时间会变得无比漫长。所以需要定期进行AOF重写，给AOF文件瘦身。</p>
<h2 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h2><p>我们知道Redis是单线程程序，这个线程要同时负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写。  </p>
<p>在服务线上请求的同时，Redis还需要进行内存快照，内存快照要求Redis必须进行文件IO操作，可文件IO操作是不能使用多路复用API。  </p>
<p>这意味着单线程同时在服务线上的请求和吉林文件IO操作，文件IO操作会严重拖垮服务器请求的性能。还有个<b>重要的问题就是为了不阻塞线上的业务，就需要边持久化边响应客户端请求</b>。持久化的同时，内存数据结构还在变化，比如一个大型的hash字典正在持久化，结果一个请求过来把它给删除了，还没持久化，这该怎么办？  </p>
<font color="red">Redis使用操作系统的多进程COW（copy On Write）机制来实现快照持久化。</font>

<a id="more"></a>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>Redis在持久化时会调用glibc的函数fork产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段。这时你可以将父子进程想象成一个连体婴儿，共享身体。这时liunx操作系统的机制，为了节约内存资源，所以尽可能让他们共享。在进程分离的一瞬间，内存的增长几乎没有明显变化。  </p>
<p>子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断修改。  </p>
<p>这个时候就会使用操作系统的COW机制进行数据段页的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程像一粒的页面是没有变化的，还是进程产生时那一瞬间的数据。  </p>
<p>随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的2倍大小。另外一个Redis实例里冷数据占的比例往往是比较高的，所以很少会出现所有的页面都会被分离，被分离的往往只有其中一部分。每个页面的大小只有4k，一个Redis实例里面一般会有成千上万的页面。  </p>
<p>子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变，这也是为什么Redis的持久化交【快照】的原因。接下来子进程就可以非常安心的遍历数据进行序列化写磁盘了。</p>
<h2 id="AOF原理"><a href="#AOF原理" class="headerlink" title="AOF原理"></a>AOF原理</h2><p>AOF日志存储的Redis服务器的顺序指令序列，AOF日志只记录对内存进行修改的指令记录。  </p>
<p>假设AOF日志记录了自Redis实例创建以来所有的修改性指令序列，那么就可以通过对一个空的Redis实例顺序执行所有的指令，也就是重放来恢复Redis当前实例的内存数据结构的状态。  </p>
<p>Redis会在收到客户端修改指令后，进行参数校验进行逻辑处理后，如果没有问题，就立即将该指令存储到AOF日志中，也就是先执行指令才将日志存盘。这点不同于leveldb、hbase等存储引擎，他们都是先存储日志再做逻辑处理。  </p>
<p>Redis在长期运行的过程中，AOF的日志会变得越来越多。如果实例宕机重启，重放整个AOF日志会非常耗时，导致 长时间Redis无法对外提供服务，所以需要对AOF进行日志瘦身。</p>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>Redis提供了bgrewriteaof指令用于对AOF日志进行瘦身。其原理就是开辟一个子进程对内存进行遍历转换成一系列Redis的操作指令，序列化到一个新的AOF日志文件中。序列化完毕后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，追加完毕后就立即替换旧的日志文件。</p>
<h2 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h2><p>AOF日志是以文件的形式存在的，当程序对AOF日志文件进行写操作时，实际上就是内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回到磁盘。  </p>
<p>这意味着如果机器突然宕机，AOF日志内容可能还没来得及完全刷到磁盘，这个时候就会出现日志丢失。  </p>
<p>Linux的glibc提供了fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷到磁盘。只要Redis进程实时调用fsync函数就可以保证aof日志不丢失。但是fsync是一个磁盘IO操作，这意味着他很慢。如果Reids执行一条指令就要fsync一次，那么Redis的高性能地位就不保了。  </p>
<p>所以在生产环境的服务器中，Redis通常是每隔1s左右执行一次fsync操作，这是在数据安全性和性能之间做了一个折中，在保持高性能的同时，尽可能使得数据少丢失。  </p>
<p>Redis提供了另外两种策略：永不fsync（让操作系统来决定何时同步磁盘），用一个指令就fsync一次（非常慢，基本不会在生产中使用）</p>
<h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><p>快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。<br>1、遍历整个内存，大块写磁盘会加重系统负载。<br>2、AOF的fsync是一个比较耗时的IO操作，它会降低Redis性能，同时也会增加系统IO负担。  </p>
<p>所以通常Redis的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源比较充沛。  </p>
<p>但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，所以在生产环境要做好实例监控工作，保证网络畅通或者能快速修复。另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失。</p>
<h2 id="Redis4-0混合持久化"><a href="#Redis4-0混合持久化" class="headerlink" title="Redis4.0混合持久化"></a>Redis4.0混合持久化</h2><p>重启Redis时，我们很少使用rdb来恢复内存状态，因为会丢失大量数据。我们通常使用AOF日志重做，但是重放AOF日志性能相对RDB来说要慢很多，这样在Redis实例很大的情况下，启动需要花费很长的时间。  </p>
<p>Redis4.0为了解决这个问题，带来了一个新的持久化选项–混合持久化。将RDB文件的内容和增量的AOF日志文件存在一起。这里的AOF日志不在是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量AOF日志，通常这部分AOF日志很小。  </p>
<p>于是在Redis重启的时候，可以先加载rdb的内容，然后再重放增量AOF日志就可以完全替代之前的AOF全量文件重放，重启效率大幅度提升。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码阅读目录]]></title>
      <url>/2018/10/21/Redis/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>文件</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>adlist.c 、 adlist.h</td>
<td style="text-align:center">双端链表数据结构的实现。</td>
</tr>
<tr>
<td>ae.c 、 ae.h 、 ae_epoll.c 、 ae_evport.c 、 ae_kqueue.c 、 ae_select.c</td>
<td style="text-align:center">事件处理器，以及各个具体实现。</td>
</tr>
<tr>
<td>anet.c 、 anet.h</td>
<td style="text-align:center">Redis 的异步网络框架，内容主要为对 socket 库的包装。</td>
</tr>
<tr>
<td>aof.c</td>
<td style="text-align:center">AOF 功能的实现。</td>
</tr>
<tr>
<td>asciilogo.h</td>
<td style="text-align:center">保存了 Redis 的 ASCII LOGO 。</td>
</tr>
<tr>
<td>bio.c 、 bio.h</td>
<td style="text-align:center">Redis 的后台 I/O 程序，用于将 I/O 操作放到子线程里面执行， 减少 I/O 操作对主线程的阻塞。</td>
</tr>
<tr>
<td>bitops.c</td>
<td style="text-align:center">二进制位操作命令的实现文件。</td>
</tr>
<tr>
<td>blocked.c</td>
<td style="text-align:center">用于实现 BLPOP 命令和 WAIT 命令的阻塞效果。</td>
</tr>
<tr>
<td>cluster.c 、 cluster.h</td>
<td style="text-align:center">Redis 的集群实现。</td>
</tr>
<tr>
<td>config.c 、 config.h</td>
<td style="text-align:center">Redis 的配置管理实现，负责读取并分析配置文件， 然后根据这些配置修改 Redis 服务器的各个选项。</td>
</tr>
<tr>
<td>crc16.c 、 crc64.c 、 crc64.h</td>
<td style="text-align:center">计算 CRC 校验和。</td>
</tr>
<tr>
<td>db.c</td>
<td style="text-align:center">数据库实现。</td>
</tr>
<tr>
<td>debug.c</td>
<td style="text-align:center">调试实现。</td>
</tr>
<tr>
<td>dict.c 、 dict.h</td>
<td style="text-align:center">字典数据结构的实现。</td>
</tr>
<tr>
<td>endianconv.c 、 endianconv.h</td>
<td style="text-align:center">二进制的大端、小端转换函数。</td>
</tr>
<tr>
<td>fmacros.h</td>
<td style="text-align:center">一些移植性方面的宏。</td>
</tr>
<tr>
<td>help.h</td>
<td style="text-align:center">utils/generate-command-help.rb 程序自动生成的命令帮助信息。</td>
</tr>
<tr>
<td>hyperloglog.c</td>
<td style="text-align:center">HyperLogLog 数据结构的实现。</td>
</tr>
<tr>
<td>intset.c 、 intset.h</td>
<td style="text-align:center">整数集合数据结构的实现，用于优化 SET 类型。</td>
</tr>
<tr>
<td>lzf_c.c 、 lzf_d.c 、 lzf.h 、 lzfP.h</td>
<td style="text-align:center">Redis 对字符串和 RDB 文件进行压缩时使用的 LZF 压缩算法的实现。</td>
</tr>
<tr>
<td>Makefile 、 Makefile.dep</td>
<td style="text-align:center">构建文件。</td>
</tr>
<tr>
<td>memtest.c</td>
<td style="text-align:center">内存测试。</td>
</tr>
<tr>
<td>mkreleasehdr.sh</td>
<td style="text-align:center">用于生成释出信息的脚本。</td>
</tr>
<tr>
<td>multi.c</td>
<td style="text-align:center">Redis 的事务实现。</td>
</tr>
<tr>
<td>networking.c</td>
<td style="text-align:center">Redis 的客户端网络操作库， 用于实现命令请求接收、发送命令回复等工作， 文件中的函数大多为 write 、 read 、 close 等函数的包装， 以及各种协议的分析和构建函数。</td>
</tr>
<tr>
<td>notify.c</td>
<td style="text-align:center">Redis 的数据库通知实现。</td>
</tr>
<tr>
<td>object.c</td>
<td style="text-align:center">Redis 的对象系统实现。</td>
</tr>
<tr>
<td>pqsort.c 、 pqsort.h</td>
<td style="text-align:center">快速排序（QuickSort）算法的实现。</td>
</tr>
<tr>
<td>pubsub.c</td>
<td style="text-align:center">发布与订阅功能的实现。</td>
</tr>
<tr>
<td>rand.c 、 rand.h</td>
<td style="text-align:center">伪随机数生成器。</td>
</tr>
<tr>
<td>rdb.c 、 rdb.h</td>
<td style="text-align:center">RDB 持久化功能的实现。</td>
</tr>
<tr>
<td>redisassert.h</td>
<td style="text-align:center">Redis 自建的断言系统。</td>
</tr>
<tr>
<td>redis-benchmark.c</td>
<td style="text-align:center">Redis 的性能测试程序。</td>
</tr>
<tr>
<td>redis.c</td>
<td style="text-align:center">负责服务器的启动、维护和关闭等事项。</td>
</tr>
<tr>
<td>redis-check-aof.c 、 redis-check-dump.c</td>
<td style="text-align:center">RDB 文件和 AOF 文件的合法性检查程序。</td>
</tr>
<tr>
<td>redis-cli.c</td>
<td style="text-align:center">Redis 客户端的实现。</td>
</tr>
<tr>
<td>redis.h</td>
<td style="text-align:center">Redis 的主要头文件，记录了 Redis 中的大部分数据结构， 包括服务器状态和客户端状态。</td>
</tr>
<tr>
<td>redis-trib.rb</td>
<td style="text-align:center">Redis 集群的管理程序。</td>
</tr>
<tr>
<td>release.c 、 release.h</td>
<td style="text-align:center">记录和生成 Redis 的释出版本信息。</td>
</tr>
<tr>
<td>replication.c</td>
<td style="text-align:center">复制功能的实现。</td>
</tr>
<tr>
<td>rio.c 、 rio.h</td>
<td style="text-align:center">Redis 对文件 I/O 函数的包装， 在普通 I/O 函数的基础上增加了显式缓存、以及计算校验和等功能。</td>
</tr>
<tr>
<td>scripting.c</td>
<td style="text-align:center">脚本功能的实现。</td>
</tr>
<tr>
<td>sds.c 、 sds.h</td>
<td style="text-align:center">SDS 数据结构的实现，SDS 为 Redis 的默认字符串表示。</td>
</tr>
<tr>
<td>sentinel.c</td>
<td style="text-align:center">Redis Sentinel 的实现。</td>
</tr>
<tr>
<td>setproctitle.c</td>
<td style="text-align:center">进程环境设置函数。</td>
</tr>
<tr>
<td>sha1.c 、 sha1.h</td>
<td style="text-align:center">SHA1 校验和计算函数。</td>
</tr>
<tr>
<td>slowlog.c 、 slowlog.h</td>
<td style="text-align:center">慢查询功能的实现。</td>
</tr>
<tr>
<td>solarisfixes.h</td>
<td style="text-align:center">针对 Solaris 系统的补丁。</td>
</tr>
<tr>
<td>sort.c</td>
<td style="text-align:center">SORT 命令的实现。</td>
</tr>
<tr>
<td>syncio.c</td>
<td style="text-align:center">同步 I/O 操作。</td>
</tr>
<tr>
<td>testhelp.h</td>
<td style="text-align:center">测试辅助宏。</td>
</tr>
<tr>
<td>t_hash.c 、 t_list.c 、 t_set.c、 t_string.c 、 t_zset.c</td>
<td style="text-align:center">定义了 Redis 的各种数据类型，以及这些数据类型的命令。</td>
</tr>
<tr>
<td>util.c 、 util.h</td>
<td style="text-align:center">各种辅助函数。</td>
</tr>
<tr>
<td>valgrind.sup</td>
<td style="text-align:center">valgrind 的suppression文件。</td>
</tr>
<tr>
<td>version.h</td>
<td style="text-align:center">记录了 Redis 的版本号。</td>
</tr>
<tr>
<td>ziplist.c 、 ziplist.h</td>
<td style="text-align:center">ZIPLIST 数据结构的实现，用于优化 LIST 类型。</td>
</tr>
<tr>
<td>zipmap.c 、 zipmap.h</td>
<td style="text-align:center">ZIPMAP 数据结构的实现，在 Redis 2.6 以前用与优化 HASH 类型， Redis 2.6 开始已经废弃。</td>
</tr>
<tr>
<td>zmalloc.c 、 zmalloc.h</td>
<td style="text-align:center">内存管理程序。</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----通信协议]]></title>
      <url>/2018/10/21/Redis/Redis%E5%8E%9F%E7%90%86----%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>Redis的作者认为数据库系统的瓶颈一般不在于网络流量，而是数据库自身内部逻辑处理上。所以即使Redis使用了浪费流量的文本协议，依然可以取得极高的访问性能。Redis将所有数据都放在内存，用一个单线程对外提供服务，单个节点在跑满一个CPU核心的情况下可以达到10w/s的超高QPS。</p>
<h2 id="RESP"><a href="#RESP" class="headerlink" title="RESP"></a>RESP</h2><p>RESP（Redis Serialization Protocol）是Redis序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简单，解析性能极好。</p>
<p>Redis歇息将传输的数据结构分为5种最小单元类型，单元结束时统一加上回车换行符号\r\n。  </p>
<ul>
<li>单行字符以<font color="red">+</font>符号开头</li>
<li>多行字符以<font color="red">$</font>符号开头，后跟字符串长度</li>
<li>整数值以<font color="red">：</font>符号开头，后跟整数的字符串形式</li>
<li>错误消息以<font color="red">-</font>符号开头</li>
<li>数组以<font color="red">*</font>符号开头，后跟数组的长度</li>
</ul>
<p>单行字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+hello world\r\n</span><br></pre></td></tr></table></figure></p>
<p>多行字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$11\r\n  </span><br><span class="line">hello world\r\n</span><br></pre></td></tr></table></figure></p>
<p>整数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1024\r\n</span><br></pre></td></tr></table></figure></p>
<p>错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-WRONGTYPE Operation ....</span><br></pre></td></tr></table></figure></p>
<p>数组[1,2,3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n  </span><br><span class="line">:1\r\n</span><br><span class="line">:2\r\n  </span><br><span class="line">:3\r\n</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="客户端-gt-服务器"><a href="#客户端-gt-服务器" class="headerlink" title="客户端-&gt;服务器"></a>客户端-&gt;服务器</h2><p>客户端向服务器发送的指令只有一种格式，多行字符串数组。比如一个简单的set指令set k v会被序列化成以下字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n  </span><br><span class="line">$3\r\n  </span><br><span class="line">set\r\n</span><br><span class="line">$1\r\n</span><br><span class="line">k\r\n</span><br><span class="line">$1\r\n</span><br><span class="line">v\r\n</span><br></pre></td></tr></table></figure></p>
<h2 id="服务器-gt-客户端"><a href="#服务器-gt-客户端" class="headerlink" title="服务器-&gt;客户端"></a>服务器-&gt;客户端</h2><p>服务器向客户端恢复的响应要支持多种数据结构，所以消息响应在结构上要复杂不少。不过在复杂的响应消息也是以上的5种基本类型的组合。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redis协议里有大量冗余的回车换行符，但是这并不影响它成为互联网技术领域非常受欢迎的一个文本歇息。有很多开源项目目前使用RESP作为它的通讯协议。在技术领域性能并不是一切，还有简单性、易理解性和易实现性，这些都是需要进行适当权衡的。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis原理----线程IO模型]]></title>
      <url>/2018/10/20/Redis/Redis%E5%8E%9F%E7%90%86----%E7%BA%BF%E7%A8%8BIO%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p><b>Redis是一个单线程程序</b></p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>当我们调用套接字的读写方法，默认他们是阻塞的，比如read方法要传递一个参数n，表示最多读取这门多字节后返回，如果一个字节都没有，那么线程就会卡在那里，直到新的数据到来或者连接关闭，read方法才可以返回，线程才能够继续处理。而write方法一般来说不会阻塞，除非内核为套接字分配的写缓冲区已经写满了，write方法才会阻塞，直到缓冲区有空闲空间。<img src="https://i.imgur.com/0sE9kXD.png" alt=""><br>非阻塞IO在套接字对象上提供了一个选项Non_Blocking,当这个选项打开时，读写方法不会阻塞。能读多少取决于内核为套接字分配的读缓冲区的空闲空间字节数，能写多少取决于内核为套接字分配的写缓冲区的空闲空间字节数。读方法和写方法都会通过返回值来告知程序实际读写了多少字节。</p>
<h2 id="事件轮询（多路复用）"><a href="#事件轮询（多路复用）" class="headerlink" title="事件轮询（多路复用）"></a>事件轮询（多路复用）</h2><p>非阻塞IO有个问题，就是线程要读数据，但是读了一部分就返回了，线程如何知道什么时候应该继续读，也就是当数据到来时，线程如何得到通知。写也是一样。<img src="https://i.imgur.com/bxF8jbN.png" alt=""><br>事件轮询API就是用来解决这个问题的，最简单的时间轮询API是select函数，它是操作系统提供给用户程序的API。输入时读写描述符列表read_fds &amp; write_fds，输出是与之对应的可读可写时间。同时还提供了一个timeout参数，如果没有任何事件的到来，那么最多等待timeout时间，线程处于阻塞状态。一旦期间有事件到来，就可以立即返回。线程就可以继续挨个处理相应的事件。处理完了继续过来轮询。于是线程就进入了一个死循环。我们把这个死循环称为事件轮询，一个循环为一个周期。<br><b>事件轮询API就是Java语言中的NIO技术</b></p>
<h2 id="指令队列"><a href="#指令队列" class="headerlink" title="指令队列"></a>指令队列</h2><p>Redis会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务。</p>
<h2 id="响应队列"><a href="#响应队列" class="headerlink" title="响应队列"></a>响应队列</h2><p>Redis同样会为每个客户端套接字关联一个响应队列。<br>Redis服务器通过响应队列来将指令的返回结果回复给客户端。如果队列为空，那么以为这连接暂时处于空闲状态，不需要去获取写事件，也就是可以将当前的客户端描述符从write_fds里面移除。等到队列有数据了，再将描述符放进去。避免select系统调用立即返回写事件，结果发现没什么数据可以写。<b>出现这种情况的线程会飙高CPU</b></p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>服务器处理要响应的IO事件外，还要处理其他事情。比如定时任务。<br>如果线程阻塞在select系统调用上，定时任务将无法得到准时调度。那么Redis是如何解决这个问题的呢？  </p>
<p>Redis的定时任务会记录在一个最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是select系统调用的timeout参数。因为Redis知道未来timeout时间内，没有其他定时任务需要处理，所以可以安心睡眠timeout时间。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[reset master和reset slave]]></title>
      <url>/2018/09/23/MySQL/reset%20master%E5%92%8Crester%20slave/</url>
      <content type="html"><![CDATA[<h3 id="reset-master"><a href="#reset-master" class="headerlink" title="reset master"></a>reset master</h3><p>删除index file中记录的所有binlog文件，将日志索引文件清空，创建一个新的日志文件，这个命令通常用于第一次搭建主从关系的主库。  </p>
<h4 id="reset-master和purge-binary-log的区别"><a href="#reset-master和purge-binary-log的区别" class="headerlink" title="reset master和purge binary log的区别"></a>reset master和purge binary log的区别</h4><ol>
<li>reset master 删除日志索引文件中记录的所有binlog文件，重新建立一个新的日志文件，起始值从000001开始，purge binary log 命令不会修改记录binlog顺序的数值</li>
<li>reset master 不能用于有任何slave正在运行的主从关系的主库。因为在slave运行时刻reset master命令不被支持。从库此时会报错。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In MySQL 5.6.5 and later, RESET MASTER also clears the values of the gtid_purged system variable (known as gtid_lost in MySQL 5.6.8 and earlier) as well as the global value of the gtid_executed (gtid_done, prior to MySQL 5.6.9) system variable (but not its session value); that is, executing this statement sets each of these values to an empty string (&apos;&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="reset-slave"><a href="#reset-slave" class="headerlink" title="reset slave"></a>reset slave</h3><p>reset slave 将使slave忘记主从复制关系的位置信息。该语句用于干净的启动，它删除master.info文件和relay-log.info文件以及所有的relay log文件并重新启用一个新的relay-log文件。</p>
<h3 id="reset-slave-all"><a href="#reset-slave-all" class="headerlink" title="reset slave all"></a>reset slave all</h3><p>在 5.6 版本中 reset slave 并不会清理存储于内存中的复制信息比如  master host, master port, master user, or master password,也就是说如果没有使用change master 命令做重新定向，执行start slave 还是会指向旧的master 上面。<br>当从库执行reset slave之后,将mysqld shutdown 复制参数将被重置。<br>在5.6.3 版本以及以后 使用使用 RESET SLAVE ALL 来完全的清理复制连接参数信息。(Bug #11809016)<br>RESET SLAVE ALL does not clear the IGNORE_SERVER_IDS list set by CHANGE MASTER TO. This issue is fixed in MySQL 5.7. (Bug #18816897)<br>In MySQL 5.6.7 and later, RESET SLAVE causes an implicit commit of an ongoing transaction. See Section 13.3.3, “Statements That Cause an Implicit Commit”.</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python装饰器]]></title>
      <url>/2018/08/19/python/python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>python装饰器就是用于<font color="red">扩展原来函数功能的一种函数</font>，这个函数的特殊之处在于它的返回值也是一个函数。使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原函数</span><br><span class="line">def func():</span><br><span class="line">	print(&quot;hello&quot;)</span><br></pre></td></tr></table></figure></p>
<p>要想扩展一个函数的功能，最简单的方法就是直接修改原函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def func():</span><br><span class="line">	print(&quot;before&quot;)</span><br><span class="line">	print(&quot;hello&quot;)</span><br><span class="line">	print(&quot;after&quot;)</span><br></pre></td></tr></table></figure></p>
<p>如果不想修改原函数，还是想增强函数的功能时，可以另外定义一个函数调用原函数。（类似于设计模式中的装饰模式，有组合和代理两种方式）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def deco(func):</span><br><span class="line">	print(&quot;before&quot;)</span><br><span class="line">	func()</span><br><span class="line">	print(&quot;after&quot;)</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">	print(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    f = func</span><br><span class="line">    deco(f)#只有把func()或者f()作为参数执行，新加入功能才会生效</span><br><span class="line">    print(&quot;f.__name__ is&quot;,f.__name__)#f的name就是func()</span><br><span class="line">    print()</span><br><span class="line">    #func()</span><br></pre></td></tr></table></figure></p>
<p>但是如果存在很多个类似于func的函数需要相同的扩展，那岂不是要执行deco函数许多次？<br>下面我们实现一个最简陋的装饰器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def deco(func):</span><br><span class="line">	def wrapper(*args, **kwargs):</span><br><span class="line">		print(&quot;before&quot;)</span><br><span class="line">		func(*args, **kwargs)</span><br><span class="line">		print(&quot;after&quot;)</span><br><span class="line">	return wrapper</span><br><span class="line"></span><br><span class="line">@deco</span><br><span class="line">def func():</span><br><span class="line">	print(&quot;hello&quot;)</span><br></pre></td></tr></table></figure></p>
<p>这里的deco函数就是最原始的装饰器，它的参数是一个函数，然后返回值也是一个函数。其中作为参数的这个函数func()就在返回函数wrapper()的内部执行。然后在函数func()前面加上@deco。<br>所以这里装饰器就像一个注入符号：有了它，拓展了原来函数的功能既不需要侵入函数内更改代码，也不需要重复执行原函数。<br>在func函数前还可以使用多个@的方式来执行多个装饰器，多个装饰器的执行顺序就是从最后一个装饰器开始执行到第一个装饰器，在执行函数本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def dec1(func):  </span><br><span class="line">    print(&quot;1111&quot;)  </span><br><span class="line">    def one():  </span><br><span class="line">        print(&quot;2222&quot;)  </span><br><span class="line">        func()  </span><br><span class="line">        print(&quot;3333&quot;)  </span><br><span class="line">    return one  </span><br><span class="line"></span><br><span class="line">def dec2(func):  </span><br><span class="line">    print(&quot;aaaa&quot;)  </span><br><span class="line">    def two():  </span><br><span class="line">        print(&quot;bbbb&quot;)  </span><br><span class="line">        func()  </span><br><span class="line">        print(&quot;cccc&quot;)  </span><br><span class="line">    return two  </span><br><span class="line"></span><br><span class="line">@dec1  </span><br><span class="line">@dec2  </span><br><span class="line">def test():  </span><br><span class="line">    print(&quot;test test&quot;)  </span><br><span class="line"></span><br><span class="line">test()  </span><br><span class="line"></span><br><span class="line">aaaa  </span><br><span class="line">1111  </span><br><span class="line">2222  </span><br><span class="line">bbbb  </span><br><span class="line">test test  </span><br><span class="line">cccc  </span><br><span class="line">3333</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL主从复制]]></title>
      <url>/2018/08/16/MySQL/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h3><p>将主数据库中的DDL和DML操作通过二进制日志文件传输到从数据库上，然后将这些日志重新执行（重做）；从而使从数据库的数据和主数据库的数据保持一致。</p>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ul>
<li>主数据库出现问题时，可以切换到从数据库</li>
<li>可以在数据库层面进行读写分离</li>
<li>可以在从数据库上进行备份操作</li>
</ul>
<h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p><img src="http://ocx5m3vc3.bkt.clouddn.com/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt=""><br>Binary log：主数据库的二进制文件<br>Relay log：从服务器的中继日志<br><a id="more"></a></p>
<ol>
<li>master在每个事物更新数据完成之前，将该操作记录串行地写入binlog文件中。</li>
<li>salve开启一个I/O线程，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的时间。I/O线程最终的目的是将这些事件写入到中继日志中。</li>
<li>SQL线程会读取中继日志，并顺序执行该日志中的SQL时间，从而与主数据库中的数据保持一致。</li>
</ol>
<h3 id="配置主从"><a href="#配置主从" class="headerlink" title="配置主从"></a>配置主从</h3><p>一、主服务器</p>
<ul>
<li>开启二进制日志</li>
<li>配置唯一的server-id</li>
<li>创建一个用于slave和master通信的用户账号</li>
<li>获得master二进制日志文件名及位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">basedir = /home/huzb/mysql</span><br><span class="line">datadir = /home/huzb/mysql/data</span><br><span class="line">port = 23307</span><br><span class="line">server_id = 119961011</span><br><span class="line">socket = /home/huzb/mysql/mysql_23307.sock</span><br><span class="line">log-bin = master-bin</span><br><span class="line">log-bin-index = master-bin.index</span><br><span class="line"> </span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"> </span><br><span class="line">[client]</span><br><span class="line">port = 23307</span><br><span class="line">socket = /home/huzb/mysql/mysql_23307.sock</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#添加复制权限的用户</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE USER &apos;repl&apos;@&apos;100.73.41.62&apos; IDENTIFIED BY &apos;slavepass&apos;;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;100.73.41.62&apos;;</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看master状态</span><br><span class="line"></span><br><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure>
<p>二、从服务器：</p>
<ul>
<li>配置唯一的server-id</li>
<li>使用master分配的用户账号读取master二进制日志</li>
<li>启动slave服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">basedir = /home/huzb/mysql</span><br><span class="line">datadir = /home/huzb/mysql/data</span><br><span class="line">port = 23306</span><br><span class="line">server_id = 220180801</span><br><span class="line">socket = /home/huzb/mysql/mysql_23306.sock</span><br><span class="line">relay-log = slave-relay-bin</span><br><span class="line">relay-log-index = slave-relay-bin.index</span><br><span class="line"> </span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"> </span><br><span class="line">[client]</span><br><span class="line">port = 23306</span><br><span class="line">socket = /home/huzb/mysql/mysql_23306.sock</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#添加master信息</span><br><span class="line"></span><br><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line"></span><br><span class="line">MASTER_HOST=&apos;100.73.41.53&apos;,</span><br><span class="line">MASTER_PORT=23307,</span><br><span class="line">MASTER_USER=&apos;repl&apos;,</span><br><span class="line">MASTER_PASSWORD=&apos;slavepass&apos;,</span><br><span class="line">MASTER_LOG_FILE=&apos;master-bin.000001&apos;,</span><br><span class="line">MASTER_LOG_POS=629;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动slave进程</span><br><span class="line"></span><br><span class="line">mysql&gt; start slave;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看slave状态</span><br><span class="line"></span><br><span class="line">当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL之备份]]></title>
      <url>/2018/08/11/MySQL/MySQL%E4%B9%8B%E5%A4%87%E4%BB%BD/</url>
      <content type="html"><![CDATA[<h2 id="备份的类型"><a href="#备份的类型" class="headerlink" title="备份的类型"></a>备份的类型</h2><h3 id="根据是否需要数据库离线"><a href="#根据是否需要数据库离线" class="headerlink" title="根据是否需要数据库离线"></a>根据是否需要数据库离线</h3><p>1、取决于业务的需求，而不是备份工具。<br>2、MyISAM不支持热备，INNODB支持热备，但是需要专门的工具。  </p>
<ul>
<li>冷备：需要关闭mysql服务，读写请求均不支持    状态下进行。</li>
<li>温备：服务在线，但仅支持读请求，不允许写请求。</li>
<li>热备：备份的同时，业务不受影响。</li>
</ul>
<h3 id="根据备份的数据集合的范围"><a href="#根据备份的数据集合的范围" class="headerlink" title="根据备份的数据集合的范围"></a>根据备份的数据集合的范围</h3><ul>
<li>完全备份：备份全部字符集。</li>
<li>增量备份：上一次完全备份或增量备份以来改变的数据。</li>
<li>差异备份：上一次完全备份以来改变的数。</li>
</ul>
<h3 id="根据备份数据或文件"><a href="#根据备份数据或文件" class="headerlink" title="根据备份数据或文件"></a>根据备份数据或文件</h3><ul>
<li>物理备份：直接备份数据文件。</li>
<li>逻辑备份：备份表中的数据和代码。<a id="more"></a>
</li>
</ul>
<h2 id="常用的备份工具"><a href="#常用的备份工具" class="headerlink" title="常用的备份工具"></a>常用的备份工具</h2><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>mysqldump是逻辑备份，所以使用这种备份方式数据的安全的。跨平台、版本都很容易。  </p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>mysqldump的优势是可以查看或者编辑十分方面，他可以灵活的恢复之前的数据。它也不关心底层的存储引擎，即适用于支持事务的，也适用于不支持事务的的表。  </p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>mysql的缺点是如果数据过大，即使备份步骤需要的时间不算太久，但有可能恢复数据的速度很慢，因为他涉及的SQL语句插入磁盘IO，创建索引等。</p>
<h3 id="mysqlhotcopy"><a href="#mysqlhotcopy" class="headerlink" title="mysqlhotcopy"></a>mysqlhotcopy</h3><p>mysqlhotcopy使用lock tables、flush tables、cp和scp来快速备份数据库。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>它是备份数据库或单个表最快的途径，完全属于物理备份。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>只能用于备份MyIsam和archive存储引擎；并且是一个服务器命令，只能运行在数据库目录所在的机器上。使用mysqlhotcopy命令之前需要安装相应的软件依赖包。</p>
<h3 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h3><p>Percona XtraBackup是一款基于MySQL的物理热备份的开源实用程序。xtrabackup基于innodb的crash-recovery（实例恢复）功能，先copy innodb的物理文件（这个时候数据的一致性是无法满足的），然后进行基于redo log进行恢复，达到数据的一致性。</p>
<h3 id="mysqlbackup"><a href="#mysqlbackup" class="headerlink" title="mysqlbackup"></a>mysqlbackup</h3><p>首先检测并应用全备事务日志文件，然后基于全备去应用增量的log。这个时候如果有多次增量备份也可以（基于LSN点向后应用）。所有的的应用完成之后就是一个可以直接cp的数据库了。</p>
<h2 id="备份和恢复的实现"><a href="#备份和恢复的实现" class="headerlink" title="备份和恢复的实现"></a>备份和恢复的实现</h2><ol>
<li>使用select into outfile实现数据的备份和还原。<br>1.1 把需要备份的数据备份出来<br>select * from test into outfile ‘/tmp/out.txt’;<br>1.2 导入<br>load data infile ‘/tmp/out.txt’ into table XXX;</li>
<li>利用mysqldump工具对数据进行备份和还原<br>mysqldump常用来做温备，所以需要对想备份的数据施加读锁。<br>2.1 施加读锁的方式：<br>2.1.1 直接在备份时添加选项<br>–lock-all-tables：对要备份的数据库的所有表施加读锁。<br>–lock-table：对单表施加读锁。<br>2.1.2 在服务端书写命令<br>mysql&gt;flush tables with read lock;施加锁，表示把内存上的表统统同步到磁盘上去后施加读锁。<br>mysql&gt;flush tables with read unlock;释放锁。<br>2.2 备份策略：完全备份+增量备份+二进制文件。</li>
</ol>
<ul>
<li>先给数据库做全量备份</li>
<li>回到mysql服务器更新数据</li>
<li>做增量备份</li>
<li>到处二进制文件</li>
<li>让mysql离线</li>
</ul>
<ol start="3">
<li>利用lvm快照实现几乎热备的数据备份和恢复</li>
<li>基于Xtrabackup做备份恢复<br>优势：</li>
</ol>
<ul>
<li>快速可靠的进行完全备份</li>
<li>在备份过程中会影响事务</li>
<li>支持数据流、网络传输、压缩，所以它可以有效的节约磁盘资源和网络带宽。</li>
<li>可以自动备份校验数据的可用性。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL之权限管理]]></title>
      <url>/2018/08/11/MySQL/Mysql%E4%B9%8B%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="一、MySQL权限简介"><a href="#一、MySQL权限简介" class="headerlink" title="一、MySQL权限简介"></a>一、MySQL权限简介</h2><p>关于mysql的权限简单的理解就是mysql允许你做你权利以内的事情，不可以越界。</p>
<h3 id="mysql权限控制的实现"><a href="#mysql权限控制的实现" class="headerlink" title="mysql权限控制的实现"></a>mysql权限控制的实现</h3><p>第一阶段：服务器首先会检查你是否允许连接。因为创建用户的时候会加上主机限制，可以限制成本地、IP、网段、任何地方等。只允许你从配置的指定地方登陆。<br>第二阶段：Mysql会检查你发出的每个请求，看你是否有足够的权限实施它。</p>
<table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:center">权限级别</th>
<th style="text-align:center">权限说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CREATE</td>
<td style="text-align:center">数据库、表或索引</td>
<td style="text-align:center">创建</td>
</tr>
<tr>
<td style="text-align:center">DROP</td>
<td style="text-align:center">数据库或表</td>
<td style="text-align:center">删除</td>
</tr>
<tr>
<td style="text-align:center">GRANT OPTION</td>
<td style="text-align:center">数据库、表或保存的程序</td>
<td style="text-align:center">赋予权限</td>
</tr>
<tr>
<td style="text-align:center">REFERENCES</td>
<td style="text-align:center">数据库或表</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ALTER</td>
<td style="text-align:center">表</td>
<td style="text-align:center">修改表</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">表</td>
<td style="text-align:center">删除数据</td>
</tr>
<tr>
<td style="text-align:center">INDEX</td>
<td style="text-align:center">表</td>
<td style="text-align:center">索引权限</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="二、MySQL权限实战"><a href="#二、MySQL权限实战" class="headerlink" title="二、MySQL权限实战"></a>二、MySQL权限实战</h2><ol>
<li>GRANT命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all privileges on *.* to jack@&apos;localhost&apos; identified by &quot;jack&quot; with grant option;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>grant:授予权限操作。</li>
<li>all:具体权限。(all代表所有权限，还可以为select、update、delete等单项权限选择)</li>
<li>on <em>.</em>:权限操作的数据库和表。(第一个<em>代表数据库，第二个</em>代表具体的表。<em>.</em>代表所有的库和表，可以指定具体库和表）</li>
<li>to user@ip:被授予权限的用户和ip。</li>
<li>identified by “passwd”:被授予用户的密码。</li>
<li>with grant option:是否拥有授予其他用户权限的权限。</li>
</ul>
<ol start="2">
<li>刷新权限：flush privileges;</li>
<li><p>查看权限：show grants;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">查看当前用户的权限：</span><br><span class="line">mysql&gt; show grants;</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">| Grants for root@localhost                                           |</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">| GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION |</span><br><span class="line">| GRANT PROXY ON &apos;&apos;@&apos;&apos; TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION        |</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">查看某个用户的权限：</span><br><span class="line">mysql&gt; show grants for &apos;jack&apos;@&apos;%&apos;;</span><br><span class="line">+-----------------------------------------------------------------------------------------------------+</span><br><span class="line">| Grants for jack@%                                                                                   |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------+</span><br><span class="line">| GRANT USAGE ON *.* TO &apos;jack&apos;@&apos;%&apos; IDENTIFIED BY PASSWORD &apos;*9BCDC990E611B8D852EFAF1E3919AB6AC8C8A9F0&apos; |</span><br><span class="line">+-----------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>回收权限：revoke</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; revoke delete on *.* from &apos;jack&apos;@&apos;localhost&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop user &apos;jack&apos;@&apos;localhost&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对用户重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; rename user &apos;jack&apos;@&apos;%&apos; to &apos;jim&apos;@&apos;%&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1、用set password命令</span><br><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">2、用mysqladmin</span><br><span class="line">[root@rhel5 ~]# mysqladmin -uroot -p123456 password 1234abcd</span><br><span class="line">备注：</span><br><span class="line">格式：mysqladmin -u用户名 -p旧密码 password 新密码</span><br><span class="line">3、用update直接编辑user表</span><br><span class="line">mysql&gt; use mysql</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; update user set PASSWORD = PASSWORD(&apos;1234abcd&apos;) where user = &apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">4、在丢失root密码的时候：</span><br><span class="line">[root@rhel5 ~]# mysqld_safe --skip-grant-tables &amp;</span><br><span class="line">[1] 15953</span><br><span class="line">[root@rhel5 ~]# 130911 09:35:33 mysqld_safe Logging to &apos;/mysql/mysql5.5/data/rhel5.4.err&apos;.</span><br><span class="line">130911 09:35:33 mysqld_safe Starting mysqld daemon with databases from /mysql/mysql5.5/data</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="三、MySQL权限经验原则"><a href="#三、MySQL权限经验原则" class="headerlink" title="三、MySQL权限经验原则"></a>三、MySQL权限经验原则</h2><ul>
<li>只授予能满足需要的最小权限。</li>
<li>创建用户时限制用户的登录主机，一般是限制成指定IP或内网IP段。</li>
<li>初始化数据库时删除没有密码的用户。</li>
<li>为每个用户设置满足密码复杂度的密码。</li>
<li>定期清理不需要的用户，回收权限或者删除用户。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[information_schema]]></title>
      <url>/2018/08/11/MySQL/information_schema/</url>
      <content type="html"><![CDATA[<h3 id="information-schema简介"><a href="#information-schema简介" class="headerlink" title="information_schema简介"></a>information_schema简介</h3><p>information_schema数据库是mysql系统自带的数据库，它提供了数据库元数据的访问方式。可以说information_schema就是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了解的信息，比如字符集、权限相关、数据库实体对象信息、外键等。</p>
<p>在每个MySQL实例中都有一个独立的information_schema，information_schema数据集库下包含多个只读表（非持久表），所以在磁盘中的数据目录下没有对应的关联文件，<font color="red">也是说数据库 重启后，这些数据会丢失。</font>且不能对这些表设置触发器、insert、update、delete等数据变更操作。</p>
<h4 id="访问information-schema需要的权限"><a href="#访问information-schema需要的权限" class="headerlink" title="访问information_schema需要的权限"></a>访问information_schema需要的权限</h4><p>所有用户都有访问information_schema下的表权限（但只能看到这些表中用户具有访问权限的对象相对应的数据行），只能访问Server层的部分数据字典表，Server层中的部分数据字典表以及InnoDB层的数据字典表需要额外授权才能访问，如果用户权限不足，则不会有数据显示；如果是某列没有访问权限，那么访问时该列会显示为NULL；访问InnoDB数据字典表需要有process权限。</p>
<a id="more"></a>
<p>MySQL5.6下的information_schema表<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show tables;</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| Tables_in_information_schema          |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| CHARACTER_SETS                        |</span><br><span class="line">| COLLATIONS                            |</span><br><span class="line">| COLLATION_CHARACTER_SET_APPLICABILITY |</span><br><span class="line">| COLUMNS                               |</span><br><span class="line">| COLUMN_PRIVILEGES                     |</span><br><span class="line">| ENGINES                               |</span><br><span class="line">| EVENTS                                |</span><br><span class="line">| FILES                                 |</span><br><span class="line">| GLOBAL_STATUS                         |</span><br><span class="line">| GLOBAL_VARIABLES                      |</span><br><span class="line">| KEY_COLUMN_USAGE                      |</span><br><span class="line">| OPTIMIZER_TRACE                       |</span><br><span class="line">| PARAMETERS                            |</span><br><span class="line">| PARTITIONS                            |</span><br><span class="line">| PLUGINS                               |</span><br><span class="line">| PROCESSLIST                           |</span><br><span class="line">| PROFILING                             |</span><br><span class="line">| REFERENTIAL_CONSTRAINTS               |</span><br><span class="line">| ROUTINES                              |</span><br><span class="line">| SCHEMATA                              |</span><br><span class="line">| SCHEMA_PRIVILEGES                     |</span><br><span class="line">| SESSION_STATUS                        |</span><br><span class="line">| SESSION_VARIABLES                     |</span><br><span class="line">| STATISTICS                            |</span><br><span class="line">| TABLES                                |</span><br><span class="line">| TABLESPACES                           |</span><br><span class="line">| TABLE_CONSTRAINTS                     |</span><br><span class="line">| TABLE_PRIVILEGES                      |</span><br><span class="line">| TRIGGERS                              |</span><br><span class="line">| USER_PRIVILEGES                       |</span><br><span class="line">| VIEWS                                 |</span><br><span class="line">| INNODB_LOCKS                          |</span><br><span class="line">| INNODB_TRX                            |</span><br><span class="line">| INNODB_SYS_DATAFILES                  |</span><br><span class="line">| INNODB_LOCK_WAITS                     |</span><br><span class="line">| INNODB_SYS_TABLESTATS                 |</span><br><span class="line">| INNODB_CMP                            |</span><br><span class="line">| INNODB_METRICS                        |</span><br><span class="line">| INNODB_CMP_RESET                      |</span><br><span class="line">| INNODB_CMP_PER_INDEX                  |</span><br><span class="line">| INNODB_CMPMEM_RESET                   |</span><br><span class="line">| INNODB_FT_DELETED                     |</span><br><span class="line">| INNODB_BUFFER_PAGE_LRU                |</span><br><span class="line">| INNODB_SYS_FOREIGN                    |</span><br><span class="line">| INNODB_SYS_COLUMNS                    |</span><br><span class="line">| INNODB_SYS_INDEXES                    |</span><br><span class="line">| INNODB_FT_DEFAULT_STOPWORD            |</span><br><span class="line">| INNODB_SYS_FIELDS                     |</span><br><span class="line">| INNODB_CMP_PER_INDEX_RESET            |</span><br><span class="line">| INNODB_BUFFER_PAGE                    |</span><br><span class="line">| INNODB_CMPMEM                         |</span><br><span class="line">| INNODB_FT_INDEX_TABLE                 |</span><br><span class="line">| INNODB_FT_BEING_DELETED               |</span><br><span class="line">| INNODB_SYS_TABLESPACES                |</span><br><span class="line">| INNODB_FT_INDEX_CACHE                 |</span><br><span class="line">| INNODB_SYS_FOREIGN_COLS               |</span><br><span class="line">| INNODB_SYS_TABLES                     |</span><br><span class="line">| INNODB_BUFFER_POOL_STATS              |</span><br><span class="line">| INNODB_FT_CONFIG                      |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">59 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<h3 id="CHARACTER-SETS（字符集）"><a href="#CHARACTER-SETS（字符集）" class="headerlink" title="CHARACTER_SETS（字符集）"></a>CHARACTER_SETS（字符集）</h3><p>CHARACTER_SETS表提供了有关字符集的信息，它包含了以下列：</p>
<ul>
<li>CHARACTER_SET_NAME：字符集名称</li>
<li>DEFAULT_COLLATE_NAME：默认字符集排序规则</li>
<li>DESCRIPTION：字符集描述</li>
<li>MAXLEN：存储一个字符需要的最大字节数</li>
</ul>
<h3 id="COLLATIONS（字符集排序规则）"><a href="#COLLATIONS（字符集排序规则）" class="headerlink" title="COLLATIONS（字符集排序规则）"></a>COLLATIONS（字符集排序规则）</h3><p>COLLATIONS表提供了有关每个字符集排序规则的信息，它包含以下列：</p>
<ul>
<li>COLLATION_NAME：排序规则名称</li>
<li>CHARACTER_SET_NAME：与排序规则关联的字符集的名称</li>
<li>ID：排序规则的ID</li>
<li>IS_DEFAULT：排序规则是否为其字符集的默认规则</li>
<li>IS_COMPILED：字符集是否编译到服务器中</li>
<li>SORTLEN：对应字符集中表示的字符串进行排序需要的内存量</li>
</ul>
<h3 id="COLLATION-CHARACTER-SET-APPLICABILITY（排序规则）"><a href="#COLLATION-CHARACTER-SET-APPLICABILITY（排序规则）" class="headerlink" title="COLLATION_CHARACTER_SET_APPLICABILITY（排序规则）"></a>COLLATION_CHARACTER_SET_APPLICABILITY（排序规则）</h3><p>表COLLATION_CHARACTER_SET_APPLICABILITY表示哪种字符集适用于哪种排序规则，它包含以下列：</p>
<ul>
<li>COLLATION_NAME：排序规则名称</li>
<li>CHARACTER_SET_NAME与培训规则关联的字符集名称</li>
</ul>
<h3 id="COLUMNS（列信息）"><a href="#COLUMNS（列信息）" class="headerlink" title="COLUMNS（列信息）"></a>COLUMNS（列信息）</h3><p>表COLUMNS提供表中列的信息，它包含以下列：</p>
<ul>
<li>TABLE_CATALOG：包含改列的表所属的目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA：包含改列的表所属的数据库名称</li>
<li>TABLE_NAME：包含改列的表的名称</li>
<li>COLUMN_NAME：列名</li>
<li>ORDINAL_POSITION：表中列的位置</li>
<li>COLUMN_DEFAULT：列的默认值</li>
<li>IS_NULLABLE：列是否可控</li>
<li>DATA_TYPE：列的数据类型</li>
<li>CHARACTER_MAXIMUM_LENGTH：对于字符串列，表示最大长度（以字符为单位）</li>
<li>CHARACTER_OCTET_LENGTH：对于字符串列，表示最大长度（以字节为单位）</li>
<li>NUMERIC_PRECISION：对于数字列，数字精度</li>
<li>NUMERIC_SCALE：对于数字列，数字刻度</li>
<li>DATETIME_PRECISION：对于时间列，小数秒精度</li>
<li>DATETIME_PRECISION：对于字符串列，字符集名称</li>
<li>COLLATION_NAME：对于字符串列，排序规则名称</li>
<li>COLUMN_TYPE：列数据类型，包含类名称以及可能的其他信息，列如精度或长度</li>
<li>COLUMN_TYPE：列是否编入索引</li>
<li>EXTRA：指定列的任何其他可用信息</li>
<li>PRIVILEGES：当前用户对改列的权限</li>
<li>COLUMN_COMMENT：列的注释</li>
<li>GENERATION_EXPRESSION：对于生成的列，显示用于计算列值的表达式</li>
</ul>
<h3 id="COLUMN-PRIVILEGES（列权限）"><a href="#COLUMN-PRIVILEGES（列权限）" class="headerlink" title="COLUMN_PRIVILEGES（列权限）"></a>COLUMN_PRIVILEGES（列权限）</h3><p>表COLUMN_PRIVILEGES提供有关列权限的信息，它是从mysql.columns_priv系统表中获取的信息。主要包含以下列：</p>
<ul>
<li>GRANTEE：授予权限的账户的名称，格式为’用户名‘@’主机名’</li>
<li>TABLE_CATALOG：包含该列的表所属的目录名称，总默认为def</li>
<li>TABLE_SCHEMA：包含该列的表所属数据库名称</li>
<li>TABLE_NAME：包含该列的表的名称</li>
<li>COLUMN_NAME：列的名称</li>
<li>PRIVILEGE_TYPE：授予的特权</li>
<li>IS_GRANTABLE：该用户是否能够将此列权利授予给他人</li>
</ul>
<h3 id="ENGINES（存储引擎）"><a href="#ENGINES（存储引擎）" class="headerlink" title="ENGINES（存储引擎）"></a>ENGINES（存储引擎）</h3><p>表ENGINES提供有关存储引擎的信息，这对于检查是否支持存储引擎或查看默认引擎是特别有用。主要包含以下列：</p>
<ul>
<li>ENGINE：存储引擎名称</li>
<li>SUPPORT：服务器对该存储引擎的支持级别</li>
<li>COMMENT：简要说明</li>
<li>TRANSACTIONS：是否支持XA事务</li>
<li>SAVEPOINTS：是否支持保存点</li>
</ul>
<h3 id="EVENTS（事件）"><a href="#EVENTS（事件）" class="headerlink" title="EVENTS（事件）"></a>EVENTS（事件）</h3><p>表EVENTS提供有关事件管理器事件的信息，它包含以下列：</p>
<ul>
<li>EVENT_CATALOG：事件所属目录的名称。该值始终为def</li>
<li>EVENT_SCHEMA：事件所属的数据库名称</li>
<li>EVENT_NAME：事件名称</li>
<li>DEFINER：创建事件的用户账号</li>
<li>TIME_ZONE：事件时区，默认为SYSTEM</li>
<li>EVENT_BODY：事件的DO子句中的语言，始终为SQL</li>
<li>EVENT_DEFINITION：事件执行的语句</li>
<li>EVENT_TYPE：事件重复类型，一次/重复</li>
<li>EXECUTE_AT：一次性事件执行事件点</li>
<li>INTERVAL_VALUE：重复事件的间隔时间</li>
<li>INTERVAL_FIELD：重复事件间隔的时间单位</li>
<li>SQL_MODE：创建或更改时间时生效的SQL模式，以及执行事件的情况</li>
<li>STARTS：重复事件开始的时间</li>
<li>ENDS：重复事件结束的时间</li>
<li>STATUS：事件状态。ENABLED|DISABLED|SLAVESIDE_DISABLED|SLAVESIDE_DISABLED</li>
<li>ON_COMPLETION：</li>
<li>CREATED：事件的创建事件</li>
<li>LAST_ALTERED：最后一次修改事件的时间</li>
<li>LAST_EXECUTED：最后一次执行事件的时间</li>
<li>EVENT_COMMENT：事件注释</li>
<li>ORIGINATOR：创建事件的MySQL服务器ID</li>
<li>CHARACTER_SET_CLIENT：创建事件时CHARACTER_SET_CLIENT系统变量的会话值</li>
<li>COLLATION_CONNECTION：创建事件时COLLATION_CONNECTION系统变量的会话值</li>
<li>DATABASE_COLLATION：与事件关联的数据库排序规则</li>
</ul>
<h3 id="FILES（文件）"><a href="#FILES（文件）" class="headerlink" title="FILES（文件）"></a>FILES（文件）</h3><p>表FILES提供有关存储MySQL表空间数据的文件信息，它包含以下列（innodb）：</p>
<ul>
<li>FILES_ID：表空间ID；</li>
<li>FILE_NAME：数据文件的名称</li>
<li>FILE_TYPE：表空间文件类型</li>
<li>TABLESPACE_NAME：表空间的SQL名称</li>
<li>TABLE_CATALOG：始终为空</li>
<li>TABLE_SCHEMA：始终为NULL</li>
<li>TABLE_NAME：始终为NULL</li>
<li>LOGFILE_GROUP_NAME：始终为NULL</li>
<li>LOGFILE_GROUP_NUMBER：始终为NULL</li>
<li>ENGINE：始终为INNODB</li>
<li>FULLTEXT_KEYS：始终为NULL</li>
<li>DELETED_ROWS：始终为NULL</li>
<li>UPDATE_COUNT：始终为NULL</li>
<li>FREE_EXTENTS：当前数据文件中完全空闲的extents数</li>
<li>TOTAL_EXTENTS：当前数据文件中使用的完整的extents的数量</li>
<li>EXTENT_SIZE：对于页面大小为4k/8k/16k的文件，范围大小为1048576(1MB),对于页面大小为32k的文件，范围大小为2097152(2MB)，对于页面大小为64k的文件，范围大小为4194304(4MB)。</li>
<li>INITIAL_SIZE：文件的初始大小（以字节为单位）。</li>
<li>MAXIMUM_SIZE：文件中允许的最大字节数</li>
<li>AUTOEXTEND_SIZE：系统表空间的innodb_data_file_path定义的自动扩展大小，或者是临时表空间的innodb_temp_data_file_path。</li>
<li>CREATION_TIME：始终为NULL</li>
<li>LAST_UPDATE_TIME：始终为NULL</li>
<li>LAST_ACCESS_TIME：始终为NULL</li>
<li>RECOVER_TIME：始终为NULL</li>
<li>TRANSACTION_COUNTER：始终为NULL</li>
<li>VERSION：始终为NULL</li>
<li>ROW_FORMAT：始终为NULL</li>
<li>TABLE_ROWS：始终为NULL</li>
<li>AVG_ROW_LENGTH：始终为NULL</li>
<li>DATA_LENGTH：始终为NULL</li>
<li>MAX_DATA_LENGTH：始终为NULL</li>
<li>INDEX_LENGTH：始终为NULL</li>
<li>DATA_FREE：整个表空间的可用空间总量（以字节为单位）</li>
<li>CREATE_TIME：始终为NULL</li>
<li>UPDATE_TIME：始终为NULL</li>
<li>CHECK_TIME：始终为NULL</li>
<li>CHECKSUM：始终为NULL</li>
<li>STATUS：默认为NORMAL</li>
<li>EXTRA：始终为NULL</li>
</ul>
<h3 id="GLOBAL-STATUS-与-SESSION-STATUS（服务器状态变量）"><a href="#GLOBAL-STATUS-与-SESSION-STATUS（服务器状态变量）" class="headerlink" title="GLOBAL_STATUS 与 SESSION_STATUS（服务器状态变量）"></a>GLOBAL_STATUS 与 SESSION_STATUS（服务器状态变量）</h3><p>GLOBAL_STATUS和SESSION_STATUS表提供有关服务器状态变量的信息。它们的内容对应于SHOW GLOBAL STATUS和SHOW SESSION STATUS语句产生的结果。<a href="https://dev.mysql.com/doc/refman/5.7/en/show-status.html" target="_blank" rel="noopener">SHOW STATUS语法</a></p>
<h3 id="GLOBAL-VARIABLES-与-SESSION-VARIABLES（服务器状态变量）"><a href="#GLOBAL-VARIABLES-与-SESSION-VARIABLES（服务器状态变量）" class="headerlink" title="GLOBAL_VARIABLES 与 SESSION_VARIABLES（服务器状态变量）"></a>GLOBAL_VARIABLES 与 SESSION_VARIABLES（服务器状态变量）</h3><p>GLOBAL_VARIABLES和SESSION_VARIABLES表提供有关服务器状态变量的信息，它们的内容对应于SHOW GLOBAL VARIABLES和SHOW SESSION VARIABLES语句产生的信息。<a href="https://dev.mysql.com/doc/refman/5.7/en/show-variables.html" target="_blank" rel="noopener">SHOW VARIABLES语法</a></p>
<h3 id="KEY-COLUMN-USAGE（键列约束）"><a href="#KEY-COLUMN-USAGE（键列约束）" class="headerlink" title="KEY_COLUMN_USAGE（键列约束）"></a>KEY_COLUMN_USAGE（键列约束）</h3><p>KEY_COLUMN_USAGE表描述哪些键列具有约束，它包含以下列：</p>
<ul>
<li>CONSTRAINT_CATALOG：约束所属目录的名称。该值始终为def</li>
<li>CONSTRAINT_SCHEMA：约束所属数据库名称</li>
<li>CONSTRAINT_NAME：约束名称</li>
<li>TABLE_CATALOG：表所属目录名称，该值始终为def</li>
<li>TABLE_SCHEMA：表所属数据库名称</li>
<li>TABLE_NAME：表名</li>
<li>COLUMN_NAME：具有约束的列的名称，如果约束是外键，则是外键的列，而不是外键引用的列。</li>
<li>ORDINAL_POSITION：列在约束内的位置，而不是列在表中的位置。</li>
<li>POSITION_IN_UNIQUE_CONSTRAINT：NULL对于唯一和主键约束。对于外键约束，此列是正在引用的表的键中的序号位置</li>
<li>REFERENCED_TABLE_SCHEMA：约束引用的数据库名称</li>
<li>REFERENCED_TABLE_NAME：约束引用的表的名称</li>
<li>REFERENCED_COLUMN_NAME：约束引用的列的名称</li>
</ul>
<h3 id="OPTIMIZER-TRACE（语句优化程序）"><a href="#OPTIMIZER-TRACE（语句优化程序）" class="headerlink" title="OPTIMIZER_TRACE（语句优化程序）"></a>OPTIMIZER_TRACE（语句优化程序）</h3><p>OPTIMIZER_TRACE表提供由跟踪语句的优化程序跟踪功能生成的信息，它包含以下列：</p>
<ul>
<li>QUERY：跟踪的文本</li>
<li>TRACE：以JSON格式跟踪</li>
<li>MISSING_BYTES_BEYOND_MAX_MEM_SIZE：跟踪的每个文件是一个字符串，随着优化的进行而扩展，并将数据附加到该字符串。</li>
<li>INSUFFICIENT_PRIVILEGES：如果跟踪查询使用具有值为DEFINER的SQL SECURITY的视图或存储例程，则可能会拒绝定义者以外的用户查看查询的跟踪。 在这种情况下，跟踪显示为空INSUFFICIENT_PRIVILEGES的值为1.否则，该值为0。</li>
</ul>
<h3 id="PARAMETERS（存储例程参数）"><a href="#PARAMETERS（存储例程参数）" class="headerlink" title="PARAMETERS（存储例程参数）"></a>PARAMETERS（存储例程参数）</h3><p>PARAMETERS表提供有关存储例程的参数（存储过程和存储函数）的参数以及存储函数的返回值的信息。</p>
<ul>
<li>SPECIFIC_CATALOG：包含参数的例程所属的目录的名称，该值始终为def</li>
<li>SPECIFIC_SCHEMA：包含参数的例程所属的数据库名称</li>
<li>SPECIFIC_NAME：包含参数的例程的名称</li>
<li>ORDINAL_POSITION：对于存储过程或函数的连续参数，ORDINAL_POSITION值为1，2，3等。对于存储函数，还有一行适用于函数返回值</li>
<li>PARAMETER_MODE：参数的模式</li>
<li>PARAMETER_NAME：参数的名称</li>
<li>DATA_TYPE：参数数据类型</li>
<li>CHARACTER_MAXIMUM_LENGTH：对于字符串，以字符为单位的最大长度</li>
<li>CHARACTER_OCTET_LENGTH：对于字符串，以字节为单位的最大长度</li>
<li>NUMERIC_PRECISION：对于数字参数，显示数字精度</li>
<li>NUMERIC_SCALE：对于数字参数，显示数字刻度</li>
<li>DATETIME_PRECISION：对于时间参数，以小数秒精度</li>
<li>CHARACTER_SET_NAME：对于字符串参数，字符集名称</li>
<li>COLLATION_NAME：对于字符串参数，排序规则名称</li>
<li>DTD_IDENTIFIER：参数数据类型</li>
<li>ROUTINE_TYPE：PROCEDURE用于存储过程， FUNCTION用于存储的函数</li>
</ul>
<h3 id="PARTITIONS（表分区）"><a href="#PARTITIONS（表分区）" class="headerlink" title="PARTITIONS（表分区）"></a>PARTITIONS（表分区）</h3><p>PARTITIONS表提供有关表分区的信息。</p>
<ul>
<li>TABLE_CATALOG：表所属目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA：表所属数据库名称</li>
<li>TABLE_NAME：分区表名称</li>
<li>PARTITION_NAME：分区名称</li>
<li>SUBPARTITION_NAME：如果PARTITIONS表行代表子分区，则为子分区的名称，否则为NULL</li>
<li>PARTITION_ORDINAL_POSITION：所有分区的索引顺序与它们的定义的顺序相同。</li>
<li>SUBPARTITION_ORDINAL_POSITION：给定分区中的子分区也被索引和重新索引，其方式与在表中索引分区的方式相同</li>
<li>PARTITION_METHOD：分区的方式。值RANGE，LIST，HASH，LINEAR HASH，KEY或LINEAR KEY之一</li>
<li>SUBPARTITION_METHOD：值HASH, LINEAR HASH, KEY, 或者 LINEAR KEY之一</li>
<li>PARTITION_EXPRESSION：创建表的当前分区方案的CREATE TABLE或ALTER TABLE语句中使用的分区函数的表达式</li>
</ul>
<h3 id="PLUGINS（插件）"><a href="#PLUGINS（插件）" class="headerlink" title="PLUGINS（插件）"></a>PLUGINS（插件）</h3><p>PLUGINS表提供有关服务器插件的信息</p>
<ul>
<li>PLUGINS_NAME：用于在诸如INSTALL PLUGINS和UNINSTALL PLUGINS之类的语句中引用插件的名称</li>
<li>PLUGIN_VERSION：插件的常规类型描述符中的版本。</li>
<li>PLUGIN_STATUS：插件状态，ACTIVE、INACTIVE、DISABLED或DELETED之一</li>
<li>PLUGIN_TYPE：插件的类型，列如STORAGE ENGINE，INFORMATION_SCHEMA或AUTHENTICATION。</li>
<li>PLUGIN_TYPE_VERSION：插件的特定于类型的描述符中的版本</li>
<li>PLUGIN_LIBRARY：插件共享库文件的名称</li>
<li>PLUGIN_LIBRARY_VERSION：插件API接口版本</li>
<li>PLUGIN_AUTHOR：插件作者</li>
<li>PLUGIN_DESCRIPTION：插件的简短描述</li>
<li>PLUGIN_LICENSE：插件如何获得许可</li>
<li>LOAD_OPTION：如何加载插件</li>
</ul>
<h3 id="PROCESSLIST（线程）"><a href="#PROCESSLIST（线程）" class="headerlink" title="PROCESSLIST（线程）"></a>PROCESSLIST（线程）</h3><p>PROCESSLIST表提供有关正在运行的线程的信息</p>
<ul>
<li>ID：连接标识符</li>
<li>USER：发出语句的用户</li>
<li>HOST：发出语句的客户端的主机名</li>
<li>DB：默认数据库</li>
<li>COMMAND：线程正在执行的命令类型</li>
<li>TIME：线程处于当前状态的时间</li>
<li>STATE：指示献出了正在执行的操作，事件或状态。</li>
<li>INFO：线程正在执行的语句</li>
</ul>
<h3 id="PROFILING（语句分析）"><a href="#PROFILING（语句分析）" class="headerlink" title="PROFILING（语句分析）"></a>PROFILING（语句分析）</h3><p>PROFILING表提供语句分析信息。其内容对应于SHOW PROFILE和SHOW PROFILES语句生成的信息。</p>
<ul>
<li>QUERY_ID：数字语句标识符</li>
<li>SEQ：一个序列号，指示具有相同QUERY_ID值得行的显示顺序</li>
<li>STATUS：状态</li>
<li>DURATION：语句执行在给定状态中保持多长时间，以秒为单位</li>
<li>CPU_USER：用户使用CPU时间，以s为单位</li>
<li>CPU_SYSTEM：系统使用CPU时间，以s为单位</li>
<li>CONTEXT_VOLUNTARY：发生了多少自愿的上下文切换</li>
<li>CONTEXT_INVOLUNTARY：发生了多少非自愿的上下文切换</li>
<li>BLOCK_OPS_IN：块输入操作数量</li>
<li>BLOCK_OPS_OUT：块输出操作数量</li>
<li>MESSAGES_SENT：发送的通信消息数</li>
<li>MESSAGES_RECEIVED：接受的通信消息数</li>
<li>PAGE_FAULTS_MAJOR：主页面错误数量</li>
<li>PAGE_FAULTS_MINOR：次页面错误数量</li>
<li>SWAPS：发生了多少次swap</li>
<li>SOURCE_FUNCTION：指配置文件状态在源代码function位置的执行的信息</li>
<li>SOURCE_FILE：指配置文件状态在源代码file位置的执行的信息</li>
<li>SOURCE_LINE：指配置文件状态在源代码line位置的执行的信息</li>
</ul>
<h3 id="REFERENTIAL-CONSTRAINTS（外键）"><a href="#REFERENTIAL-CONSTRAINTS（外键）" class="headerlink" title="REFERENTIAL_CONSTRAINTS（外键）"></a>REFERENTIAL_CONSTRAINTS（外键）</h3><p>REFERENTIAL_CONSTRAINTS表提供有关外键的信息</p>
<ul>
<li>CONSTRAINT_CATALOG：约束所属目录的名称，始终为def</li>
<li>CONSTRAINT_SCHEMA：约束所属数据库名称</li>
<li>CONSTRAINT_NAME：约束名称</li>
<li>UNIQUE_CONSTRAINT_CATALOG：包含约束引用的唯一约束的目录的名称，始终为def</li>
<li>UNIQUE_CONSTRAINT_SCHEMA：包含约束引用的唯一约束的数据库名称</li>
<li>UNIQUE_CONSTRAINT_NAME：约束引用的唯一约束的名称</li>
<li>MATCH_OPTION：约束MATCH属性的值</li>
<li>UPDATE_RULE：约束ON UPDATE属性的值，可能为CASCADE，SET NULL，SET DEFAULT，RESTRICT，NO ACTION</li>
<li>DELETE_RULE：约束ON DELETE属性的值。可能的值是CASCADE，SET NULL，SET DEFAULT，RESTRICT，NO ACTION</li>
<li>TABLE_NAME：表的名称</li>
<li>REFERENCED_TABLE_NAME：约束引用的表的名称</li>
</ul>
<h3 id="ROUTINES（存储例程）"><a href="#ROUTINES（存储例程）" class="headerlink" title="ROUTINES（存储例程）"></a>ROUTINES（存储例程）</h3><p>ROUTINES表提供有关存储例程的信息。ROUTINES表不包含内置SQL函数或用户定义函数（UDF）</p>
<ul>
<li>SPECIFIC_NAME：例程的名称</li>
<li>ROUTINE_CATALOG：例程所属目录名称，默认def</li>
<li>ROUTINE_SCHEMA：例程所属数据库名称</li>
<li>ROUTINE_NAME：例程名称</li>
<li>ROUTINE_TYPE：存储过程的PROCEDURE ，存储函数的FUNCTION</li>
<li>DATA_TYPE ：如果例程是存储函数，则返回值数据类型。如果例程是存储过程，则此值为空</li>
<li>CHARACTER_MAXIMUM_LENGTH：对于存储的函数字符串返回值，以字符为单位的最大长度。如果例程是存储过程，则此值为NULL</li>
<li>CHARACTER_OCTET_LENGTH ：对于存储的函数字符串返回值，以字节为单位的最大长度。如果例程是存储过程，则此值为NULL</li>
<li>NUMERIC_PRECISION ：对于存储函数数字返回值，数字精度。如果例程是存储过程，则此值为NULL</li>
<li>NUMERIC_SCALE ：对于存储的函数数字返回值，数字刻度。如果例程是存储过程，则此值为NULL</li>
<li>DATETIME_PRECISION ：对于存储的函数时间返回值，小数秒精度。如果例程是存储过程，则此值为NULL</li>
<li>CHARACTER_SET_NAME ：对于存储的函数字符串返回值，字符集名称。如果例程是存储过程，则此值为NULL</li>
<li>COLLATION_NAME ：对于存储的函数字符串返回值，排序规则名称。如果例程是存储过程，则此值为NULL</li>
<li>DTD_IDENTIFIER ：如果例程是存储函数，则返回值数据类型。如果例程是存储过程，则此值为空。DATA_TYPE值只是类型名称，没有其他信息。 DTD_IDENTIFIER值包含类型名称以及可能的其他信息，例如精度或长度</li>
<li>ROUTINE_BODY ：用于例程定义的语言。该值始终为SQL</li>
<li>ROUTINE_DEFINITION ：例程执行的SQL语句的文本</li>
<li>EXTERNAL_NAME ：此值始终为NULL</li>
<li>EXTERNAL_LANGUAGE ：存储例程的语言</li>
<li>PARAMETER_STYLE ：该值始终为SQL</li>
<li>IS_DETERMINISTIC ：yes或no，取决于是否使用DETERMINISTIC特性定义例程</li>
<li>SQL_DATA_ACCESS ：例程的数据访问特性。该值是CONTAINS SQL，NO SQL，READS SQL DATA或MODIFIES SQL DATA之一</li>
<li>SQL_PATH ：此值始终为NULL</li>
<li>SECURITY_TYPE ：例程SQL SECURITY特性。该值是DEFINER或INVOKER之一</li>
<li>CREATED ：创建例程的日期和时间。这是TIMESTAMP值</li>
<li>LAST_ALTERED ：上次修改例程的日期和时间。这是TIMESTAMP值。如果例程自创建以来未被修改，则此值与CREATED值相同</li>
<li>SQL_MODE ：创建或更改例程时执行的SQL模式，以及执行例程的情况</li>
<li>ROUTINE_COMMENT ：如果例程有注释，则以文本显示。反正，则为空</li>
<li>DEFINER ：以“user_name”@“host_name”格式创建例程的用户的帐户</li>
<li>CHARACTER_SET_CLIENT ：创建例程时character_set_client系统变量的会话值</li>
<li>COLLATION_CONNECTION ：创建例程时collat​​ion_connection系统变量的会话值</li>
<li>DATABASE_COLLATION ：与例程关联的数据库的排序规则</li>
</ul>
<h3 id="SCHEMATA（数据库）"><a href="#SCHEMATA（数据库）" class="headerlink" title="SCHEMATA（数据库）"></a>SCHEMATA（数据库）</h3><p>SCHEMATA表提供有关数据库的信息</p>
<ul>
<li>CATALOG_NAME：SCHEMA所属目录的名称。该值始终为def</li>
<li>SCHEMA_NAME ：SCHEMA名称</li>
<li>DEFAULT_CHARACTER_SET_NAME：SCHEMA默认字符集</li>
<li>DEFAULT_COLLATION_NAME ：SCHEMA字符集排序规则</li>
<li>SQL_PATH ：此值始终为NULL</li>
</ul>
<h3 id="SCHEMA-PRIVILEGES（数据库权限）"><a href="#SCHEMA-PRIVILEGES（数据库权限）" class="headerlink" title="SCHEMA_PRIVILEGES（数据库权限）"></a>SCHEMA_PRIVILEGES（数据库权限）</h3><p>SCHEMA_PRIVILEGES表提供有关数据库权限的信息，从mysql.db系统表获取值</p>
<ul>
<li>GRANTEE ：授予权限的帐户的名称，格为“user_name”@“host_name”</li>
<li>TABLE_CATALOG ：schema所属目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA ：schema的名称</li>
<li>PRIVILEGE_TYPE：授予的特权。</li>
<li>IS_GRANTABLE ：如果用户具有GRANT OPTION权限，则为YES，否则为NO</li>
</ul>
<h3 id="STATISTICS（表索引）"><a href="#STATISTICS（表索引）" class="headerlink" title="STATISTICS（表索引）"></a>STATISTICS（表索引）</h3><p>STATISTICS表提供有关表索引的信息</p>
<ul>
<li>TABLE_CATALOG：包含索引的表所属的目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA ：包含索引的表所属的schema（数据库）的名称</li>
<li>TABLE_NAME ：包含索引的表的名称</li>
<li>NON_UNIQUE ：如果索引不能包含重复项，则为0;如果可以，则为1</li>
<li>INDEX_SCHEMA ：索引所属的schema（数据库）的名称</li>
<li>INDEX_NAME ：索引的名称。如果索引是主键，则名称始终为PRIMARY</li>
<li>SEQ_IN_INDEX ：索引中的列序列号，以1开头</li>
<li>COLUMN_NAME ：列名称</li>
<li>COLLATION ：列如何在索引中排序</li>
<li>CARDINALITY ：估计索引中唯一值的数量</li>
<li>SUB_PART ：索引前缀</li>
</ul>
<h3 id="TABLES（表）"><a href="#TABLES（表）" class="headerlink" title="TABLES（表）"></a>TABLES（表）</h3><p>TABLES表提供有关数据库中表的信息，它包含以下列：</p>
<ul>
<li>TABLE_CATALOG：表所属目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA：表所在库的名称</li>
<li>TABLE_NAME：表名称</li>
<li>TABLE_TYPE：BASE TABLE(表)、VIEW(视图)、SYSTEM VIEW(INFORMATION_SCHEMA库中的表)</li>
<li>ENGINE：表的存储引擎</li>
<li>VERSION：表的.frm文件的版本号</li>
<li>ROW_FORMAT：行存储格式</li>
<li>TABLE_ROWS：行数</li>
<li>AVG_ROW_LENGTH：平均行长</li>
<li>DATA_LENGTH：对于MyISAM表，代表数据文件的长度，单位为字节；对于Innodb，代表聚簇索引配置的近似内存量，单位为字节</li>
<li>MAX_DATA_LENGTH：数据文件的最大长度</li>
<li>INDEX_LENGTH：索引文件的长度</li>
<li>DATA_FREE：已分配但未使用的字节数</li>
<li>AUTO_INCREMENT：自增主键的下一个值</li>
<li>CREATE_TIME：创建表的时间</li>
<li>UPDATE_TIME：上次更新数据文件的时间</li>
<li>CHECK_TIME：上次检查表的时间</li>
<li>TABLE_COLLATION：表的默认排序规则</li>
<li>CHECKSUM：实时校验和值</li>
<li>CREATE_OPTIONS：CREATE TABLE使用的额外选项</li>
<li>TABLE_COMMENT：创建表时使用的注释</li>
</ul>
<h3 id="TABLESPACES（表空间）"><a href="#TABLESPACES（表空间）" class="headerlink" title="TABLESPACES（表空间）"></a>TABLESPACES（表空间）</h3><p>TABLESPACES表提供有关活动MySQL Cluster表空间的信息</p>
<ul>
<li>TABLESPACE_NAME ：表空间名称</li>
<li>ENGINE ：表空间使用的存储引擎名称</li>
<li>TABLESPACE_TYPE ：表空间类型</li>
<li>LOGFILE_GROUP_NAME：分配给表空间的日志文件组的名称</li>
<li>EXTENT_SIZE ：属于表空间的文件使用的扩展区的大小（以字节为单位）</li>
<li>AUTOEXTEND_SIZE ：不使用</li>
<li>MAXIMUM_SIZE ：不使用</li>
<li>NODEGROUP_ID ：不使用</li>
<li>TABLESPACE_COMMENT：不使用</li>
</ul>
<h3 id="TABLE-CONSTRAINTS（表约束）"><a href="#TABLE-CONSTRAINTS（表约束）" class="headerlink" title="TABLE_CONSTRAINTS（表约束）"></a>TABLE_CONSTRAINTS（表约束）</h3><p>TABLE_CONSTRAINTS表描述哪些表具有约束</p>
<ul>
<li>CONSTRAINT_CATALOG：约束所属目录的名称。该值始终为def</li>
<li>CONSTRAINT_SCHEMA ：约束所属的schema（数据库）的名称</li>
<li>CONSTRAINT_NAME ：约束名称</li>
<li>TABLE_SCHEMA ：表所属的schema（数据库）的名称</li>
<li>TABLE_NAME ：表名称</li>
<li>CONSTRAINT_TYPE ：约束的类型</li>
</ul>
<h3 id="TABLE-PRIVILEGES（表权限）"><a href="#TABLE-PRIVILEGES（表权限）" class="headerlink" title="TABLE_PRIVILEGES（表权限）"></a>TABLE_PRIVILEGES（表权限）</h3><p>TABLE_PRIVILEGES表提供有关表权限的信息，它从mysql.tables_priv系统表中获取值。</p>
<ul>
<li>GRANTEE ：授予权限的帐户的名称，格为”user_name”@”host_name”</li>
<li>TABLE_CATALOG ：表所属目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA ：表所属的schema（数据库）的名称</li>
<li>TABLE_NAME ：表名称</li>
<li>PRIVILEGE_TYPE：授予的特权</li>
<li>IS_GRANTABLE ：如果用户具有GRANT OPTION权限，则为YES，否则为NO</li>
</ul>
<h3 id="TRIGGERS（触发器）"><a href="#TRIGGERS（触发器）" class="headerlink" title="TRIGGERS（触发器）"></a>TRIGGERS（触发器）</h3><p>TRIGGERS表提供有关触发器的信息</p>
<ul>
<li>TRIGGER_CATALOG：触发器所属目录的名称。该值始终为def</li>
<li>TRIGGER_SCHEMA ：触发器所属schema（database）的名称</li>
<li>TRIGGER_NAME ：触发器名称</li>
<li>EVENT_MANIPULATION ：触发事件</li>
<li>EVENT_OBJECT_CATALOG，EVENT_OBJECT_SCHEMA，EVENT_OBJECT_TABLE：如“使用触发器”中所述，每个触发器只与一个表相关联。 这些列分别表示此表所在的目录和schema（数据库）以及表名。 EVENT_OBJECT_CATALOG值始终为def</li>
<li>ACTION_ORDER ：触发器操作在具有相同EVENT_MANIPULATION和ACTION_TIMING值的同一表上的触发器列表中的序号位置</li>
<li>ACTION_CONDITION ：此值始终为NULL</li>
<li>ACTION_STATEMENT ：触发体</li>
<li>ACTION_ORIENTATION ：该值始终为ROW</li>
<li>ACTION_TIMING ：触发器在触发事件之前还是之后激活</li>
<li>ACTION_REFERENCE_OLD_TABLE：此值始终为NULL</li>
<li>ACTION_REFERENCE_NEW_TABLE：此值始终为NULL</li>
<li>ACTION_REFERENCE_OLD_ROW,ACTION_REFERENCE_NEW_ROW：分别是旧的和新的列标识符。 ACTION_REFERENCE_OLD_ROW值始终为OLD，ACTION_REFERENCE_NEW_ROW值始终为NEW</li>
<li>CREATED ：创建触发器的日期和时间</li>
<li>SQL_MODE ：创建触发器时生效的SQL模式，以及触发器执行的模式</li>
<li>DEFINER ：以‘user_name‘@’host_name’格式创建触发器的用户的帐户</li>
<li>CHARACTER_SET_CLIENT ：创建触发器时character_set_client系统变量的会话值</li>
<li>COLLATION_CONNECTION ：创建触发器时collat​​ion_connection系统变量的会话值</li>
<li>DATABASE_COLLATION ：与触发器关联的数据库的排序规则</li>
</ul>
<h3 id="USER-PRIVILEGES（全局特权）"><a href="#USER-PRIVILEGES（全局特权）" class="headerlink" title="USER_PRIVILEGES（全局特权）"></a>USER_PRIVILEGES（全局特权）</h3><p>USER_PRIVILEGES提供有关全局特权的信息，它从mysql.user系统表中获取值</p>
<ul>
<li>GRANTEE ：授予权限的帐户的名称，格为‘user_name‘@’host_name’</li>
<li>TABLE_CATALOG ：目录的名称。该值始终为def</li>
<li>PRIVILEGE_TYPE：授予的特权</li>
<li>IS_GRANTABLE ：如果用户具有GRANT OPTION权限，则为YES，否则为NO</li>
</ul>
<h3 id="VIEWS（视图）"><a href="#VIEWS（视图）" class="headerlink" title="VIEWS（视图）"></a>VIEWS（视图）</h3><p>VIEWS表提供数据库视图信息</p>
<ul>
<li>TABLE_CATALOG ：视图所属目录的名称。该值始终为def</li>
<li>TABLE_SCHEMA ：视图所属的schema（数据库）的名称</li>
<li>TABLE_NAME ：视图名称</li>
<li>VIEW_DEFINITION ：提供视图定义的SELECT语句</li>
<li>CHECK_OPTION ：CHECK_OPTION属性的值</li>
<li>IS_UPDATABLE ：MySQL在CREATE VIEW时设置一个标志，称为视图可更新性标志</li>
<li>DEFINER ：以’user_name’@’host_name’格式创建视图的用户的帐户</li>
<li>SECURITY_TYPE ：视图SQL SECURITY特性。该值是DEFINER或INVOKER之一</li>
<li>CHARACTER_SET_CLIENT：创建视图时character_set_client系统变量的会话值</li>
<li>COLLATION_CONNECTION：创建视图时collat​​ion_connection系统变量的会话值</li>
</ul>
<h3 id="INNODB-LOCKS"><a href="#INNODB-LOCKS" class="headerlink" title="INNODB_LOCKS"></a>INNODB_LOCKS</h3><p>INNODB_LOCKS提供innodb引擎事务中正在请求的且并未获得的且同时阻塞了其他事务的锁信息（即没有发生不同事务之间的锁等待信息，在这里看不到）。该表中的内容可以用于诊断高并发下的锁争用信息。</p>
<h3 id="INNODB-TRX"><a href="#INNODB-TRX" class="headerlink" title="INNODB_TRX"></a>INNODB_TRX</h3><p>INNODB_TRX提供当前在InnoDB引擎中执行的每个事务（不包括只读事务）的信息，包括事务是否正在锁等待、事务什么时候开始、以及事务正在执行的SQL语句文本信息等。</p>
<h3 id="INNODB-SYS-DATAFILES"><a href="#INNODB-SYS-DATAFILES" class="headerlink" title="INNODB_SYS_DATAFILES"></a>INNODB_SYS_DATAFILES</h3><p>INNODB_SYS_DATAFILES提供InnoDB file-per-table和常规表空间数据文件的路径，等同于InnoDB数据字典中SYS_DATAFILES表信息。该表中的信息包含InnoDB所有表空间类型的元数据，包括独立表空间、常规表空间、系统表空间、临时表空间和undo表空间。</p>
<h3 id="INNODB-LOCK-WAITS"><a href="#INNODB-LOCK-WAITS" class="headerlink" title="INNODB_LOCK_WAITS"></a>INNODB_LOCK_WAITS</h3><p>INNODB_LOCK_WAITS提供查询关于每个被阻塞的InnoDB事务的锁等待记录，包括发生锁等事务所请求的锁和阻止该锁请求被授予的表。</p>
<h3 id="INNODB-SYS-TABLESTATS"><a href="#INNODB-SYS-TABLESTATS" class="headerlink" title="INNODB_SYS_TABLESTATS"></a>INNODB_SYS_TABLESTATS</h3><p>INNODB_SYS_TABLESTATS提供查询有关InnoDB表较低级别的状态信息视图。MySQL优化器会使用这些统计信息来计算并确定在查询InnoDB表时使用哪个索引。</p>
<h3 id="INNODB-CMP和INNODB-CMP-RESET"><a href="#INNODB-CMP和INNODB-CMP-RESET" class="headerlink" title="INNODB_CMP和INNODB_CMP_RESET"></a>INNODB_CMP和INNODB_CMP_RESET</h3><p>这两个表中的数据包含了与压缩的InnoDB表页有关的操作的状态信息。表中记录的数据为测量数据库中的InnoDB表压缩的有效性提供参考。</p>
<h3 id="INNODB-METRICS"><a href="#INNODB-METRICS" class="headerlink" title="INNODB_METRICS"></a>INNODB_METRICS</h3><p>INNODB_METRICS提供查询InnoDB更为详细细致的性能信息，是对InnoDB的P_S的补充。通过对该表的查询，可用于检查InnoDB的整体健康状况。也可用于诊断性能瓶颈、资源短缺和应用程序的问题。</p>
<h3 id="INNODB-CMP-PER-INDEX和INNODB-CMP-PER-INDEX-RESET"><a href="#INNODB-CMP-PER-INDEX和INNODB-CMP-PER-INDEX-RESET" class="headerlink" title="INNODB_CMP_PER_INDEX和INNODB_CMP_PER_INDEX_RESET"></a>INNODB_CMP_PER_INDEX和INNODB_CMP_PER_INDEX_RESET</h3><p>这两个表中记录着InnoDB压缩表数据和索引相关的操作状态信息。对数据库、表、索引的每个组合使用不同的统计信息，一遍评估特定表的压缩性能和使用性提供参考数据。</p>
<h3 id="INNODB-CMPMEM和INNODB-CMPMEM-RESET"><a href="#INNODB-CMPMEM和INNODB-CMPMEM-RESET" class="headerlink" title="INNODB_CMPMEM和INNODB_CMPMEM_RESET"></a>INNODB_CMPMEM和INNODB_CMPMEM_RESET</h3><p>这两个表记录着InnoDB缓冲池中压缩页上的状态信息，为测量数据库中InnoDB表压缩的有效性提供了参考。</p>
<h3 id="INNODB-FT-DELETED"><a href="#INNODB-FT-DELETED" class="headerlink" title="INNODB_FT_DELETED"></a>INNODB_FT_DELETED</h3><p>INNODB_FT_DELETED提供查询InnoDB表的FULLTEXT索引中删除的行信息。它的存在是为了避免在InnoDB 全文索引的DML操作期间进行昂贵的索引重组操作，新删除的全文索引中单词的信息将单独存储在该表中，在执行文本搜索时从中过滤出搜索结果，该表中的信息仅在执行OPTIMIZE TABLE语句时清空。</p>
<h3 id="INNODB-BUFFER-PAGE-LRU"><a href="#INNODB-BUFFER-PAGE-LRU" class="headerlink" title="INNODB_BUFFER_PAGE_LRU"></a>INNODB_BUFFER_PAGE_LRU</h3><p>INNODB_BUFFER_PAGE_LRU提供查询缓冲池中的页面信息，与INNODB_BUFFER_PAGE表不同，INNODB_BUFFER_PAGE_LRU表保存有关innodb buffer pool中的页如何进入LRU链表以及在buffer pool不够用时确定需要从缓冲池中逐出哪些页</p>
<h3 id="INNODB-SYS-FOREIGN"><a href="#INNODB-SYS-FOREIGN" class="headerlink" title="INNODB_SYS_FOREIGN"></a>INNODB_SYS_FOREIGN</h3><p>INNODB_SYS_FOREIGN提供查询有关InnoDB外键的元数据信息，等同于InnoDB数据字典内部SYS_FOREIGN表的信息</p>
<h3 id="INNODB-SYS-COLUMNS"><a href="#INNODB-SYS-COLUMNS" class="headerlink" title="INNODB_SYS_COLUMNS"></a>INNODB_SYS_COLUMNS</h3><p>INNODB_SYS_COLUMNS提供有关查询有关InnoDB表列的元数据信息，等同于InnoDB数据字典内部SYS_COLUMNS表的信息</p>
<h3 id="INNODB-SYS-INDEXES"><a href="#INNODB-SYS-INDEXES" class="headerlink" title="INNODB_SYS_INDEXES"></a>INNODB_SYS_INDEXES</h3><p>提供查询有关InnoDB索引的元数据信息，等同于InnoDB数据字典内部SYS_INDEXES表中的信息</p>
<h3 id="INNODB-FT-DEFAULT-STOPWORD"><a href="#INNODB-FT-DEFAULT-STOPWORD" class="headerlink" title="INNODB_FT_DEFAULT_STOPWORD"></a>INNODB_FT_DEFAULT_STOPWORD</h3><p>该表为默认的全文索引停用词表，提供查询停用词列表值。</p>
<h3 id="INNODB-SYS-FIELDS"><a href="#INNODB-SYS-FIELDS" class="headerlink" title="INNODB_SYS_FIELDS"></a>INNODB_SYS_FIELDS</h3><p>提供查询有关InnoDB索引键列（字段）的元数据信息，等同于InnoDB数据字典内部SYS_FIELDS表的信息</p>
<h3 id="INNODB-BUFFER-PAGE"><a href="#INNODB-BUFFER-PAGE" class="headerlink" title="INNODB_BUFFER_PAGE"></a>INNODB_BUFFER_PAGE</h3><p>提供查询关于buffer pool中的页相关的信息</p>
<h3 id="INNODB-FT-INDEX-TABLE"><a href="#INNODB-FT-INDEX-TABLE" class="headerlink" title="INNODB_FT_INDEX_TABLE"></a>INNODB_FT_INDEX_TABLE</h3><p>提供查询关于innodb表全文索引中用于反向文本查找的倒排索引的分词信息</p>
<h3 id="INNODB-FT-BEING-DELETED"><a href="#INNODB-FT-BEING-DELETED" class="headerlink" title="INNODB_FT_BEING_DELETED"></a>INNODB_FT_BEING_DELETED</h3><p>该表仅在OPTIMIZE TABLE语句执行维护操作期间作为INNODB_FT_DELETED表的快照数据存放使用。</p>
<h3 id="INNODB-SYS-TABLESPACES"><a href="#INNODB-SYS-TABLESPACES" class="headerlink" title="INNODB_SYS_TABLESPACES"></a>INNODB_SYS_TABLESPACES</h3><p>提供查询有关InnoDB独立表空间和普通表空间的元数据信息（也包含了全文索引表空间），等同于InnoDB数据字典内部SYS_TABLESPACES表中的信息</p>
<h3 id="INNODB-FT-INDEX-CACHE"><a href="#INNODB-FT-INDEX-CACHE" class="headerlink" title="INNODB_FT_INDEX_CACHE"></a>INNODB_FT_INDEX_CACHE</h3><p>提供查询包含FULLTEXT索引的innodb存储引擎表中新插入行的全文索引标记信息。它存在的目的是为了避免在DML操作期间进行昂贵的索引重组，新插入的全文索引的单词的信息被单独存储在该表中，直到对表执行OPTIMIZE TABLE语句时、或者关闭服务器时、或者当高速缓存中存放的信息大小超过了innodb_ft_cache_size或innodb_ft_total_cache_size系统配置参数指定的大小才会执行清理。默认不记录数据，需要使用innodb_ft_aux_table系统配置参数指定需要记录哪个表中的新插入行的全文索引数据</p>
<h3 id="INNODB-SYS-FOREIGN-COLS"><a href="#INNODB-SYS-FOREIGN-COLS" class="headerlink" title="INNODB_SYS_FOREIGN_COLS"></a>INNODB_SYS_FOREIGN_COLS</h3><p>提供查询有关InnoDB外键列的状态信息，等同于InnoDB数据字典内部SYS_FOREIGN_COLS表的信息</p>
<h3 id="INNODB-SYS-TABLES"><a href="#INNODB-SYS-TABLES" class="headerlink" title="INNODB_SYS_TABLES"></a>INNODB_SYS_TABLES</h3><p>提供查询有关InnoDB表的元数据，等同于InnoDB数据字典内部SYS_TABLES表的信息</p>
<h3 id="INNODB-BUFFER-POOL-STATS"><a href="#INNODB-BUFFER-POOL-STATS" class="headerlink" title="INNODB_BUFFER_POOL_STATS"></a>INNODB_BUFFER_POOL_STATS</h3><p>提供查询一些Innodb buffer pool中的状态信息，该表中记录的信息与SHOW ENGINE INNODB STATUS输出的信息类似相同，另外，innodb buffer pool的一些状态变量也提供了部分相同的值</p>
<h3 id="INNODB-FT-CONFIG"><a href="#INNODB-FT-CONFIG" class="headerlink" title="INNODB_FT_CONFIG"></a>INNODB_FT_CONFIG</h3><p>提供查询有关InnoDB表的FULLTEXT索引和关联的元数据信息。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python获取本机IP]]></title>
      <url>/2018/07/21/python/%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAIP/</url>
      <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_host_ip</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">      s.connect((<span class="string">'8.8.8.8'</span>, <span class="number">80</span>))</span><br><span class="line">      ip = s.getsockname()[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">      s.close()</span><br><span class="line">  <span class="keyword">return</span> ip</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（6）-压缩列表]]></title>
      <url>/2018/06/12/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%886%EF%BC%89--%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>压缩列表：压缩列表是列表键和哈希键的底层实现之一。为了提高内存存储效率而升级的。<br>当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis会使用压缩列表来做列表键的底层实现。</p>
<p><code>注：redis 3.2以后，quicklist作为列表键的底层实现之一，代替了压缩列表。</code></p>
<h2 id="压缩列表的组成"><a href="#压缩列表的组成" class="headerlink" title="压缩列表的组成"></a>压缩列表的组成</h2><p><a href="https://imgchr.com/i/V73HxI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73HxI.md.jpg" alt="V73HxI.md.jpg"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 保存 ziplist 节点信息的结构</span><br><span class="line"> */</span><br><span class="line">typedef struct zlentry &#123;</span><br><span class="line"></span><br><span class="line">    // prevrawlen ：前置节点的长度</span><br><span class="line">    // prevrawlensize ：编码 prevrawlen 所需的字节大小</span><br><span class="line">    unsigned int prevrawlensize, prevrawlen;</span><br><span class="line"></span><br><span class="line">    // len ：当前节点值的长度</span><br><span class="line">    // lensize ：编码 len 所需的字节大小</span><br><span class="line">    unsigned int lensize, len;</span><br><span class="line"></span><br><span class="line">    // 当前节点 header 的大小</span><br><span class="line">    // 等于 prevrawlensize + lensize</span><br><span class="line">    unsigned int headersize;</span><br><span class="line"></span><br><span class="line">    // 当前节点值所使用的编码类型</span><br><span class="line">    unsigned char encoding;</span><br><span class="line"></span><br><span class="line">    // 指向当前节点的指针</span><br><span class="line">    unsigned char *p;</span><br><span class="line"></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>
<p>虽然定义了这个结构体，但是根本就没有使用zlentry结构来作为压缩列表中用来存储数据节点中的结构。<br>因为这个结构存小整数或短字符是在太浪费空间了。这个结构总共在32位机占用28个字节，64位机占用32个字节。这不符合压缩列表的设计目的。<br>压缩列表的节点真正结构如下图：<br><a href="https://imgchr.com/i/V73TGd" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73TGd.md.jpg" alt="V73TGd.md.jpg"></a></p>
<ul>
<li>prev_entry_len：记录前驱节点的长度</li>
<li>encoding：记录当前节点的value成员的数据类型以及长度</li>
<li>value：根据encoding保存字节数组或整数</li>
</ul>
<h2 id="prev-entry-len"><a href="#prev-entry-len" class="headerlink" title="prev_entry_len"></a>prev_entry_len</h2><p>prev_entry_len成员实际上就是zlentry结构中prevrawlensize,和prevrawlen这两个成员的压缩版。<br>这两个成员都是int类型，因此将两者压缩为一个成员prev_entry_len。分别对不同长度的前驱节点使用不同的字节数表示：<br>1) 如果前置节点的长度小于 254 字节，那么程序将使用 1 个字节来保存这个长度值。<br>2) 如果前置节点的长度大于等于 254 字节，那么程序将使用 5 个字节来保存这个长度值：<br>    a) 第 1 个字节的值将被设为 254 ，用于标识这是一个 5 字节长的长度值。<br>    b) 之后的 4 个字节则用于保存前置节点的实际长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/* Encode the length of the previous entry and write it to &quot;p&quot;. Return the</span><br><span class="line"> * number of bytes needed to encode this length if &quot;p&quot; is NULL. </span><br><span class="line"> *</span><br><span class="line"> * 对前置节点的长度 len 进行编码，并将它写入到 p 中，</span><br><span class="line"> * 然后返回编码 len 所需的字节数量。</span><br><span class="line"> *</span><br><span class="line"> * 如果 p 为 NULL ，那么不进行写入，仅返回编码 len 所需的字节数量。</span><br><span class="line"> *</span><br><span class="line"> * T = O(1)</span><br><span class="line"> */</span><br><span class="line">static unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) &#123;</span><br><span class="line"></span><br><span class="line">    // 仅返回编码 len 所需的字节数量</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        return (len &lt; ZIP_BIGLEN) ? 1 : sizeof(len)+1;</span><br><span class="line"></span><br><span class="line">    // 写入并返回编码 len 所需的字节数量</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // 1 字节</span><br><span class="line">        if (len &lt; ZIP_BIGLEN) &#123;</span><br><span class="line">            p[0] = len;</span><br><span class="line">            return 1;</span><br><span class="line"></span><br><span class="line">        // 5 字节</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 添加 5 字节长度标识</span><br><span class="line">            p[0] = ZIP_BIGLEN;</span><br><span class="line">            // 写入编码</span><br><span class="line">            memcpy(p+1,&amp;len,sizeof(len));</span><br><span class="line">            // 如果有必要的话，进行大小端转换</span><br><span class="line">            memrev32ifbe(p+1);</span><br><span class="line">            // 返回编码长度</span><br><span class="line">            return 1+sizeof(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h2><p>和prev_entry_len一样，encoding成员同样可以看做成zlentry结构中lensize和len的压缩版。<br>同样的lensize和len都是占4个字节的，因此将两者压缩为一个成员encoding，只要encoding能够同时具有lensize和len成员的功能，而且对当前节点保存的是字节数组还是整数分别编码。</p>
<p>zlentry中len字段配合encoding字段进行了编码, 尽量压缩字段长度, 减少内存使用。<br>1）如果节点保存的是字符串，那么使用两个字节来保存编码字符串长度所使用的类型。之后的跟着的内容为字符串的实际长度。</p>
<pre><code>1. |00pppppp| 字符串长度小于等于63字节（6bit)
2. |01pppppp|qqqqqqqq| 字符串长度小于等于16383字节(14bit)
3. |10______|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| 字符串大于等于16384字节；
</code></pre><p>2）如果节点保存的是征收值，则头两位设置为1，紧跟着的两位用于标识节点所保存的整数类型。</p>
<pre><code>1. |11000000| 节点的值为 int16_t 类型的整数，长度为 2 字节。
2. |11010000| 节点的值为 int32_t 类型的整数，长度为 4 字节。
3. |11100000| 节点的值为 int64_t 类型的整数，长度为 8 字节。
4. |11110000| 节点的值为 24 位（3 字节）长的整数。
5. |11111110| 节点的值为 8 位（1 字节）长的整数。
6. |1111xxxx| 节点的值为介于 0 至 12 之间的无符号整数。取出来的值还得减一。
7. |11111111| ziplist 的结尾标识
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/*字符串编码标识使用了最高2bit位 */</span><br><span class="line">#define ZIP_STR_06B (0 &lt;&lt; 6)  //6bit</span><br><span class="line">#define ZIP_STR_14B (1 &lt;&lt; 6)  //14bit</span><br><span class="line">#define ZIP_STR_32B (2 &lt;&lt; 6)  //32bit</span><br><span class="line"></span><br><span class="line">/*zlentry中len字段进行编码过程*/</span><br><span class="line">static unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen) &#123;</span><br><span class="line">    unsigned char len = 1, buf[5];</span><br><span class="line"></span><br><span class="line">    if (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        /*</span><br><span class="line">          *6bit可以存储, 占用空间为1个字节, 值存储在字节后6bit中.</span><br><span class="line">          */</span><br><span class="line">        if (rawlen &lt;= 0x3f) &#123;</span><br><span class="line">            if (!p) return len;</span><br><span class="line">            buf[0] = ZIP_STR_06B | rawlen;</span><br><span class="line">        &#125; else if (rawlen &lt;= 0x3fff) &#123;</span><br><span class="line">            len += 1;</span><br><span class="line">            if (!p) return len;</span><br><span class="line">               /*14bit可以存储, 置前两个bit位为ZIP_STR_14B标志 */</span><br><span class="line">            buf[0] = ZIP_STR_14B | ((rawlen &gt;&gt; 8) &amp; 0x3f);</span><br><span class="line">            buf[1] = rawlen &amp; 0xff;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            len += 4;</span><br><span class="line">            if (!p) return len;</span><br><span class="line">            buf[0] = ZIP_STR_32B;</span><br><span class="line">            buf[1] = (rawlen &gt;&gt; 24) &amp; 0xff;</span><br><span class="line">            buf[2] = (rawlen &gt;&gt; 16) &amp; 0xff;</span><br><span class="line">            buf[3] = (rawlen &gt;&gt; 8) &amp; 0xff;</span><br><span class="line">            buf[4] = rawlen &amp; 0xff;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* 内容编码为整型, 长度默认为1*/</span><br><span class="line">        if (!p) return len;</span><br><span class="line">        buf[0] = encoding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Store this length at p */</span><br><span class="line">    memcpy(p,buf,len);</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line">2.3 zlentry之encoding和p编码</span><br><span class="line">zlentry中encoding和p表示元素编码和内容, 下面分析下具体编码规则, 可以看到这里对内存节省真是到了魔性的地步. encoding是保存在len字段第一个字节中, 第一个字节最高2bit标识字符串编码, 5和6bit位标识是整数编码, 解码时直接从第一个字节中获取编码信息.</span><br><span class="line"></span><br><span class="line">/* 整数编码标识使用了5和6bit位 */</span><br><span class="line">#define ZIP_INT_16B (0xc0 | 0&lt;&lt;4)  //16bit整数</span><br><span class="line">#define ZIP_INT_32B (0xc0 | 1&lt;&lt;4)  //32bit整数</span><br><span class="line">#define ZIP_INT_64B (0xc0 | 2&lt;&lt;4)  //64bit整数</span><br><span class="line">#define ZIP_INT_24B (0xc0 | 3&lt;&lt;4)  //24bit整数</span><br><span class="line">#define ZIP_INT_8B 0xfe            //8bit整数</span><br><span class="line"></span><br><span class="line">#define ZIP_INT_IMM_MASK 0x0f</span><br><span class="line">#define ZIP_INT_IMM_MIN 0xf1    /* 11110001 */</span><br><span class="line">#define ZIP_INT_IMM_MAX 0xfd    /* 11111101 */</span><br><span class="line"></span><br><span class="line">static int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) &#123;</span><br><span class="line">    long long value;</span><br><span class="line">    if (entrylen &gt;= 32 || entrylen == 0) return 0;</span><br><span class="line">   </span><br><span class="line">    if (string2ll((char*)entry,entrylen,&amp;value)) &#123;</span><br><span class="line">        /* 0-12之间的值, 直接在保存在了encoding字段中, 其他根据值大小, 直接设置为相应的编码*/</span><br><span class="line">        if (value &gt;= 0 &amp;&amp; value &lt;= 12) &#123;</span><br><span class="line">            *encoding = ZIP_INT_IMM_MIN+value;</span><br><span class="line">        &#125; else if (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_8B;</span><br><span class="line">        &#125; else if (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_16B;</span><br><span class="line">        &#125; else if (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_24B;</span><br><span class="line">        &#125; else if (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_32B;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            *encoding = ZIP_INT_64B;</span><br><span class="line">        &#125;</span><br><span class="line">        *v = value;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>当将一个新节点添加到某个节点之前时，如果原节点的header空间不足以保存新节点的长度，那么就需要对原节点的header空间进行扩展（从1字节扩展到5字节）。但是当对这个节点进行扩展后，可能又会引起后续节点的扩展，这就会引起连锁更新。这种情况在多个连续节点的长度都接近 ZIP_BIGLEN 时可能发生。</p>
<p>反过来说，因为节点的长度变小而引起的连续缩小也是可能出现的，为了避免扩展-缩小-扩展-缩小这样的情况反复出现（flapping，抖动），我们不处理这种情况，而是任由 prevlen 比所需的长度更长。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（5）-整数集合]]></title>
      <url>/2018/06/11/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%885%EF%BC%89-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h1 id="inset-c-inset-h"><a href="#inset-c-inset-h" class="headerlink" title="inset.c/inset.h"></a>inset.c/inset.h</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    // 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    // 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line">    // 保存元素的数组</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))</span><br><span class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))</span><br><span class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/V73WqK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73WqK.jpg" alt="V73WqK.jpg"></a></p>
<p>length记录了整数集合中包含的元素个数，即contents数组的长度。<br>contents数组是整数集合的底层实现，整数集合中的一个元素就是contents数组的一个元素，其中的元素都是按照数值从小到大排序的，并且元素不重复。虽然contents数组被定义为int8_t类型，但其中的元素类型取决于encoding。</p>
<p>inset是Redis中的整数集合数据结构，只允许保存整数值。<br>inset之所以有三种表示编码格式的宏定义，是因为根据存储元素数值的大小，能够选取一个最“合适”的类型存储，既能够表示元素的大小，又可以节省空间。当插入的新元素编码要大于当前集合编码格式，则需要进行<strong>升级操作</strong>。</p>
<p>升级步骤主要分成三步：</p>
<ol>
<li>根据新元素的类型，扩展整数集合的底层数组空间大小。</li>
<li>将底层数组中的元素全部转换成跟新元素一样的类型，并从后向前将元素放到相应的位置，保证跟原有顺序一样。</li>
<li>将新元素加入到底层数组中。如果因为加入新元素而导致类型调整，则新加入的元素只会在数组的开头或结尾处。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123;</span><br><span class="line">    // 当前的编码方式</span><br><span class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    // 新值所需的编码方式</span><br><span class="line">    uint8_t newenc = _intsetValueEncoding(value);</span><br><span class="line">    // 当前集合的元素数量</span><br><span class="line">    int length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    // 根据 value 的值，决定是将它添加到底层数组的最前端还是最后端</span><br><span class="line">    // 注意，因为 value 的编码比集合原有的其他元素的编码都要大</span><br><span class="line">    // 所以 value 要么大于集合中的所有元素，要么小于集合中的所有元素</span><br><span class="line">    // 因此，value 只能添加到底层数组的最前端或最后端</span><br><span class="line">    int prepend = value &lt; 0 ? 1 : 0;</span><br><span class="line">    /* First set new encoding and resize */</span><br><span class="line">    // 更新集合的编码方式</span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    // 根据新编码对集合（的底层数组）进行空间调整</span><br><span class="line">    // T = O(N)</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);</span><br><span class="line">    // T = O(N)</span><br><span class="line">    while(length--)</span><br><span class="line">     _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line">    /* Set the value at the beginning or the end. */</span><br><span class="line">    // 设置新值，根据 prepend 的值来决定是添加到数组头还是数组尾</span><br><span class="line">    if (prepend)</span><br><span class="line">        _intsetSet(is,0,value);</span><br><span class="line">    else</span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    // 更新整数集合的元素数量</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);</span><br><span class="line">    return is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样升级的特点：</p>
<ul>
<li>提高灵活性：通过自动升级底层数组来适应不同类型的新元素，不需要担心类型错误。</li>
<li>节约内存：整数集合即可以让集合保存三种不同类型的值，又可以确保升级操作只在需要的时候进行</li>
<li>不支持降级：一旦对数据进行升级后，编码就会一直保存升级后的状态。</li>
</ul>
<p>添加或删除元素。在向底层数组中插入或删除新元素时，因为不会导致底层数组的类型变换，所以只需要计算出申请或清除固定的数组空间，进行整体移动后，再进行添加或删除操作。下面就是进行整体移动的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) &#123;</span><br><span class="line">    void *src, *dst;</span><br><span class="line">    // 要移动的元素个数</span><br><span class="line">    uint32_t bytes = intrev32ifbe(is-&gt;length)-from;</span><br><span class="line">    // 集合的编码方式</span><br><span class="line">    uint32_t encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    // 根据不同的编码</span><br><span class="line">    // src = (Enc_t*)is-&gt;contents+from 记录移动开始的位置</span><br><span class="line">    // dst = (Enc_t*)is_.contents+to 记录移动结束的位置</span><br><span class="line">    // bytes *= sizeof(Enc_t) 计算一共要移动多少字节</span><br><span class="line">    if (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (int64_t*)is-&gt;contents+from;</span><br><span class="line">        dst = (int64_t*)is-&gt;contents+to;</span><br><span class="line">        bytes *= sizeof(int64_t);</span><br><span class="line">    &#125; else if (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (int32_t*)is-&gt;contents+from;</span><br><span class="line">        dst = (int32_t*)is-&gt;contents+to;</span><br><span class="line">        bytes *= sizeof(int32_t);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        src = (int16_t*)is-&gt;contents+from;</span><br><span class="line">        dst = (int16_t*)is-&gt;contents+to;</span><br><span class="line">        bytes *= sizeof(int16_t);</span><br><span class="line">    &#125;</span><br><span class="line">    // 进行移动</span><br><span class="line">    // T = O(N)</span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">### API</span><br><span class="line">创建并返回一个空的整数集合</span><br><span class="line">intset *intsetNew(void);</span><br><span class="line">static intset *intsetResize(intset *is, uint32_t len);//重新分配contents数组指定长度的内存</span><br><span class="line">//用二分查找在contents数组中查找value，返回pos</span><br><span class="line">static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos);</span><br><span class="line">//添加value到contents正确的位置，保证inset的有序性</span><br><span class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success);</span><br><span class="line">//从整数集合中删除指定value</span><br><span class="line">intset *intsetRemove(intset *is, int64_t value, int *success);</span><br><span class="line">uint8_t intsetFind(intset *is, int64_t value);//在inset查找value</span><br><span class="line">int64_t intsetRandom(intset *is);//从整数集合中随机获取一个value</span><br><span class="line">uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);//获取整数集合指定位置的value</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（4）--跳跃表]]></title>
      <url>/2018/06/10/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%884%EF%BC%89-%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="Redis跳表"><a href="#Redis跳表" class="headerlink" title="Redis跳表"></a>Redis跳表</h1><p>Redis中的跳表实现在3.0版本是在Redis.h中，到3.2版本时定义到了server.h中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* ZSETs use a specialized version of Skiplists */</span><br><span class="line">/*</span><br><span class="line"> * 跳跃表节点</span><br><span class="line"> */</span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    // 成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line">    // 分值</span><br><span class="line">    double score;</span><br><span class="line">    // 后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    // 层</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        // 前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        // 跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line">/*</span><br><span class="line"> * 跳跃表</span><br><span class="line"> */</span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    // 表头节点和表尾节点</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">    // 表中节点的数量，除去第一个节点</span><br><span class="line">    unsigned long length;</span><br><span class="line">    // 表中层数最大的节点的层数，除去第一个节点</span><br><span class="line">    int level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p>
<p><img src="media/15561830762143/15568090203540.jpg" alt="-w859"></p>
<h2 id="幂次定律"><a href="#幂次定律" class="headerlink" title="幂次定律"></a>幂次定律</h2><p>在Redis中，跳表返回的随机层数值使用的算法就是幂次定律。</p>
<ul>
<li>含义是：如果某件事的发生频率和它的某个属性成幂关系，那么这个频率就可以称之为符合幂次定律。</li>
<li>表现是：少数几个事件的发生频率占了整个发生频率的大部分，而其余的大多数事件只占整个发生频率的一个小部分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int zslRandomLevel(void) &#123;</span><br><span class="line">    int level = 1;</span><br><span class="line">    while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))//ZSKIPLIST_P（0.25）所以level+1的概率为0.25</span><br><span class="line">        level += 1;</span><br><span class="line">    return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="media/15561830762143/15568113664892.jpg" alt=""></p>
<h2 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 创建并返回一个新的跳跃表</span><br><span class="line"> *</span><br><span class="line"> * T = O(1)</span><br><span class="line"> */</span><br><span class="line">zskiplist *zslCreate(void) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    // 分配空间</span><br><span class="line">    zsl = zmalloc(sizeof(*zsl));</span><br><span class="line"></span><br><span class="line">    // 设置高度和起始层数</span><br><span class="line">    zsl-&gt;level = 1;</span><br><span class="line">    zsl-&gt;length = 0;</span><br><span class="line"></span><br><span class="line">    // 初始化表头节点</span><br><span class="line">    // T = O(1)</span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);</span><br><span class="line">    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = NULL;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = NULL;</span><br><span class="line"></span><br><span class="line">    // 设置表尾</span><br><span class="line">    zsl-&gt;tail = NULL;</span><br><span class="line"></span><br><span class="line">    return zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 创建一个成员为 obj ，分值为 score 的新节点，</span><br><span class="line"> * 并将这个新节点插入到跳跃表 zsl 中。</span><br><span class="line"> * </span><br><span class="line"> * 函数的返回值为新节点。</span><br><span class="line"> *</span><br><span class="line"> * T_wrost = O(N^2), T_avg = O(N log N)</span><br><span class="line"> */</span><br><span class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    unsigned int rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    int i, level;</span><br><span class="line"></span><br><span class="line">    redisAssert(!isnan(score));</span><br><span class="line"></span><br><span class="line">    // 在各个层查找节点的插入位置</span><br><span class="line">    // T_wrost = O(N^2), T_avg = O(N log N)</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</span><br><span class="line"></span><br><span class="line">        /* store rank that is crossed to reach the insert position */</span><br><span class="line">        // 如果 i 不是 zsl-&gt;level-1 层</span><br><span class="line">        // 那么 i 层的起始 rank 值为 i+1 层的 rank 值</span><br><span class="line">        // 各个层的 rank 值一层层累积</span><br><span class="line">        // 最终 rank[0] 的值加一就是新节点的前置节点的排位</span><br><span class="line">        // rank[0] 会在后面成为计算 span 值和 rank 值的基础</span><br><span class="line">        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];</span><br><span class="line"></span><br><span class="line">        // 沿着前进指针遍历跳跃表</span><br><span class="line">        // T_wrost = O(N^2), T_avg = O(N log N)</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                // 比对分值</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                // 比对成员， T = O(N)</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; 0))) &#123;</span><br><span class="line"></span><br><span class="line">            // 记录沿途跨越了多少个节点</span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line"></span><br><span class="line">            // 移动至下一指针</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        // 记录将要和新节点相连接的节点</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* we assume the key is not already inside, since we allow duplicated</span><br><span class="line">     * scores, and the re-insertion of score and redis object should never</span><br><span class="line">     * happen since the caller of zslInsert() should test in the hash table</span><br><span class="line">     * if the element is already inside or not. </span><br><span class="line">     *</span><br><span class="line">     * zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</span><br><span class="line">     * 所以这里不需要进一步进行检查，可以直接创建新元素。</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 获取一个随机值作为新节点的层数</span><br><span class="line">    // T = O(N)</span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line"></span><br><span class="line">    // 如果新节点的层数比表中其他节点的层数都要大</span><br><span class="line">    // 那么初始化表头节点中未使用的层，并将它们记录到 update 数组中</span><br><span class="line">    // 将来也指向新节点</span><br><span class="line">    if (level &gt; zsl-&gt;level) &#123;</span><br><span class="line"></span><br><span class="line">        // 初始化未使用层</span><br><span class="line">        // T = O(1)</span><br><span class="line">        for (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = 0;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 更新表中节点最大层数</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建新节点</span><br><span class="line">    x = zslCreateNode(level,score,obj);</span><br><span class="line"></span><br><span class="line">    // 将前面记录的指针指向新节点，并做相应的设置</span><br><span class="line">    // T = O(1)</span><br><span class="line">    for (i = 0; i &lt; level; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        // 设置新节点的 forward 指针</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        </span><br><span class="line">        // 将沿途记录的各个节点的 forward 指针指向新节点</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        /* update span covered by update[i] as x is inserted here */</span><br><span class="line">        // 计算新节点跨越的节点数量</span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);</span><br><span class="line"></span><br><span class="line">        // 更新新节点插入之后，沿途节点的 span 值</span><br><span class="line">        // 其中的 +1 计算的是新节点</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* increment span for untouched levels */</span><br><span class="line">    // 未接触的节点的 span 值也需要增一，这些节点直接从表头指向新节点</span><br><span class="line">    // T = O(1)</span><br><span class="line">    for (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置新节点的后退指针</span><br><span class="line">    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];</span><br><span class="line">    if (x-&gt;level[0].forward)</span><br><span class="line">        x-&gt;level[0].forward-&gt;backward = x;</span><br><span class="line">    else</span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line"></span><br><span class="line">    // 跳跃表的节点计数增一</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line"></span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank </span><br><span class="line"> * </span><br><span class="line"> * 内部删除函数，</span><br><span class="line"> * 被 zslDelete 、 zslDeleteRangeByScore 和 zslDeleteByRank 等函数调用。</span><br><span class="line"> *</span><br><span class="line"> * T = O(1)</span><br><span class="line"> */</span><br><span class="line">void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) &#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    // 更新所有和被删除节点 x 有关的节点的指针，解除它们之间的关系</span><br><span class="line">    // T = O(1)</span><br><span class="line">    for (i = 0; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        if (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;</span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新被删除节点 x 的前进和后退指针</span><br><span class="line">    if (x-&gt;level[0].forward) &#123;</span><br><span class="line">        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新跳跃表最大层数（只在被删除节点是跳跃表中最高的节点时才执行）</span><br><span class="line">    // T = O(1)</span><br><span class="line">    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line"></span><br><span class="line">    // 跳跃表节点计数器减一</span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取节点排名"><a href="#获取节点排名" class="headerlink" title="获取节点排名"></a>获取节点排名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/* Find the rank for an element by both score and key.</span><br><span class="line"> *</span><br><span class="line"> * 查找包含给定分值和成员对象的节点在跳跃表中的排位。</span><br><span class="line"> *</span><br><span class="line"> * Returns 0 when the element cannot be found, rank otherwise.</span><br><span class="line"> *</span><br><span class="line"> * 如果没有包含给定分值和成员对象的节点，返回 0 ，否则返回排位。</span><br><span class="line"> *</span><br><span class="line"> * Note that the rank is 1-based due to the span of zsl-&gt;header to the</span><br><span class="line"> * first element. </span><br><span class="line"> *</span><br><span class="line"> * 注意，因为跳跃表的表头也被计算在内，所以返回的排位以 1 为起始值。</span><br><span class="line"> *</span><br><span class="line"> * T_wrost = O(N), T_avg = O(log N)</span><br><span class="line"> */</span><br><span class="line">unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    unsigned long rank = 0;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    // 遍历整个跳跃表</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</span><br><span class="line"></span><br><span class="line">        // 遍历节点并对比元素</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                // 比对分值</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                // 比对成员对象</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= 0))) &#123;</span><br><span class="line"></span><br><span class="line">            // 累积跨越的节点数量</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line"></span><br><span class="line">            // 沿着前进指针遍历跳跃表</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span><br><span class="line">        // 必须确保不仅分值相等，而且成员对象也要相等</span><br><span class="line">        // T = O(N)</span><br><span class="line">        if (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</span><br><span class="line">            return rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 没找到</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间操作"><a href="#区间操作" class="headerlink" title="区间操作"></a>区间操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) &#123; //返回第一个分数在range范围内的节点</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    /* If everything is out of range, return early. */</span><br><span class="line">    if (!zslIsInRange(zsl,range)) return NULL;  //如果不在范围内，则返回NULL，确保至少有一个节点符号range</span><br><span class="line"></span><br><span class="line">    //判断下限</span><br><span class="line">    x = zsl-&gt;header;//遍历跳跃表</span><br><span class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;//遍历每一层</span><br><span class="line">        /* Go forward while *OUT* of range. */</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;           //如果该层有下一个节点且</span><br><span class="line">            !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))//当前节点的score还小于(小于等于)range的min</span><br><span class="line">                x = x-&gt;level[i].forward;        //继续指向下一个节点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* This is an inner range, so the next node cannot be NULL. */</span><br><span class="line">    x = x-&gt;level[0].forward;    //找到目标节点</span><br><span class="line">    redisAssert(x != NULL);     //保证能找到</span><br><span class="line"></span><br><span class="line">    /* Check if score &lt;= max. */</span><br><span class="line">    //判断上限</span><br><span class="line">    if (!zslValueLteMax(x-&gt;score,range)) return NULL;   //该节点的分值如果比max还要大，就返回NULL</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) &#123;//返回最后一个分数在range范围内的节点</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    /* If everything is out of range, return early. */</span><br><span class="line">    if (!zslIsInRange(zsl,range)) return NULL;  //如果不在范围内，则返回NULL，确保至少有一个节点符号range</span><br><span class="line"></span><br><span class="line">    //判断上限</span><br><span class="line">    x = zsl-&gt;header;//遍历跳跃表</span><br><span class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;   //遍历每一层</span><br><span class="line">        /* Go forward while *IN* range. */</span><br><span class="line">        while (x-&gt;level[i].forward &amp;&amp;   //如果该层有下一个节点且</span><br><span class="line">            zslValueLteMax(x-&gt;level[i].forward-&gt;score,range))//当前节点的score小于(小于等于)max</span><br><span class="line">                x = x-&gt;level[i].forward;    //继续指向下一个节点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* This is an inner range, so this node cannot be NULL. */</span><br><span class="line">    redisAssert(x != NULL);//保证能找到</span><br><span class="line"></span><br><span class="line">    /* Check if score &gt;= min. */</span><br><span class="line">    //判断下限</span><br><span class="line">    if (!zslValueGteMin(x-&gt;score,range)) return NULL;   //如果找到的节点的分值比range的min还要小</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么Redis要使用跳表来实现有序集合而不是红黑树？"><a href="#为什么Redis要使用跳表来实现有序集合而不是红黑树？" class="headerlink" title="为什么Redis要使用跳表来实现有序集合而不是红黑树？"></a>为什么Redis要使用跳表来实现有序集合而不是红黑树？</h2><p>Redis中有序集合支持的核心操作主要有：</p>
<ul>
<li>插入一个数据</li>
<li>删除一个数据</li>
<li>查找一个数据</li>
<li>按照区间查找数据</li>
<li>迭代输出有序序列</li>
</ul>
<p>其中插入、删除、查找以及迭代有序序列这几个操作，红黑树也能够完成，时间复杂度跟跳表是一样的。</p>
<p>但是按照区间查找数据这个操作，红黑树的效率没有跳表高。跳表可以在O(logn)时间复杂度定位区间的起点，然后在原始链表中顺序先后查询，这非常高效。</p>
<p>此外，相比于红黑树，跳表还具有代码更容易实现、可读性高、不容易出错、更加灵活等特点。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（3）--字典]]></title>
      <url>/2018/06/10/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%883%EF%BC%89-%E5%AD%97%E5%85%B8/</url>
      <content type="html"><![CDATA[<h2 id="字典和哈希表"><a href="#字典和哈希表" class="headerlink" title="字典和哈希表"></a>字典和哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组，存放一个数组的地址</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小，初始化大小为4</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>table属性是一个数组，数组中的每个元素都是一个指向dictEntry结构的指针，每个dictEntry结构都保存着一个键值对。size记录了哈希表的大小，used记录了哈希表已有键值对的数量。<br>dictEntry的next指针指向另一个哈希表节点，通过链表的结构将多个hash值一样的键值对连接起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典类型特定函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>Redis中的字典是由dict结构表示的：type和privdata属性用于针对不同类型的键值对，用于实现多种字典。<br>ht是一个大小为2的数组，主要用于扩缩容。在一般情况下，数据都是存储在ht[0]中，ht[1]是一个只进行了初始化操作的哈希表。只有在迁移过程中，数据才有可能保存在ht[1]中。<br><a href="https://imgchr.com/i/V73J8s" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73J8s.md.jpg" alt="V73J8s.md.jpg"></a></p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>Thomas Wang认为好的hash函数具有两个好的特点：</p>
<ol>
<li>hash函数可逆</li>
<li>具有雪崩效应，即输入值1bit位的变化会造成输出值1/2的bit位发生变化</li>
</ol>
<h3 id="计算int整型哈希值的哈希函数"><a href="#计算int整型哈希值的哈希函数" class="headerlink" title="计算int整型哈希值的哈希函数"></a>计算int整型哈希值的哈希函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned int dictIntHashFunction(unsigned int key)      //用于计算int整型哈希值的哈希函数</span><br><span class="line">&#123;</span><br><span class="line">    key += ~(key &lt;&lt; 15);</span><br><span class="line">    key ^=  (key &gt;&gt; 10);</span><br><span class="line">    key +=  (key &lt;&lt; 3);</span><br><span class="line">    key ^=  (key &gt;&gt; 6);</span><br><span class="line">    key += ~(key &lt;&lt; 11);</span><br><span class="line">    key ^=  (key &gt;&gt; 16);</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MurmurHash2哈希算法"><a href="#MurmurHash2哈希算法" class="headerlink" title="MurmurHash2哈希算法"></a>MurmurHash2哈希算法</h3><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，redis用MurmurHash2算法来计算哈希值，能产生32-bit或64-bit哈希值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">unsigned int dictGenHashFunction(const void *key, int len) &#123;  //用于计算字符串的哈希值的哈希函数</span><br><span class="line">    /* &apos;m&apos; and &apos;r&apos; are mixing constants generated offline.</span><br><span class="line">     They&apos;re not really &apos;magic&apos;, they just happen to work well.  */</span><br><span class="line">    //m和r这两个值用于计算哈希值，只是因为效果好。</span><br><span class="line">    uint32_t seed = dict_hash_function_seed;</span><br><span class="line">    const uint32_t m = 0x5bd1e995;</span><br><span class="line">    const int r = 24;</span><br><span class="line"></span><br><span class="line">    /* Initialize the hash to a &apos;random&apos; value */</span><br><span class="line">    uint32_t h = seed ^ len;    //初始化</span><br><span class="line"></span><br><span class="line">    /* Mix 4 bytes at a time into the hash */</span><br><span class="line">    const unsigned char *data = (const unsigned char *)key;</span><br><span class="line"></span><br><span class="line">    //将字符串key每四个一组看成uint32_t类型，进行运算的到h</span><br><span class="line">    while(len &gt;= 4) &#123;</span><br><span class="line">        uint32_t k = *(uint32_t*)data;</span><br><span class="line"></span><br><span class="line">        k *= m;</span><br><span class="line">        k ^= k &gt;&gt; r;</span><br><span class="line">        k *= m;</span><br><span class="line"></span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= k;</span><br><span class="line"></span><br><span class="line">        data += 4;</span><br><span class="line">        len -= 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Handle the last few bytes of the input array  */</span><br><span class="line">    switch(len) &#123;</span><br><span class="line">    case 3: h ^= data[2] &lt;&lt; 16;</span><br><span class="line">    case 2: h ^= data[1] &lt;&lt; 8;</span><br><span class="line">    case 1: h ^= data[0]; h *= m;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /* Do a few final mixes of the hash to ensure the last few</span><br><span class="line">     * bytes are well-incorporated. */</span><br><span class="line">    h ^= h &gt;&gt; 13;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= h &gt;&gt; 15;</span><br><span class="line"></span><br><span class="line">    return (unsigned int)h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="djb哈希算法"><a href="#djb哈希算法" class="headerlink" title="djb哈希算法"></a>djb哈希算法</h3><p>算法的思想是利用字符串中的ascii码值与一个随机seed，通过len次变换，得到最后的hash值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) &#123;   //用于计算字符串的哈希值的哈希函数</span><br><span class="line">    unsigned int hash = (unsigned int)dict_hash_function_seed;</span><br><span class="line"></span><br><span class="line">    while (len--)</span><br><span class="line">        hash = ((hash &lt;&lt; 5) + hash) + (tolower(*buf++)); /* hash * 33 + c */</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>当哈希表的大小不能满足需求，就可能会有两个或者两个以上数量的键被分配到了哈希表数组的同一个索引上，于是就发生了<strong>哈希冲突</strong>。在Redis中解决冲突的办法是链接法。但是为了避免通过索引上的键过多，当满足一定条件时就会触发rehash行为。rehash主要是受键的数量和负载因子的影响。</p>
<p>Redis是一个单线程处理程序，为了避免在迁移过程中造成阻塞，Redis采用渐进式hash的方式来对数据进行迁移。通过对迁移的槽个数以及迁移时间的控制来完成逐步迁移操作。</p>
<p>我们通过查看dict.c文件可以发现在rehash期间，每次对字典的增删改查操作，都会进行单步rehash操作。<br>主要迁移函数为dictRehash:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只可以在 rehash 进行中时执行</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行 N 步迁移</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">        <span class="comment">// 如果 0 号哈希表为空，那么表示 rehash 执行完毕</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放 0 号哈希表</span></span><br><span class="line">            zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">            <span class="comment">// 将原来的 1 号哈希表设置为新的 0 号哈希表</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 重置旧的 1 号哈希表</span></span><br><span class="line">            _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 关闭 rehash 标识</span></span><br><span class="line">            d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 返回 0 ，向调用者表示 rehash 已经完成</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        <span class="comment">// 确保 rehashidx 没有越界</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span>)d-&gt;rehashidx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 略过数组中为空的索引，找到下一个非空索引</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) d-&gt;rehashidx++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向该索引的链表表头节点</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="comment">// 将链表中的所有节点迁移到新哈希表</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存下个节点的指针</span></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="comment">// 计算新哈希表的哈希值，以及节点插入的索引位置</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入节点到新哈希表</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新计数器</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继续处理下个节点</span></span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将刚迁移完的哈希表索引的指针设为空</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 更新 rehash 索引</span></span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Redis为了避免一次性迁移的太多引起阻塞，所以对于多步迁移进行了迁移时间控制。在两种情况下会先暂停本次迁移：1. 达到限制的时间；2. 字典已被迁移完</p>
<p>返回值说是迁移的槽的个数，但是这个地方其实是不太准确的，存在100以内的一个误差。此外，由于代码各处的单步hash操作，导致误差可接受。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 如果时间已过，跳出</span></span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h2><p>Redis在进行key的扫描的话是有两种方式：keys或者scan。使用keys的话可以一次性将所有需要的键值对给取出来，但是相应的，会阻塞Redis的单线程。所以Redis提供了另外一种扫描方式：scan。scan通过返回扫描槽的cursor值来记录扫描进度，当cursor等于0时代表扫描完成。<br>在Redis中，键值对都是通过一定的hash算法来计算该存放在哪个位置。在哈希表的结构中，我们可以看到存在一个sizemask专门用来计算hash值，来决定键值对存放的位置。假如当前hash表的大小为8，那么该值为7，转化成二进制就是111。在Scan过程中，Redis并没有采取传统的低位-&gt;高位的加法进位方式来扫描，而是通过高位-&gt;低位加法进位的方式；即000-&gt;100-&gt;010…<br>为什么要采用这样的方式来进行Scan呢？我们来分析一下Redis的Scan过程：<br><a href="https://imgchr.com/i/V73Y2n" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73Y2n.md.jpg" alt="V73Y2n.md.jpg"></a><br>通过这张图，我们可以发现采用高位进位的遍历顺序，rehash后的槽位在遍历顺序上是相邻的。</p>
<p>假设我们接下来要遍历的位置是110这个位置，那么扩容后，当前槽位中所有的元素对应的新槽位是0110和1110。这时我们只需要从0110这个槽位开始继续往后遍历，0110槽位之前的槽位都是遍历过的，所以在遍历过程中遇到字典rehash并不会对我们的遍历造成影响。</p>
<p>考虑缩容情况，缩容后，010和110这两个槽位上对应的元素都会合并到10上面，我们接下来遍历的10这个槽；但是会发现原来010上的元素我们已经遍历过了，所以可能会造成遍历元素的重复。</p>
<hr>
<p>看到这，你可能会问既然会造成元素的重复，为什么我们还要采用这种方式呢？我们再来考虑从低位-&gt;高位的遍历方式。</p>
<p>我们还是通过上图来看，如果采用低位-&gt;高位的遍历方式，我们可以发现rehash后的槽位并不连续。</p>
<p>假设我们接下来要遍历的是001这个位置，在没有缩容前我们只遍历了000这个位置；在这个时候遇到缩容的情况，那么我们接下来遍历的就是01这个位置，等价于我们已经将00这个位置给遍历完了。发现了吗？我们有个100位置的元素给漏了，这就会造成元素遍历的遗漏。</p>
<p>我们宁愿返回给应用的元素存在重复，这在应用端很容易进行去重；也不愿遗漏元素。</p>
<p>另外：</p>
<ol>
<li>如果在Scan过程中，有客户端对已经遍历过的位置进行修改操作的话，Redis是无法进行感知，也就是这一部分的修改并不会再Scan返回的元素中。</li>
<li>如果在Scan过程中，发现字典处于rehash的状态中的话，会去遍历ht[0]和ht[1]两个哈希表。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过空字典</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代只有一个哈希表的字典</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向哈希表</span></span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录 mask</span></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="comment">// 指向哈希桶</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="comment">// 遍历桶中的所有节点</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = de-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代有两个哈希表的字典</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向两个哈希表</span></span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure t0 is the smaller and t1 is the bigger table */</span></span><br><span class="line">        <span class="comment">// 确保 t0 比 t1 要小</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;size &gt; t1-&gt;size) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录掩码</span></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="comment">// 指向桶，并迭代桶中的所有节点</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = de-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment">         * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line">        <span class="comment">// Iterate over indices in larger table             // 迭代大表中的桶</span></span><br><span class="line">        <span class="comment">// that are the expansion of the index pointed to   // 这些桶被索引的 expansion 所指向</span></span><br><span class="line">        <span class="comment">// by the cursor in the smaller table               //</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            <span class="comment">// 指向桶，并迭代桶中的所有节点</span></span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = de-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment bits not covered by the smaller mask */</span></span><br><span class="line">            v = (((v | m0) + <span class="number">1</span>) &amp; ~m0) | (v &amp; m0);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set unmasked bits so incrementing the reversed cursor</span></span><br><span class="line"><span class="comment">     * operates on the masked bits of the smaller table */</span></span><br><span class="line">    v |= ~m0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">    v = rev(v);</span><br><span class="line">    v++;</span><br><span class="line">    v = rev(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（2）--链表]]></title>
      <url>/2018/06/09/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%882%EF%BC%89-%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><p>adlist是Redis实现的双向链表文件。addlist.c主要是链表节点和相关属性方法的定义；addlist.h实现了该addlist.c中定义的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 双端链表节点</span><br><span class="line"> */</span><br><span class="line">typedef struct listNode &#123;</span><br><span class="line">    // 前置节点</span><br><span class="line">    struct listNode *prev;</span><br><span class="line">    // 后置节点</span><br><span class="line">    struct listNode *next;</span><br><span class="line">    // 节点的值</span><br><span class="line">    void *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 双端链表结构</span><br><span class="line"> */</span><br><span class="line">typedef struct list &#123;</span><br><span class="line">    // 表头节点</span><br><span class="line">    listNode *head;</span><br><span class="line">    // 表尾节点</span><br><span class="line">    listNode *tail;</span><br><span class="line">    // 节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    // 节点值释放函数</span><br><span class="line">    void (*free)(void *ptr);</span><br><span class="line">    // 节点值对比函数</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line">    // 链表所包含的节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://imgchr.com/i/V73Mb8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V73Mb8.md.jpg" alt="V73Mb8.md.jpg"></a></p>
<p>我们可以看到Redis使用listNode来表示链表结构中的每个节点;它跟平常的链表节点一样，包含前后节点的指针以及一个<strong>万能指针</strong>来保存数据地址。</p>
<p>在list结构中，head指针指向有listNode组成的双向链表的第一个Node节点，tail执行双向链表的最后一个节点。而dup、free、match成员则是用于实现<strong>多态</strong>链表所需的类型特定函数，<strong>针对链表中存放的不同对象从而实现不同的方法</strong>。</p>
<p>Redis的链表实现特性可以总结如下：</p>
<ul>
<li>双端：链表节点带有prev和next指针，获取某个节点的前置或者后置节点都是O(1)</li>
<li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL</li>
<li>带表头指针和表尾指针，通过list结构的head和tail指针，可以很方便的顺序或者逆序遍历链表</li>
<li>链表计数器：通过list结构的len成员，可以O(1)获取listNode节点的个数</li>
<li>多态</li>
</ul>
<p>Redis针对list结构和listNode结构的赋值和查询操作使用宏进行封装，以下的操作复杂度都是O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* Functions implemented as macros */</span><br><span class="line">// 返回给定链表所包含的节点数量</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listLength(l) ((l)-&gt;len)</span><br><span class="line">// 返回给定链表的表头节点</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listFirst(l) ((l)-&gt;head)</span><br><span class="line">// 返回给定链表的表尾节点</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listLast(l) ((l)-&gt;tail)</span><br><span class="line">// 返回给定节点的前置节点</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listPrevNode(n) ((n)-&gt;prev)</span><br><span class="line">// 返回给定节点的后置节点</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listNextNode(n) ((n)-&gt;next)</span><br><span class="line">// 返回给定节点的值</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listNodeValue(n) ((n)-&gt;value)</span><br><span class="line"></span><br><span class="line">// 将链表 l 的值复制函数设置为 m</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span><br><span class="line">// 将链表 l 的值释放函数设置为 m</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span><br><span class="line">// 将链表的对比函数设置为 m</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span><br><span class="line"></span><br><span class="line">// 返回给定链表的值复制函数</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listGetDupMethod(l) ((l)-&gt;dup)</span><br><span class="line">// 返回给定链表的值释放函数</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listGetFree(l) ((l)-&gt;free)</span><br><span class="line">// 返回给定链表的值对比函数</span><br><span class="line">// T = O(1)</span><br><span class="line">#define listGetMatchMethod(l) ((l)-&gt;match)</span><br></pre></td></tr></table></figure></p>
<p>以下是链表操作的原型函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Prototypes */</span><br><span class="line">list *listCreate(void);                  //创建一个表头</span><br><span class="line">void listRelease(list *list);           //释放list表头和链表</span><br><span class="line">list *listAddNodeHead(list *list, void *value); //将value添加到list链表的头部</span><br><span class="line">list *listAddNodeTail(list *list, void *value); //将value添加到list链表的尾部</span><br><span class="line">list *listInsertNode(list *list, listNode *old_node, void *value, int after);   //在list中，根据after在old_node节点前后插入值为value的节点。</span><br><span class="line">void listDelNode(list *list, listNode *node);   //从list删除node节点</span><br><span class="line">listIter *listGetIterator(list *list, int direction);   //为list创建一个迭代器iterator</span><br><span class="line">listNode *listNext(listIter *iter);     //返回迭代器iter指向的当前节点并更新iter  </span><br><span class="line">void listReleaseIterator(listIter *iter);   //释放iter迭代器</span><br><span class="line">list *listDup(list *orig);                   //拷贝表头为orig的链表并返回</span><br><span class="line">listNode *listSearchKey(list *list, void *key);     //在list中查找value为key的节点并返回</span><br><span class="line">listNode *listIndex(list *list, long index);        //返回下标为index的节点地址</span><br><span class="line">void listRewind(list *list, listIter *li);          //将迭代器li重置为list的头结点并且设置为正向迭代</span><br><span class="line">void listRewindTail(list *list, listIter *li);      //将迭代器li重置为list的尾结点并且设置为反向迭代</span><br><span class="line">void listRotate(list *list);            //将尾节点插到头结点</span><br></pre></td></tr></table></figure></p>
<p>在adlist.h文件中，使用C语言实现了迭代器（设计模式中的迭代器模式）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Directions for iterators </span><br><span class="line"> *</span><br><span class="line"> * 迭代器进行迭代的方向</span><br><span class="line"> */</span><br><span class="line">// 从表头向表尾进行迭代</span><br><span class="line">#define AL_START_HEAD 0</span><br><span class="line">// 从表尾到表头进行迭代</span><br><span class="line">#define AL_START_TAIL 1</span><br><span class="line"></span><br><span class="line">typedef struct listIter &#123;</span><br><span class="line">    listNode *next;     //迭代器当前指向的节点</span><br><span class="line">    int direction;      //迭代方向，可以取以下两个值：AL_START_HEAD和AL_START_TAIL</span><br><span class="line">&#125; listIter</span><br></pre></td></tr></table></figure></p>
<p>迭代器的好处：</p>
<ul>
<li>提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示。</li>
<li>将指针操作进行统一封装，代码可读性增强。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[杂记]]></title>
      <url>/2018/06/09/%E5%90%8D%E8%A8%80/</url>
      <content type="html"><![CDATA[<ul>
<li>乌云遮蔽了整个天空，闪电便已在其中酝酿。</li>
<li>世界上只有两种秘密，骗自己的和以为能骗住别人的。</li>
<li>身不由己的抉择是痛苦的，你看似自己做了决定，但做决定的始终是命运</li>
<li>越是充满诱惑的东西，往往会越致命。你是否还会选择？</li>
<li>天空没有痕迹，风雨已在心中。</li>
<li>天地之间的无形之力，也在无形之中改变着天地。</li>
<li>在最深沉的夜里，连自己的影子都会离你而去。</li>
<li>向黑暗走去的人，或许会被黑暗吞噬，或许会化作明灯。</li>
<li>死亡能带走生命，却带不走生命的痕迹。</li>
<li>空谷足音，听到的却是自己的心。</li>
<li>行走在两个世界的边缘，得到更多。</li>
<li>不要随意翻动回忆，因为它是不可测的深渊。</li>
<li>花开在天边，而我需要走过一路的荆棘。</li>
<li>想要看清雾中的景物，不能仅仅相信自己的眼睛。    </li>
<li>若是献出生命就能赢得正义，我下一刻已身在炽热的烈焰中。</li>
<li>恶魔的爪牙伸向每个人的心，你是否还依然纯真？</li>
<li>经历过真正绝望的人，生已是一种施舍，死令他无所畏惧。</li>
<li>炽热火焰焚尽了执念，灰烬里只留下黑色的心。</li>
<li>被岁月冰封的一簇火苗，等待理想把它融化、燃烧。</li>
<li>若承受不了十指连心的痛楚，就别轻易去拼凑记忆的碎片。</li>
<li>锋芒毕露并不一定耀眼，忍辱负重才是求生之道。</li>
<li>世间本没有相思，奈何离分人世，将痴心种出了果实。</li>
<li>蝎子和人的最大区别在于，蝎子往往亮出自己的狠毒，而人则会将之隐藏。</li>
<li>蒙上双眼，看尽黑暗中的风景，心便不再惧怕。</li>
<li>枯井中的人仰观宇宙大千，坐拥天下者四顾高墙如井。</li>
<li>天空其实是无色的，但眼睛欺骗了你；灵魂其实是无欲的，但感情欺骗了你。</li>
<li>利益这杯美酒让人陶醉，但也同样剧毒无比。</li>
<li>时间沉淀为回忆，过去沉淀为传奇，你沉淀为我！</li>
<li>敢于弯腰的树枝，便不会被冰雪压折。</li>
<li>在落子的瞬间，棋手也是心魔控制的棋子。</li>
<li>执着与执念的区别，前者是为了守护珍视的人，后者则是逃避内心的怯懦。</li>
<li>灰烬并不是失败的代表，而是燃烧的证明。</li>
<li>世上最精致的面具，就是我们自己的脸皮。</li>
<li>沾过鲜血的剑可以回鞘，但手执利刃的心却无法轻易收回。</li>
<li>常在夜路独行的人，目光总能捕捉到不易察觉的危险。</li>
<li>许多东西本该腐朽，那就任它悲戚；许多事情本该舍弃，那就别怪它肆虐。</li>
<li>不要以世俗得眼光看低我的梦想，现实与虚幻终究是要斗一场。</li>
<li>在你需要做出选择的时候，你的内心就会经历一场战争。</li>
<li>即使是无尽的黑暗，舍弃一切踏入的价值，是探索无尽的重点。</li>
<li>这世上没有能真正忘记的事，只有你愿不愿意想起，和敢不敢想起。</li>
<li>机会不过是一场稍纵即逝的梦，犹豫只能令你错失改变。</li>
<li>生之路的尽头，好似铺满了荆棘和玫瑰，每一步都是苦海。</li>
<li>我们无法避免失败，只能避免因为失败而选择沉沦。</li>
<li>重点不在他怎么离开，而在其他人看着他背影的目光。</li>
<li>山高一寸，风景独好一寸，然危机也伏多一寸。</li>
<li>摘下面具的一场对话，比穿上铠甲奔赴战场更需要勇气。</li>
<li>规则的制定往往是用来掩盖游戏的本质，用来迷惑那些执着于胜负的人。</li>
<li>对手和敌人是不同的，敌人希望你更弱，对手希望你更强。</li>
<li>没有什么能够禁锢你的强大，除了你的内心。</li>
<li>云淡风轻，满月低垂，脚下万丈悬崖，天空触手可及。</li>
<li>真相虽隐藏在假象之后，但它总有一天会降临。</li>
<li>能者逞霸道之势，强者隐百转之谋。</li>
<li>如果你感到寸步难行，也许是耀眼的光明蒙蔽了你的眼睛。</li>
<li>直到曲终人散，才知晓真相已暗藏于每个符音间。</li>
<li>真正的危机，总在不经意时降临。</li>
<li>隐藏在假象后面的未必是真理，也许是另一个骗局。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis设计与实现-数据结构篇（1）--简单动态字符串SDS]]></title>
      <url>/2018/06/09/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%881%EF%BC%89--%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/</url>
      <content type="html"><![CDATA[<h2 id="Redis中的SDS结构"><a href="#Redis中的SDS结构" class="headerlink" title="Redis中的SDS结构"></a>Redis中的SDS结构</h2><h3 id="sds结构"><a href="#sds结构" class="headerlink" title="sds结构"></a>sds结构</h3><p>Redis并没有使用C语言传统的字符串结构，而是实现了自己的字符串结构sdshdr。具有以下特点：</p>
<ul>
<li>兼容传统C语言字符串类型，C语言字符串能够使用的函数，sds也能够使用</li>
<li>可以O(1)获取字符串长度和空闲空间</li>
<li>以数组的形式存储真正的字符串，保证了字符串二进制安全。</li>
<li>避免了缓冲区溢出的情况</li>
</ul>
<p><a href="https://imgchr.com/i/V71x3R" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V71x3R.md.jpg" alt="V71x3R.md.jpg"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    // buf 中已占用空间的长度</span><br><span class="line">    int len;</span><br><span class="line">    // buf 中剩余可用空间的长度</span><br><span class="line">    int free;</span><br><span class="line">    // 数据空间</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sds字符串获取和长度获取"><a href="#sds字符串获取和长度获取" class="headerlink" title="sds字符串获取和长度获取"></a>sds字符串获取和长度获取</h3><p>在sds结构中，sds指向的buf成员是一个柔性数组，它只起到占位符的作用，并不占用空间。所以sizeof(struct sdshdr)的大小为8字节。</p>
<p>由于sds类型的内存是通过<strong>动态内存分配</strong>的，所以它<strong>存储的内存位置在堆区</strong>，结构如下图。因此sds指针减区sizeof(struct sdshdr)的大小就得到了表头的地址，然后就可以通过”-&gt;”访问表头的成员。<br>所以我们看到在sds.c中，几乎所有的函数的参数都是sds类型，而非表头地址。就是使用了<strong>通过sds指针运算可以获得表头地址</strong>的技巧。<br><a href="https://imgchr.com/i/V71vC9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/06/16/V71vC9.jpg" alt="V71vC9.jpg"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 返回 sds 实际保存的字符串的长度</span><br><span class="line"> *</span><br><span class="line"> * T = O(1)</span><br><span class="line"> */</span><br><span class="line">static inline size_t sdslen(const sds s) &#123;</span><br><span class="line">    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));</span><br><span class="line">    return sh-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 返回 sds 可用空间的长度</span><br><span class="line"> *</span><br><span class="line"> * T = O(1)</span><br><span class="line"> */</span><br><span class="line">static inline size_t sdsavail(const sds s) &#123;</span><br><span class="line">    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));</span><br><span class="line">    return sh-&gt;free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sds申请"><a href="#sds申请" class="headerlink" title="sds申请"></a>sds申请</h3><ol>
<li>根据是否需要初始化，使用zmalloc和zcalloc两个不同函数。</li>
<li>一个字符串刚开始申请的时候，其free空间为0。第一次申请的实际申请空间位sizeof(sdshds)+len+1。</li>
<li>由于返回的是sh-&gt;buf，那么如果需要计算sh的长度或空闲空间怎么办？根据前面的sdslen函数，我们可以知道是通过减去两个int长度就得到了sh的地址。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sds sdsnewlen(const void *init, size_t initlen) &#123;</span><br><span class="line">    struct sdshdr *sh;</span><br><span class="line"></span><br><span class="line">    if (init) &#123;</span><br><span class="line">        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (sh == NULL) return NULL;</span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    sh-&gt;free = 0;</span><br><span class="line">    if (initlen &amp;&amp; init)</span><br><span class="line">        memcpy(sh-&gt;buf, init, initlen);</span><br><span class="line">    sh-&gt;buf[initlen] = &apos;\0&apos;;</span><br><span class="line">    return (char*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="sds预分配"><a href="#sds预分配" class="headerlink" title="sds预分配"></a>sds预分配</h3><ol>
<li>如果空闲长度大于需要增加的长度，则不会申请</li>
<li>如果新sds长度=（原sds长度+需要增加的长度）小于SDS_MAX_PREALLOC（1M）则申请新sds长度的2倍，否则每次只申请1M的空间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Enlarge the free space at the end of the sds string so that the caller</span><br><span class="line"> * is sure that after calling this function can overwrite up to addlen</span><br><span class="line"> * bytes after the end of the string, plus one more byte for nul term.</span><br><span class="line"> * </span><br><span class="line"> * Note: this does not change the *length* of the sds string as returned</span><br><span class="line"> * by sdslen(), but only the free buffer space we have. */</span><br><span class="line">sds sdsMakeRoomFor(sds s, size_t addlen) &#123;</span><br><span class="line">    struct sdshdr *sh, *newsh;</span><br><span class="line">    size_t free = sdsavail(s);</span><br><span class="line">    size_t len, newlen;</span><br><span class="line"></span><br><span class="line">    if (free &gt;= addlen) return s;</span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (void*) (s-(sizeof(struct sdshdr)));</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    if (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= 2;</span><br><span class="line">    else</span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);</span><br><span class="line">    if (newsh == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    newsh-&gt;free = newlen - len;</span><br><span class="line">    return newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="sds惰性删除"><a href="#sds惰性删除" class="headerlink" title="sds惰性删除"></a>sds惰性删除</h3><p>惰性空闲释放用于优化sds的字符串缩短操作。<br>当要缩短sds保存的字符串时，程序并不会立即进行内存回收操作，而是使用表头的free成员将这些字节记录，等待以后使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void sdsclear(sds s) &#123;  //重置sds的buf空间，懒惰释放</span><br><span class="line">    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));</span><br><span class="line">    sh-&gt;free += sh-&gt;len;    //表头free成员+已使用空间的长度len = 新的free</span><br><span class="line">    sh-&gt;len = 0;            //已使用空间变为0</span><br><span class="line">    sh-&gt;buf[0] = &apos;\0&apos;;         //字符串置空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>sdsnew</td>
<td>创建一个包含给定C字符串的SDS</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdsempty</td>
<td>创建一个内容为空的SDS</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsfree</td>
<td>释放给定的SDS</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdslen</td>
<td>返回SDS已使用空间字节数</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsavail</td>
<td>返回SDS未使用的空间字节数</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsdup</td>
<td>创建一个给定的SDS副本</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdsclear</td>
<td>清空SDS保存的字符串内容</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdscat</td>
<td>将给定的C字符串拼接到SDS末尾</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdscatsds</td>
<td>将给定的SDS字符串拼接到SDS末尾</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdscpy</td>
<td>将给定C字符串复制到SDS中，覆盖原有的字符串</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdsgrowzero</td>
<td>用空字符串扩展至给定长度</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdsrange</td>
<td>保留SDS给定区间的数据，不在区间内的数据将会被清除</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdstrim</td>
<td>将SDS中出现的C字符串给清除</td>
<td>O(M*N)</td>
</tr>
<tr>
<td>sdscmp</td>
<td>对比两个SDS是否相同</td>
<td>O(N)</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis逆向工程]]></title>
      <url>/2018/04/23/Mybatis/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>&ensp;&ensp;逆向工程的字面意思就是反向生成工程。<br>使用逆向工程时，需要注意的是表之间的关系无法映射出来！也就是说Mybatis的逆向工程生成的都是单表操作。</p>
<ol>
<li><p>Mybatis逆向工程开发文档<br><a href="http://www.mybatis.org/generator/configreference/xmlconfig.html" target="_blank" rel="noopener">http://www.mybatis.org/generator/configreference/xmlconfig.html</a></p>
</li>
<li><p>使用逆向工程生成代码有好几种方式，这里就介绍一种最简单的，Java程序生成（解释在配置中)<br>&ensp;&ensp;2.1 准备逆向工程配置文件genreatorConfig.xml,名字无所谓,只要在java程序中作为file传入就好:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;!--数据库驱动,最好不要有中文字符,不然会找不到--&gt;</span><br><span class="line">    &lt;classPathEntry location=&quot;F:/cache/mysql-connector-java-5.1.28-bin.jar&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;context id=&quot;DB2Tables&quot;    targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;commentGenerator&gt;</span><br><span class="line">            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;!--数据库链接地址账号密码--&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost/test&quot; userId=&quot;root&quot; password=&quot;&quot;&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;/javaTypeResolver&gt;</span><br><span class="line">        &lt;!--生成Model类存放位置--&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.leige.domain&quot; targetProject=&quot;src&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/javaModelGenerator&gt;</span><br><span class="line">        &lt;!--生成映射文件存放位置--&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.leige.domain&quot; targetProject=&quot;src&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line">        &lt;!--生成DaoMapper类存放位置--&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.leige.dao&quot; targetProject=&quot;src&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line">        &lt;!--生成对应表及类名,需要记住的一点是逆向工程无法生成关联关系,只能生成单表操作--&gt;</span><br><span class="line">        &lt;table tableName=&quot;student&quot; </span><br><span class="line">            domainObjectName=&quot;Student&quot; </span><br><span class="line">          &gt;&lt;/table&gt;</span><br><span class="line">           &lt;table tableName=&quot;teacher&quot; </span><br><span class="line">            domainObjectName=&quot;Teacher&quot; </span><br><span class="line">          &gt;&lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<p>&ensp;&ensp;2.2<a href="http://pan.baidu.com/s/1jIvLufG" target="_blank" rel="noopener">下载jar包</a><br>&ensp;&ensp;2.3准备java程序,在开发文档首页,粘贴一下就好了,没必要记住:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.leige.test;</span><br><span class="line"></span><br><span class="line">import java.awt.geom.GeneralPath;</span><br><span class="line">import java.awt.im.InputContext;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.log4j.chainsaw.Main;</span><br><span class="line">import org.apache.log4j.lf5.util.Resource;</span><br><span class="line">import org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line">import org.mybatis.generator.config.Configuration;</span><br><span class="line">import org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line">import org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line">public class MybatisGen &#123;</span><br><span class="line">    public static void generator() throws Exception&#123;</span><br><span class="line">           List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">           boolean overwrite = true;</span><br><span class="line">           //项目根路径不要有中文,我的有中文,所以使用绝对路径</span><br><span class="line">           File configFile = new File(&quot;F:/cache/generatorConfig.xml&quot;);</span><br><span class="line">           ConfigurationParser cp = new ConfigurationParser(warnings);</span><br><span class="line">           Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">           DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">           MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);</span><br><span class="line">           myBatisGenerator.generate(null);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            generator();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;2.4运行java程序,就会发现生成的代码: </p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[缓存机制]]></title>
      <url>/2018/04/21/Mybatis/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>Mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。<br>Mybatis提供一级缓存和二级缓存。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98.png" alt="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98.png"><br><a id="more"></a><br>一级缓存是SqlSession级别的缓存。在操作数据库时需要构造SqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的SqlSession之间的缓存数据区域是互相不影响的。</p>
<p>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"><br>第一次发起查询的时候，先在缓存中查询是否有相应数据，有就直接返回；如果没有则从数据库获取信息并存储在一级缓存中。  </p>
<p>如果SqlSession执行commit操作（执行插入、更新、删除）时，清空SqlSession中的一级缓存。这是为了让缓存中存储的是最新的信息，避免脏读。  </p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>Mybatis默认支持一级缓存。不需要配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  @Test</span><br><span class="line">    public void testCacha_1()&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user = userMapper.findUserById(1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">//        user.setName(&quot;heh&quot;);</span><br><span class="line">//        userMapper.updateUserName(user);</span><br><span class="line">        User user1 = userMapper.findUserById(1);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98debug.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98debug.png"><br>去掉代码中的注释后，输出：<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0debug.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0debug.png"></p>
<p>只用一级缓存时读取出来的值可能不是最新的。<br>例如：SqlSession1查询，SqlSession2修改，SqlSession1再查询，此时会导致SqlSession1第一次查找的结果不是最新的。此时就需要二级缓存了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacha_1_more</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="line">        SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user = userMapper1.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        user1.setName(<span class="string">"zan"</span>);</span><br><span class="line">        user1.setId(<span class="number">1</span>);</span><br><span class="line">        userMapper2.updateUserName(user1);</span><br><span class="line"></span><br><span class="line">        User user2 = userMapper1.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E4%B8%8D%E5%8F%8A%E6%97%B6.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Mybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E4%B8%8D%E5%8F%8A%E6%97%B6.png"></p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><h3 id="二级缓存原理"><a href="#二级缓存原理" class="headerlink" title="二级缓存原理"></a>二级缓存原理</h3><p><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>
<p>开启Mybatis的二级缓存后。</p>
<p>SqlSession1去查询信息，查询到的信息将会存储到二级缓存中。<br>如果SqlSession3去执行相同mapper下SQL，执行commit提交；将会清空二级缓存。<br>SqlSession去查询信息，现在二级缓存中查找数据。如果存在就直接取出。</p>
<font color="red">二级缓存的范围更大，多个SqlSession可以共享Mapper的二级缓存区域。</font>

<h3 id="开启二级缓存"><a href="#开启二级缓存" class="headerlink" title="开启二级缓存"></a>开启二级缓存</h3><ul>
<li><p>在SqlMapConfig.xml中加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在UserMapper.xml中开启二级缓存。UserMapper.xml下的sql磁性完成会存储到它的缓存区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;dao.UserMapper&quot;&gt;</span><br><span class="line">    &lt;cache /&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为二级缓存存储介质多种多样，不一定在内存。对应的实体需要实现序列化接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacha_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user1 = userMapper1.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        User user = new User();</span></span><br><span class="line"><span class="comment">//        user.setId(2);</span></span><br><span class="line"><span class="comment">//        user.setName("GG");</span></span><br><span class="line"><span class="comment">//        userMapper1.updateUserName(user);</span></span><br><span class="line"></span><br><span class="line">        sqlSession1.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user2 = userMapper2.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">        sqlSession2.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="useCache配置"><a href="#useCache配置" class="headerlink" title="useCache配置"></a>useCache配置</h3><p>在statement中设置&lt;font color = ‘red”&gt;useCache=”false”可以禁用当前select的二级缓存，即每次查询都会发出SQL去查询。默认情况是true。<br>如果每次查询都需要最新的数据sql时要禁用二级缓存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findOrderListResultMap&quot; resultMap=&quot;ordersUserMap&quot; useCache=&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h3><p>刷新缓存就是清空缓存。在mapper的同一个namespace中，如果有其他insert、update、delete操作数据后需要刷新缓存，否则会出现脏读现象。</p>
<p>设置statement配置中的&lt;font color = ‘red”&gt;flushCache=”true”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;pojo.User&quot; flushCache=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="应用场景和局限性"><a href="#应用场景和局限性" class="headerlink" title="应用场景和局限性"></a>应用场景和局限性</h3><ul>
<li><p>应用场景<br>对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。<br>实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。</p>
</li>
<li><p>局限性<br>mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[延迟加载]]></title>
      <url>/2018/04/21/Mybatis/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>resultMap可以实现高级映射（使用association、collection实现一对一以及一对多映射），association、collection具备延迟加载功能。</p>
<p>延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能。<br><a id="more"></a><br>开启延迟加载需要在SqlMapConfig.xml的setting中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!-- 打开延迟加载 的开关 --&gt;</span><br><span class="line">    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;!-- 将积极加载改为消极加载即按需要加载 --&gt;</span><br><span class="line">    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure></p>
<p>书写需要的两个satatement </p>
<ul>
<li>查询用户</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUserLazy&quot; resultMap=&quot;findUserAndCarLazyMap&quot;&gt;</span><br><span class="line">        SELECT *</span><br><span class="line">        FROM user</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查询拥有的Car  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findCarByUserId&quot; parameterType=&quot;int&quot; resultType=&quot;pojo.Car&quot;&gt;</span><br><span class="line">        SELECT *</span><br><span class="line">        FROM car</span><br><span class="line">        WHERE user_id = #&#123;value&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>书写resultMap  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;findUserAndCarLazyMap&quot; type=&quot;pojo.User&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;password&quot; column=&quot;password&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            多了select和column</span><br><span class="line">            select:会去寻找相应的方法，如果不在本mapper中则需要在前面添加其namespace（我这里是放在本mapper中的）</span><br><span class="line">            column:根据哪一列去进行查询。</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;association property=&quot;car&quot;</span><br><span class="line">                     select=&quot;findCarByUserId&quot; </span><br><span class="line">                     column=&quot;id&quot;</span><br><span class="line">                     javaType=&quot;pojo.Car&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/association&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在相应的Mapper接口中书写方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public User findUserLazy(int id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testFindUserLazyLoding()&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user = userMapper.findUserLazy(2);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        //System.out.println(user.getCar().toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>PS:这里不知道是我用的IDEA的问题还是怎么的，在输出的时候竟然也执行了第二条sql语句。。。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDdebug.png" alt="http://ocx5m3vc3.bkt.clouddn.com/mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDdebug.png"></p>
<center>延迟加载debug</center><br><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis%E4%B8%8D%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDdebug.png" alt="http://ocx5m3vc3.bkt.clouddn.com/mybatis%E4%B8%8D%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BDdebug.png"><br><center>不延迟加载debug</center>

<hr>
<p>更新：后来发现出现上面第一图的情况是由于在System.out.println(user);会执行第二条SQL。。  需要配置一下设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setting     name=&quot;lazyLoadTriggerMethods&quot; value=&quot; &quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>lazyLoadTriggerMethods默认情况下仅仅支持自动将equals,clone,hashCode,toString这几个方法定义为延迟加载的加载触发方法。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动态sql]]></title>
      <url>/2018/04/21/Mybatis/%E5%8A%A8%E6%80%81sql/</url>
      <content type="html"><![CDATA[<p>mybatis核心。对sql语句进行灵活操作，通过表达式进行判断，对SQL进行灵活拼接、组装。<br><a id="more"></a></p>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><ul>
<li>mapper.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"pojp.UserQueryVo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"pojo.UserCustom"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="comment">&lt;!--  where 可以自动去掉条件中的第一个and --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom!=null"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.sex!=null and userCustom.sex != '' "</span>&gt;</span></span><br><span class="line">               AND user.sex=#&#123;userCustom.sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.username!=null and userCustom.username != '' "</span>&gt;</span></span><br><span class="line">               AND user.username LIKE '%$&#123;userCustom.username&#125;%'</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：如果传入的userCustom为null<br>那么查询语句会变成<font color="red">SELECT * FROM user</font></p>
<h3 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h3><p>将上面实现的动态sql判断代码块抽取出来，组成一个sql片段。其他的statement中就可以应用sql片段。</p>
<ul>
<li><p>定义SQL片段</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义sql片段</span></span><br><span class="line"><span class="comment">id：sql片段的唯 一标识</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">经验：是基于单表来定义sql片段，这样话这个sql片段可重用性才高</span></span><br><span class="line"><span class="comment">在sql片段中不要包括 where</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"query_user_where"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom!=null"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.sex!=null and userCustom.sex!=''"</span>&gt;</span></span><br><span class="line">            AND user.sex = #&#123;userCustom.sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userCustom.username!=null and userCustom.username!=''"</span>&gt;</span></span><br><span class="line">            AND user.username LIKE '%$&#123;userCustom.username&#125;%'</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用SQL片段</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"pojo.UserQueryVo"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">"pojo.UserCustom"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"query_user_where"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在这里还要引用其它的sql片段  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p>向SQL传递数组或List，mybatis使用foreach解析<br>多id条件查询常有以下两种sql写法：  </p>
<ul>
<li><font color="red">SELECT * FROM USER WHERE id=1 OR id=10 OR id=16</font>  </li>
<li><font color="red">SELECT * FROM USER WHERE id IN(1,10,16)</font>

</li>
</ul>
<p>在输入参数类型中添加<font color="red">List<integer> ids</integer></font>传入多个id<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserQueryVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入多个id</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line"></span><br><span class="line">    getter、setter方法</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改mapper.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ids!=null"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 foreach遍历传入ids</span></span><br><span class="line"><span class="comment">    collection：指定输入 对象中集合属性</span></span><br><span class="line"><span class="comment">    item：每个遍历生成对象中</span></span><br><span class="line"><span class="comment">    open：开始遍历时拼接的串</span></span><br><span class="line"><span class="comment">    close：结束遍历时拼接的串</span></span><br><span class="line"><span class="comment">    separator：遍历的两个对象中需要拼接的串</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用实现下边的sql拼接：</span></span><br><span class="line"><span class="comment">     AND (id=1 OR id=10 OR id=16)</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"user_id"</span> <span class="attr">open</span>=<span class="string">"AND ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">"or"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每个遍历需要拼接的串 --&gt;</span></span><br><span class="line">        id=#&#123;user_id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 实现  “ and id IN(1,10,16)”拼接 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;foreach collection="ids" item="user_id" open="and id IN(" close=")" separator=","&gt;</span></span><br><span class="line"><span class="comment">        每个遍历需要拼接的串</span></span><br><span class="line"><span class="comment">        #&#123;user_id&#125;</span></span><br><span class="line"><span class="comment">    &lt;/foreach&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[phpStudy升级MySQL]]></title>
      <url>/2018/04/20/%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E5%9D%91/phpStudy%E5%8D%87%E7%BA%A7MySQL/</url>
      <content type="html"><![CDATA[<p>今天在导入别人给我的sql文件的时候，怎么也导不进去。后来才知道我用的phpStudy的SQL版本太低了。于是需要升级一下。</p>
<p>首先从官网下载MySql安装包<a href="https://dev.mysql.com/downloads/file/?id=467269" title="https://dev.mysql.com/downloads/file/?id=467269" target="_blank" rel="noopener">https://dev.mysql.com/downloads/file/?id=467269</a></p>
<p>步骤：<br>1.最好先备份一份原来phpStudy的MYSQL文件夹<br>2.把下载的 MySQL 压缩文件解压至 phpStudy 下的 MySQL目录，复制 my-default.ini ，重命名为 my.ini。<br>3.打开 my.ini，找到 #basedir 处编辑：  </p>
<pre><code>basedir = I:\phpStudy\MySQL  
datadir = I:\phpStudy\MySQL\data  
</code></pre>
注：有任何错误都是因为以上路径配置错误导致的
<a id="more"></a>
4.把 MySQL 安装路径添加至系统环境变量  
PATH=…….;I:\phpStudy\MySQL\bin

5.在 cmd 下进入 MySQL 的 bin 目录（我的是 I:\phpStudy\MySQL\bin），执行：  
初始化数据库：  
<pre><code>mysqld --initialize
</code></pre>  

<p>安装服务：  </p>
<pre><code>mysqld -install
</code></pre> 

<p>启动服务：  </p>
<pre><code>net start MySQL
</code></pre>

<p>6.打开 my.ini，找到 [mysqld]，在下面添加：<br>skip-grant-tables(此参数用于忘记mysql密码)<br>此时使用 root 账号，密码处按回车即可登录。</p>
<p>7.修改密码：  </p>
<pre><code>mysql>update mysql.user set authentication_string=password('新密码') where user='root' and Host ='localhost';
</code></pre>  
8.刷新权限：  
<pre><code>FLUSH PRIVILEGES;
</code></pre>  
9.注释掉 my.ini 中刚才添加的
skip-grant-tables
重新登录。

10.更新用户信息：  
<pre><code>mysql> ALTER USER USER() IDENTIFIED BY '新密码';
</code></pre>
11.查看 mySQL 版本：  
<pre><code>mysql> select version();  
+-----------+  
| version() |  
+-----------+  
| 5.7.17 |  
+-----------+  
</code></pre>]]></content>
      
        <categories>
            
            <category> 软件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 坑 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[输入映射和输出映射]]></title>
      <url>/2018/04/20/Mybatis/%E8%BE%93%E5%85%A5%E6%98%A0%E5%B0%84%E5%92%8C%E8%BE%93%E5%87%BA%E6%98%A0%E5%B0%84/</url>
      <content type="html"><![CDATA[<h2 id="输入映射"><a href="#输入映射" class="headerlink" title="输入映射"></a>输入映射</h2><p>Mybatis映射文件通过<font color="red">parameterType</font>指定输入参数的类型，类型可以是  </p>
<ul>
<li>简单类型</li>
<li>hashmap</li>
<li>pojo的包装类型</li>
</ul>
<p>在xml映射文件中sql语句会根据OGNL自动获取传入类型中的属性值。<br>如果传入类型中没有相应的属性值，就会报找不到对应属性的错。  </p>
<p>即使传入类型的具体对象中的相应属性为null，也并不会报错。因为Mybatis使用的是动态sql，如果没有设置某个值，条件就不会拼接在sql中去。<br><a id="more"></a></p>
<h2 id="输出映射"><a href="#输出映射" class="headerlink" title="输出映射"></a>输出映射</h2><p>输入映射主要有两种方式： </p>
<ul>
<li><font color="red">resultType</font></li>
<li><font color="red">resultMap</font>

</li>
</ul>
<h3 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h3><ul>
<li>使用<font color="red">resultType</font>进行输出映射时，只有查询出来的列名和pojo中的属性名一致，才能映射成功。<ul>
<li>列名与pojo的属性名<b>只要有一个不一致</b>就不会创建pojo对象，此时会报错。</li>
<li>列名与pojo的属性名<b>只要有一个一致</b>就会创建一个pojo对象并返回。</li>
</ul>
</li>
</ul>
<h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>如果查询出来的列名和pojo的属性名不一致，可以通过定义一个resultMap对列名和属性名之间进行映射。<br>1.定义resultMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt;</span><br><span class="line">        &lt;!-- id表示查询结果集中唯一标识 </span><br><span class="line">        column：查询出来的列名</span><br><span class="line">        property：type指定的pojo类型中的属性名</span><br><span class="line">        最终resultMap对column和property作一个映射关系 （对应关系）</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;!-- </span><br><span class="line">        result：对普通名映射定义</span><br><span class="line">        column：查询出来的列名</span><br><span class="line">        property：type指定的pojo类型中的属性名</span><br><span class="line">        最终resultMap对column和property作一个映射关系 （对应关系）</span><br><span class="line">         --&gt;</span><br><span class="line">        &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        一对一映射</span><br><span class="line">        association：用于映射关联查询单个对象的信息</span><br><span class="line">        property：要将关联查询的用户信息映射到Orders中哪个属性</span><br><span class="line">        javaType：映射到user的哪个属性</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;!--</span><br><span class="line">       一对多映射</span><br><span class="line">       collection：对关联查询到多条记录映射到集合对象中</span><br><span class="line">       property：将关联查询到多条记录映射到com.iot.mybatis.po.Orders哪个属性</span><br><span class="line">       ofType：指定映射到list集合属性中pojo的类型</span><br><span class="line">       --&gt;</span><br><span class="line">     &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<p>2.使用resultMap作为statement的输出映射类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用resultMap进行输出映射</span><br><span class="line">        resultMap：指定定义的resultMap的id，如果这个resultMap在其它的mapper文件，前边需要加namespace</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;</span><br><span class="line">        SELECT id id_,username username_ FROM USER WHERE id=#&#123;value&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>使用resultMap多表查询时，可能会导致重复字段赋值错误。<br>解决方法：在查询时定义别名。resultMap中根据别名列来映射</p>
<hr>
<p>resultType和resultMap区别：</p>
<ul>
<li>resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。</li>
<li>resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。</li>
<li>resultMap可以实现延迟加载，resultType无法实现延迟加载。</li>
</ul>
<hr>
<p>association：</p>
<ul>
<li>作用：将关联查询信息映射到一个pojo对象中。  </li>
<li>场合：为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。</li>
</ul>
<p>collection：  </p>
<ul>
<li>作用：将关联查询信息映射到一个list集合中。</li>
<li>场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。如果使用resultType无法将查询结果映射到list集合中。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SqlMapConfig]]></title>
      <url>/2018/04/20/Mybatis/SqlMapConfig/</url>
      <content type="html"><![CDATA[<p>SqlMapConfig.xml中配置的内容和顺序： </p>
<ul>
<li>properties(属性)</li>
<li>settings(全局配置参数)</li>
<li><b>typeAliases(类型别名)</b></li>
<li><em>objectFactory(对象工厂)</em></li>
<li><em>plugins(插件)</em></li>
<li>environments(环境集合属性对象)  <ul>
<li>environment(环境属性对象)<ul>
<li>transactionManager(事务管理)</li>
<li>dataSource(数据源)</li>
</ul>
</li>
</ul>
</li>
<li><b>mappers(映射器）</b></li>
</ul>
<a id="more"></a>
<h3 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties(属性)"></a>properties(属性)</h3><p>将数据库连接参数单独配置在db.properties中，可以避免xml硬编码，方便以后更改以及其他文件使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:////mybatis?characterEncoding=utf-8</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123</span><br></pre></td></tr></table></figure></p>
<p>在sqlMapConfig.xml中加载属性文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--properties中还可以配置一些属性名和属性值  --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="jdbc.driver" value=""/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><font color="red">Mybatis加载资源属性顺序：(后面加载的会覆盖前面）</font>  </p>
<ol>
<li>在<b>properties</b>元素体内定义的属性</li>
<li><b>properties</b>元素中resource或url加载的属性</li>
<li><b>parameterType</b>传递的属性</li>
</ol>
<h3 id="settings-全局参数配置"><a href="#settings-全局参数配置" class="headerlink" title="settings(全局参数配置)"></a>settings(全局参数配置)</h3><p>Mybatis框架运行时的一些参数。比如：二级缓存、延迟加载等<br>官方文档：<a href="http://www.mybatis.org/mybatis-3/configuration.html#settings" title="http://www.mybatis.org/mybatis-3/configuration.html#settings" target="_blank" rel="noopener">mybatis-settings</a></p>
<h3 id="typeAliases-类型别名"><a href="#typeAliases-类型别名" class="headerlink" title="typeAliases(类型别名)"></a>typeAliases(类型别名)</h3><p><font color="red">parameterType</font> 指定输入参数的类型  </p>
<p><font color="red">resultType</font> 指定输出参数的映射类型<br>每次都要输入全名路径太过于麻烦,类型别名简化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 别名定义 --&gt;</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 针对单个别名定义</span><br><span class="line">    type：类型的路径</span><br><span class="line">    alias：别名</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;!-- &lt;typeAlias type=&quot;Pojo.User&quot; alias=&quot;user&quot;/&gt; --&gt;</span><br><span class="line">    &lt;!-- 批量别名定义</span><br><span class="line">    指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写或小写都可以）</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;package name=&quot;Pojo&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure></p>
<p>具体参考官网文档：<a href="http://www.mybatis.org/mybatis-3/configuration.html#typeAliases" title="http://www.mybatis.org/mybatis-3/configuration.html#typeAliases" target="_blank" rel="noopener">typeAliases</a></p>
<p>Mybatis默认支持的别名 </p>
<center>（8大基本类型及其包装类+Data+大数类型） </center>

<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型   </th>
</tr>
</thead>
<tbody>
<tr>
<td>_byte</td>
<td>byte  </td>
</tr>
<tr>
<td>_long</td>
<td>long  </td>
</tr>
<tr>
<td>_short</td>
<td>short  </td>
</tr>
<tr>
<td>_int</td>
<td>int  </td>
</tr>
<tr>
<td>_integer</td>
<td>int  </td>
</tr>
<tr>
<td>_double</td>
<td>double  </td>
</tr>
<tr>
<td>_float</td>
<td>float  </td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean  </td>
</tr>
<tr>
<td>string</td>
<td>String  </td>
</tr>
<tr>
<td>byte</td>
<td>Byte  </td>
</tr>
<tr>
<td>long</td>
<td>Long  </td>
</tr>
<tr>
<td>short</td>
<td>Short  </td>
</tr>
<tr>
<td>int</td>
<td>Integer  </td>
</tr>
<tr>
<td>integer</td>
<td>Integer  </td>
</tr>
<tr>
<td>double</td>
<td>Double  </td>
</tr>
<tr>
<td>float</td>
<td>Float  </td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean  </td>
</tr>
<tr>
<td>date</td>
<td>Date  </td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal  </td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal  </td>
</tr>
</tbody>
</table>
<h3 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers(类型处理器)"></a>typeHandlers(类型处理器)</h3><p>mybatis中通过typeHandlers完成jdbc类型和java类型的转换。<br>参考：<a href="http://www.mybatis.org/mybatis-3/configuration.html#typeHandlers" title="http://www.mybatis.org/mybatis-3/configuration.html#typeHandlers" target="_blank" rel="noopener">typeHandlers</a></p>
<h3 id="mappers-映射配置"><a href="#mappers-映射配置" class="headerlink" title="mappers(映射配置)"></a>mappers(映射配置)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--通过resource方法一次加载一个映射文件 --&gt;</span><br><span class="line">&lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--通过mapper接口加载单个mapper--&gt;</span><br><span class="line">&lt;mapper class=&quot;mapper.UserMapper&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 批量加载mapper(推荐使用)</span><br><span class="line">        指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载</span><br><span class="line">        遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 中</span><br><span class="line">        上边规范的前提是：使用的是mapper代理方法</span><br><span class="line">         --&gt;</span><br><span class="line">&lt;package name=&quot;mapper&quot;/&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis--原始dao和mapper代理方法]]></title>
      <url>/2018/04/20/Mybatis/Mybatis-%E5%8E%9F%E5%A7%8Bdao%E5%92%8Cmapper%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<ul>
<li><p>SqlSessionFactoryBuilder<br>通过<font color="red">SqlSessionFactoryBuilder</font>创建会话工厂<font color="red">SqlSessionFactory</font>。将<font color="red">SqlSessionFactoryBuilder</font>当成一个工具类使用即可，不需要使用单例管理<font color="red">SqlSessionFactoryBuilder</font>。在创建<font color="red">SqlSessionFactory</font>时候，只需要new一次<font color="red">SqlSessionFactoryBuilder</font>即可。</p>
</li>
<li><p>SqlSessionFactory<br>通过<font color="red">SqlSessionFactory</font>创建<font color="red">SqlSession</font>；由于<font color="red">SqlSessionFactory</font>是线程安全的，应该在应用执行期间都存在，所以在应用运行期间不要重复创建多次，建议使用单例模式。</p>
</li>
<li><p>SqlSession<br><font color="red">SqlSession</font>是应用程序和持久层之间执行交互操作的一个单线程对象。<font color="red">SqlSession</font>中提供了许多操作数据库的方法。<br><font color="red">SqlSession</font>是线程不安全的。<br>使用完<font color="red">SqlSession</font>要确保在finally块中关闭它。</p>
<a id="more"></a>
<h2 id="原始dao接口开发"><a href="#原始dao接口开发" class="headerlink" title="原始dao接口开发"></a>原始dao接口开发</h2><p>程序员需要写dao接口和dao实现类  </p>
<h3 id="dao接口"><a href="#dao接口" class="headerlink" title="dao接口"></a>dao接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="dao接口实现类"><a href="#dao接口实现类" class="headerlink" title="dao接口实现类"></a>dao接口实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用构造方法注入SqlSessionFactory</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoImpl</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        User user = sqlSession.selectOne(<span class="string">"test.findUserById"</span>,id);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">"test.findUserByName"</span>,name);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//mybatis配置文件</span></span><br><span class="line">        String resource = <span class="string">"sqlMapConfig.xml"</span>;</span><br><span class="line">        <span class="comment">//得到配置文件流</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="comment">//创建会话工厂</span></span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDao</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建UserDao的对象</span></span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDaoImpl(sqlSessionFactory);</span><br><span class="line">        User user = userDao.findUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        List&lt;User&gt; list = userDao.findUserByName(<span class="string">"ho"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结原始dao开发问题"><a href="#总结原始dao开发问题" class="headerlink" title="总结原始dao开发问题"></a>总结原始dao开发问题</h3><p>1.dao接口实现类方法中存在大量的模板方法。<br>2.调用SqlSession方法时传入参数硬编码。<br>3.由于SqlSession方法使用泛型，即使变量类型传入错误，在编译阶段也不会报错，不利于程序员开发。</p>
<hr>
<h2 id="mapper代理方法"><a href="#mapper代理方法" class="headerlink" title="mapper代理方法"></a>mapper代理方法</h2><p>程序员只需要mapper接口(相当于dao接口)<br>程序员还需要编写mapper.xml映射文件<br>程序员编写mapper接口需要遵循一些开发规范，Mybatis可以自动生成mapper接口实现类代理对象。</p>
<h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><ul>
<li><p>在mapper.xml中namespace等于mapper接口地址</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离</span></span><br><span class="line"><span class="comment"> 注意：使用mapper代理方法开发，namespace有特殊重要的作用,namespace等于mapper接口地址</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"mapper.UserMapper"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mapper.java接口中的方法名和mapper.xml中statement的id一致  </p>
</li>
<li>mapper.java接口中的方法输入参数类型和mapper.xml中statement的parameterType指定的类型一致。  </li>
<li>mapper.java接口中的方法返回值类型和mapper.xml中statement的resultType指定的类型一致。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis入门程序2]]></title>
      <url>/2018/04/19/Mybatis/Mybatis%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F2/</url>
      <content type="html"><![CDATA[<p>在User.xml文件中增加增删改三个功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">       parameterType 为实体对象</span><br><span class="line">       #&#123;&#125; 会使用OGNL来获得同名的值</span><br><span class="line">       insert update delete 默认返回的都是影响的条数</span><br><span class="line">   --&gt;</span><br><span class="line">   &lt;insert id=&quot;insertUser&quot; parameterType=&quot;Pojo.User&quot;&gt;</span><br><span class="line">       &lt;!--</span><br><span class="line">           如果要求返回刚插入的id值则需要增加&lt;selectKey&gt;</span><br><span class="line"></span><br><span class="line">           SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用与自增主键</span><br><span class="line">           keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性</span><br><span class="line">           order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序</span><br><span class="line">           resultType：指定SELECT LAST_INSERT_ID()的结果类型</span><br><span class="line"></span><br><span class="line">           //也可以使用以下这种方法</span><br><span class="line">           useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</span><br><span class="line"></span><br><span class="line">           以上两种方法可以自动将id赋值给传入的那个实体相应的属性中去</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">           SELECT LAST_INSERT_ID()</span><br><span class="line">       &lt;/selectKey&gt;</span><br><span class="line">       INSERT INTO user(name,password)</span><br><span class="line">       VALUES (#&#123;name&#125;,#&#123;password&#125;)</span><br><span class="line"></span><br><span class="line">   &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--更新用户信息，id必须存在--&gt;</span><br><span class="line">   &lt;update id=&quot;updateUser&quot; parameterType=&quot;Pojo.User&quot;&gt;</span><br><span class="line">       UPDATE user</span><br><span class="line">       SET password = #&#123;password&#125;</span><br><span class="line">       WHERE id = #&#123;id&#125;</span><br><span class="line">   &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--根据id删除用户--&gt;</span><br><span class="line">   &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">       DELETE FROM</span><br><span class="line">       user</span><br><span class="line">       WHERE id = #&#123;id&#125;</span><br><span class="line">   &lt;/delete&gt;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在测试类中添加相应的三个测试方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//增加测试</span><br><span class="line">      User user = new User();</span><br><span class="line">      user.setName(&quot;JJ&quot;);</span><br><span class="line">      user.setPassword(&quot;JJ&quot;);</span><br><span class="line">      sqlSession.insert(&quot;test.insertUser&quot;,user);</span><br><span class="line">      System.out.println(user.getId());</span><br><span class="line"></span><br><span class="line">//更新测试</span><br><span class="line">      User user = new User();</span><br><span class="line">      user.setId(4);</span><br><span class="line">      user.setName(&quot;JJ&quot;);</span><br><span class="line">      user.setPassword(&quot;KK&quot;);</span><br><span class="line">      sqlSession.update(&quot;test.updateUser&quot;,user);</span><br><span class="line"></span><br><span class="line">      //删除测试</span><br><span class="line">sqlSession.delete(&quot;test.deleteUser&quot;,4);</span><br></pre></td></tr></table></figure></p>
<h3 id="mybatis和hibernate本质区别和应用场景"><a href="#mybatis和hibernate本质区别和应用场景" class="headerlink" title="mybatis和hibernate本质区别和应用场景"></a>mybatis和hibernate本质区别和应用场景</h3><ul>
<li>hibernate  </li>
</ul>
<p>是一个标准ORM框架（对象关系映射）。入门门槛较高的，不需要程序写sql，sql语句自动生成了。对sql语句进行优化、修改比较困难的。<font color="red">hibernate对象/关系映射能力强，数据库无关性好。</font></p>
<p>应用场景：适用与需求变化不多的中小型项目，比如：后台管理系统，erp、orm、oa。。</p>
<ul>
<li>mybatis</li>
</ul>
<p>专注是sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，mybatis也可以实现映射（输入映射、输出映射）。<font color="red">但是灵活的前提是Mybatis无法做到数据库无关性。</font></p>
<p>应用场景：适用与需求变化较多的项目，比如：互联网项目。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis入门程序]]></title>
      <url>/2018/04/19/Mybatis/Mybatis%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>在IDEA中新建一个Java项目。并加入jar包，工程结构如图。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="">  </p>
<a id="more"></a>
<ul>
<li>在config文件夹中创建出所需要的配置文件</li>
<li>log4j.properties</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"># Console output...</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>
<ul>
<li><p>SqlMapConfig.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 和spring整合后 environments配置将废除 --&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;!-- 使用jdbc事务管理 --&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot; /&gt;</span><br><span class="line">            &lt;!-- 数据库连接池 --&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot;</span><br><span class="line">                          value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;!--加载你书写的xml文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;sqlmapper/User.xml&quot;&gt;&lt;/mapper&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>User.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离</span><br><span class="line"> 注意：使用mapper代理方法开发，namespace有特殊重要的作用</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;mapper namespace=&quot;test&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">         根据id查询单条数据</span><br><span class="line">         id方法名，与dao类的方法名相同</span><br><span class="line">         parameterType输入参数的类型</span><br><span class="line">         resultType指定返回类型</span><br><span class="line">         #&#123;&#125;接受参数占位符</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;Pojo.User&quot;&gt;</span><br><span class="line">        SELECT *</span><br><span class="line">        FROM user</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        根据用户名模糊查询多条数据</span><br><span class="line">        resultType返回的是单条数据的类型</span><br><span class="line">        $&#123;&#125;:表示拼接sql串，将接收到的参数不加任何修饰的拼接到sql中（可能会引起SQL注入）</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;Pojo.User&quot;&gt;</span><br><span class="line">        SELECT *</span><br><span class="line">        FROM  user</span><br><span class="line">        WHERE name LIKE &apos;%$&#123;value&#125;%&apos;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>User实体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编写测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by huzhibin on 2018/4/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//mybatis配置文件</span></span><br><span class="line">        String resource = <span class="string">"sqlMapConfig.xml"</span>;</span><br><span class="line">        <span class="comment">//得到配置文件流</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="comment">//创建会话工厂</span></span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUserByIdTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//通过工厂得到Session</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//操作数据库</span></span><br><span class="line">        User user = sqlSession.selectOne(<span class="string">"test.findUserById"</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUserByNameTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//通过工厂得到Session</span></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//操作数据库</span></span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">"test.findUserByName"</span>,<span class="string">"ho"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意测试返回集合类型的时候使用的是selectList，如果使用selectOne会报错：查询有多个结果</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mybatis概述]]></title>
      <url>/2018/04/17/Mybatis/Mybatis%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h3 id="Mybatis介绍"><a href="#Mybatis介绍" class="headerlink" title="Mybatis介绍"></a>Mybatis介绍</h3><p>mybatis是一个持久层的框架，是apache下的顶级项目。</p>
<p>mybatis托管到goolecode下，再后来托管到github下（<a href="https://github.com/mybatis/mybatis-3/releases" title="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a>)。</p>
<p>Mybatis让程序将主要精力放在sql上，通过Mybatis提供的映射方式，只有灵活生成（半自动化，大部分需要程序员编写sql）满足需要SQL语句。</p>
<p>Mybatis可以将向preparedStatement中的输入参数自动进行输入映射，将查询结果灵活映射成java对象。（输出映射）<br><a id="more"></a></p>
<h2 id="框架原理"><a href="#框架原理" class="headerlink" title="框架原理"></a>框架原理</h2><p>Mybatis框架<br><img src="http://ocx5m3vc3.bkt.clouddn.com/mybatis_%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt=""></p>
<h3 id="Mybatis框架执行过程"><a href="#Mybatis框架执行过程" class="headerlink" title="Mybatis框架执行过程"></a>Mybatis框架执行过程</h3><p>1、配置Mybatis的配置文件，sqlMapConfig.xml（名称不固定）<br>2、通过配置文件，加载Mybatis运行环境，创建SQLSessionFactory会话工厂（SQLSessionFactory在实际使用时按单例方式）<br>3、通过SQLSessionFactory创建SQLSession。SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议SqlSession应用场合在方法体内。<br>4、调用SqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。<br>5、释放资源，关闭SqlSession。</p>
<h3 id="Mybatis开发dao的方法"><a href="#Mybatis开发dao的方法" class="headerlink" title="Mybatis开发dao的方法"></a>Mybatis开发dao的方法</h3><p>1.原始dao的方法</p>
<ul>
<li>需要程序员编写dao接口和实现类</li>
<li>需要在dao实现类中注入一个SQLSessionFactory工厂</li>
</ul>
<p>2.mapper代理开发方法（建议使用）<br>只需要程序员编写mapper接口（就是dao接口）。<br>程序员在编写mapper.xml（映射文件）和mapper.java需要遵循一个开发规范：</p>
<ul>
<li>mapper.xml中namespace就是mapper.java的类全路径。  </li>
<li>mapper.xml中statement的id和mapper.java中方法名一致。  </li>
<li>mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法输入参数类型一致。  </li>
<li>mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致。</li>
</ul>
<p>SqlMapConfig.xml配置文件：可以配置properties属性、别名、mapper加载。</p>
<h3 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h3><p>输入映射：</p>
<ul>
<li>parameterType：指定输入参数类型可以简单类型、pojo、hashmap。</li>
<li>对于综合查询，建议parameterType使用包装的pojo，有利于系统 扩展。</li>
</ul>
<p>输出映射：  </p>
<ul>
<li>resultType：查询到的列名和resultType指定的pojo的属性名一致，才能映射成功。  </li>
<li>reusltMap：可以通过resultMap 完成一些高级映射。如果查询到的列名和映射的pojo的属性名不一致时，通过resultMap设置列名和属性名之间的对应关系（映射关系）。可以完成映射。   </li>
<li>高级映射：<br>&ensp;&ensp;&ensp;&ensp;将关联查询的列映射到一个pojo属性中。（一对一）<br>&ensp;&ensp;&ensp;&ensp;将关联查询的列映射到一个List中。（一对多）</li>
</ul>
<h3 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h3><ul>
<li>动态sql：（重点）<br>&ensp;&ensp;&ensp;&ensp; - if判断（掌握）<br>&ensp;&ensp;&ensp;&ensp; - where<br>&ensp;&ensp;&ensp;&ensp; - foreach<br>&ensp;&ensp;&ensp;&ensp; - sql片段（掌握）  </li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原生JDBC的问题总结]]></title>
      <url>/2018/04/17/Mybatis/%E5%8E%9F%E7%94%9FJDBC%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="JDBC编程步骤"><a href="#JDBC编程步骤" class="headerlink" title="JDBC编程步骤"></a>JDBC编程步骤</h3><p>1.加载数据库驱动<br>2.创建并获取数据库连接<br>3.创建jdbc statement对象<br>4.设置SQL语句<br>5.设置SQL语句中的参数（使用preparedStatement)<br>6.通过statement执行sql并获取结果<br>7.对sql执行结果进行解析处理<br>8.释放资源（resultSet、preparedStatement、connection)</p>
<h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><a id="more"></a>
<p>1.数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。</p>
<p>设想：使用数据库连接池管理数据库连接。</p>
<p>2.将sql语句硬编码到java代码中，如果sql语句修改，需要重新编译java代码，不利于系统维护。</p>
<p>设想：将SQL语句配置在xml配置文件中，即时SQL变化，不需要对java代码进行重新编译。</p>
<p>3.向preparedStatement设置参数，对占位符位置和设置参数值，硬编码在java代码中，不利于系统维护。</p>
<p>设想：将sql语句及占位符号和参数全部配置在xml中。</p>
<p>4.从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。</p>
<p>设想：将查询的结果集，自动映射成Java对象。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate关系映射]]></title>
      <url>/2018/02/05/kuangjia/Hibernate/Hibernate_%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<h2 id="Hibernate关系映射"><a href="#Hibernate关系映射" class="headerlink" title="Hibernate关系映射"></a>Hibernate关系映射</h2><h3 id="一对多关系映射"><a href="#一对多关系映射" class="headerlink" title="一对多关系映射"></a>一对多关系映射</h3><p>数据库：在多的一方添加外键来描述关联关系。<br>实体对象：在一的一方，增加一个集合用来存放多的一方。在多的一方添加一个一的一方的属性。<br>映射文件配置：<br>User.hbm.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">           set代表用的什么集合</span><br><span class="line">           name代表多的一方的集合的属性名</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;set name=&quot;carSet&quot;&gt;</span><br><span class="line">           &lt;!--</span><br><span class="line">               key：多的一方的外键名称</span><br><span class="line">           --&gt;</span><br><span class="line">           &lt;key column=&quot;user_id&quot;&gt;&lt;/key&gt;</span><br><span class="line">           &lt;one-to-many class=&quot;pojo.Car&quot;&gt;&lt;/one-to-many&gt;</span><br><span class="line">       &lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>Car.hbm.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">            name：一的一方的属性名</span><br><span class="line">            class：一的一方的类全路径</span><br><span class="line">            colum：表中的外键外键名称</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;many-to-one name=&quot;user&quot; class=&quot;pojo.User&quot; column=&quot;user_id&quot;&gt;&lt;/many-to-one&gt;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>编写测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test_HiernateYinshe()&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName(&quot;cl&quot;);</span><br><span class="line">        user.setPassword(&quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">        Car car1 = new Car();</span><br><span class="line">        car1.setCar_name(&quot;byd&quot;);</span><br><span class="line">        car1.setColor(&quot;red&quot;);</span><br><span class="line">        Car car2 = new Car();</span><br><span class="line">        car2.setCar_name(&quot;baoma&quot;);</span><br><span class="line">        car2.setColor(&quot;blue&quot;);</span><br><span class="line"></span><br><span class="line">        //建立关系</span><br><span class="line">        user.getCarSet().add(car1);</span><br><span class="line">        user.getCarSet().add(car2);</span><br><span class="line">        car1.setUser(user);</span><br><span class="line">        car2.setUser(user);</span><br><span class="line"></span><br><span class="line">        session.save(user);</span><br><span class="line">//        以下两句在测试只保存一方时注释</span><br><span class="line">        session.save(car1);</span><br><span class="line">        session.save(car2);</span><br><span class="line"></span><br><span class="line">        tx.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过观察控制台，会发现控制台输出了三条insert语句和两条update语句。<br>既然两个对象以及进行了双向关联，那我们只保存一方是否可以呢？<br>将上面的测试代码中保存Car的两条语句注释。会报一下错误：<br><img src="http://ocx5m3vc3.bkt.clouddn.com/%E7%9E%AC%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%BC%82%E5%B8%B8.png" alt="http://ocx5m3vc3.bkt.clouddn.com/%E7%9E%AC%E6%97%B6%E5%AF%B9%E8%B1%A1%E5%BC%82%E5%B8%B8.png"><br>这样保存是不行的，无论是从哪一方保存都会报错：瞬时对象异常。一个持久化对象关联了一个瞬时态对象。<br>如果我们只想保存一个方向，那么我们可以使用Hibernate的级联操作。<br>首先要确定我们要保存的的主控方式哪一方，用户拥有车，所以用户是主控方。我们需要在用户的映射文件中进行以下配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;set name=&quot;carSet&quot; cascade=&quot;save-update&quot;&gt;</span><br><span class="line">           &lt;key column=&quot;user_id&quot; &gt;&lt;/key&gt;</span><br><span class="line">           &lt;one-to-many class=&quot;pojo.Car&quot;&gt;&lt;/one-to-many&gt;</span><br><span class="line">       &lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>当我们在一方配置了级联配置后，保存时会将其级联的对象也保存在数据库。此时运行测试代码，会发现还是三条insert和两条update语句。因为在Car中还会进行维护外键的操作。其实这是没必要的了。所以我们必须选择一方放弃维护关系。<br>我们选择User放弃维护，因为一个老师要记住所有学生是比较困难的，但是让学生记住老师确是很容易的。<br>我们再修改User.hbm.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">           inverse默认值为false,代表不放弃维护。</span><br><span class="line">       --&gt;</span><br><span class="line">&lt;set name=&quot;carSet&quot; cascade=&quot;save-update&quot; inverse=&quot;true&quot;&gt;</span><br><span class="line">           &lt;key column=&quot;user_id&quot; &gt;&lt;/key&gt;</span><br><span class="line">           &lt;one-to-many class=&quot;pojo.Car&quot;&gt;&lt;/one-to-many&gt;</span><br><span class="line">       &lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>此时再执行测试代码。会发现只剩下了三条insert语句</p>
<ul>
<li>区分cascade和inverse<br>cascade强调的是操作一个对象时，是否操作其关联对象。<br>inverse强调的是外键的维护权</li>
</ul>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>数据库：通过一张中间表来描述其对应关系。<br>实体对象：在两个实体类中都创建一个集合来代表拥有的另一方。<br>User.hbm.xml配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">           name：关联的另一方的集合名称</span><br><span class="line">           table：中间表的名称</span><br><span class="line">           cascade：级联维护相关对象</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;set name=&quot;roleSet&quot; table=&quot;tb_user_role&quot; cascade=&quot;save-update&quot;&gt;</span><br><span class="line">           &lt;!--</span><br><span class="line">               colum：当前对象在中间表的外键名称</span><br><span class="line">           --&gt;</span><br><span class="line">           &lt;key column=&quot;user_id&quot;&gt;&lt;/key&gt;</span><br><span class="line">           &lt;!--</span><br><span class="line">               class：关联另一方的类的全路径。</span><br><span class="line">               colum：关联的另一方在中间表的外键</span><br><span class="line">           --&gt;</span><br><span class="line">           &lt;many-to-many class=&quot;pojo.Role&quot; column=&quot;role_id&quot;&gt;&lt;/many-to-many&gt;</span><br><span class="line">       &lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>Role.hbm.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">           inverse：多对多的关系映射中必须要有一方放弃维护外键。</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;set name=&quot;userSet&quot; table=&quot;tb_user_role&quot; inverse=&quot;true&quot;&gt;</span><br><span class="line">           &lt;key column=&quot;role_id&quot;&gt;&lt;/key&gt;</span><br><span class="line">           &lt;many-to-many class=&quot;pojo.User&quot; column=&quot;user_id&quot;&gt;&lt;/many-to-many&gt;</span><br><span class="line">       &lt;/set&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们很容易就发现多对多的两方的映射文件差不多。<br>加载映射配置后编写测试代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void test_many2Many()&#123;</span><br><span class="line">       Session session = HibernateUtils.openSession();</span><br><span class="line">       Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">       User user1 = new User(&quot;u1&quot;,&quot;u1&quot;);</span><br><span class="line">       User user2 = new User(&quot;u2&quot;,&quot;u2&quot;);</span><br><span class="line"></span><br><span class="line">       Role role1 = new Role(&quot;前台&quot;);</span><br><span class="line">       Role role2 = new Role(&quot;人事&quot;);</span><br><span class="line">       Role role3 = new Role(&quot;助理&quot;);</span><br><span class="line"></span><br><span class="line">       //建立关系，如果建立了双向关系，一定要有一方放弃外键维护。</span><br><span class="line">       user1.getRoleSet().add(role1);</span><br><span class="line">       user1.getRoleSet().add(role2);</span><br><span class="line">       user2.getRoleSet().add(role1);</span><br><span class="line">       user2.getRoleSet().add(role3);</span><br><span class="line"></span><br><span class="line">       role1.getUserSet().add(user1);</span><br><span class="line">       role1.getUserSet().add(user2);</span><br><span class="line">       role2.getUserSet().add(user1);</span><br><span class="line">       role3.getUserSet().add(user2);</span><br><span class="line"></span><br><span class="line">       session.save(user1);</span><br><span class="line">       session.save(user2);</span><br><span class="line"></span><br><span class="line">       tx.commit();</span><br><span class="line">       session.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在多对多的关系映射中，进行了双向维护，此时必须有一方需要放弃维护。  </p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate_一级缓存]]></title>
      <url>/2018/02/04/kuangjia/Hibernate/Hibernate_%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>Hibernate的一级缓存就是Session缓存，Session缓存是一块内存空间，用来存放相互管理的java对象，在Hibernate查询对象的时候，首先会使用对象属性的OID值在Hibernate的一级缓存中进行查找，如果找到匹配OID值的对象，就直接将该对象从一级缓存中取出使用，不会再查询数据库；如果没有找到相同OID值对象，则会去数据库中查找相应数据。当从数据库中查询到所需数据时，该数据信息也会放置到一级缓存中。<font color="red">Hibernate的一级缓存的作用就是减少对数据库的访问次数。</font><br><a id="more"></a></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>当应用程序调用Session接口的save()、update()、savaOrUpdate()时，如果Session缓存中没有相应的对象，Hibernate就会自动的把数据库查询到的相应对象信息加入到一级缓存中去。</li>
<li>当调用Session接口的load()、get()方法以及Query接口的list()、iterator()方法时，会判断缓存中是否有该对象，有则返回；没有就去数据库中查询并添加到一级缓存中。</li>
<li>当调用Session的close()方法时。Session缓存会被清空。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test_Cacha()&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        User user = session.get(User.class,1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        User user1 = session.get(User.class,1);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line"></span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E7%BC%93%E5%AD%98%E6%B5%8B%E8%AF%95.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E7%BC%93%E5%AD%98%E6%B5%8B%E8%AF%95.png"><br>测试发现，只执行一次查询操作，并且user和user1是同一个对象。这说明了第二次查询操作时直接从缓存中取的。</p>
<ul>
<li>一级缓存的内存结构（快照区）<br>Hibernate向一级缓存放入数据时，同时复制一份数据放入Hibernate快照中，当使用commit()方法提交事务时，同时会清理Session的一级缓存，<font color="red">这时会使用OID判断一级缓存中的对象和快照中的对象是否一致，如果两个对象中的数据发生变化，则执行update语句，将缓存的内容同步到数据库，并更新快照：如果一致，则不执行update语句。</font>Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test_Cacha_2()&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        User user = session.get(User.class,1);</span><br><span class="line"></span><br><span class="line">        //先改变姓名后改回去再提交</span><br><span class="line">        user.setName(&quot;haha&quot;);</span><br><span class="line">        //后一个测试时会将此处注释</span><br><span class="line">        user.setName(&quot;xixi&quot;);</span><br><span class="line"></span><br><span class="line">        tx.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>更改姓名后更改回去，Hibernate发现user对象和快照区的一样，不会执行update方法。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%BF%AB%E7%85%A7%E6%B5%8B%E8%AF%95.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%BF%AB%E7%85%A7%E6%B5%8B%E8%AF%95.png"><br>更改姓名，Hibernate发现user对象和快照区的不一样，执行update方法。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%BF%AB%E7%85%A7%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%BF%AB%E7%85%A7%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95.png"></p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate_持久化类]]></title>
      <url>/2018/02/04/kuangjia/Hibernate/Hibernate_%E6%8C%81%E4%B9%85%E5%8C%96%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="Hibernate持久化类"><a href="#Hibernate持久化类" class="headerlink" title="Hibernate持久化类"></a>Hibernate持久化类</h2><p>在Hibernate中持久化的英文名称时Persistent Object（简称PO），PO = POJO+hbm映射配置文件。  </p>
<h3 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h3><ol>
<li>必须提供一个无参数的public构造方法。</li>
<li>所有属性用private修饰，对外提供public的get/set方法。</li>
<li>在PO类必须提供一个标识属性，与数据库中的主键对应。我们管这属性叫OID。</li>
<li>PO类中的属性尽量使用基本类型的包装类。</li>
<li>PO类不能使用final修饰符。<a id="more"></a></li>
</ol>
<ul>
<li><p>为什么PO类必须提供一个标识属性OID，让它与数据库中的主键对应呢？<br>OID指的是数据库中表的主键对应的属性。Hibernate框架是通过OID来区分不同的PO对象，如果在内存中有两个相同的OID对象，那么Hibernate认为它们是一个对象。</p>
</li>
<li><p>为什么PO类中的属性要尽量使用基本类型的包装类？<br>使用基本数据类型是没有办法去描述不存在的概念的。如果使用包装类型，它就是一个对象，对于对象它的默认值是null。如果它为null就代表这不存在。</p>
</li>
<li><p>为什么PO类不能使用final修饰符？<br>因为Hibernate会使用代理模式在延迟关联的情况下提高性能。如果把实体类定义成final类之后，java不允许对final类进行扩展；所以Hibernate就无法再使用代理了。</p>
</li>
</ul>
<h2 id="持久化对象的三种状态"><a href="#持久化对象的三种状态" class="headerlink" title="持久化对象的三种状态"></a>持久化对象的三种状态</h2><ul>
<li>瞬时态：也叫做临时态或自由态，他一般指的我们new出来的对象，此时它<font color="red">不存在OID，与Hibernate Session无关联，在数据库中也无记录。</font></li>
<li>持久态：在Hibernate Session管理范围内，他具有持久化标识OID。它的特点是在事务未提交前一直是持久态，当它发生改变时，Hibernate会检测到。<font color="red">有OID且由Session管理，在数据库中可能有，也可能没有。</font></li>
<li>托管态：也叫游离态或离线态。它是指<font color="red">持久态对象失去了Session的关联。</font>对于托管态对象，发生改变时Hibernate不会检测。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HibernateTest &#123;</span><br><span class="line"></span><br><span class="line">    // 测试持久化对象的三种状态</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        // 1.得到session</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        Customer c = new Customer(); // 瞬时态(无OID，与session无关联)</span><br><span class="line">        c.setName(&quot;张三&quot;);</span><br><span class="line">        c.setSex(&quot;男&quot;);</span><br><span class="line"></span><br><span class="line">        session.save(c); // 建立c与session的关联关系，它就是持久态的了(有OID)</span><br><span class="line"></span><br><span class="line">        // 2.事务提交，并关闭session</span><br><span class="line">        session.getTransaction().commit();</span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(c.getId()); // 断开了与session的关联，它就是脱管态的了(有OID)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png"></p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate主键生成策略]]></title>
      <url>/2018/02/04/kuangjia/Hibernate/Hibernate%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<ol>
<li><p>increment<br>用于long、short、int类型，由Hibernate自动以递增的方式生成唯一标识符，每次增量为1。只有当没有其他进程向同一张表中插入数据时才可以使用，不能在集群环境下使用。适用于代理主键。</p>
</li>
<li><p>identity<br>采用底层数据库本身提供的主键生成标识符，条件是数据库支持自动增长数据类型。在DB2、MySQL、MS SQL Server、Sybase和HypersonicSQL数据库中可以使用该生成器，该生成器要求在数据库中把主键定义成为自增长类型。适用于代理主键。</p>
</li>
<li><p>sequence<br>Hibernate根据底层数据库序列生成标识符。条件是数据库支持序列。适用于代理主键。</p>
</li>
<li><p>native<br>根据底层数据库对自动生成表示符的能力来选择identity、sequence、hilo三种生成器中的一种，适合跨数据库平台开发。适用于代理主键。</p>
</li>
<li><p>uuid<br>Hibernate采用128位的UUID算法来生成标识符。该算法能够在网络环境中生成唯一的字符串标识符，其UUID被编码为一个长度为32位的十六进制字符串。这种策略并不流行，因为字符串类型的主键比整数类型的主键占用更多的数据库空间。适用于代理主键。</p>
</li>
<li><p>assigned<br>由Java程序负责生成标识符，如果不指定ID元素的generator属性，则默认使用该主键生成策略。适用于自然主键。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate框架搭建]]></title>
      <url>/2018/02/03/kuangjia/Hibernate/Hibernate_01/</url>
      <content type="html"><![CDATA[<ul>
<li>Hibernate框架关键词：dao层框架、以面向对象的方式操作数据库、orm思想（对象关系映射，通过映射文件配置对象和数据库中表的关系）</li>
</ul>
<h2 id="Hibernate框架搭建步骤"><a href="#Hibernate框架搭建步骤" class="headerlink" title="Hibernate框架搭建步骤"></a>Hibernate框架搭建步骤</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>required+驱动包<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E9%A9%B1%E5%8A%A8%E5%8C%85.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E9%A9%B1%E5%8A%A8%E5%8C%85.png"><br><a id="more"></a></p>
<h3 id="准备实体类和orm元数据"><a href="#准备实体类和orm元数据" class="headerlink" title="准备实体类和orm元数据"></a>准备实体类和orm元数据</h3><ul>
<li><p>User.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>User.hbm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"pojo"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        name：即实体类的全名</span></span><br><span class="line"><span class="comment">        table：映射到数据库里面的那个表的名称</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"tb_user"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- class下必须要有一个id的子元素 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id是用于描述主键的 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- type是规定类型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 主键生成策略 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            使用property来描述属性与字段的对应关系</span></span><br><span class="line"><span class="comment">            如果length忽略不写，且你的表是自动创建这种方案，那么length的默认长度是255</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">length</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">length</span>=<span class="string">"50"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下表是Hibernate的类型对应表<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84.png"></p>
<h3 id="创建主配置文件"><a href="#创建主配置文件" class="headerlink" title="创建主配置文件"></a>创建主配置文件</h3><ul>
<li>hibernate.cfg.xml<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置关于数据库连接的四个项：driverClass  url username password --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 可以将向数据库发送的SQL语句显示出来 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式化SQL语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- hibernate的方言 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">               create:每次加载hibernate时都自动创建表</span></span><br><span class="line"><span class="comment">               create-drop:每次加载hibernate时自动创建表，结束时删除表。适合用于开发环境。</span></span><br><span class="line"><span class="comment">               update：最常用的属性。第一次加载hibernate时创建表结构；</span></span><br><span class="line"><span class="comment">                        以后每次加载都会更新表结构，但是不会删除以前的记录。。适用于运行环境。</span></span><br><span class="line"><span class="comment">               validate：每次加载都验证数据库表结构，并不会创建表</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>create<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置hibernate的映射文件所在的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"pojo/User.hbm.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="书写测试代码"><a href="#书写测试代码" class="headerlink" title="书写测试代码"></a>书写测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savaUserTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        u.setName(<span class="string">"xixi"</span>);</span><br><span class="line">        u.setPassword(<span class="string">"xixi"</span>);</span><br><span class="line"></span><br><span class="line">        Configuration config = <span class="keyword">new</span> Configuration().configure(); <span class="comment">// Hibernate框架加载hibernate.cfg.xml文件</span></span><br><span class="line">        SessionFactory sessionFactory = config.buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession(); <span class="comment">// 相当于得到一个Connection</span></span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        session.save(u);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事务提交</span></span><br><span class="line">        session.getTransaction().commit();</span><br><span class="line">        session.close();</span><br><span class="line">        sessionFactory.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查看控制台会发现创表语句和插入语句。<br><img src="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%88%9B%E8%A1%A8debug.png" alt="http://ocx5m3vc3.bkt.clouddn.com/Hibernate%E5%88%9B%E8%A1%A8debug.png"></p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS中搭建redis]]></title>
      <url>/2017/11/14/Redis/CentOS%E4%B8%AD%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/</url>
      <content type="html"><![CDATA[<h3 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">首先安装环境：</span><br><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line">安装步骤：</span><br><span class="line">1. 将Redis源码包上传到服务器</span><br><span class="line"></span><br><span class="line">2. 解压缩</span><br><span class="line">tar zxf redis-3.0.0.tar.gz</span><br><span class="line"></span><br><span class="line">3. 进入redis-3.0.0目录下编译</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">4. 安装</span><br><span class="line">make install PREFIX=/root/redis</span><br><span class="line"></span><br><span class="line">5.复制配置文件</span><br><span class="line">cp redis.conf ~/redis-3.0.0/redis.conf </span><br><span class="line"></span><br><span class="line">6.修改配置文件</span><br><span class="line">vim redis.conf</span><br><span class="line">修改    daemonize yes</span><br><span class="line">	</span><br><span class="line">7.启动</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">这样redis在后端启动了</span><br><span class="line"></span><br><span class="line">8.查看</span><br><span class="line">ps aux|grep redis</span><br></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<h3 id="集群版"><a href="#集群版" class="headerlink" title="集群版"></a>集群版</h3><p>Redis集群中至少应该有3个节点，每个节点有一个备用机。<br>所以Redis集群至少需要6台服务器。<br>我们采用伪分布式。用一台服务器搭建6个Redis实例。需要修改Redis的端口号7001-7006</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.复制一个单机版的bin目录到一个实例中</span><br><span class="line">cp -r redis/bin/ redis-cluster/redis01/</span><br><span class="line"></span><br><span class="line">2.删除快照</span><br><span class="line">rm -rf dump.rdb</span><br><span class="line"></span><br><span class="line">3.修改配置文件</span><br><span class="line">vim redis.conf</span><br><span class="line">修改端口:port 7001</span><br><span class="line">打开可以使用集群 cluster-enabled yes</span><br><span class="line"></span><br><span class="line">4.将这个实例复制几份</span><br><span class="line">cp -r redis01/ redis02</span><br><span class="line">cp -r redis01/ redis03</span><br><span class="line">cp -r redis01/ redis04</span><br><span class="line">cp -r redis01/ redis05</span><br><span class="line">cp -r redis01/ redis06</span><br><span class="line"></span><br><span class="line">5.分别修改其中配置文件中的端口</span><br><span class="line"></span><br><span class="line">6.启动（可以用批处理）</span><br><span class="line"></span><br><span class="line">--------------------------------</span><br><span class="line">搭建集群</span><br><span class="line"></span><br><span class="line">使用ruby脚本搭建集群。需要ruby的运行环境</span><br><span class="line">yum install ruby</span><br><span class="line">yum install rubygems</span><br><span class="line"></span><br><span class="line">将redis-3.0.0.gem上传到服务器</span><br><span class="line">gem install redis-3.0.0.gem</span><br><span class="line"></span><br><span class="line">进入redis-3.0.0/src目录下</span><br><span class="line">cp redis-trip.rb /redis-cluster/</span><br><span class="line"></span><br><span class="line">到redis-cluster目录下执行脚本</span><br><span class="line">./redis-trib.rb create --replicas 1 192.168.25.153:7001 192.168.25.153:7002 192.168.25.153:7003 192.168.25.153:7004 192.168.25.153:7005 192.168.25.153:7006</span><br></pre></td></tr></table></figure>
<p><a href="http://pan.baidu.com/s/1i4Vzydv" target="_blank" rel="noopener">redis-3.0.0.gem</a><br><a href="http://pan.baidu.com/s/1bp532sn" target="_blank" rel="noopener">redis-3.0.0.tar.gz</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS安装JDK、MySQL、tomcat、zookeeper]]></title>
      <url>/2017/11/07/CentOS%E5%AE%89%E8%A3%85JDK/</url>
      <content type="html"><![CDATA[<p>&ensp;&ensp;最近跟着视频做项目的时候发觉如果本机又是服务端又是客户端总感觉哪里有点那么不爽–<br>&ensp;&ensp;于是本来打算在我本机上的虚拟机试试看结果感觉效果不是很好，然后就珍惜自己最后一年的学生身份去晚上买了一个云服务器= =</p>
<ul>
<li><a href="https://www.mtyun.com/activity-school?site=mos&amp;campaign=20170706sales" target="_blank" rel="noopener">云帆校园扶持计划-美团云</a></li>
</ul>
<hr>
<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.查看是否安装JDK</span><br><span class="line">	rpm -qa|grep java</span><br><span class="line"></span><br><span class="line">2.卸载已经安装的两个openJDK</span><br><span class="line">	rpm -e--nodeps [要卸载的软件]</span><br><span class="line"></span><br><span class="line">3.上传JDK到Linux</span><br><span class="line">//安装JDK运行需要的插件 yum install glibc.i686</span><br><span class="line">4.解压JDK到/usr/local/目录下</span><br><span class="line">	tar –xvf jdk-7u71-linux-i586.tar.gz –C /usr/local</span><br><span class="line"></span><br><span class="line">5.配置JDK环境变量，将下面的配置拷贝进去</span><br><span class="line">	vim /etc/profile</span><br><span class="line"></span><br><span class="line">	#set java environment</span><br><span class="line">	JAVA_HOME=/usr/local/jdk1.7.0_71</span><br><span class="line">	CLASSPATH=.:$JAVA_HOME/lib.tools.jar</span><br><span class="line">	PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">	export JAVA_HOME CLASSPATH PATH </span><br><span class="line"></span><br><span class="line">6.重新加载/etc/profile配置文件</span><br><span class="line">	source /etc/profile</span><br><span class="line"></span><br><span class="line">测试是否安装成功</span><br><span class="line">	java -version</span><br></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1.查看Centos自带的MySQL</span><br><span class="line">	rpm -qa|grep mysql</span><br><span class="line"></span><br><span class="line">2.卸载自带的MySQL  （rpm -e--nodeps)</span><br><span class="line"></span><br><span class="line">3.上传MySQL到Linux</span><br><span class="line">/*</span><br><span class="line">安装MySQL所需要的依赖</span><br><span class="line">yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6</span><br><span class="line">yum  update libstdc++-4.4.7-4.el6.x86_64</span><br><span class="line">*/</span><br><span class="line">4.解压Mysql到/usr/local/下的mysql目录(mysql目录需要手动创建)内</span><br><span class="line">	cd /usr/local</span><br><span class="line">	mkdir mysql</span><br><span class="line">	tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /usr/local/mysql</span><br><span class="line">5.在/usr/local/mysql下安装mysql</span><br><span class="line">安装服务器端：rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm</span><br><span class="line">安装客户端：rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm</span><br><span class="line">6.启动mysql</span><br><span class="line">	service mysql start</span><br><span class="line">7.将mysql加到系统服务中并设置开机启动</span><br><span class="line">加入到系统服务：chkconfig --add mysql</span><br><span class="line">自动启动：chkconfig mysql on</span><br><span class="line">8.登录mysql</span><br><span class="line">mysql安装好后会生成一个临时随机密码，存储位置在/root/.mysql_secret</span><br><span class="line">9.登录后修改密码</span><br><span class="line">	set password = password(&apos;root&apos;);</span><br><span class="line">10.开启mysql的远程登录</span><br><span class="line">默认情况下mysql为安全起见，不支持远程登录mysql，所以需要设置开启	远程登录mysql的权限</span><br><span class="line">登录mysql后输入如下命令：</span><br><span class="line">	grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;root&apos;;</span><br><span class="line">flush privileges;</span><br><span class="line">11.开放Linux的对外访问的端口3306</span><br><span class="line">	/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT</span><br><span class="line">	/etc/rc.d/init.d/iptables save ---将修改永久保存到防火墙中</span><br><span class="line"></span><br><span class="line">PS：后面操作数据库时发现中文会乱码。。。。</span><br><span class="line">-进入/etc/my.cnf文件</span><br><span class="line">	在[mysqld]段增加下面的代码</span><br><span class="line">	character-set-server=utf8</span><br><span class="line">	collation-server=utf8_general_ci</span><br><span class="line">重启mysql。</span><br><span class="line">/*</span><br><span class="line">	如果没有这个文件只需要复制一个/usr/share/mysql目录下的.cnf文件到/etc目录，并改名为my.cnf即可。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h3><p><a href="http://pan.baidu.com/s/1kVvJKKv" target="_blank" rel="noopener">tomcat压缩包</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.上传Tomcat到linux上</span><br><span class="line">2.解压Tomcat到/usr/local下</span><br><span class="line">3.开放Linux的对外访问的端口8080</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</span><br><span class="line">/etc/rc.d/init.d/iptables save</span><br><span class="line">4.启动关闭Tomcat</span><br><span class="line">进入tomcat的bin下启动：./startup.sh</span><br><span class="line">进入tomcat的bin下关闭：./shutdown.sh</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h3><ol>
<li><p>创建/usr/local/zookeeper文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/zookeeper</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入到/usr/local/zookeeper目录中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/zookeeper</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载 zookeeper-3.4.9.tar.gz：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.9/zookeeper-3.4.9.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压缩 zookeeper-3.4.9.tar.gz：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.9.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建/usr/local/services/zookeeper/zookeeper-3.4.9/data:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/services/zookeeper/zookeeper-3.4.9/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入到 /usr/local/services/zookeeper/zookeeper-3.4.9/conf 目录中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd zookeeper-3.4.9/conf/</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制 zoo_sample.cfg 文件的并命名为为 zoo.cfg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>用 vim 打开 zoo.cfg 文件并修改其dataDir内容为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 数据文件夹</span><br><span class="line">dataDir=/root/usr/local/services/zookeeper/zookeeper-3.4.9/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存并关闭 zoo.cfg 文件:</p>
</li>
<li><p>进入到 /usr/local/services/zookeeper/zookeeper-3.4.9/bin 目录中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../bin/</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 zookeeper 服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    zkServer.sh start</span><br><span class="line">    如打印如下信息则表明启动成功：</span><br><span class="line">    ZooKeeper JMX enabled by default</span><br><span class="line">    Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg</span><br><span class="line">    Starting zookeeper ... STARTED</span><br><span class="line">``` </span><br><span class="line">12. 查询 zookeeper 状态：</span><br><span class="line">```    </span><br><span class="line">zkServer.sh status</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="13">
<li><p>关闭 zookeeper 服务：<br>zkServer.sh stop<br>如打印如下信息则表明成功关闭：<br>ZooKeeper JMX enabled by default<br>Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg<br>Stopping zookeeper … STOPPED</p>
</li>
<li><p>重启 zookeeper 服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh restart</span><br><span class="line">如打印如下信息则表明重启成功：</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg</span><br><span class="line">Stopping zookeeper ... STOPPED</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件安装 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--Sorted-Sets数据结构]]></title>
      <url>/2017/10/31/Redis/Redis%E5%AD%A6%E4%B9%A0--Sorted-Sets%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)却是可以重复的。<br>&ensp;&ensp;在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数。由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ZADD key score member [score] [member]</td>
<td style="text-align:center">O(log(N))</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Sets中成员的数量。添加参数中指定的所有成员及其分数到指定key的Sorted-Set中，在该命令中我们可以指定多组score/member作为参数。如果在添加时参数中的某一成员已经存在，该命令将更新此成员的分数为新值，同时再将该成员基于新值重新排序。如果键不存在，该命令将为该键创建一个新的Sorted-Sets Value，并将score/member对插入其中。如果该键已经存在，但是与其关联的Value不是Sorted-Sets类型，相关的错误信息将被返回。</td>
<td style="text-align:center">本次操作实际插入的成员数量。</td>
</tr>
<tr>
<td style="text-align:center">ZCARD key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取与该Key相关联的Sorted-Sets中包含的成员数量。</td>
<td style="text-align:center">返回Sorted-Sets中的成员数量，如果该Key不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">ZCOUNT key min max</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Sets中成员的数量，M则表示min和max之间元素的数量。该命令用于获取分数(score)在min和max之间的成员数量。针对min和max参数需要额外说明的是，-inf和+inf分别表示Sorted-Sets中分数的最高值和最低值。缺省情况下，min和max表示的范围是闭区间范围，即min &lt;= score &lt;= max内的成员将被返回。然而我们可以通过在min和max的前面添加”(“字符来表示开区间，如(min max表示min &lt; score &lt;= max，而(min (max表示min &lt; score &lt; max。</td>
<td style="text-align:center">分数指定范围内成员的数量。</td>
</tr>
<tr>
<td style="text-align:center">ZINCRBY key increment member</td>
<td style="text-align:center">O(log(N))</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Sets中成员的数量。该命令将为指定Key中的指定成员增加指定的分数。如果成员不存在，该命令将添加该成员并假设其初始分数为0，此后再将其分数加上increment。如果Key不存，该命令将创建该Key及其关联的Sorted-Sets，并包含参数指定的成员，其分数为increment参数。如果与该Key关联的不是Sorted-Sets类型，相关的错误信息将被返回。</td>
<td style="text-align:center">以字符串形式表示的新分数。</td>
</tr>
<tr>
<td style="text-align:center">ZRANGE key start stop [WITHSCORES]</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令返回顺序在参数start和stop指定范围内的成员，这里start和stop参数都是0-based，即0表示第一个成员，-1表示最后一个成员。如果start大于该Sorted-Set中的最大索引值，或start &gt; stop，此时一个空集合将被返回。如果stop大于最大索引值，该命令将返回从start到集合的最后一个成员。如果命令中带有可选参数WITHSCORES选项，该命令在返回的结果中将包含每个成员的分数值，如value1,score1,value2,score2…。　　</td>
<td style="text-align:center">返回索引在start和stop之间的成员列表。</td>
</tr>
<tr>
<td style="text-align:center">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令将返回分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的成员，其中返回的成员是按照其分数从低到高的顺序返回，如果成员具有相同的分数，则按成员的字典顺序返回。可选参数LIMIT用于限制返回成员的数量范围。可选参数offset表示从符合条件的第offset个成员开始返回，同时返回count个成员。可选参数WITHSCORES的含义参照ZRANGE中该选项的说明。最后需要说明的是参数中min和max的规则可参照命令ZCOUNT。</td>
<td style="text-align:center">返回分数在指定范围内的成员列表。</td>
</tr>
<tr>
<td style="text-align:center">ZRANK key member</td>
<td style="text-align:center">O(log(N))</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量。Sorted-Set中的成员都是按照分数从低到高的顺序存储，该命令将返回参数中指定成员的位置值，其中0表示第一个成员，它是Sorted-Set中分数最低的成员。</td>
<td style="text-align:center">如果该成员存在，则返回它的位置索引值。否则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">ZREM key member [member …]</td>
<td style="text-align:center">O(M log(N))</td>
<td style="text-align:center">时间复杂度中N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。该命令将移除参数中指定的成员，其中不存在的成员将被忽略。如果与该Key关联的Value不是Sorted-Set，相应的错误信息将被返回。</td>
<td style="text-align:center">实际被删除的成员数量。</td>
</tr>
<tr>
<td style="text-align:center">ZREVRANGE key start stop [WITHSCORES]</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令的功能和ZRANGE基本相同，唯一的差别在于该命令是通过反向排序获取指定位置的成员，即从高到低的顺序。如果成员具有相同的分数，则按降序字典顺序排序。</td>
<td style="text-align:center">返回指定的成员列表。</td>
</tr>
<tr>
<td style="text-align:center">ZREVRANK key member</td>
<td style="text-align:center">O(log(N))</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量。该命令的功能和ZRANK基本相同，唯一的差别在于该命令获取的索引是从高到低排序后的位置，同样0表示第一个元素，即分数最高的成员。</td>
<td style="text-align:center">如果该成员存在，则返回它的位置索引值。否则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">ZSCORE key member</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取指定Key的指定成员的分数。</td>
<td style="text-align:center">如果该成员存在，以字符串的形式返回其分数，否则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令除了排序方式是基于从高到低的分数排序之外，其它功能和参数含义均与ZRANGEBYSCORE相同。</td>
<td style="text-align:center">返回分数在指定范围内的成员列表。</td>
</tr>
<tr>
<td style="text-align:center">ZREMRANGEBYRANK key start stop</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。删除索引位置位于start和stop之间的成员，start和stop都是0-based，即0表示分数最低的成员，-1表示最后一个成员，即分数最高的成员。</td>
<td style="text-align:center">被删除的成员数量。</td>
</tr>
<tr>
<td style="text-align:center">ZREMRANGEBYSCORE key min max</td>
<td style="text-align:center">O(log(N)+M)</td>
<td style="text-align:center">时间复杂度中的N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。删除分数在min和max之间的所有成员，即满足表达式min &lt;= score &lt;= max的所有成员。对于min和max参数，可以采用开区间的方式表示，具体规则参照ZCOUNT。</td>
<td style="text-align:center">被删除的成员数量。</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>ZADD/ZCARD/ZCOUNT/ZREM/ZINCRBY/ZSCORE/ZRANGE/ZRANK:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#在Shell的命令行下启动Redis客户端工具。</span><br><span class="line">/&gt; redis-cli</span><br><span class="line">#添加一个分数为<span class="number">1</span>的成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> <span class="string">"one"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#添加两个分数分别是<span class="number">2</span>和<span class="number">3</span>的两个成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">2</span> <span class="string">"two"</span> <span class="number">3</span> <span class="string">"three"</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#<span class="number">0</span>表示第一个成员，<span class="number">-1</span>表示最后一个成员。WITHSCORES选项表示返回的结果中包含每个成员及其分数，否则只返回成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"3"</span></span><br><span class="line">#获取成员one在Sorted-Set中的位置索引值。<span class="number">0</span>表示第一个位置。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrank myzset one</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#成员four并不存在，因此返回nil。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrank myzset four</span><br><span class="line">(nil)</span><br><span class="line">#获取myzset键中成员的数量。    </span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcard myzset</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">#返回与myzset关联的Sorted-Set中，分数满足表达式<span class="number">1</span> &lt;= score &lt;= <span class="number">2</span>的成员的数量。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcount myzset <span class="number">1</span> <span class="number">2</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#删除成员one和two，返回实际删除成员的数量。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrem myzset one two</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#查看是否删除成功。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcard myzset</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#获取成员three的分数。返回值是字符串形式。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zscore myzset three</span><br><span class="line"><span class="string">"3"</span></span><br><span class="line">#由于成员two已经被删除，所以该命令返回nil。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zscore myzset two</span><br><span class="line">(nil)</span><br><span class="line">#将成员one的分数增加<span class="number">2</span>，并返回该成员更新后的分数。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zincrby myzset <span class="number">2</span> one</span><br><span class="line"><span class="string">"3"</span></span><br><span class="line">#将成员one的分数增加<span class="number">-1</span>，并返回该成员更新后的分数。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zincrby myzset <span class="number">-1</span> one</span><br><span class="line"><span class="string">"2"</span></span><br><span class="line">#查看在更新了成员的分数后是否正确。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"3"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ZRANGEBYSCORE/ZREMRANGEBYRANK/ZREMRANGEBYSCORE</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del myzset</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> one <span class="number">2</span> two <span class="number">3</span> three <span class="number">4</span> four</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line">#获取分数满足表达式<span class="number">1</span> &lt;= score &lt;= <span class="number">2</span>的成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrangebyscore myzset <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br><span class="line">#获取分数满足表达式<span class="number">1</span> &lt; score &lt;= <span class="number">2</span>的成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrangebyscore myzset (<span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"two"</span></span><br><span class="line">#-inf表示第一个成员，+inf表示最后一个成员，limit后面的参数用于限制返回成员的自己，</span><br><span class="line">#<span class="number">2</span>表示从位置索引(<span class="number">0</span>-based)等于<span class="number">2</span>的成员开始，去后面<span class="number">3</span>个成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrangebyscore myzset -inf +inf limit <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"four"</span></span><br><span class="line">#删除分数满足表达式<span class="number">1</span> &lt;= score &lt;= <span class="number">2</span>的成员，并返回实际删除的数量。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zremrangebyscore myzset <span class="number">1</span> <span class="number">2</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#看出一下上面的删除是否成功。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"four"</span></span><br><span class="line">#删除位置索引满足表达式<span class="number">0</span> &lt;= rank &lt;= <span class="number">1</span>的成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zremrangebyrank myzset <span class="number">0</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#查看上一条命令是否删除成功。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcard myzset</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ZREVRANGE/ZREVRANGEBYSCORE/ZREVRANK:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#为后面的示例准备测试数据。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del myzset</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> one <span class="number">2</span> two <span class="number">3</span> three <span class="number">4</span> four</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line">#以位置索引从高到低的方式获取并返回此区间内的成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrange myzset <span class="number">0</span> <span class="number">-1</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) <span class="string">"four"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"4"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"3"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">8</span>) <span class="string">"1"</span></span><br><span class="line">#由于是从高到低的排序，所以位置等于<span class="number">0</span>的是four，<span class="number">1</span>是three，并以此类推。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrange myzset <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"one"</span></span><br><span class="line">#由于是从高到低的排序，所以one的位置是<span class="number">3</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrank myzset one</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">#由于是从高到低的排序，所以four的位置是<span class="number">0</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrank myzset four</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#获取分数满足表达式<span class="number">3</span> &gt;= score &gt;= <span class="number">0</span>的成员，并以相反的顺序输出，即从高到底的顺序。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrangebyscore myzset <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"one"</span></span><br><span class="line">#该命令支持limit选项，其含义等同于zrangebyscore中的该选项，只是在计算位置时按照相反的顺序计算和获取。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrangebyscore myzset <span class="number">4</span> <span class="number">0</span> limit <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h3><ol>
<li>可以用于一个大型在线游戏的积分排行榜。每当玩家的分数发生变化时，可以执行ZADD命令更新玩家的分数，此后再通过ZRANGE命令获取积分TOP TEN的用户信息。当然我们也可以利用ZRANK命令通过username来获取玩家的排行信息。最后我们将组合使用ZRANGE和ZRANK命令快速的获取和某个玩家积分相近的其他用户的信息。</li>
<li>Sorted-Sets类型还可用于构建索引数据。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--Hashs数据结构]]></title>
      <url>/2017/10/31/Redis/Redis%E5%AD%A6%E4%B9%A0--Hashs%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;我们可以将Redis中的Hashes类型看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash可以存储4294967295个键值对。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HSET key field value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">为指定的Key设定Field/Value对，如果Key不存在，该命令将创建新Key以参数中的Field/Value对，如果参数中的Field在该Key中已经存在，则用新值覆盖其原有值。</td>
<td style="text-align:center">1表示新的Field被设置了新值，0表示Field已经存在，用新值覆盖原有值。</td>
</tr>
<tr>
<td style="text-align:center">HGET key field</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回指定Key中指定Field的关联值。</td>
<td style="text-align:center">返回参数中Field的关联值，如果参数中的Key或Field不存，返回nil。</td>
</tr>
<tr>
<td style="text-align:center">HEXISTS key field</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">判断指定Key中的指定Field是否存在。</td>
<td style="text-align:center">1表示存在，0表示参数中的Field或Key不存在。</td>
</tr>
<tr>
<td style="text-align:center">HLEN key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取该Key所包含的Field的数量。</td>
<td style="text-align:center">返回Key包含的Field数量，如果Key不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">HDEL key field [field …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示参数中待删除的字段数量。从指定Key的Hashes Value中删除参数中指定的多个字段，如果不存在的字段将被忽略。如果Key不存在，则将其视为空Hashes，并返回0.</td>
<td style="text-align:center">实际删除的Field数量。</td>
</tr>
<tr>
<td style="text-align:center">HSETNX key field value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">只有当参数中的Key或Field不存在的情况下，为指定的Key设定Field/Value对，否则该命令不会进行任何操作。</td>
<td style="text-align:center">1表示新的Field被设置了新值，0表示Key或Field已经存在，该命令没有进行任何操作。</td>
</tr>
<tr>
<td style="text-align:center">HINCRBY key field increment</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">增加指定Key中指定Field关联的Value的值。如果Key或Field不存在，该命令将会创建一个新Key或新Field，并将其关联的Value初始化为0，之后再指定数字增加的操作。该命令支持的数字是64位有符号整型，即increment可以负数。</td>
<td style="text-align:center">返回运算后的值。</td>
</tr>
<tr>
<td style="text-align:center">HGETALL key</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示Key包含的Field数量。获取该键包含的所有Field/Value。其返回格式为一个Field、一个Value，并以此类推。</td>
<td style="text-align:center">Field/Value的列表。</td>
</tr>
<tr>
<td style="text-align:center">HKEYS key</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示Key包含的Field数量。返回指定Key的所有Fields名</td>
<td style="text-align:center">Field的列表。</td>
</tr>
<tr>
<td style="text-align:center">HVALS key</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示Key包含的Field数量。返回指定Key的所有Values名。</td>
<td style="text-align:center">Value的列表。</td>
</tr>
<tr>
<td style="text-align:center">HMGET key field [field …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示请求的Field数量。获取和参数中指定Fields关联的一组Values。如果请求的Field不存在，其值返回nil。如果Key不存在，该命令将其视为空Hash，因此返回一组nil。</td>
<td style="text-align:center">返回和请求Fields关联的一组Values，其返回顺序等同于Fields的请求顺序。</td>
</tr>
<tr>
<td style="text-align:center">HMSET key field value [field value …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示被设置的Field数量。逐对依次设置参数中给出的Field/Value对。如果其中某个Field已经存在，则用新值覆盖原有值。如果Key不存在，则创建新Key，同时设定参数中的Field/Value。</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>LPUSH/LPUSHX/LRANGE:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#在Shell命令行启动Redis客户端程序</span><br><span class="line">/&gt; redis-cli</span><br><span class="line">#给键值为myhash的键设置字段为field1，值为stephen。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset myhash field1 <span class="string">"stephen"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#获取键值为myhash，字段为field1的值。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget myhash field1</span><br><span class="line"><span class="string">"stephen"</span></span><br><span class="line"><span class="meta">#myhash键中不存在field2字段，因此返回nil。</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget myhash field2</span><br><span class="line">(nil)</span><br><span class="line">#给myhash关联的Hashes值添加一个新的字段field2，其值为liu。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset myhash field2 <span class="string">"liu"</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#获取myhash键的字段数量。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hlen myhash</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#判断myhash键中是否存在字段名为field1的字段，由于存在，返回值为<span class="number">1</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hexists myhash field1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#删除myhash键中字段名为field1的字段，删除成功返回<span class="number">1</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hdel myhash field1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#再次删除myhash键中字段名为field1的字段，由于上一条命令已经将其删除，因为没有删除，返回<span class="number">0</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hdel myhash field1</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#判断myhash键中是否存在field1字段，由于上一条命令已经将其删除，因为返回<span class="number">0</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hexists myhash field1</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#通过hsetnx命令给myhash添加新字段field1，其值为stephen，因为该字段已经被删除，所以该命令添加成功并返回<span class="number">1</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hsetnx myhash field1 stephen</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#由于myhash的field1字段已经通过上一条命令添加成功，因为本条命令不做任何操作后返回<span class="number">0</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hsetnx myhash field1 stephen</span><br><span class="line">(integer) <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HINCRBY：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#删除该键，便于后面示例的测试。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del myhash</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#准备测试数据，该myhash的field字段设定值<span class="number">1</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset myhash field <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#给myhash的field字段的值加<span class="number">1</span>，返回加后的结果。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hincrby myhash field <span class="number">1</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line">#给myhash的field字段的值加<span class="number">-1</span>，返回加后的结果。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hincrby myhash field <span class="number">-1</span></span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line">#给myhash的field字段的值加<span class="number">-10</span>，返回加后的结果。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hincrby myhash field <span class="number">-10</span></span><br><span class="line">(integer) <span class="number">-5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HGETALL/HKEYS/HVALS/HMGET/HMSET:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#删除该键，便于后面示例测试。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del myhash</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#为该键myhash，一次性设置多个字段，分别是field1 = <span class="string">"hello"</span>, field2 = <span class="string">"world"</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hmset myhash field1 <span class="string">"hello"</span> field2 <span class="string">"world"</span></span><br><span class="line">OK</span><br><span class="line">#获取myhash键的多个字段，其中field3并不存在，因为在返回结果中与该字段对应的值为nil。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hmget myhash field1 field2 field3</span><br><span class="line"><span class="number">1</span>) <span class="string">"hello"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"world"</span></span><br><span class="line"><span class="number">3</span>) (nil)</span><br><span class="line">#返回myhash键的所有字段及其值，从结果中可以看出，他们是逐对列出的。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hgetall myhash</span><br><span class="line"><span class="number">1</span>) <span class="string">"field1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"hello"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"field2"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"world"</span></span><br><span class="line">#仅获取myhash键中所有字段的名字。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hkeys myhash</span><br><span class="line"><span class="number">1</span>) <span class="string">"field1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"field2"</span></span><br><span class="line">#仅获取myhash键中所有字段的值。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hvals myhash</span><br><span class="line"><span class="number">1</span>) <span class="string">"hello"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"world"</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--Set数据类型]]></title>
      <url>/2017/10/31/Redis/Redis%E5%AD%A6%E4%B9%A0--Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为O(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295。<br>&ensp;&ensp;和List类型不同的是，Set集合中不允许出现重复的元素，这一点和C++标准库中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SADD key member [member …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示操作的成员数量。如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。如果该Key的Value不是Set类型，该命令将返回相关的错误信息。</td>
<td style="text-align:center">本次操作实际插入的成员数量。</td>
</tr>
<tr>
<td style="text-align:center">SCARD key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取Set中成员的数量。</td>
<td style="text-align:center">返回Set中成员的数量，如果该Key并不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">SISMEMBER key member</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">判断参数中指定成员是否已经存在于与Key相关联的Set集合中。</td>
<td style="text-align:center">1表示已经存在，0表示不存在，或该Key本身并不存在。</td>
</tr>
<tr>
<td style="text-align:center">SMEMBERS key</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示Set中已经存在的成员数量。获取与该Key关联的Set中所有的成员。</td>
<td style="text-align:center">返回Set中所有的成员。</td>
</tr>
<tr>
<td style="text-align:center">SPOP key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">随机的移除并返回Set中的某一成员。 由于Set中元素的布局不受外部控制，因此无法像List那样确定哪个元素位于Set的头部或者尾部。</td>
<td style="text-align:center">返回移除的成员，如果该Key并不存在，则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">SREM key member [member …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示被删除的成员数量。从与Key关联的Set中删除参数中指定的成员，不存在的参数成员将被忽略，如果该Key并不存在，将视为空Set处理。</td>
<td style="text-align:center">从Set中实际移除的成员数量，如果没有则返回0。</td>
</tr>
<tr>
<td style="text-align:center">SRANDMEMBER key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">和SPOP一样，随机的返回Set中的一个成员，不同的是该命令并不会删除返回的成员。</td>
<td style="text-align:center">返回随机位置的成员，如果Key不存在则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">SMOVE source destination member</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性的将参数中的成员从source键移入到destination键所关联的Set中。因此在某一时刻，该成员或者出现在source中，或者出现在destination中。如果该成员在source中并不存在，该命令将不会再执行任何操作并返回0，否则，该成员将从source移入到destination。如果此时该成员已经在destination中存在，那么该命令仅是将该成员从source中移出。如果和Key关联的Value不是Set，将返回相关的错误信息。</td>
<td style="text-align:center">1表示正常移动，0表示source中并不包含参数成员。</td>
</tr>
<tr>
<td style="text-align:center">SDIFF key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示所有Sets中成员的总数量。返回参数中第一个Key所关联的Set和其后所有Keys所关联的Sets中成员的差异。如果Key不存在，则视为空Set。</td>
<td style="text-align:center">差异结果成员的集合。</td>
</tr>
<tr>
<td style="text-align:center">SDIFFSTORE destination key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">该命令和SDIFF命令在功能上完全相同，两者之间唯一的差别是SDIFF返回差异的结果成员，而该命令将差异成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。</td>
<td style="text-align:center">返回差异成员的数量。</td>
</tr>
<tr>
<td style="text-align:center">SINTER key [key …]</td>
<td style="text-align:center">O(N*M)</td>
<td style="text-align:center">时间复杂度中的N表示最小Set中元素的数量，M则表示参数中Sets的数量。该命令将返回参数中所有Keys关联的Sets中成员的交集。因此如果参数中任何一个Key关联的Set为空，或某一Key不存在，那么该命令的结果将为空集。</td>
<td style="text-align:center">交集结果成员的集合。</td>
</tr>
<tr>
<td style="text-align:center">SINTERSTORE destination key [key …]</td>
<td style="text-align:center">O(N*M)</td>
<td style="text-align:center">该命令和SINTER命令在功能上完全相同，两者之间唯一的差别是SINTER返回交集的结果成员，而该命令将交集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。</td>
<td style="text-align:center">返回交集成员的数量。</td>
</tr>
<tr>
<td style="text-align:center">SUNION key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中的N表示所有Sets中成员的总数量。该命令将返回参数中所有Keys关联的Sets中成员的并集。</td>
<td style="text-align:center">并集结果成员的集合。</td>
</tr>
<tr>
<td style="text-align:center">SUNIONSTORE destination key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">该命令和SUNION命令在功能上完全相同，两者之间唯一的差别是SUNION返回并集的结果成员，而该命令将并集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。</td>
<td style="text-align:center">返回并集成员的数量。</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>SADD/SMEMBERS/SCARD/SISMEMBER:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#在Shell命令行下启动Redis的客户端程序。</span><br><span class="line">/&gt; redis-cli</span><br><span class="line">#插入测试数据，由于该键myset之前并不存在，因此参数中的三个成员都被正常插入。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset a b c</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">#由于参数中的a在myset中已经存在，因此本次操作仅仅插入了d和e两个新成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset a d e</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#判断a是否已经存在，返回值为<span class="number">1</span>表示存在。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sismember myset a</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#判断f是否已经存在，返回值为<span class="number">0</span>表示不存在。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sismember myset f</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#通过smembers命令查看插入的结果，从结果可以，输出的顺序和插入顺序无关。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"e"</span></span><br><span class="line">#获取Set集合中元素的数量。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; scard myset</span><br><span class="line">(integer) <span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SPOP/SREM/SRANDMEMBER/SMOVE:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#删除该键，便于后面的测试。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; del myset</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#为后面的示例准备测试数据。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset a b c d</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line">#查看Set中成员的位置。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"b"</span></span><br><span class="line">#从结果可以看出，该命令确实是随机的返回了某一成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srandmember myset</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line">#Set中尾部的成员b被移出并返回，事实上b并不是之前插入的第一个或最后一个成员。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; spop myset</span><br><span class="line"><span class="string">"b"</span></span><br><span class="line">#查看移出后Set的成员信息。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a"</span></span><br><span class="line">#从Set中移出a、d和f三个成员，其中f并不存在，因此只有a和d两个成员被移出，返回为<span class="number">2</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; srem myset a d f</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#查看移出后的输出结果。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line">#为后面的smove命令准备数据。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset a b</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset2 c d</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line">#将a从myset移到myset2，从结果可以看出移动成功。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smove myset myset2 a</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">#再次将a从myset移到myset2，由于此时a已经不是myset的成员了，因此移动失败并返回<span class="number">0</span>。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smove myset myset2 a</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line">#分别查看myset和myset2的成员，确认移动是否真的成功。</span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">"b"</span></span><br><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset2</span><br><span class="line"><span class="number">1</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"a</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SDIFF/SDIFFSTORE/SINTER/SINTERSTORE:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">    #为后面的命令准备测试数据。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sadd myset a b c d</span></span><br><span class="line"><span class="string">    (integer) 4</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sadd myset2 c</span></span><br><span class="line"><span class="string">    (integer) 1</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sadd myset3 a c e</span></span><br><span class="line"><span class="string">    (integer) 3</span></span><br><span class="line"><span class="string">    #myset和myset2相比，a、b和d三个成员是两者之间的差异成员。再用这个结果继续和myset3进行差异比较，b和d是myset3不存在的成员。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sdiff myset myset2 myset3</span></span><br><span class="line"><span class="string">    1) "</span>d<span class="string">"</span></span><br><span class="line"><span class="string">    2) "</span>b<span class="string">"</span></span><br><span class="line"><span class="string">    #将3个集合的差异成员存在在diffkey关联的Set中，并返回插入的成员数量。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sdiffstore diffkey myset myset2 myset3</span></span><br><span class="line"><span class="string">    (integer) 2</span></span><br><span class="line"><span class="string">    #查看一下sdiffstore的操作结果。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; smembers diffkey</span></span><br><span class="line"><span class="string">    1) "</span>d<span class="string">"</span></span><br><span class="line"><span class="string">    2) "</span>b<span class="string">"</span></span><br><span class="line"><span class="string">    #从之前准备的数据就可以看出，这三个Set的成员交集只有c。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sinter myset myset2 myset3</span></span><br><span class="line"><span class="string">    1) "</span>c<span class="string">"</span></span><br><span class="line"><span class="string">    #将3个集合中的交集成员存储到与interkey关联的Set中，并返回交集成员的数量。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sinterstore interkey myset myset2 myset3</span></span><br><span class="line"><span class="string">    (integer) 1</span></span><br><span class="line"><span class="string">    #查看一下sinterstore的操作结果。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; smembers interkey</span></span><br><span class="line"><span class="string">    1) "</span>c<span class="string">"</span></span><br><span class="line"><span class="string">    #获取3个集合中的成员的并集。    </span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sunion myset myset2 myset3</span></span><br><span class="line"><span class="string">    1) "</span>b<span class="string">"</span></span><br><span class="line"><span class="string">    2) "</span>c<span class="string">"</span></span><br><span class="line"><span class="string">    3) "</span>d<span class="string">"</span></span><br><span class="line"><span class="string">    4) "</span>e<span class="string">"</span></span><br><span class="line"><span class="string">    5) "</span>a<span class="string">"</span></span><br><span class="line"><span class="string">    #将3个集合中成员的并集存储到unionkey关联的set中，并返回并集成员的数量。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; sunionstore unionkey myset myset2 myset3</span></span><br><span class="line"><span class="string">    (integer) 5</span></span><br><span class="line"><span class="string">    #查看一下suiionstore的操作结果。</span></span><br><span class="line"><span class="string">    redis 127.0.0.1:6379&gt; smembers unionkey</span></span><br><span class="line"><span class="string">    1) "</span>b<span class="string">"</span></span><br><span class="line"><span class="string">    2) "</span>c<span class="string">"</span></span><br><span class="line"><span class="string">    3) "</span>d<span class="string">"</span></span><br><span class="line"><span class="string">    4) "</span>e<span class="string">"</span></span><br><span class="line"><span class="string">    5) "</span>a<span class="string">"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h3><ol>
<li>可以使用Redis的Set数据类型跟踪一些唯一性数据，比如访问某一博客的唯一IP地址信息。对于此场景，我们仅需在每次访问该博客时将访问者的IP存入Redis中，Set数据类型会自动保证IP地址的唯一性。</li>
<li>充分利用Set类型的服务端聚合操作方便、高效的特性，可以用于维护数据对象之间的关联关系。比如所有购买某一电子设备的客户ID被存储在一个指定的Set中，而购买另外一种电子产品的客户ID被存储在另外一个Set中，如果此时我们想获取有哪些客户同时购买了这两种商品时，Set的intersections命令就可以充分发挥它的方便和效率的优势了。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--List数据类型]]></title>
      <url>/2017/10/30/Redis/Redis%E5%AD%A6%E4%B9%A0--List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。<br>&ensp;&ensp;从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。相信对于有良好数据结构基础的开发者而言，这一点并不难理解。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LPUSH key value [value …]</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">在指定Key所关联的List Value的头部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的头部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">LPUSHX key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的头部插入参数中给出的Value，否则将不会有任何操作发生。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">LRANGE key start stop</td>
<td style="text-align:center">O(S+N)</td>
<td style="text-align:center">时间复杂度中的S为start参数表示的偏移量，N表示元素的数量。该命令的参数start和end都是0-based。即0表示链表头部(leftmost)的第一个元素。其中start的值也可以为负值，-1将表示链表中的最后一个元素，即尾部元素，-2表示倒数第二个并以此类推。该命令在获取元素时，start和end位置上的元素也会被取出。如果start的值大于链表中元素的数量，空链表将会被返回。如果end的值大于元素的数量，该命令则获取从start(包括start)开始，链表中剩余的所有元素。</td>
<td style="text-align:center">返回指定范围内元素的列表。</td>
</tr>
<tr>
<td style="text-align:center">LPOP key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回并弹出指定Key关联的链表中的第一个元素，即头部元素，。如果该Key不存，返回nil。</td>
<td style="text-align:center">链表头部的元素。</td>
</tr>
<tr>
<td style="text-align:center">LLEN key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回指定Key关联的链表中元素的数量，如果该Key不存在，则返回0。如果与该Key关联的Value的类型不是链表，则返回相关的错误信息。</td>
<td style="text-align:center">链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">LREM key count value</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示链表中元素的数量。在指定Key关联的链表中，删除前count个值等于value的元素。如果count大于0，从头向尾遍历并删除，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。如果指定的Key不存在，则直接返回0。</td>
<td style="text-align:center">返回被删除的元素数量。</td>
</tr>
<tr>
<td style="text-align:center">LSET key index value</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示链表中元素的数量。但是设定头部或尾部的元素时，其时间复杂度为O(1)。设定链表中指定位置的值为新值，其中0表示第一个元素，即头部元素，-1表示尾部元素。如果索引值Index超出了链表中元素的数量范围，该命令将返回相关的错误信息。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LINDEX key index</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示在找到该元素时需要遍历的元素数量。对于头部或尾部元素，其时间复杂度为O(1)。该命令将返回链表中指定位置(index)的元素，index是0-based，表示头部元素，如果index为-1，表示尾部元素。如果与该Key关联的不是链表，该命令将返回相关的错误信息。</td>
<td style="text-align:center">返回请求的元素，如果index超出范围，则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">LTRIM key start stop</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示被删除的元素数量。该命令将仅保留指定范围内的元素，从而保证链接中的元素数量相对恒定。start和stop参数都是0-based，0表示头部元素。和其他命令一样，start和stop也可以为负值，-1表示尾部元素。如果start大于链表的尾部，或start大于stop，该命令不错报错，而是返回一个空的链表，与此同时该Key也将被删除。如果stop大于元素的数量，则保留从start开始剩余的所有元素。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LINSERT key BEFORE,AFTER pivot value</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">时间复杂度中N表示在找到该元素pivot之前需要遍历的元素数量。这样意味着如果pivot位于链表的头部或尾部时，该命令的时间复杂度为O(1)。该命令的功能是在pivot元素的前面或后面插入参数中的元素value。如果Key不存在，该命令将不执行任何操作。如果与Key关联的Value类型不是链表，相关的错误信息将被返回。</td>
<td style="text-align:center">成功插入后链表中元素的数量，如果没有找到pivot，返回-1，如果key不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">RPUSH key value [value …]</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">指定Key所关联的List Value的尾部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的尾部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">RPUSHX key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的尾部插入参数中给出的Value，否则将不会有任何操作发生。</td>
<td style="text-align:center">插入后链表中元素的数量。</td>
</tr>
<tr>
<td style="text-align:center">RPOP key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回并弹出指定Key关联的链表中的最后一个元素，即尾部元素，。如果该Key不存，返回nil</td>
<td style="text-align:center">链表尾部的元素</td>
</tr>
<tr>
<td style="text-align:center">RPOPLPUSH source destination</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性的从与source键关联的链表尾部弹出一个元素，同时再将弹出的元素插入到与destination键关联的链表的头部。如果source键不存在，该命令将返回nil，同时不再做任何其它的操作了。如果source和destination是同一个键，则相当于原子性的将其关联链表中的尾部元素移到该链表的头部。</td>
<td style="text-align:center">返回弹出和插入的元素。</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>LPUSH/LPUSHX/LRANGE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/&gt; redis-cli    #在Shell提示符下启动redis客户端工具。</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey</span><br><span class="line">(integer) 1</span><br><span class="line">#mykey键并不存在，该命令会创建该键及与其关联的List，之后在将参数中的values从左到右依次插入。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d</span><br><span class="line">(integer) 4</span><br><span class="line">#取从位置0开始到位置2结束的3个元素。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 2</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">#取链表中的全部元素，其中0表示第一个元素，-1表示最后一个元素。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;a&quot;</span><br><span class="line">#mykey2键此时并不存在，因此该命令将不会进行任何操作，其返回值为0。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpushx mykey2 e</span><br><span class="line">(integer) 0</span><br><span class="line">#可以看到mykey2没有关联任何List Value。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey2 0 -1</span><br><span class="line">(empty list or set)</span><br><span class="line">#mykey键此时已经存在，所以该命令插入成功，并返回链表中当前元素的数量。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpushx mykey e</span><br><span class="line">(integer) 5</span><br><span class="line">#获取该键的List Value的头部元素。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 0</span><br><span class="line">1) &quot;e&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LPOP/LLEN:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d</span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; lpop mykey</span><br><span class="line">&quot;d&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; lpop mykey</span><br><span class="line">&quot;c&quot;</span><br><span class="line">#在执行lpop命令两次后，链表头部的两个元素已经被弹出，此时链表中元素的数量是2</span><br><span class="line">redis 127.0.0.1:6379&gt; llen mykey</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>LREM/LSET/LINDEX/LTRIM:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#为后面的示例准备测试数据。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d a c</span><br><span class="line">(integer) 6</span><br><span class="line">#从头部(left)向尾部(right)变量链表，删除2个值等于a的元素，返回值为实际删除的数量。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrem mykey 2 a</span><br><span class="line">(integer) 2</span><br><span class="line">#看出删除后链表中的全部元素。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;d&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line">#获取索引值为1(头部的第二个元素)的元素值。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 1</span><br><span class="line">&quot;d&quot;</span><br><span class="line">#将索引值为1(头部的第二个元素)的元素值设置为新值e。</span><br><span class="line">redis 127.0.0.1:6379&gt; lset mykey 1 e</span><br><span class="line">OK</span><br><span class="line">#查看是否设置成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 1</span><br><span class="line">&quot;e&quot;</span><br><span class="line">#索引值6超过了链表中元素的数量，该命令返回nil。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 6</span><br><span class="line">(nil)</span><br><span class="line">#设置的索引值6超过了链表中元素的数量，设置失败，该命令返回错误信息。</span><br><span class="line">redis 127.0.0.1:6379&gt; lset mykey 6 hh</span><br><span class="line">(error) ERR index out of range</span><br><span class="line">#仅保留索引值0到2之间的3个元素，注意第0个和第2个元素均被保留。</span><br><span class="line">redis 127.0.0.1:6379&gt; ltrim mykey 0 2</span><br><span class="line">OK</span><br><span class="line">#查看trim后的结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;e&quot;</span><br><span class="line">3) &quot;c&quot;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>LINSERT:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#删除该键便于后面的测试。</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey</span><br><span class="line">(integer) 1</span><br><span class="line">#为后面的示例准备测试数据。</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush mykey a b c d e</span><br><span class="line">(integer) 5</span><br><span class="line">#在a的前面插入新元素a1。</span><br><span class="line">redis 127.0.0.1:6379&gt; linsert mykey before a a1</span><br><span class="line">(integer) 6</span><br><span class="line">#查看是否插入成功，从结果看已经插入。注意lindex的index值是0-based。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 0</span><br><span class="line">&quot;e&quot;</span><br><span class="line">#在e的后面插入新元素e2，从返回结果看已经插入成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; linsert mykey after e e2</span><br><span class="line">(integer) 7</span><br><span class="line">#再次查看是否插入成功。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 1</span><br><span class="line">&quot;e2&quot;</span><br><span class="line">#在不存在的元素之前或之后插入新元素，该命令操作失败，并返回-1。</span><br><span class="line">redis 127.0.0.1:6379&gt; linsert mykey after k a</span><br><span class="line">(integer) -1</span><br><span class="line">#为不存在的Key插入新元素，该命令操作失败，返回0。</span><br><span class="line">redis 127.0.0.1:6379&gt; linsert mykey1 after a a2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>RPUSH/RPUSHX/RPOP/RPOPLPUSH:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#删除该键，以便于后面的测试。</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey</span><br><span class="line">(integer) 1</span><br><span class="line">#从链表的尾部插入参数中给出的values，插入顺序是从左到右依次插入。</span><br><span class="line">redis 127.0.0.1:6379&gt; rpush mykey a b c d</span><br><span class="line">(integer) 4</span><br><span class="line">#通过lrange的可以获悉rpush在插入多值时的插入顺序。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br><span class="line">#该键已经存在并且包含4个元素，rpushx命令将执行成功，并将元素e插入到链表的尾部。</span><br><span class="line">redis 127.0.0.1:6379&gt; rpushx mykey e</span><br><span class="line">(integer) 5</span><br><span class="line">#通过lindex命令可以看出之前的rpushx命令确实执行成功，因为索引值为4的元素已经是新元素了。</span><br><span class="line">redis 127.0.0.1:6379&gt; lindex mykey 4</span><br><span class="line">&quot;e&quot;</span><br><span class="line">#由于mykey2键并不存在，因此该命令不会插入数据，其返回值为0。</span><br><span class="line">redis 127.0.0.1:6379&gt; rpushx mykey2 e</span><br><span class="line">(integer) 0</span><br><span class="line">#在执行rpoplpush命令前，先看一下mykey中链表的元素有哪些，注意他们的位置关系。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br><span class="line">5) &quot;e&quot;</span><br><span class="line">#将mykey的尾部元素e弹出，同时再插入到mykey2的头部(原子性的完成这两步操作)。</span><br><span class="line">redis 127.0.0.1:6379&gt; rpoplpush mykey mykey2</span><br><span class="line">&quot;e&quot;</span><br><span class="line">#通过lrange命令查看mykey在弹出尾部元素后的结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br><span class="line">#通过lrange命令查看mykey2在插入元素后的结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey2 0 -1</span><br><span class="line">1) &quot;e&quot;</span><br><span class="line">#将source和destination设为同一键，将mykey中的尾部元素移到其头部。</span><br><span class="line">redis 127.0.0.1:6379&gt; rpoplpush mykey mykey</span><br><span class="line">&quot;d&quot;</span><br><span class="line">#查看移动结果。</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange mykey 0 -1</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;c&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="链表结构的小技巧"><a href="#链表结构的小技巧" class="headerlink" title="链表结构的小技巧"></a>链表结构的小技巧</h3><p>&ensp;&ensp; 针对链表结构的Value，Redis在其官方文档中给出了一些实用技巧，如RPOPLPUSH命令，下面给出具体的解释。<br>&ensp;&ensp; Redis链表经常会被用于消息队列的服务，以完成多程序之间的消息交换。假设一个应用程序正在执行LPUSH操作向链表中添加新的元素，我们通常将这样的程序称之为”生产者(Producer)”，而另外一个应用程序正在执行RPOP操作从链表中取出元素，我们称这样的程序为”消费者(Consumer)”。如果此时，消费者程序在取出消息元素后立刻崩溃，由于该消息已经被取出且没有被正常处理，那么我们就可以认为该消息已经丢失，由此可能会导致业务数据丢失，或业务状态的不一致等现象的发生。然而通过使用RPOPLPUSH命令，消费者程序在从主消息队列中取出消息之后再将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时我们还可以提供一个守护进程，当发现备份队列中的消息过期时，可以重新将其再放回到主消息队列中，以便其它的消费者程序继续处理。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis学习--String数据类型]]></title>
      <url>/2017/10/30/Redis/Redis%E5%AD%A6%E4%B9%A0-String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。<br><a id="more"></a></p>
<h3 id="相关命令列表"><a href="#相关命令列表" class="headerlink" title="相关命令列表"></a>相关命令列表</h3><table>
<thead>
<tr>
<th style="text-align:center">命令原型</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">命令描述</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">APPEND key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">如果该Key已经存在，APPEND命令将参数Value的数据追加到已存在Value的末尾。如果该Key不存在，APPEND命令将会创建一个新的Key/Value。</td>
<td style="text-align:center">追加后Value的长度。</td>
</tr>
<tr>
<td style="text-align:center">DECR key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的递减1。如果该Key不存在，其初始值为0，在decr之后其值为-1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">递减后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">INCR key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的递增1。如果该Key不存在，其初始值为0，在incr之后其值为1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">递增后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">DECRBY key decrement</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的减少decrement。如果该Key不存在，其初始值为0，在decrby之后其值为-decrement。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">减少后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">INCRBY key increment</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">将指定Key的Value原子性的增加increment。如果该Key不存在，其初始值为0，在incrby之后其值为increment。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。</td>
<td style="text-align:center">增加后的Value值。</td>
</tr>
<tr>
<td style="text-align:center">GET key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">获取指定Key的Value。如果与该Key关联的Value不是string类型，Redis将返回错误信息，因为GET命令只能用于获取string Value。</td>
<td style="text-align:center">与该Key相关的Value，如果该Key不存在，返回nil。</td>
</tr>
<tr>
<td style="text-align:center">SET key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性的设置该Key为指定的Value，同时返回该Key的原有值。和GET命令一样，该命令也只能处理string Value，否则Redis将给出相关的错误信息。</td>
<td style="text-align:center">返回该Key的原有值，如果该Key之前并不存在，则返回nil。</td>
</tr>
<tr>
<td style="text-align:center">STRLEN key</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回指定Key的字符值长度，如果Value不是string类型，Redis将执行失败并给出相关的错误信息。</td>
<td style="text-align:center">返回指定Key的Value字符长度，如果该Key不存在，返回0。</td>
</tr>
<tr>
<td style="text-align:center">SETEX key seconds value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">原子性完成两个操作，一是设置该Key的值为指定字符串，同时设置该Key在Redis服务器中的存活时间(秒数)。该命令主要应用于Redis被当做Cache服务器使用时。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">SETNX key value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">如果指定的Key不存在，则设定该Key持有指定字符串Value，此时其效果等价于SET命令。相反，如果该Key已经存在，该命令将不做任何操作并返回。</td>
<td style="text-align:center">1表示设置成功，否则0。</td>
</tr>
<tr>
<td style="text-align:center">SETRANGE key offset value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">替换指定Key的部分字符串值。从offset开始，替换的长度为该命令第三个参数value的字符串长度，其中如果offset的值大于该Key的原有值Value的字符串长度，Redis将会在Value的后面补齐(offset - strlen(value))数量的0x00，之后再追加新值。如果该键不存在，该命令会将其原值的长度假设为0，并在其后添补offset个0x00后再追加新值。鉴于字符串Value的最大长度为512M，因此offset的最大值为536870911。最后需要注意的是，如果该命令在执行时致使指定Key的原有值长度增加，这将会导致Redis重新分配足够的内存以容纳替换后的全部字符串，因此就会带来一定的性能折损。</td>
<td style="text-align:center">修改后的字符串Value长度。</td>
</tr>
<tr>
<td style="text-align:center">GETRANGE key start end</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">如果截取的字符串长度很短，我们可以该命令的时间复杂度视为O(1)，否则就是O(N)，这里N表示截取的子字符串长度。该命令在截取子字符串时，将以闭区间的方式同时包含start(0表示第一个字符)和end所在的字符，如果end值超过Value的字符长度，该命令将只是截取从start开始之后所有的字符数据。</td>
<td style="text-align:center">子字符串</td>
</tr>
<tr>
<td style="text-align:center">SETBIT key offset value</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">设置在指定Offset上BIT的值，该值只能为1或0，在设定后该命令返回该Offset上原有的BIT值。如果指定Key不存在，该命令将创建一个新值，并在指定的Offset上设定参数中的BIT值。如果Offset大于Value的字符长度，Redis将拉长Value值并在指定Offset上设置参数中的BIT值，中间添加的BIT值为0。最后需要说明的是Offset值必须大于0</td>
<td style="text-align:center">在指定Offset上的BIT原有值。</td>
</tr>
<tr>
<td style="text-align:center">GETBIT key offset</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">返回在指定Offset上BIT的值，0或1。如果Offset超过string value的长度，该命令将返回0，所以对于空字符串始终返回0。</td>
<td style="text-align:center">在指定Offset上的BIT值。</td>
</tr>
<tr>
<td style="text-align:center">MGET key [key …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示获取Key的数量。返回所有指定Keys的Values，如果其中某个Key不存在，或者其值不为string类型，该Key的Value将返回nil。</td>
<td style="text-align:center">返回一组指定Keys的Values的列表。</td>
</tr>
<tr>
<td style="text-align:center">MSET key value [key value …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SET命令。</td>
<td style="text-align:center">该命令不会失败，始终返回OK。</td>
</tr>
<tr>
<td style="text-align:center">MSETNX key value [key value …]</td>
<td style="text-align:center">O(N)</td>
<td style="text-align:center">N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SETNX命令。然而这里需要明确说明的是，如果在这一批Keys中有任意一个Key已经存在了，那么该操作将全部回滚，即所有的修改都不会生效。</td>
<td style="text-align:center">1表示所有Keys都设置成功，0则表示没有任何Key被修改</td>
</tr>
</tbody>
</table>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><ol>
<li><p>SET/GET/APPEND/STRLEN:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/&gt; redis-cli   #执行Redis客户端工具。</span><br><span class="line">redis 127.0.0.1:6379&gt; exists mykey                   #判断该键是否存在，存在返回1，否则返回0。</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; append mykey &quot;hello&quot;      #该键并不存在，因此append命令返回当前Value的长度。</span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:6379&gt; append mykey &quot; world&quot;    #该键已经存在，因此返回追加后Value的长度。</span><br><span class="line">(integer) 11</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                      #通过get命令获取该键，以判断append的结果。</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey &quot;this is a test&quot; #通过set命令为键设置新值，并覆盖原有值。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey</span><br><span class="line">&quot;this is a test&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; strlen mykey                  #获取指定Key的字符长度，等效于C库中strlen函数。</span><br><span class="line">(integer) 14</span><br></pre></td></tr></table></figure>
</li>
<li><p>INCR/DECR/INCRBY/DECRBY:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set mykey 20     #设置Key的值为20</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; incr mykey         #该Key的值递增1</span><br><span class="line">(integer) 21</span><br><span class="line">redis 127.0.0.1:6379&gt; decr mykey        #该Key的值递减1</span><br><span class="line">(integer) 20</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey          #删除已有键。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; decr mykey        #对空值执行递减操作，其原值被设定为0，递减后的值为-1</span><br><span class="line">(integer) -1</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey   </span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; incr mykey        #对空值执行递增操作，其原值被设定为0，递增后的值为1</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey hello #将该键的Value设置为不能转换为整型的普通字符串。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; incr mykey        #在该键上再次执行递增操作时，Redis将报告错误信息。</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey 10</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; decrby mykey 5 </span><br><span class="line">(integer) 5</span><br><span class="line">redis 127.0.0.1:6379&gt; incrby mykey 10</span><br><span class="line">(integer) 15</span><br></pre></td></tr></table></figure>
</li>
<li><p>GETSET：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; incr mycounter      #将计数器的值原子性的递增1</span><br><span class="line">(integer) 1</span><br><span class="line">#在获取计数器原有值的同时，并将其设置为新值，这两个操作原子性的同时完成。</span><br><span class="line">redis 127.0.0.1:6379&gt; getset mycounter 0  </span><br><span class="line">&quot;1&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; get mycounter       #查看设置后的结果。</span><br><span class="line">&quot;0&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SETEX:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; setex mykey 10 &quot;hello&quot;   #设置指定Key的过期时间为10秒。</span><br><span class="line">OK    </span><br><span class="line">#通过ttl命令查看一下指定Key的剩余存活时间(秒数)，0表示已经过期，-1表示永不过期。</span><br><span class="line">redis 127.0.0.1:6379&gt; ttl mykey                       </span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                      #在该键的存活期内我们仍然可以获取到它的Value。</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; ttl mykey                        #该ttl命令的返回值显示，该Key已经过期。</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                      #获取已过期的Key将返回nil。</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
</li>
<li><p>SETNX:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; del mykey                      #删除该键，以便于下面的测试验证。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; setnx mykey &quot;hello&quot;        #该键并不存在，因此该命令执行成功。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; setnx mykey &quot;world&quot;       #该键已经存在，因此本次设置没有产生任何效果。</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                      #从结果可以看出，返回的值仍为第一次设置的值。</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SETRANGE/GETRANGE:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; set mykey &quot;hello world&quot;       #设定初始值。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; setrange mykey 6 dd          #从第六个字节开始替换2个字节(dd只有2个字节)</span><br><span class="line">(integer) 11</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                         #查看替换后的值。</span><br><span class="line">&quot;hello ddrld&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; setrange mykey 20 dd        #offset已经超过该Key原有值的长度了，该命令将会在末尾补0。</span><br><span class="line">(integer) 22</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                           #查看补0后替换的结果。</span><br><span class="line">&quot;hello ddrld\x00\x00\x00\x00\x00\x00\x00\x00\x00dd&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; del mykey                         #删除该Key。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; setrange mykey 2 dd         #替换空值。</span><br><span class="line">(integer) 4</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                        #查看替换空值后的结果。</span><br><span class="line">&quot;\x00\x00dd&quot;   </span><br><span class="line">redis 127.0.0.1:6379&gt; set mykey &quot;0123456789&quot;   #设置新值。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; getrange mykey 1 2      #截取该键的Value，从第一个字节开始，到第二个字节结束。</span><br><span class="line">&quot;12&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; getrange mykey 1 20   #20已经超过Value的总长度，因此将截取第一个字节后面的所有字节。</span><br><span class="line">&quot;123456789&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SETBIT/GETBIT:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; del mykey</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit mykey 7 1       #设置从0开始计算的第七位BIT值为1，返回原有BIT值0</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                #获取设置的结果，二进制的0000 0001的十六进制值为0x01</span><br><span class="line">&quot;\x01&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; setbit mykey 6 1       #设置从0开始计算的第六位BIT值为1，返回原有BIT值0</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; get mykey                #获取设置的结果，二进制的0000 0011的十六进制值为0x03</span><br><span class="line">&quot;\x03&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; getbit mykey 6          #返回了指定Offset的BIT值。</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; getbit mykey 10        #Offset已经超出了value的长度，因此返回0。</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>MSET/MGET/MSETNX:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; mset key1 &quot;hello&quot; key2 &quot;world&quot;   #批量设置了key1和key2两个键。</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; mget key1 key2                        #批量获取了key1和key2两个键的值。</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">#批量设置了key3和key4两个键，因为之前他们并不存在，所以该命令执行成功并返回1。</span><br><span class="line">redis 127.0.0.1:6379&gt; msetnx key3 &quot;stephen&quot; key4 &quot;liu&quot; </span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; mget key3 key4                   </span><br><span class="line">1) &quot;stephen&quot;</span><br><span class="line">2) &quot;liu&quot;</span><br><span class="line">#批量设置了key3和key5两个键，但是key3已经存在，所以该命令执行失败并返回0。</span><br><span class="line">redis 127.0.0.1:6379&gt; msetnx key3 &quot;hello&quot; key5 &quot;world&quot; </span><br><span class="line">(integer) 0</span><br><span class="line">#批量获取key3和key5，由于key5没有设置成功，所以返回nil。</span><br><span class="line">redis 127.0.0.1:6379&gt; mget key3 key5                   </span><br><span class="line">1) &quot;stephen&quot;</span><br><span class="line">2) (nil)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[servlet的9大内置对象]]></title>
      <url>/2017/10/28/servlet%E7%9A%849%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">隐式对象</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">request</td>
<td style="text-align:center">转译后的HttpServletRquest/ServletRequest对象</td>
</tr>
<tr>
<td style="text-align:center">response</td>
<td style="text-align:center">转译后对应HttpServletRespons/ServletResponse对象</td>
</tr>
<tr>
<td style="text-align:center">session</td>
<td style="text-align:center">转译后对应HttpSession对象</td>
</tr>
<tr>
<td style="text-align:center">application</td>
<td style="text-align:center">转译后对应ServletContext对象</td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td style="text-align:center">转译后对应JspWriter对象，其内部关联一个PringWriter对象</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">转译后对应this</td>
</tr>
<tr>
<td style="text-align:center">config</td>
<td style="text-align:center">转译后对应ServletConfig对象</td>
</tr>
<tr>
<td style="text-align:center">exception</td>
<td style="text-align:center">转译后对应Throwable对象，代表由其他JSP页面抛出的异常对象，只会出现于JSP错误页面(isErrorPage设置为true的JSP页面)</td>
</tr>
<tr>
<td style="text-align:center">pageContext</td>
<td style="text-align:center">转译后对应PageContext对象，它提供了JSP页面资源的封装，并可设置页面范围属性</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="JSP隐含变量"><a href="#JSP隐含变量" class="headerlink" title="JSP隐含变量"></a>JSP隐含变量</h2><p>1.out 来源于Java.io.Writer类，它用于发送输出流到客户端。<br>2.request 来源于javax.servlet.http.HttpServletRequest接口。它被关联到每一个HTTP请求。<br>3.response 来源于javax.servlet.http.HttpServletResponse。response对象用于把取得的数据返回到客户端。<br>4.pageContext 提供访问JSP页面的命名空间。它也提供用来访问其他的JSP隐含对象。<br>5.session 来源于javax.servlet.http.HttpSession。它用于存储客户端请求的信息，因此它是有状态交互式的。<br>6.application 来源于javax.servlet.ServletContext。<br>7.config 来源于ServletConfig，它包含了当前JSP/Servlet所在的WEB应用的配置信息。<br>8.page 来源于当前被访问JSP页面的实例化。它实际使用的是JSP转换成的Servlet。<br>9.exception 用于捕获JSP抛出的异常。它只有在JSP页面属性isErrorPage=true时才可用。</p>
<h3 id="一、request对象："><a href="#一、request对象：" class="headerlink" title="一、request对象："></a>一、request对象：</h3><p>&ensp;&ensp;该对象封装了用户提交的信息，通过调用该对象相应的方法可以获取封装的信息， 即使用该对象可以获取用户提交信息。 客户端的请求参数都被封装到这个对象里面</p>
<h3 id="二、response对象："><a href="#二、response对象：" class="headerlink" title="二、response对象："></a>二、response对象：</h3><p>&ensp;&ensp;对客户的请求做出动态的响应，向客户发送数据。</p>
<h3 id="三、session对象："><a href="#三、session对象：" class="headerlink" title="三、session对象："></a>三、session对象：</h3><p>&ensp;&ensp;1.什么是session：session对象是一个JSP内置对象，它在第一个JSP页面被装载时自动创建，完成会话期管理。<br>从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。当一个客户访问一个服务器时，可能会在这个服务器的几个页面之间反复连接，反复刷新一个页面，服务器应当通过某种办法知道这是同一个客户，这就需要session对象。</p>
<p>&ensp;&ensp;2．session对象的ID：当一个客户首次访问服务器上的一个JSP页面时，JSP引擎产生一个session对象，同时分配一个String类型的ID号，JSP引擎同时将这个ID号发送到客户端，存放在Cookie中，这样session对象和客户之间就建立了一一对应的关系。当客户再访问连接该服务器的其他页面时，不再分配给客户新的session对象，直到客户关闭浏览器后，服务器端该客户的session对象才取消，并且和客户的会话对应关系消失。当客户重新打开浏览器再连接到该服务器时，服务器为该客户再创建一个新的session对象。</p>
<h3 id="四、aplication对象："><a href="#四、aplication对象：" class="headerlink" title="四、aplication对象："></a>四、aplication对象：</h3><p>&ensp;&ensp;1．什么是application:<br>服务器启动后就产生了这个application对象，当客户在所访问的网站的各个页面之间浏览时，这个application对象都是同一个，直到服务器关闭。但是与session不同的是，所有客户的application对象都是同一个，即所有客户共享这个内置的application对象。</p>
<p>&ensp;&ensp;2．application对象常用方法:<br>(1)public void setAttribute(String key,Object obj): 将参数Object指定的对象obj添加到application对象中，并为添加的对象指定一个索引关键字。<br>(2)public Object getAttribute(String key): 获取application对象中含有关键字的对象。 </p>
<h3 id="五、out对象："><a href="#五、out对象：" class="headerlink" title="五、out对象："></a>五、out对象：</h3><p>&ensp;&ensp;out 对象是一个输出流，用来向客户端输出数据。out对象用于各种数据的输出。</p>
<h3 id="六、page-java-lang-Object："><a href="#六、page-java-lang-Object：" class="headerlink" title="六、page java.lang.Object："></a>六、page java.lang.Object：</h3><p>&ensp;&ensp;对应this关键字。JSP网页本身<br>page对象是当前页面转换后的Servlet类的实例。从转换后的Servlet类的代码中，可以看到这种关系：<br>Object page = this;<br>在JSP页面中，很少使用page对象。</p>
<h3 id="七、config："><a href="#七、config：" class="headerlink" title="七、config："></a>七、config：</h3><p>&ensp;&ensp;javax.servlet. ServletConfig 的实例，该实例代表该JSP 的配置信息。常用的方法有getInitPararneter(String paramNarne) 及getInitPararneternarnes() 等方法。事实上， JSP 页面通常无须配置，也就不存在配置信息。因此，该对象更多地在Servlet 中有效。</p>
<h3 id="八、exception-java-lang-Throwable-的实例："><a href="#八、exception-java-lang-Throwable-的实例：" class="headerlink" title="八、exception java.lang.Throwable 的实例："></a>八、exception java.lang.Throwable 的实例：</h3><p>&ensp;&ensp;该实例代表其他页面中的异常和错误。只有当页面是错误处理页面，即编译指令page 的isErrorPage 属性为true 时，该对象才可以使用。常用的方法有getMessageO和printStackTraceO等。</p>
<h3 id="九、pageContext："><a href="#九、pageContext：" class="headerlink" title="九、pageContext："></a>九、pageContext：</h3><p>&ensp;&ensp;out 对象是一个输出流，用来向客户端输出数据。out对象用于各种数据的输出。</p>
<hr>
<p>//使用pageContext 设置属性，该属性默认在page 范围内<br>pageContext. setAttribute (“page” , “hello”) ; </p>
<p>  //使用request 设置属性，该属性默认在request 范围内<br>request. setAttribute (“request” , “hello”); </p>
<p>  //使用pageContext将属性设置在request 范围中<br>pageContext.setAttribute(“request2” , “hello” , pageContext.REQUEST_SCOPE); </p>
<p>  // 使用session将属性设置在session 范围中<br>session.setAttribute(“session” , “hello”l; </p>
<p>  //使用pageContext将属性设置在session范围中<br>pageContext.setAttribute(“session2” , “hello” , pageContext.SESSION_SCOPE); </p>
<p>  //使用application将属性设置在application范围中<br>application. setAttribute (“app” , “hello”) ; </p>
<p>  //使用pageContext 将属性设置在application 范围中<br>pageContext.setAttribute(“app2” , “hello” , pageContext.APPL 工CATION_SCOPE) ;</p>
<hr>
<h2 id="四个作用域："><a href="#四个作用域：" class="headerlink" title="四个作用域："></a>四个作用域：</h2><h3 id="application："><a href="#application：" class="headerlink" title="application："></a>application：</h3><p>全局作用范围，整个应用程序共享，就是在部署文件中的同一个webApp共享，生命周期为：应用程序启动到停止。</p>
<h3 id="session："><a href="#session：" class="headerlink" title="session："></a>session：</h3><p>会话作用域，当用户首次访问时，产生一个新的会话，以后服务器就可以记住这个会话状态。生命周期：会话超时，或者服务器端强制使会话失效。</p>
<h3 id="request"><a href="#request" class="headerlink" title="request:"></a>request:</h3><p>请求作用域，就是客户端的一次请求。</p>
<h3 id="page："><a href="#page：" class="headerlink" title="page："></a>page：</h3><p>一个JSP页面。</p>
<p>以上作用范围使越来越小， request和page的生命周期都是短暂的，他们之间的区别就是：一个request可以包含多个page页(include，forward以及filter)。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux命令（特殊功能）]]></title>
      <url>/2017/10/24/Linux/Linux%E5%91%BD%E4%BB%A4%EF%BC%88%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%EF%BC%89/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk  &apos;NR==FNR&#123;a[$0]&#125;NR&gt;FNR&#123; if(!($1 in a)) print $0&#125;&apos; file1 file2 找出文件2中不同的值</span><br><span class="line"></span><br><span class="line">awk  &apos;NR==FNR&#123;a[$0]&#125;NR&gt;FNR&#123; if($1 in a)    print $0&#125;&apos; file1 file2 找出两文件中相同的值</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux常用命令（简）]]></title>
      <url>/2017/10/24/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="目录与文件命令"><a href="#目录与文件命令" class="headerlink" title="目录与文件命令"></a>目录与文件命令</h2><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a><a href="https://omg-by.github.io/1900/01/01/Linux/cd/" title="cd详细介绍" target="_blank" rel="noopener">cd命令</a></h3><p>&ensp;&ensp;跟Windows中一样，进入相应的目录下。<br>&ensp;&ensp;命令格式： cd [目录]</p>
<h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a><a href="https://omg-by.github.io/1900/01/01/Linux/ls/" title="ls详细介绍" target="_blank" rel="noopener">ls命令</a></h3><p>&ensp;&ensp;查看当前目录下的目录、文件等及其相应权限。<br>&ensp;&ensp;命令格式： ls [选项] 目录</p>
<h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><p>&ensp;&ensp;查看当前工作目录的完整路径。<br>&ensp;&ensp;pwd [选项]</p>
<h3 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h3><p>&ensp;&ensp;创建一个指定的名称的目录，要求创建目录的用户具有权限且该目录名不存在。<br>&ensp;&ensp;mkdir [选项]目录<br><a id="more"></a></p>
<h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><p>&ensp;&ensp;删除一个目录中的一个或多个文件或目录。<br>&ensp;&ensp;rm [选项] 文件或目录</p>
<h3 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h3><p>&ensp;&ensp;删除空目录。<br>&ensp;&ensp;rmdir [选项] 目录</p>
<h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p>&ensp;&ensp;移动文件或者将文件改名，经常用来备份文件或者目录。<br>&ensp;&ensp;mv [选项] 源文件或目录 目标文件或者目录</p>
<h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p>&ensp;&ensp;复制文件，如果目标文件已经存在，会询问是否覆盖。<br>&ensp;&ensp;cp [选项] 源文件或目录  目的目录</p>
<h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p>&ensp;&ensp;用来修改文件时间戳或者新建一个不存在的文件。<br>&ensp;&ensp;touch [选项] 文件</p>
<h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><p>&ensp;&ensp;用来压缩和解压文件。tar本身不具有压缩功能，他是调用压缩功能实现的。<br>&ensp;&ensp;tar [必要参数][选择参数][文件]</p>
<h2 id="查看与搜索"><a href="#查看与搜索" class="headerlink" title="查看与搜索"></a>查看与搜索</h2><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>&ensp;&ensp;显示文件内容 或者将几个文件连接起来显示 或者从标准输入读取内容并显示，常与重定向符号配合使用。<br>&ensp;&ensp;cat [选项] 文件</p>
<h3 id="nl命令"><a href="#nl命令" class="headerlink" title="nl命令"></a>nl命令</h3><p>&ensp;&ensp;用来计算文件中行号，可以将输出的文件内容自动的加上行号。<br>&ensp;&ensp;nl [选项] 文件</p>
<h3 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h3><p>&ensp;&ensp;功能类似cat，cat是整个文件的内容从上到下显示到屏幕上，more会以一页一页的显示方便使用者阅读，空格向后，b键向前。more从前向后读取文件，因此在启动时就加载整个文件。<br>&ensp;&ensp;more [选项] [每屏几行] [查找的子串] [第几行开始] [文件] </p>
<h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p>&ensp;&ensp;跟more类似，但使用less可以任意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看前不会加载整个文件。<br>&ensp;&ensp;less [参数] 文件</p>
<h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><p>&ensp;&ensp;用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。<br>&ensp;&ensp;head [参数] 文件</p>
<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>&ensp;&ensp;用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。<br>&ensp;&ensp;tail[必要参数][选择参数] 文件</p>
<h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><p>&ensp;&ensp;which指令会在PATH变量指定的路径下，搜索某个系统命令的位置，并且返回第一个搜索结果。<br>&ensp;&ensp;which 可执行文件命令</p>
<h3 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h3><p>&ensp;&ensp;whereis命令是定位可执行文件、源代码文件、帮助文件、在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。<br>&ensp;&ensp;whereis [-bmsu] [BMS 目录名 -f ] 文件名</p>
<h3 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h3><p>&ensp;&ensp;通过系统自动生成是数据库表来查询文件，支持匹配符。但是由于有些系统的数据库表不是实时更新的，所以查到的数据可能不是最新的。<br>&ensp;&ensp;locate[选择参数][样式]</p>
<h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><p>&ensp;&ensp;用于在文件树中查找文件，并作出相应的处理。<br>&ensp;&ensp;find pathname -options [-print -exec -ok …] </p>
<p>##磁盘相关##</p>
<h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h3><p>&ensp;&ensp;列出文件系统的整体磁盘使用量</p>
<h3 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h3><p>&ensp;&ensp;评估文件系统的磁盘使用量（常用于评估目录所占容量）</p>
<h3 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h3><p>&ensp;&ensp;连接文件<br>&ensp;&ensp;ls [-sf] 源文件 目标文件<br>&ensp;&ensp;-s 如果不加任何参数就进行连接，那就是hard link，至于-s就是symbolic link<br>&ensp;&ensp;-f 如果目标文件存在时，就主动将目标文件删除后再创建。</p>
<h3 id="fdisk命令"><a href="#fdisk命令" class="headerlink" title="fdisk命令"></a>fdisk命令</h3><p>&ensp;&ensp;磁盘分区</p>
<h3 id="mkfs命令"><a href="#mkfs命令" class="headerlink" title="mkfs命令"></a>mkfs命令</h3><p>&ensp;&ensp;磁盘格式化<br>&ensp;&ensp;mkfs [-t 文件系统格式] 设备文件名</p>
<h3 id="fsck命令"><a href="#fsck命令" class="headerlink" title="fsck命令"></a>fsck命令</h3><p>&ensp;&ensp;磁盘检验</p>
<h3 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h3><p>&ensp;&ensp;磁盘挂载</p>
<h3 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a>umount命令</h3><p>&ensp;&ensp;磁盘卸载</p>
<p><br><br><br><br><center> <strong>长期不定时更新中。。。。。。。。。</strong></center></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ActionContext]]></title>
      <url>/2017/10/21/kuangjia/Struts/ActionContext/</url>
      <content type="html"><![CDATA[<h3 id="ActionContext"><a href="#ActionContext" class="headerlink" title="ActionContext"></a><center>ActionContext</center></h3><p>&ensp;&ensp;ActionContext是Action的上下文，Struct2自动在其中保存了一些在Action执行过程中所需的对象，比如session、parameters、locale等。Struts2会根据每个执行HTTp请求的线程来创建对应的ActionContext，即一个线程只有一个唯一的ActionContext。因此，使用者可以使用静态方法ActionContext.getContext&#40;&#41;来获取当前线程的ActionContext，也正是由于这个原因，使用者不用去操心让Action是线程安全的。</p>
<p>&ensp;&ensp;无论如何，ActionContext都是用来存放数据的。Struts2本身会在其中放入不少数据，而使用者也可以放入自己想要的数据。ActionContext本身的数据结构是映射结构，即一个Map，用key来映射value。所以使用者完全可以像使用Map一样来使用它，或者直接使用Action.getContextMap&#40;&#41;方法来对Map进行操作。</p>
<p>&ensp;&ensp;Struts2本身在其中放入的数据有Actionlnvocation、application&#40;即ServletContext&#41;、conversionErrors、Locale、action的name、request的参数、HTTP的Session以及值栈等。完整的列表请参考它的Javadoc。</p>
<p>&ensp;&ensp;由于ActionContext的线程唯一和静态方法就能获得的特性，使得在非Action类中可以直接获得它，而不需要等待Action传入或注入。<font color="#DC143C">需要注意的是，它仅在由于request而创建的线程中有效&#40;因为request时才创建对应的ActionContext&#41;，而在服务器启动的线程中&#40;比如fliter的init方法&#41;无效。</font>由于在非Action类中访问其的方便性，ActionContext也可以用来在非Action类中向JSP传递数据&#40;因为JSP也能很方便的访问它&#41;。<br><a id="more"></a></p>
<h3 id="ValueStack与ActionContext的联系和区别"><a href="#ValueStack与ActionContext的联系和区别" class="headerlink" title="ValueStack与ActionContext的联系和区别"></a><center>ValueStack与ActionContext的联系和区别</center></h3><p>&ensp;&ensp;<font color="#DC143C">相同点：它们都是在一次HTTP请求的范围内使用的，即它们的生命周期都是一次请求。<br>&ensp;&ensp;不同点：值栈是栈的结构，ActionContext是映射&#40;Map&#41;的结构。</font></p>
<p>&ensp;&ensp;联系：ValueStack.getContext&#40;&#41;方法得到的Map其实就是ActionContext的Map。查看Struts2的源代码可知&#40;Struts2.3.1.2的org.apache.struts2.dispatcher.ng.PrepareOperations的第79行，createActionContext方法&#41;，在创建ActionContext时，就是把ValueStack.getContext&#40;&#41;作为ActionContext的构造函数的参数。所以，ValueStack和ActionContext本质上可以互相获得。</p>
<p>&ensp;&ensp;注意：在一些文档中，会出现把对象存入“stack‘s context”的字样，其实就是把值存入了ActionContext。所以在阅读这些文档时，要看清楚，到底是放入了栈结构&#40;即值栈&#41;，还是映射结构&#40;值栈的context，即ActionContext&#41;。</p>
<h3 id="如何获得ActionContext"><a href="#如何获得ActionContext" class="headerlink" title="如何获得ActionContext"></a><center>如何获得ActionContext</center></h3><p>&ensp;&ensp;在自定义的拦截器中：使用ActionInvocation.getInvocationContext&#40;&#41;或者使用ActionContext.getContext&#40;&#41;。</p>
<p>&ensp;&ensp;在Action类中：让拦截器注入或者使用ActionContext.getContext&#40;&#41;。</p>
<p>&ensp;&ensp;在非Action类中：让Action类传递参数、使用注入机制注入或者使用ActionContext.getContext&#40;&#41;。</p>
<p>&ensp;&ensp;<font color="#DC143C">注意：只有运行在request线程中的代码才能调用ActionContext.getContext&#40;&#41;，否则返回的是null。<br>在JSP中：一般不需要获得ActionContext本身。</font></p>
<h3 id="如何向ActionContext存入值"><a href="#如何向ActionContext存入值" class="headerlink" title="如何向ActionContext存入值"></a><center>如何向ActionContext存入值</center></h3><p>&ensp;&ensp;在拦截器、Action类、非Action类等Java类中：使用ActionContext.put&#40;Object key,Object value&#41;方法。</p>
<p>&ensp;&ensp;在JSP中：标签&lt;S:set value=”…”/&gt;默认将值存入ActionContext中&#40;当然，&lt;s:set&gt;标签还可以把值存到其他地方&#41;。</p>
<p>&ensp;&ensp;另外，许多标签都有var属性&#40;以前用的是id属性，现在id属性已被抛弃&#41;，这个属性能向ActionContext存入值，key为var属性的值，value为标签的value值。&#40;有些文档写的是向ValueStack的context存入值，其实是一样的&#41;</p>
<h3 id="如何向ActionContext读取值"><a href="#如何向ActionContext读取值" class="headerlink" title="如何向ActionContext读取值"></a><center>如何向ActionContext读取值</center></h3><p>&ensp;&ensp;在拦截器、Action类、非Action类等Java类中：使用ActionContext.get&#40;Object key&#41;方法。</p>
<p>&ensp;&ensp;在JSP中：使用#开头的Ognl表达式解析，则需要使用%&#123;&#125;把表达式括起来，于是就会出现类似“%&#123;#name&#125;”的表达式。</p>
<p>&ensp;&ensp;在JSP中：总之，在JSP中使用ActionContext一方面由于它是映射结构，另一方面是能读取Action的一些配置。当你需要为许多Action提供通用的值的话，可以让每个Action都提供getXXX&#40;&#41;方法，但更好的方法是在拦截器或JSP模板中把这些通用的值存放到ActionC中&#40;因为拦截器或JSP模板往往通用于多个Action&#41;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本类将演示拦截器中对ActionContext的操作   </span></span><br><span class="line">publicclass MyInterceptor extends AbstractInterceptor &#123;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception </span>&#123;   </span><br><span class="line">        <span class="comment">// 获得ActionContext   </span></span><br><span class="line">        ActionContext actionContext = invocation.getInvocationContext();   </span><br><span class="line">        <span class="comment">// 存入值   </span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();   </span><br><span class="line">        actionContext.put(<span class="string">"person"</span>, person);   </span><br><span class="line">        <span class="comment">// 获取值   </span></span><br><span class="line">        Object value = actionContext.get(<span class="string">"person"</span>);   </span><br><span class="line">        <span class="comment">// 获取HttpServletRequest   </span></span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) actionContext.get(StrutsStatics.HTTP_REQUEST);   </span><br><span class="line">        <span class="comment">// 获取request的Map，即HttpServletRequest.getAttribute(...)和HttpServletRequest.setAttribute(...)所操作的值  </span></span><br><span class="line">        Map requestMap = (Map) actionContext.get(<span class="string">"request"</span>);   </span><br><span class="line">        <span class="comment">// 其他代码   </span></span><br><span class="line">        <span class="comment">// ......   </span></span><br><span class="line">        <span class="keyword">return</span> invocation.invoke();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本类将演示在Action中对ActionContext进行操作   </span></span><br><span class="line">publicclass MyAction extends ActionSupport &#123;   </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;   </span><br><span class="line">        <span class="comment">// 获得值栈   </span></span><br><span class="line">        ActionContext actionContext = ActionContext.getContext();   </span><br><span class="line">        <span class="comment">// 存入值   </span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();<span class="comment">// 这是之前例子中定义的类  </span></span><br><span class="line">        actionContext.put(<span class="string">"person"</span>, person);   </span><br><span class="line">        <span class="comment">// 获取值   </span></span><br><span class="line">        Object object = actionContext.get(<span class="string">"person"</span>);   </span><br><span class="line">        <span class="comment">// 其他代码   </span></span><br><span class="line">        <span class="comment">// ......   </span></span><br><span class="line">        <span class="keyword">return</span> SUCCESS;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">metahttp-equiv="Content-Type"content="text</span>/<span class="attr">html</span>; <span class="attr">charset</span>=<span class="string">UTF-8</span>"&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 本JSP将演示在JSP中对ActionContext的使用 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 本JSP为MyAction对应的JSP --&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!-- 由于Action中已经向ActionContext存入了key为"person"的值，所以可以使用“#person”来获取它，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#person"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 获得person的name属性，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#person.name"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 获得Struts2在ActionContext中存入的值，比如request的Map，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#request"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 获得Struts2在ActionContext中存入的值，比如session的Map，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#session"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 获得Struts2在ActionContext中存入的值，request请求传递的GET参数或POST参数的Map，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#parameters"</span>/&gt;</span>  </span><br><span class="line">           </span><br><span class="line">        <span class="comment">&lt;!-- 以下演示在JSP中把值存入ActionContext中  --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 存入一个字符串"myName"，key为"myKey"，如下 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:setvalue="%&#123;‘myName‘&#125;"var="myKey"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 使用s:bean标签来创建一个对象，并把它存入ActionContext中，key为myObject，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:beanname="com.example.Person"var="myObject"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 之后就可以用“#”来读取它们，如下  --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#myKey"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">s:propertyvalue="#myObject"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Struts2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java内存区域]]></title>
      <url>/2017/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="http://ocx5m3vc3.bkt.clouddn.com/JVM_1.jpg" alt=""><br><a id="more"></a></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>&ensp;&ensp;程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。（此内存区域是唯一一个在JAVA虚拟机规范中没有规定任何OME情况的区域）</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>&ensp;&ensp;与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>&ensp;&ensp;本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java（也就是字节码）服务，而本地方法栈则为虚拟机使用的Native方法服务。在虚拟机规范中对本地方法栈中使用的语言、使用方式、与数据结构并没有强制规定，因此具体的虚拟机可以自由的实现它。甚至有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>&ensp;&ensp;对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>&ensp;&ensp;方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个一个别名叫做Non-Heap（非栈），目的应该是与Java堆分开来。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>&ensp;&ensp;运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，已不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用。</p>
<h2 id="虚拟机对象探索"><a href="#虚拟机对象探索" class="headerlink" title="虚拟机对象探索"></a>虚拟机对象探索</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>&ensp;&ensp;虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。<br>&ensp;&ensp;在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后完全可以确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>
<ul>
<li>指针碰撞</li>
<li>空闲列表</li>
</ul>
<p>&ensp;&ensp;内存分配完成后，虚拟机需要将分配到的内存空间都初始化零值。<br>&ensp;&ensp;接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。<br>&ensp;&ensp;在上面工作都完成后，从虚拟机的视角看，一个新的对象已经产生了，但从Java程序的视角来就看，对象创建才刚刚开始—<init>方法还没有执行所有字段都还为零。</init></p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>&ensp;&ensp;对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对齐填充。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><ul>
<li>句柄访问</li>
<li>直接指针</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[static]]></title>
      <url>/2017/10/18/static/</url>
      <content type="html"><![CDATA[<h1 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用:"></a>static的作用:</h1><h2 id="不考虑类"><a href="#不考虑类" class="headerlink" title="不考虑类"></a>不考虑类</h2><h3 id="第一个作用：隐藏"><a href="#第一个作用：隐藏" class="headerlink" title="第一个作用：隐藏"></a>第一个作用：隐藏</h3><p>&ensp;&ensp;当我们同时编译多个文件时，所有未加static前缀的<strong>全局变量</strong>和<strong>函数</strong>都具有全局可见性。</p>
<p>&ensp;&ensp;如果加了static，就会对其他源文件隐藏，利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。</p>
<hr>
<ul>
<li>static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用<a id="more"></a>
</li>
</ul>
<hr>
<h3 id="第二个作用：默认初始化为0"><a href="#第二个作用：默认初始化为0" class="headerlink" title="第二个作用：默认初始化为0"></a>第二个作用：默认初始化为0</h3><p>&ensp;&ensp;包括未初始化的全局静态变量与局部静态变量。其实未初始化的全局变量也具备这一属性，因为未初始化的全局变量与未初始化的静态变量是存储在同一块区域内的（BBS段）。</p>
<p>&ensp;&ensp;在BBS段中，内存中所有的字节默认值都是0x00，某些时候这一特性可以减少程序员的工作量。</p>
<h3 id="第三个作用：保持局部变量内容的持久"><a href="#第三个作用：保持局部变量内容的持久" class="headerlink" title="第三个作用：保持局部变量内容的持久"></a>第三个作用：保持局部变量内容的持久</h3><p>&ensp;&ensp;函数内的自动（局部）变量，当调用时就存在，退出函数时就消失，当静态局部变量虽然在函数内定义，当静态局部变量始终存在着，也就是说它的生存周期为整个源程序，其特点就是只进行一次初始化且具有“记忆性”。</p>
<p>&ensp;&ensp;静态局部变量的生存期虽然为整个源程序，但是其作用域仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出函数后，尽管该变量还继续存在，但是不能使用它。</p>
<hr>
<h2 id="类中static的作用"><a href="#类中static的作用" class="headerlink" title="类中static的作用"></a>类中static的作用</h2><p>&ensp;&ensp;C++重用了static这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定的对象的变量和函数（和Java中此关键字的含义相同）</p>
<ul>
<li>静态数据成员</li>
<li>静态成员函数</li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[软件]]></title>
      <url>/2017/10/18/%E5%B0%8F%E8%BD%AF%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>各种杂七杂八的软件：</p>
<ul>
<li><a href="http://pan.baidu.com/s/1pLSfj9x" target="_blank" rel="noopener">Windows FX</a></li>
<li><a href="http://pan.baidu.com/s/1hrJVDU8" target="_blank" rel="noopener">Myeclipse</a></li>
<li><a href="http://pan.baidu.com/s/1hrDQbAW" target="_blank" rel="noopener">Kali系统</a></li>
<li><a href="http://pan.baidu.com/s/1dFni0Jv" target="_blank" rel="noopener">JDK压缩包</a></li>
<li><a href="http://pan.baidu.com/s/1i49KJlj" target="_blank" rel="noopener">zookeeper</a></li>
<li><a href="http://pan.baidu.com/s/1kVvJKKv" target="_blank" rel="noopener">tomcat</a></li>
<li></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软件 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[虚函数]]></title>
      <url>/2017/10/18/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>引入原因：为了方便使用多态特性，我们常常需要在基类中定于虚函数。</p>
<p>关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</p>
<p><strong>虚函数表</strong><br><a id="more"></a><br>&emsp;&ensp;虚函数是通过一张虚函数表来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p>
<p>这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。<br>假设我们有这样的一个类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">Base b;</span><br><span class="line">Fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表地址："</span> &lt;&lt; (<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表 — 第一个函数地址："</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的一点争议的个人看法：</span></span><br><span class="line">原文认为(<span class="keyword">int</span>*)(&amp;b)是虚表的地址，而很多网友都说，（包括我也认为）：(<span class="keyword">int</span> *)*(<span class="keyword">int</span>*)(&amp;b)才是虚表地址</span><br><span class="line">而(<span class="keyword">int</span>*)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)); 才是虚表第一个虚函数的地址。</span><br><span class="line">其实看后面的调用pFun = (Fun)*((int*)*(int*)(&amp;b)); 就可以看出，*((int*)*(int*)(&amp;b));转成函数指针给pFun，然后正确的调用到了虚函数virtual void f()。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke the first virtual function</span></span><br><span class="line">pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b));</span><br><span class="line">pFun();</span><br><span class="line">实际运行经果如下：(Windows XP+VS2003, Linux <span class="number">2.6</span><span class="number">.22</span> + GCC <span class="number">4.1</span><span class="number">.3</span>)</span><br><span class="line">虚函数表地址：<span class="number">0012F</span>ED4</span><br><span class="line">虚函数表 — 第一个函数地址：<span class="number">0044F</span>148</span><br><span class="line">Base::f</span><br><span class="line">通过这个示例，我们可以看到，我们可以通过强行把&amp;b转成<span class="keyword">int</span> *，取得</span><br><span class="line">虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也</span><br><span class="line">就是Base::f()，这在上面的程序中得到了验证（把<span class="keyword">int</span>* 强制转成了函</span><br><span class="line">数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和</span><br><span class="line">Base::h()，其代码如下：</span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>); <span class="comment">// Base::f()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>); <span class="comment">// Base::g()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>); <span class="comment">// Base::h()</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>一般继承（无虚函数覆盖）</strong></p>
<p>下面，让我们来看看继承时的虚函数表示什么样的。假设有如下所以的一个继承关系：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_2.jpg" alt=""></p>
<p>请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：<br>对于实例：Derive d; 的虚函数表如下：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_3.jpg" alt=""></p>
<p>我们可以看到下面几点：</p>
<p>1.虚函数按照其声明顺序放于表中。</p>
<p>2.父类的虚函数在子类的虚函数前面。</p>
<p><strong>一般继承（有虚函数覆盖）</strong></p>
<p>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_4.jpg" alt=""></p>
<p>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_5.jpg" alt=""></p>
<p>我们从表中可以看到下面几点：</p>
<p>1.覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</p>
<p>2.没有被覆盖的函数依旧。</p>
<p><strong>多重继承（无虚函数覆盖）</strong></p>
<p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_6.jpg" alt=""></p>
<p>对于子类实例中的虚函数表，是下面这个样子：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_7.jpg" alt=""></p>
<p>我们可以看到：</p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<p><strong>多重继承（有虚函数覆盖）</strong></p>
<p>下面我们再来看看，如果发生虚函数覆盖的情况。</p>
<p>下图中，我们在子类中覆盖了父类的f()函数。</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_8.jpg" alt=""></p>
<p>下面是对于子类实例中的虚函数表的图：</p>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/virtual_9.jpg" alt=""></p>
<p>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。</p>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深复制和浅复制]]></title>
      <url>/2017/10/18/%E6%B7%B1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B5%85%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>浅复制：被复制对象的所有变量都含有与原来对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>深复制：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shallow_copy</span><span class="params">(Test &amp; src,Test &amp; dest)</span></span>&#123;</span><br><span class="line">	dest.ptr = src.ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deep_copy</span><span class="params">(Test &amp; src,Test &amp; dest)</span></span>&#123;</span><br><span class="line">	dest.ptr=<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src.ptr)+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(dest.ptr,src.ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浅复制可能会导致运行时错误，特别是在对象的创建和删除过程中。</p>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存泄露和缓冲区溢出]]></title>
      <url>/2017/10/18/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
      <content type="html"><![CDATA[<p>什么是内存泄露？</p>
<ul>
<li>一般我们常说的内存泄露是指堆内存的泄露。堆内存是指程序从堆中分配的，大小任意的内存块，使用完后必须显示释放的内存。应用程序一般使用malloc、realloc、new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能再被使用，我们就说这块内存泄露了。</li>
</ul>
<hr>
<p>什么是缓冲区溢出？</p>
<ul>
<li>缓冲区溢出是指向缓冲区内填充数据位数超过了缓冲区本身的容量限制，导致溢出的数据覆盖在合法数据上的情况。理想的情况是程序检查数据长度并不允许输出超出缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的存储空间相匹配，这九尾缓冲区溢出埋下了隐患。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC工作流程]]></title>
      <url>/2017/10/18/kuangjia/SpringMVC/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Spring_Running_1.png" alt=""></p>
<a id="more"></a>
<p><img src="http://ocx5m3vc3.bkt.clouddn.com/Spring_Running_2.png" alt=""></p>
<hr>
<p>SpringMVC工作流程描述：<br>1.用户向服务器发送请求，请求被Spring前端控制Servlet DispatcherServlet捕获；</p>
<p>2.DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象相应的拦截器），最后以HandlerExecutionChain对象的形式返回。</p>
<p>3.DispatcherServlet根据获得Handler，选择一个合适HandlerAdapter。（如果成功获取HandlerAdapter后，此时将开始执行拦截器的PreHandler方法）</p>
<p>4.提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller）。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConveter：将请求消息（如Json、Xml等数据）转化成一个对象，将对象转换成指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>
<li>数据格式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证：验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ul>
<p>5.Handler执行完成后，先DispatcherServlet返回一个ModelAndView对象</p>
<p>6.根据返回的ModelAndView，选择一个合适的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet</p>
<p>7.ViewResolver结合Model和View来渲染视图</p>
<p>8.将渲染结果返回给客户端</p>
<hr>
<p>Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler？</p>
<p>答：符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的是代码可复用性高。如HandlerAdapter可能会被用于处理多种Handler。</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java的四种线程池]]></title>
      <url>/2017/10/17/%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>Java通过Executors提供了四种线程池：</p>
<ul>
<li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(index * <span class="number">1000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程.</p>
<ul>
<li>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超过的线程会在队列中等待。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;  </span><br><span class="line">   fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">try</span> &#123;  </span><br><span class="line">      System.out.println(index);  </span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">      e.printStackTrace();  </span><br><span class="line">     &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   &#125;);  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以没两秒打印3个数字。</p>
<ul>
<li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);  </span><br><span class="line">  scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"delay 3 seconds"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;, <span class="number">3</span>, TimeUnit.SECONDS);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>表示延迟3秒执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);  </span><br><span class="line">  scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表示延迟1秒后每3秒执行一次。</p>
<ul>
<li>newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照指定顺序（FIFO，LIFO,优先级）执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> index = i;  </span><br><span class="line">   singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">try</span> &#123;  </span><br><span class="line">      System.out.println(index);  </span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">      e.printStackTrace();  </span><br><span class="line">     &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   &#125;);  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>顺序执行每个任务。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1269 B君的圆锥]]></title>
      <url>/2016/05/27/ACM/51nod1269%20B%E5%90%9B%E7%9A%84%E5%9C%86%E9%94%A5/</url>
      <content type="html"><![CDATA[<p>1629 B君的圆锥<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题<br> 收藏<br> 关注<br>B君要用一个表面积为S的圆锥将白山云包起来。</p>
<p>B君希望包住的白山云体积尽量大，B君想知道体积最大可以是多少。</p>
<p>注意圆锥的表面积包括底面和侧面。<br>Input<br>一行一个整数，表示表面积S。(1 &lt;= S &lt;= 10^9)<br>Output<br>一行一个实数，表示体积。<br>Input示例<br>8<br>Output示例<br>1.504506<br>wwwwodddd (题目提供者)<br>拿到这道题的第一想法就是写出面积体积关系，然后再找关系。<br>大神们说这道题的标准做法是用三分法~可以作为渣渣的我并不会—-以后学了再来补上。<br>不过群巨给了另一种数学建模的思想：<br>  　　 要达成面积/体积最佳比，则模型样式是一致的。可以按比例缩放的。以放大2倍为例：<br>　　   R=r<em>2<br>　　　S=S底+S侧=2^2</em>s底+2^2<em>s底=2^2s<br>　　　V=1/3</em>S底<em>H=1/3</em>2^2s底<em>2</em>h=2^3v<br>~简直奇妙~~又让渣渣我学到一招~<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(n*n*n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s))&#123;</span><br><span class="line">        <span class="keyword">double</span> v;</span><br><span class="line">        v = (<span class="keyword">double</span>)<span class="number">1.504506</span>*<span class="built_in">pow</span>(s/<span class="number">8.0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod 1021 石头归并]]></title>
      <url>/2016/05/16/ACM/51nod%201021%20%E7%9F%B3%E5%A4%B4%E5%BD%92%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p>1021 石子归并<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 20 难度：3级算法题<br> 收藏<br> 关注<br>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。</p>
<p>例如： 1 2 3 4，有不少合并方法<br>1 2 3 4 =&gt; 3 3 4(3) =&gt; 6 4(9) =&gt; 10(19)<br>1 2 3 4 =&gt; 1 5 4(5) =&gt; 1 9(14) =&gt; 10(24)<br>1 2 3 4 =&gt; 1 2 7(7) =&gt; 3 7(10) =&gt; 10(20)</p>
<p>括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。</p>
<p>Input<br>第1行：N（2 &lt;= N &lt;= 100)<br>第2 - N + 1：N堆石子的数量（1 &lt;= A[i] &lt;= 10000)<br>Output<br>输出最小合并代价<br>Input示例<br>4<br>1<br>2<br>3<br>4<br>Output示例<br>19<br>这道题初一看很容易往贪心方向想，后来看了提示才知道是dp，可是并不知道怎么dp。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">int</span> i,len,temp;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;vis[i]);</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(len=<span class="number">1</span>;len&lt;n;len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i+len&lt;=n;i++)&#123;</span><br><span class="line">                dp[i][i + len] = INF;</span><br><span class="line">                temp=sum[i+len]-sum[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;i+len;k++)</span><br><span class="line">                    dp[i][i+len]=min(dp[i][i+len],dp[i][k]+dp[k+<span class="number">1</span>][i+len]+temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1417 天堂里的游戏]]></title>
      <url>/2016/05/09/ACM/51nod1417%20%E5%A4%A9%E5%A0%82%E9%87%8C%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<p>1417 天堂里的游戏<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 10 难度：2级算法题<br> 收藏<br> 关注<br>多年后，每当Noder看到吉普赛人，就会想起那个遥远的下午。</p>
<p>Noder躺在草地上漫无目的的张望，二楼的咖啡馆在日光下闪着亮，像是要进化成一颗巨大的咖啡豆。天气稍有些冷，但草还算暖和。不远的地方坐着一个吉普赛姑娘，手里拿着塔罗牌，带着耳机，边上是她的狗。狗看起来有点凶，姑娘却漂亮。Noder开始计算各种搭讪方式的成功概率，然而狗的存在……。</p>
<p>奇怪的事情发生了，姑娘自己走了过来，把耳机戴在Noder的耳朵上，里面播放着：“……Knock-knock-knockin’ on heaven’s door ……”。姑娘冲他诡异的一笑，Noder只觉得自己眼前一阵眩晕，然后就站在了天堂的门口。</p>
<p>正当Noder惊魂未定的时候，走来一个美女，要求和他一起玩个数学游戏。美女提议：“让我们各自亮出硬币的一面，或正或反。如果我们都是正面，那么我给你A元，如果我们都是反面，我给你B元（A + B为偶数）。剩下的情况你给我（A + B） / 2元就可以了。</p>
<p>Noder知道这个游戏他多半要输，可他并不在乎，他只想让自己输的慢一点。</p>
<p>那么你来帮美女计算一下，她选择出正面的概率应该是多少（以最简分数形式输出）？</p>
<p>当Noder输光了钱后从草地上醒来，吉普赛姑娘已经不见了，只留下了这样一张塔罗牌，上面印有那个美女的照片。<br><img src="http://img.51nod.com/upload/000FBECA/08D271A9F742E9BE0000000000000008.jpeg?_=5474275" alt=""></p>
<p>关于样例的解释：</p>
<p>美女采取了(3/8,5/8)这个方案，不论Noder采用什么方案，都是不能改变局面的。如果全部出正面，每次的期望收益是 (3+3+3-2-2-2-2-2)/8=-1/8元；如果全部出反面，每次的期望收益也是(-2-2-2+1+1+1+1+1)/8=-1/8元。而任何策略无非只是上面两种策略的线性组合，所以期望还是-1/8元。</p>
<p>Input<br>第1行：一个数T，表示后面用作输入测试的数的数量（1 &lt;= T &lt;= 20)。<br>第2 - T + 1行：每行2个数A, B中间用空格分隔。(1 &lt;= A, B &lt;= 10^9，且A + B为偶数)。<br>Output<br>输出共T行，对应美女选择正面的概率，以最简分数形式输出，具体请参看输出样例。<br>Input示例<br>2<br>3 1<br>1 3<br>Output示例<br>3/8<br>5/8<br>PS: 给的提示标签是博弈论，结果是个数学问题；<br> 不管是正是反，女的赢的几率都是一样的，所以左边的式子设正面为x，右边的式子设反面为x，写出期望，然后两边相等，就可以列方程了，然后最大公约数用辗转相乘法弄一下就出来了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span> ? a : gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t))&#123;</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            LL a,b;</span><br><span class="line">            LL x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%I64d%I64d"</span>,&amp;a,&amp;b);</span><br><span class="line">            x=a+<span class="number">3</span>*b;</span><br><span class="line">            y=<span class="number">4</span>*(a+b);</span><br><span class="line">            LL t=gcd(x,y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%I64d/%I64d\n"</span>,x/t,y/t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1265四点共面]]></title>
      <url>/2016/04/11/ACM/51nod1265%E5%9B%9B%E7%82%B9%E5%85%B1%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>1265 四点共面<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题<br>给出三维空间上的四个点（点与点的位置均不相同），判断这4个点是否在同一个平面内（4点共线也算共面）。如果共面，输出”Yes”，否则输出”No”。<br>Input<br>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)<br>第2 - 4T + 1行：每行4行表示一组数据，每行3个数，x, y, z, 表示该点的位置坐标(-1000 &lt;= x, y, z &lt;= 1000)。<br>Output<br>输出共T行，如果共面输出”Yes”，否则输出”No”。<br>Input示例<br>1<br>1 2 0<br>2 3 0<br>4 0 0<br>0 0 0<br>Output示例<br>Yes<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*利用四点组成构成的三个向量的混合积为0来判断是否共面*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    point a,b,c,d;</span><br><span class="line">    <span class="keyword">double</span> r1,r2,r3,r4,r5,r6,r7,r8,r9;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;a.x,&amp;a.y,&amp;a.z);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;b.x,&amp;b.y,&amp;b.z);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;c.x,&amp;c.y,&amp;c.z);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>,&amp;d.x,&amp;d.y,&amp;d.z);</span><br><span class="line">        r1=a.x-b.x; r2=a.y-b.y; r3=a.z-b.z;</span><br><span class="line">        r4=a.x-c.x; r5=a.y-c.y; r6=a.z-c.z;</span><br><span class="line">        r7=a.x-d.x; r8=a.y-d.y; r9=a.z-d.z;</span><br><span class="line">        <span class="keyword">double</span> n=r1*r5*r9+r2*r6*r7+r3*r4*r8-r3*r5*r7-r2*r4*r9-r1*r6*r8;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1240莫比乌斯函数]]></title>
      <url>/2016/04/10/ACM/51nod1240%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>莫比乌斯函数，由德国数学家和天文学家莫比乌斯提出。梅滕斯(Mertens)首先使用μ(n)（miu(n)）作为莫比乌斯函数的记号。（据说，高斯(Gauss)比莫比乌斯早三十年就曾考虑过这个函数）。</p>
<p>具体定义如下：<br>如果一个数包含平方因子，那么miu(n) = 0。例如：miu(4), miu(12), miu(18) = 0。<br>如果一个数不包含平方因子，并且有k个不同的质因子，那么miu(n) = (-1)^k。例如：miu(2), miu(3), miu(30) = -1,miu(1), miu(6), miu(10) = 1。<br>给出一个数n, 计算miu(n)。<br>Input<br>输入包括一个数n，(2 &lt;= n &lt;= 10^9)<br>Output<br>输出miu(n)。<br>Input示例<br>5<br>Output示例<br>-1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">miu</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,cnt;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                n=n/i;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (num%<span class="number">2</span>==<span class="number">0</span>)?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,miu(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1212无向图最小生成树]]></title>
      <url>/2016/04/10/ACM/51nod1212%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>1212 无向图最小生成树<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题<br> 收藏<br> 关注<br>N个点M条边的无向连通图，每条边有一个权值，求该图的最小生成树。</p>
<p>Input<br>第1行：2个数N,M中间用空格分隔，N为点的数量，M为边的数量。（2 &lt;= N &lt;= 1000, 1 &lt;= M &lt;= 50000)<br>第2 - M + 1行：每行3个数S E W，分别表示M条边的2个顶点及权值。(1 &lt;= S, E &lt;= N，1 &lt;= W &lt;= 10000)<br>Output<br>输出最小生成树的所有边的权值之和。<br>Input示例<br>9 14<br>1 2 4<br>2 3 8<br>3 4 7<br>4 5 9<br>5 6 10<br>6 7 2<br>7 8 1<br>8 9 7<br>2 8 11<br>3 9 2<br>7 9 6<br>3 6 4<br>4 6 14<br>1 8 8<br>Output示例<br>37<br>prim算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> G[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1001</span>],lowc[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> G[][<span class="number">1001</span>],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,p,minc,res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));<span class="comment">//全部初值为0表示没有访问过；</span></span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        lowc[i]=G[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        minc=inf;</span><br><span class="line">        p=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;lowc[j]&lt;minc)</span><br><span class="line">                &#123;minc=lowc[j];p=j;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inf==minc) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//原图不连通</span></span><br><span class="line">        res+=minc;</span><br><span class="line">        vis[p]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//更新lowc[]</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;lowc[j]&gt;G[p][j])</span><br><span class="line">                lowc[j]=G[p][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(G,inf,<span class="keyword">sizeof</span>(G));</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">            G[x][y]=G[y][x]=w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,prim(G,n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> kruskal算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _min_(a,b) ((a)&lt;(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_E 50005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">edge es[MAX_E];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> W[MAX_N][MAX_N];</span><br><span class="line"><span class="keyword">int</span> mincost[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> used[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge e1, edge e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union-find set</span></span><br><span class="line"><span class="keyword">int</span> par[MAX_N];</span><br><span class="line"><span class="keyword">int</span> rank[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_inion_find</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        par[i]=i;</span><br><span class="line">        rank[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x]==x)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> par[x]=find(par[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     x=find(x);</span><br><span class="line">     y=find(y);</span><br><span class="line">     <span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(rank[x]&lt;rank[y])&#123;</span><br><span class="line">         par[x]=y;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          par[y]=x;</span><br><span class="line">          <span class="keyword">if</span>(rank[x]==rank[y])&#123;</span><br><span class="line">              rank[x]++;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> find(x)==find(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// end of union-find set</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;MAX_N;j++)&#123;</span><br><span class="line">            W[i][j]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">        mincost[i]=INF;</span><br><span class="line">        used[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        edge e=es[i];</span><br><span class="line">        <span class="keyword">if</span>(!same(e.u, e.v))&#123;</span><br><span class="line">            unite(e.u, e.v);</span><br><span class="line">            res += e.cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("18_kruskal.txt","r",stdin);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,cost;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;cost);</span><br><span class="line">        es[i].u = u<span class="number">-1</span>;</span><br><span class="line">        es[i].v = v<span class="number">-1</span>;</span><br><span class="line">        es[i].cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(es,es+M,cmp);</span><br><span class="line"></span><br><span class="line">    init_inion_find(N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1256乘法逆元]]></title>
      <url>/2016/04/10/ACM/51nod1256%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
      <content type="html"><![CDATA[<p>1256 乘法逆元</p>
<p>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 收藏 关注<br>给出2个数M和N(M &lt; N)，且M与N互质，找出一个数K满足0 &lt; K &lt; N且K <em> M % N = 1，如果有多个满足条件的，输出最小的。<br>Input<br>输入2个数M, N中间用空格分隔（1 &lt;= M &lt; N &lt;= 10^9)<br>OutPut<br>输出一个数K，满足0 &lt; K &lt; N且K </em> M % N = 1，如果有多个满足条件的，输出最小的。<br>Input示例<br>2 3<br>Output示例</p>
<p>2</p>
<p>思路：K <em> M % N = 1等价于 K</em>M=N<em>X+1  即 K</em>M+N*(-X)=1 </p>
<p>根据扩展欧几里德算法，求出K和（-X）；</p>
<p>而K是应为正整数，即需要若K为负整数，则需要将之化正，即与负数取模同理，将K加上N，直至K&gt;0为止，所得的数即为最小的乘法逆元；</p>
<p>若K为正整数，则直接输出即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r=exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> t=x;x=y;y=t-(a/b)*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,x,y;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n))&#123;</span><br><span class="line">        exgcd(m,n,x,y);</span><br><span class="line">        <span class="keyword">while</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            x+=n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1264线段相交]]></title>
      <url>/2016/04/10/ACM/51nod1264%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4/</url>
      <content type="html"><![CDATA[<p>1264 线段相交<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题<br>给出平面上两条线段的两个端点，判断这两条线段是否相交（有一个公共点或有部分重合认为相交）。 如果相交，输出”Yes”，否则输出”No”。<br>Input<br>第1行：一个数T，表示输入的测试数量(1 &lt;= T &lt;= 1000)<br>第2 - T + 1行：每行8个数，x1,y1,x2,y2,x3,y3,x4,y4。(-10^8 &lt;= xi, yi &lt;= 10^8)<br>(直线1的两个端点为x1,y1 | x2, y2,直线2的两个端点为x3,y3 | x4, y4)<br>Output<br>输出共T行，如果相交输出”Yes”，否则输出”No”。<br>Input示例<br>2<br>1 2 2 1 0 0 2 2<br>-1 1 1 1 0 0 1 -1<br>Output示例<br>Yes<br>No<br>做这到题首先要了解叉乘的概念~~<a href="http://blog.csdn.net/hustspy1990/article/details/11082745" target="_blank" rel="noopener">http://blog.csdn.net/hustspy1990/article/details/11082745</a><br>然后还要知道两条线段相交的必要条件 <a href="http://dev.gameres.com/Program/Abstract/Geometry.htm#%E5%88%A4%E6%96%AD%E4%B8%A4%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4" target="_blank" rel="noopener">http://dev.gameres.com/Program/Abstract/Geometry.htm#%E5%88%A4%E6%96%AD%E4%B8%A4%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  (a-c)×(d-c)*(d-c)×(b-c)&gt;=0&amp;&amp;(c-a)×(b-a)*(b-a)×(d-a)&gt;= 0就可以判断ab,cd相交*/</span></span><br><span class="line"><span class="comment">/*  p1×p2 = x1y2 - x2y1 = - p2×p1-----（叉乘公式）*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//struct point a,b,c,d;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mp</span><span class="params">(point a,point b,point c,point d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> C=(a.x-c.x)*(d.y-c.y)-(d.x-c.x)*(a.y-c.y);</span><br><span class="line">    <span class="keyword">double</span> D=(d.x-c.x)*(b.y-c.y)-(b.x-c.x)*(d.y-c.y);</span><br><span class="line">    <span class="keyword">if</span>(C*D&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(point a , point b , point c , point d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mp(a,b,c,d)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!mp(c,d,a,b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        point a,b,c,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf%lf%lf%lf%lf"</span>,&amp;a.x,&amp;a.y,&amp;b.x,&amp;b.y,&amp;c.x,&amp;c.y,&amp;d.x,&amp;d.y);</span><br><span class="line">        <span class="keyword">if</span>(check(a,b,c,d))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1242 斐波那契数列 矩阵快速幂]]></title>
      <url>/2016/04/08/ACM/51nod1242%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%20%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      <content type="html"><![CDATA[<p>斐波那契数列的定义如下：</p>
<p>F(0) = 0<br>F(1) = 1<br>F(n) = F(n - 1) + F(n - 2) (n &gt;= 2)</p>
<p>(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, …)<br>给出n，求F(n)，由于结果很大，输出F(n) % 1000000009的结果即可。</p>
<p>Input<br>输入1个数n(1 &lt;= n &lt;= 10^18)。<br>Output<br>输出F(n) % 1000000009的结果。<br>Input示例<br>11<br>Output示例<br>89</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000009</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125; t;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function">node <span class="title">mul</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//矩阵乘法</span></span><br><span class="line">    node c;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">            c.c[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">                c.c[i][j]+=(a.c[i][k]*b.c[k][j])%mod;</span><br><span class="line">        c.c[i][j]=c.c[i][j]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">kuaisumi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   node res = t;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            res=mul(res,t);</span><br><span class="line">        t=mul(t,t);</span><br><span class="line">        n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n))&#123;</span><br><span class="line">        t.c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        t.c[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        t.c[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        t.c[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        node res=kuaisumi(n<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res.c[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1174区间中最大的数]]></title>
      <url>/2016/04/05/ACM/51nod1174%E5%8C%BA%E9%97%B4%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>1174 区间中最大的数<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题 收藏 关注<br>给出一个有N个数的序列，编号0 - N - 1。进行Q次查询，查询编号i至j的所有数中，最大的数是多少。<br>例如: 1 7 6 3 1。i = 1, j = 3，对应的数为7 6 3，最大的数为7。（该问题也被称为RMQ问题）<br>Input<br>第1行：1个数N，表示序列的长度。(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：每行1个数，对应序列中的元素。(0 &lt;= S[i] &lt;= 10^9)<br>第N + 2行：1个数Q，表示查询的数量。(2 &lt;= Q &lt;= 10000)<br>第N + 3 - N + Q + 2行：每行2个数，对应查询的起始编号i和结束编号j。(0 &lt;= i &lt;= j &lt;= N - 1)<br>Output<br>共Q行，对应每一个查询区间的最大值。<br>Input示例<br>5<br>1<br>7<br>6<br>3<br>1<br>3<br>0 1<br>1 3<br>3 4<br>Output示例<br>7<br>7<br>3</p>
<p>自己写的O（n）的也能水过，特地去看了一下RMQ算法~</p>
<p>然后就变成O（logn)了</p>
<p>参考博客<a href="http://blog.csdn.net/liang5630/article/details/7917702" target="_blank" rel="noopener">http://blog.csdn.net/liang5630/article/details/7917702</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10010</span>][<span class="number">30</span>],num[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>]=num[i];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)&lt;n;i++)</span><br><span class="line">        dp[i][j]=max(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>))&lt;=R-L+<span class="number">1</span>) ++k;</span><br><span class="line">    <span class="keyword">return</span> max(dp[L][k],dp[R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">        RMQ_init(n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> L,R;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;L,&amp;R);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,RMQ(L+<span class="number">1</span>,R+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1134 最长递增子序列]]></title>
      <url>/2016/03/31/ACM/51nod1134%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的）<br>例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。</p>
<p>Input<br>第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9)<br>Output<br>输出最长递增子序列的长度。<br>Input示例<br>8<br>5<br>1<br>6<br>8<br>2<br>4<br>5<br>10<br>Output示例<br>5<br>刚开始我想到的也是动态规划，然后自己写。提交发现超时了=.=<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("C://Users//Administrator//Desktop//duipai2//1.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,i,j,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">50005</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> str[<span class="number">50005</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">50005</span>;i++)</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">   <span class="comment">// memset(dp,1,sizeof(dp));</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;str[i]);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j]&lt;str[i]&amp;&amp;dp[j]&gt;=dp[i])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// for(i=1;i&lt;=n;i++)</span></span><br><span class="line">   <span class="comment">//     printf("%d  ",dp[i]);</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         ans=max(ans,dp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后参考了网上大神的代码也是动态规划=.=但是优化了，所以AC了~~<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"algorithm"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];<span class="comment">//dp[i]表示递增数量i的最小值</span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,len=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    dp[len]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;dp[len])</span><br><span class="line">          dp[++len]=a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos=lower_bound(dp+<span class="number">1</span>,dp+len,a[i])-dp;</span><br><span class="line">            <span class="comment">//在dp[]找第一个&gt;=a[i]下标</span></span><br><span class="line">            dp[pos]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//   for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">      <span class="comment">//printf("%d  ",dp[i]);</span></span><br><span class="line">    <span class="comment">//printf("\n");</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1079中国剩余定理]]></title>
      <url>/2016/03/31/ACM/51nod1089%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2V2/</url>
      <content type="html"><![CDATA[<p>1089 最长回文子串 V2（Manacher算法）<br>基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题<br>回文串是指aba、abba、cccbccc、aaaa这种左右对称的字符串。<br>输入一个字符串Str，输出Str里最长回文子串的长度。</p>
<p>Input<br>输入Str（Str的长度 &lt;= 100000)<br>Output<br>输出最长回文子串的长度L。<br>Input示例<br>daabaac<br>Output示例<br>5</p>
<p>看到这道题才特意去看了下Manacher算法；<br>参考博客：<a href="http://blog.csdn.net/pi9nc/article/details/9251455" target="_blank" rel="noopener">http://blog.csdn.net/pi9nc/article/details/9251455</a><br>　　　　　<a href="http://blog.sina.com.cn/s/blog_70811e1a01014esn.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_70811e1a01014esn.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">200003</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200003</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pk</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;i)</span><br><span class="line">            p[i]=min(p[<span class="number">2</span>*id-i],mx-i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i+p[i]+<span class="number">1</span>]==str[i-p[i]<span class="number">-1</span>])</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(p[i]+i&gt;mx)&#123;</span><br><span class="line">            id=i;</span><br><span class="line">            mx=p[i]+id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len,ans=<span class="number">0</span>,i,l=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    str[<span class="number">0</span>]=<span class="string">'$'</span>;</span><br><span class="line">    str[<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        str[l++]=s[i];</span><br><span class="line">        str[l++]=<span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//str[len]='\n';</span></span><br><span class="line">    pk(l);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">        ans=max(ans,p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1057N的阶乘]]></title>
      <url>/2016/03/28/ACM/51nod1057N%E7%9A%84%E9%98%B6%E4%B9%98/</url>
      <content type="html"><![CDATA[<p>输入N求N的阶乘的准确值。</p>
<p>Input<br>输入N(1 &lt;= N &lt;= 10000)<br>Output<br>输出N的阶乘<br>Input示例<br>5<br>Output示例<br>120<br>参考博客：blog.csdn.net/qq_33850438/article/details/50631619<br>大数乘法问题~<br>大神代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">9999</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,n,i,c,len,j;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);  </span><br><span class="line">    <span class="keyword">for</span> ( len=<span class="number">1</span>,j=<span class="number">2</span>;j&lt;=n; ++j)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span> (c=<span class="number">0</span>,i=<span class="number">0</span>; i&lt;len;++i)   </span><br><span class="line">        &#123;   </span><br><span class="line">            a[i]= ( c+= a[i]*j ) % <span class="number">100000</span>; c/=<span class="number">100000</span>;   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>((a[i]=c)&gt;<span class="number">0</span>)++len;  </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[--len]);  </span><br><span class="line">    <span class="keyword">for</span>(;len;)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>, a[--len]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1085-----01背包]]></title>
      <url>/2016/03/27/ACM/51nod1085-----01%E8%83%8C%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">101</span>],p[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,W,i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;W);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;w[i],&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=W;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;w[i])</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][W]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 背包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1046快速幂取余]]></title>
      <url>/2016/03/26/ACM/51nod1046%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E4%BD%99/</url>
      <content type="html"><![CDATA[<p>给出3个正整数A B C，求A^B Mod C。</p>
<p>例如，3 5 8，3^5 Mod 8 = 3。<br>Input<br>3个正整数A B C，中间用空格分隔。(1 &lt;= A,B,C &lt;= 10^9)<br>Output<br>输出计算结果<br>Input示例<br>3 5 8<br>Output示例<br>3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">quickmod</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans=(ans*a)%m;<span class="comment">//这里a是a^(2^i)%m</span></span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">        a=a*a%m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,m;</span><br><span class="line">    <span class="keyword">while</span>(scanf(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;m)!=EOF)&#123;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span>   ans=quickmod(a,b,m);</span><br><span class="line">        printf(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----任务分配问题]]></title>
      <url>/2016/03/21/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>任务执行顺序</p>
<p>有N个任务需要执行，第i个任务计算时占R[i]个空间，而后会释放一部分，最后储存计算结果需要占据O[i]个空间（O[i] &lt; R[i]）。</p>
<p>分析：可以抽象成，从一个整数开始，每次减去a，再加上b (a,b都是正数)，要求每次操作都不产生负数。令a[i] = R[i], b[i] = R[i] – O[i]，O[i] &lt; R[i],有0&lt;b[i]&lt;a[i]。 所以尽管每次有减有加，但是加的没有减的多，总数在不断减小。所以——按照b[i]递增的顺序排序，是最“有利”的。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> r,o;</span><br><span class="line">&#125;p[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(point x,point y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.o&gt;y.o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//p1099t11in.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> i,N,sum,ans;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N))&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].r,&amp;p[i].o);</span><br><span class="line">            p[i].o=p[i].r-p[i].o;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(p,p+N,cmp);</span><br><span class="line">        sum=p[<span class="number">0</span>].r;</span><br><span class="line">        ans=p[<span class="number">0</span>].r;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans&lt;p[i].r)&#123;</span><br><span class="line">                sum=sum+p[i].r-ans;</span><br><span class="line">                ans=p[i].r;</span><br><span class="line">            &#125;</span><br><span class="line">                ans=ans-p[i].r+p[i].o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod动态规划-----矩阵取数]]></title>
      <url>/2016/03/21/ACM/51nod%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>一个N<em>N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。<br>例如：3 </em> 3的方格。</p>
<p>1 3 3</p>
<p>2 1 3</p>
<p>2 2 1</p>
<p>能够获得的最大价值为：11。</p>
<a id="more"></a>
<p>Input</p>
<p>第1行：N，N为矩阵的大小。(2 &lt;= N &lt;= 500)</p>
<p>第2 - N + 1行：每行N个数，中间用空格隔开，对应格子中奖励的价值。（1 &lt;= N[i] &lt;= 10000)</p>
<p>OutPut</p>
<p>输出能够获得的最大价值。</p>
<p>Input示例</p>
<p>3</p>
<p>1 3 3</p>
<p>2 1 3</p>
<p>2 2 1</p>
<p>Output示例</p>
<p>11</p>
<p>状态转移方程：f(i,j) = max{f(i+1,j),f(i,j+1)|i&lt;N,j&lt;N}+A[i][j];</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//1.txt","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> N,i,j;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N))&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">505</span>][<span class="number">505</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//不知道为什么这个不能跟前面的map一起定义。。。</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">                dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="built_in">map</span>[i][j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[N<span class="number">-1</span>][N<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----独木舟问题]]></title>
      <url>/2016/03/20/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E7%8B%AC%E6%9C%A8%E8%88%9F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>独木舟问题</p>
<p>n个人，已知每个人体重，独木舟承重固定，每只独木舟最多坐两个人，可以坐一个人或者两个人。显然要求总重量不超过独木舟承重，假设每个人体重也不超过独木舟承重，问最少需要几只独木舟？</p>
<p>分析：按照人的体重排序，最轻的人跟最重的人尽量安排在一条船上，如果超过就安排最重的.<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        j=n<span class="number">-1</span>;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]+a[j]&lt;=m)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==j)</span><br><span class="line">            ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod1079中国剩余定理]]></title>
      <url>/2016/03/20/ACM/51nod1079/</url>
      <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *中国剩余定理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LL __int64</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *gcd(a,b)=d;则存在x,y,使d=ax+by</span></span><br><span class="line"><span class="comment"> *extended_euclid(a,b)=ax+by</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LL <span class="title">extended_euclid</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span></span>&#123;<span class="comment">//扩张欧几里的算法</span></span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>; y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    d=extended_euclid(b,a%b,y,x);</span><br><span class="line">    y=y-a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *x=b[i](modw[i]) o&lt;i&lt;len</span></span><br><span class="line"><span class="comment"> *w[i]&gt;0,且w[]中任意两个数互质</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LL <span class="title">chinese_remainder</span><span class="params">(<span class="keyword">int</span> b[],<span class="keyword">int</span> w[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    LL res,i,d,x,y,n,m;</span><br><span class="line">    res=<span class="number">0</span>; n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++) n*=w[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        m=n/w[i];</span><br><span class="line">        extended_euclid(w[i],m,x,y);</span><br><span class="line">        res=(res+y*m*b[i])%n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n+res%n)%n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len,b[<span class="number">12</span>],w[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;len)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;chinese_remainder(b,w,len)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----活动安排问题2]]></title>
      <url>/2016/03/17/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%982/</url>
      <content type="html"><![CDATA[<p>题目大意就是给几个活动，问要几个教室能够弄完。</p>
<p>这个题目的想法就是把活动的开始——结束的时间看做是数轴上的一段线段，教室的个数就是在某点的时间厚度，求最大的时间厚度就是所需要的教室个数。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> start;</span><br><span class="line">   <span class="keyword">int</span> end;</span><br><span class="line">&#125;s[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span><span class="comment">//结构体的一级排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(node*)a).start&gt;(*(node*)b).start?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//data.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("C://Users//Administrator//Desktop//duipai2//out1.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,i,rooms=<span class="number">0</span>;</span><br><span class="line">     priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; myqueue;<span class="comment">//优先队列类型</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s[i].start,&amp;s[i].end);</span><br><span class="line">    qsort(s,n,<span class="keyword">sizeof</span>(node),cmp);</span><br><span class="line">    myqueue.push(s[<span class="number">0</span>].end);</span><br><span class="line">    rooms=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i].start&lt;myqueue.top())&#123;</span><br><span class="line">            rooms++;</span><br><span class="line">            myqueue.push(s[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            myqueue.pop();</span><br><span class="line">            myqueue.push(s[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,rooms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----活动安排问题]]></title>
      <url>/2016/03/05/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>有若干个活动，第i个开始时间和结束时间是[Si,fi)，只有一个教室，活动之间不能交叠，求最多安排多少个活动？</p>
<p>输入</p>
<p>第1行：1个数N，线段的数量(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：每行2个数，线段的起点和终点(-10^9 &lt;= S,E &lt;= 10^9)<br>输出</p>
<a id="more"></a>
<p>输出最多可以选择的线段数量。</p>
<p>输入示例</p>
<p>3<br>1 5<br>2 3<br>3 6</p>
<p>输出示例</p>
<p>2</p>
<p>我们可以知道先安排最早结束的活动可以更多的安排活动。首先就是将所有的活动结束时间按先后顺序给排序；然后以结束时间为线索一路检索下去，判断开始时间是否早于前面一次活动的结束时间。这里可以用结构体或者两个数组来把一个活动的开始时间和结束时间联系起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define max 10001</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,j,temps,tempo;</span><br><span class="line">    <span class="keyword">int</span> start[max],over[max];</span><br><span class="line">    <span class="keyword">while</span>(scanf(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>,t=-<span class="number">1000000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;start[i]&gt;&gt;over[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">       <span class="keyword">for</span>(j=i;j&lt;n;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(over[i]&gt;over[j])&#123;</span><br><span class="line">              tempo=over[i];</span><br><span class="line">              over[i]=over[j];</span><br><span class="line">              over[j]=tempo;</span><br><span class="line">              temps=start[i];</span><br><span class="line">              start[i]=start[j];</span><br><span class="line">              start[j]=temps;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;=start[i])&#123;</span><br><span class="line">            t=over[i];</span><br><span class="line">            sum+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//原本我还考虑了活动时间不能为负数的情况，但是在提交时系统给出的数据中把负数也给算了进去。。。。。</p>
]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51nod贪心算法入门-----完美字符串]]></title>
      <url>/2016/03/04/ACM/51nod%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-%E5%AE%8C%E7%BE%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>约翰认为字符串的完美度等于它里面所有字母的完美度之和。每个字母的完美度可以由你来分配，不同字母的完美度不同，分别对应一个1-26之间的整数。</p>
<p>约翰不在乎字母大小写。（也就是说字母F和f）的完美度相同。给定一个字符串，输出它的最大可能的完美度。例如：dad，你可以将26分配给d，25分配给a，这样整个字符串完美度为77。</p>
<p>//这题水题，只要把每个字母出现的次数统计出来然后再排序一下就OK了。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)&#123;</span><br><span class="line">	<span class="keyword">int</span> sum[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;,len,i,j,a,maxsum=<span class="number">0</span>;</span><br><span class="line">	len=s.size();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">	    a=s[i]-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">	    a&lt;=<span class="number">26</span>?sum[a]++:sum[a<span class="number">-32</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(sum,sum+<span class="number">27</span>);</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">26</span>;j++)&#123;</span><br><span class="line">	    maxsum+=j*sum[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxsum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> acm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 51nod </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[今日感想]]></title>
      <url>/1999/07/18/%E4%BB%8A%E6%97%A5%E6%84%9F%E6%83%B3/</url>
      <content type="html"><![CDATA[<p>在上个月最后一个周五，也就是7月26号跟我们领导提出了离职申请；至于为什么，许多方面的原因吧！<br>首先就是感觉在做DBA的这一年中，虽然学到了很多，也提升了很多。但是一回想起来，发现自己什么拿得出手的都没有。直白点就是浑浑噩噩的在过日志，整天很忙，又不知道自己在忙些什么。<br>重构一套运维平台？除了我跟潼姐谁还用~<br>下架了100台机器？说白了就是公司没钱了~<br>保证线上服务正常运行？出事了才想到你，还得你背锅~<br>从Oracle迁移到MySQL？出力的是我们，拿功劳的是RD，出事了还得背锅~<br>抱怨还是要有的，工作还是得照常做。。。</p>
<p>毕竟刚升级完Codis，事情还挺多的；另一方面，自己还没有Offer。所以就答应了领导在8月底再走的要求。<br>跟领导提了离职的第24天，这段时间投过许多开发岗，也做了很多准备，但是收到面试通知的并没有多少。这与自己现在是DBA以及还未离职也有一定的原因。心中也有少许焦虑和犹豫，自己离职到底对不对？在互联网寒冬选择转岗又对不对？自己总是安慰自己说：干的不爽就走呗。但心里还是知道这是给自己一个借口，为了不让自己后悔。</p>
<p>直到今天看到了一篇文章，发现跟自己非常符合。同时，也跟坚定了自己的选择。<br><a href="https://mp.weixin.qq.com/s/Wuv4tD1v78fsDufoilxT1Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Wuv4tD1v78fsDufoilxT1Q</a><br>这篇文章说的是低效人士的七个习惯，我觉得现在的我就是这样的状态；必须改变现状，所以这个选择也说不上错。</p>
<p>来北京整整一年的我，自从来了北京后，再也没有早于晚上12前睡觉。认为不努力就会被这个社会所淘汰(也的确如此)，只是自己努力的方式不对，付出和回报不成比例~<br>每天在9点后下班，一开始是觉得什么都不懂，需要花额外的时间去学习。那段时间也的确颇有收获；但是，当部门被拆分出来成为子公司后，自己的时间便不是自己的时间了。当别人有临时需求的时候，自己必须得支持，不能说不！时常被打断自己的进度，加班不再是为了学习；而变成了为加班而加班。就感觉效率极其低下，有时候一晚上什么都没学进去，白白将时间浪费了，还搞得自己精疲力尽。</p>
<blockquote>
<p>加班，从一种工作方式转变成另一种工作方式；不加班就好像上厕所不洗手一样，会被周围人鄙视。<br>靠蛮力来弥补思维上的惰性，其结果就是折腾出一堆粗略无用的解决方案。<br>当你的核心竞争力是加班，你难道不会害怕吗？</p>
</blockquote>
<p>于2019-07-18 21:53:24</p>
]]></content>
      
        <categories>
            
            <category> 生活杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习记录汇总]]></title>
      <url>/1901/10/22/new/studing/</url>
      <content type="html"><![CDATA[<p>没有总结的学习就是耍流氓</p>
<p align="right">- 沃·兹基朔德</p>

<p>大多数学习的时候太过于零散，有的时候看到了一篇很好的文章，想找个时间沉下心来好好学习，可是转眼就又给忘了。<br>看完一本书，也许当时思考过，有一定印象。但是总会遗漏点什么，等真正有需要的时候，往往就真的是有影响。<br>学完一个知识，想要写个博客文章记录一下，可是耗费时间而没有坚持下来，所以知识没有得到积累。<br>虽然一直在不断得学习，但是感觉自己太过于浮躁，很多时候的学习并没有真正的沉淀下来，过一阵时间又给忘了。经常想做总结，却有被自己的懒惰和借口拐跑了。</p>
<a id="more"></a>
<p>所以本篇博客主要是：</p>
<ol>
<li>记录看到的好的文章，便于后面有需要进行快速检索</li>
<li>记录自己的学习过程，等过几年回过头来看自己的成长</li>
<li>记录生活轨迹，等老了看看自己虚度多少时光</li>
</ol>
<p align="right">于2020-04-04 北京 天通苑</p>

<h1 id="技术文章汇总"><a href="#技术文章汇总" class="headerlink" title="技术文章汇总"></a>技术文章汇总</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="死锁系列"><a href="#死锁系列" class="headerlink" title="死锁系列"></a>死锁系列</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/xUgzKPMZP777jdytrCL7oA" target="_blank" rel="noopener">漫谈死锁</a>    （1. RC级别下也会存在Next-key 2. RC级别下，获取到不符合记录时会释放锁）<ul>
<li>innodb_print_all_deadlocks  (将死锁信息记录到errorlog中参数)</li>
<li>innodb_status_output_locks  (标准监控开关参数)</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/8XXimj2AIsRWj0fF-_iz3g" target="_blank" rel="noopener">如何阅读死锁日志</a>  （锁组合）</li>
<li><a href="https://mp.weixin.qq.com/s/2GIrpSKHe3Y3KWMfDbA7jw" target="_blank" rel="noopener">MySQL 各种SQL语句加锁分析</a><ul>
<li>innodb_locks_unsafe_for_binlog</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/MywiDdffz13i8auSv4Xs9w" target="_blank" rel="noopener">死锁案例一</a>  （简单插入唯一索引插入意向锁案例）</li>
<li><a href="https://mp.weixin.qq.com/s/7DehY-zQV1XHYufaII4oJg" target="_blank" rel="noopener">死锁案例二</a>  （delete操作会有锁区间行为。PS：删除已有记录会导致锁范围变大)</li>
<li><a href="https://mp.weixin.qq.com/s/R1dJY4leZh5qRpUkvOsNBw" target="_blank" rel="noopener">死锁案例三</a>  （insert同一区间时，唯一索引的插入意向锁导致的死锁）</li>
<li><a href="https://mp.weixin.qq.com/s/wXH9XFOK8wui7dDtR6Hzww" target="_blank" rel="noopener">死锁案例四</a>  （并发插入时，插入意向锁不同阶段死锁。<font color="red">注意跟案例三的区别：本案例为X锁等待，案例三为S锁等待</font>)</li>
<li><a href="https://mp.weixin.qq.com/s/XCdLfyjSuWAEcWIjbcVfvg" target="_blank" rel="noopener">死锁案例五</a>  （repalce into插入死锁情况）</li>
<li><a href="https://mp.weixin.qq.com/s/Lp7b2TGyFY-4uEN_M6Y8zg" target="_blank" rel="noopener">死锁案例六</a>  （不同事务加锁顺序不一样，导致锁资源交叉影响导致的死锁)</li>
<li><a href="https://mp.weixin.qq.com/s/pC4XCpUOuNPMFj6UjuhWvw" target="_blank" rel="noopener">死锁案例七</a>  （RC级别下，update不存在记录会持有lock_S + GAP锁）</li>
<li><a href="https://mp.weixin.qq.com/s/96CDhpgu5uUQ7qKYhKgt3w" target="_blank" rel="noopener">死锁案例八</a>  （多并发插入下的又一插入意向锁竞争导致的死锁案例）</li>
<li><a href="https://mp.weixin.qq.com/s/h4Mwrowft2KKdTkqmRlYqw" target="_blank" rel="noopener">死锁案例九</a>  （并发批量插入，导致的死锁）</li>
<li><a href="https://mp.weixin.qq.com/s/b9gNbdEHV3NNQrV9PKDPSw" target="_blank" rel="noopener">死锁案例十</a>  （并发更新普通二级索引造成的死锁。PS：<font color="red">另一程度上说明索引不是随便加就行</font>）</li>
<li><a href="https://mp.weixin.qq.com/s/vMGlRtMQckJ1LUZaSBn5cw" target="_blank" rel="noopener">死锁案例十一</a>  （<font color="red">5.6升级到5.7后，INSERT INTO .. ON DUPLICATE KEY语句锁模式加强</font>）</li>
<li><a href="https://mp.weixin.qq.com/s/SFdPDPhI270tnVI3uuOH0Q" target="_blank" rel="noopener">死锁案例十二</a>  （唯一索引，多插入,插入意向锁死锁情况）</li>
<li><a href="!https://www.cnblogs.com/yulibostu/articles/9844061.html">一个最不可思议的死锁分析</a>  （并发delete语句造成的死锁情况，里面引用了很多好文章，需要细品）</li>
</ul>
<p>分析死锁单从<code>show engines innodb status</code>中往往只能看到最后执行的语句，并不能很好的了解整个死锁形成过程。所以在分析死锁时，需要先了解两个死锁事务的具体逻辑和语句过程。<br>了解MySQL不同操作的加锁过程非常重要，这是对死锁形成过程分析的基础。</p>
<h3 id="故障及优化案例系列"><a href="#故障及优化案例系列" class="headerlink" title="故障及优化案例系列"></a>故障及优化案例系列</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/hYsxeevggxwkObJyOqy3iA" target="_blank" rel="noopener">引号错位引起的故障</a> （我才不会告诉你踩过的一个坑：update xx set a=’x’ and b=’x’ where …）</li>
<li><a href="https://mp.weixin.qq.com/s/snJcudytuW4_BvgVk86IXw" target="_blank" rel="noopener">一个事务中调整语句顺序</a> （MySQL45讲中也说过：一个事务中，只有需要锁的时候才会去申请锁，事务提交时才会释放锁。所以将锁资源较多的语句放在后面执行。） </li>
<li><a href="https://mp.weixin.qq.com/s/wFath89f3xXDR1Nxd5g-mw" target="_blank" rel="noopener">库表字符集修改后，老字段仍为原来字符集</a>   （修改库表字符集后，只会改变新增的字符集）</li>
<li><a href="https://mp.weixin.qq.com/s/jMU1lGhBwuIPrERqeUFAVQ" target="_blank" rel="noopener">聊聊 隐式转换</a>    （真实遇到过其中的字符串转换成浮点型比较，查询结果不准确的问题。实测当长度为17位时会有问题）</li>
<li><a href="https://mp.weixin.qq.com/s/tWDQUPG5PYaeZilz7dd73Q" target="_blank" rel="noopener">一个特殊的隐式转换问题</a> （5.6版本IN中包括多个类型的话，会存在不能走索引的情况。<a href="http://mysql.taobao.org/monthly/2017/12/06/" target="_blank" rel="noopener">相关阿里月报</a>）</li>
<li><a href="https://mp.weixin.qq.com/s/f8ZQx3Iuz-BnJ05z8vN2GA" target="_blank" rel="noopener">Strace 解决性能问题案例一则</a>  （问题排查工具，用事实说话，DB不背锅）</li>
<li><a href="https://mp.weixin.qq.com/s/MdfomhoKV4OBJ_jSv1d0Bg" target="_blank" rel="noopener">业务优化案例一则</a> (mysqlslap压测工具使用)</li>
<li><a href="https://mp.weixin.qq.com/s/2hFm_hZgbNwi8GsE5MFrQg" target="_blank" rel="noopener">MySQL 案例一则</a> （explicit_defaults_for_timestamp参数解释）<ul>
<li>explicit_defaults_for_timestamp</li>
</ul>
</li>
<li><a href="https://mp.weixin.qq.com/s/w4qtB5Dz_ybbiY-WRr72-Q" target="_blank" rel="noopener">再说 order by 优化</a> （<font color="red">很精髓的order by案例总结和优化建议。</font>）</li>
<li><a href="https://mp.weixin.qq.com/s/T6qeXpVoo-M9Iflsh-n1zA" target="_blank" rel="noopener">一次大量删除导致 MySQL 慢查的分析</a> （由于MVCC特性，如果存在长时间未提交的事务，会导致简单查询也可能会变得很慢）</li>
<li><a href="https://mp.weixin.qq.com/s/0y20YxeSvgwJM7ZUho1C7Q" target="_blank" rel="noopener">MySQL 大量sleeping before entering InnoDB 故障诊断</a> （很详细的一次问题排查步骤，里面有很多有用的命令）</li>
<li><a href="https://mp.weixin.qq.com/s/Edn_gPwcAHo5sYIzLJghzA" target="_blank" rel="noopener">哪些因素会导致慢查询？</a> （<font color="red">从应用到数据库，非常全面的列出了变慢的原因</font> 加一个：limit 时匹配不到数据会一直扫描。）</li>
</ul>
<p>SQL变慢的原因主要有：</p>
<ol>
<li>SQL执行过程走索引不合理，导致执行缓慢。</li>
<li>使用合理索引，但是获取数据量比较多。(排序，临时表等)</li>
<li>网络重传丢包导致SQL变慢。</li>
<li>并发比较高的场景，请求排队处理，等待时间长。</li>
</ol>
<p>性能优化是一个老生常谈的问题，需要对相关流程和机制有很深入的研究才能对症下药。平时扩充、积累相关知识，在遇到问题后，才会有思路。经验很重要，但更多的是建立在平时的积累上。</p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/YAE_DidgZwHOzQ4NSZPyUg" target="_blank" rel="noopener">MySQL centos 6 vs 7的性能对比</a></li>
<li><font color="gray"><a href="https://mp.weixin.qq.com/s/HlAKday9K0D6AtCdg0uUtg" target="_blank" rel="noopener">xfs vs ext4 性能压测对比</a> (先mark，后面再细细品)</font>

</li>
</ul>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/aR1fUQAkHdC0wAdJ5H6BHw" target="_blank" rel="noopener">主从替换之后的复制风暴</a>   （复制风暴、seconds_behind_master计算方式）</li>
<li><a href="https://mp.weixin.qq.com/s/CjacOYs8gdkUPdnofktnXg" target="_blank" rel="noopener">show status和set gtid_mode 导致线程死锁案例</a>  （<font color="red">TODO：gdb和通过源码分析问题思路实操</font>）</li>
</ul>
<h3 id="参数系列"><a href="#参数系列" class="headerlink" title="参数系列"></a>参数系列</h3><h3 id="工具相关"><a href="#工具相关" class="headerlink" title="工具相关"></a>工具相关</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/bOdwi_zYOghBHX-eHDb5-w" target="_blank" rel="noopener">使用innobackup 2.4遇到的问题</a>   （2.2是不能备份5.7 版本）</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li><a href="https://www.jianshu.com/p/48b0d96740a5" target="_blank" rel="noopener">Redis和IO多路复用</a></li>
<li><a href="https://yq.aliyun.com/live/1153?spm=a2c4e.11154022.liveshowinfo.11.4022ebc42plKm5" target="_blank" rel="noopener">Redis主从复制演变过程</a>  （很好的讲解了Redis各版本中复制的演变）</li>
<li><a href="https://www.cnblogs.com/zhoujinyi/p/5585723.html" target="_blank" rel="noopener">Redis Sentinel 高可用实现说明</a>  （要是早半个月看到这篇文章多好。自需求+正好遇到了文中提到的坑。PS：加一个坑：主从实例不能重命名config命令）</li>
</ul>
<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/30007037" target="_blank" rel="noopener">C/C++内存对齐</a>  （Redis 4.0中对sdshdr对象进行了内存对齐优化行为）</li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/lFas05GVWw2v26tac03czg" target="_blank" rel="noopener">深入分析线程池的实现原理</a> （从源码级别分析了ThreadPoolExecutor类的实现）</li>
</ul>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li><a href="https://segmentfault.com/a/1190000020194471" target="_blank" rel="noopener">浅析服务器并发IO性能提升之路</a></li>
</ul>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/8pMF6pGHgBpWnHrmph16Wg" target="_blank" rel="noopener">git提交规范</a></li>
</ul>
<h1 id="LeetCode题目记录"><a href="#LeetCode题目记录" class="headerlink" title="LeetCode题目记录"></a>LeetCode题目记录</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5:最长回文子串（中心扩展、马拉车算法）</a><br><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42:接雨水（简单DP、单调栈）</a><br><a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">820:单词的压缩编码（字典树）</a></p>
<h1 id="个人成长文章"><a href="#个人成长文章" class="headerlink" title="个人成长文章"></a>个人成长文章</h1><h2 id="职场"><a href="#职场" class="headerlink" title="职场"></a>职场</h2><h2 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h2><h2 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h2><h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul>
<li>Java开发规范(2020.04.07 done)</li>
<li>向上管理的艺术(2020.04.19 done)</li>
<li>图解HTTP(2019.04.19 done)</li>
<li>用户故事地图</li>
<li>Redis开发与运维</li>
<li>MongoDB权威指南</li>
<li>GO语言核心编程</li>
</ul>
<h2 id="技术储备"><a href="#技术储备" class="headerlink" title="技术储备"></a>技术储备</h2><ul>
<li>时序数据库(调研)</li>
<li>elasticsearch（极客时间视频）</li>
<li>从0开始学架构(2020.04)</li>
</ul>
<h2 id="准备学习的东西记录"><a href="#准备学习的东西记录" class="headerlink" title="准备学习的东西记录"></a>准备学习的东西记录</h2><ul>
<li>图解MySQL</li>
<li>动态代理、CGLIB代理</li>
<li>MySQL闪回工具binlog2sql和MyFlash工具问题记录</li>
<li>Having和where的区别</li>
<li>MySQL的ICP特性</li>
<li>MySQL的BKA特性</li>
<li>重新回顾一遍MySQL45讲</li>
<li>Reactor 设计模式</li>
<li>interactive_timeout和wait_timeout</li>
<li>innodb_thread_concurrency和innodb_concurrency_tickets</li>
<li>innodb_online_alter_log_max_size</li>
<li>DDL 过程回顾</li>
<li>gdb调试MySQL和Redis</li>
<li>Cmakefile文件的编写</li>
</ul>
<h1 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h1><ul>
<li>《向上管理的艺术》小结</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[cd命令]]></title>
      <url>/1900/01/01/Linux/cd/</url>
      <content type="html"><![CDATA[<p>&ensp;&ensp;cd命令可以说是Linux中最基本的命令语句，其他命令要进行操作，都是建立在使用cd命令上的。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>cd [目录名]</p>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>&ensp;&ensp;切换当前目录到dirName<br><a id="more"></a></p>
<h3 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h3><hr>
<h4 id="例1：进入系统根目录"><a href="#例1：进入系统根目录" class="headerlink" title="例1：进入系统根目录"></a>例1：进入系统根目录</h4><p>cd /</p>
<hr>
<h4 id="例2：使用-cd-命令进入当前用户主目录"><a href="#例2：使用-cd-命令进入当前用户主目录" class="headerlink" title="例2：使用 cd 命令进入当前用户主目录"></a>例2：使用 cd 命令进入当前用户主目录</h4><p>&ensp;&ensp;“当前用户主目录”和“系统根目录”是两个不同的概念。进入当前用户主目录有两个方法。<br>1.cd<br>2.cd ~</p>
<hr>
<h4 id="例3：跳转到指定目录"><a href="#例3：跳转到指定目录" class="headerlink" title="例3：跳转到指定目录"></a>例3：跳转到指定目录</h4><p>cd /opt/soft<br>&ensp;&ensp;跳转到指定目录，从根目录开始，目录名称前加 / ,当前目录内的子目录直接写名称即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /opt/soft</span><br><span class="line">[root@localhost soft]# pwd</span><br><span class="line">/opt/soft</span><br><span class="line">[root@localhost soft]# cd jdk1.6.0_16/</span><br><span class="line">[root@localhost jdk1.6.0_16]# pwd</span><br><span class="line">/opt/soft/jdk1.6.0_16</span><br><span class="line">[root@localhost jdk1.6.0_16]#</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="例4：返回进入此目录之前所在的目录"><a href="#例4：返回进入此目录之前所在的目录" class="headerlink" title="例4：返回进入此目录之前所在的目录"></a>例4：返回进入此目录之前所在的目录</h4><p>cd -<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost soft]# pwd</span><br><span class="line">/opt/soft</span><br><span class="line">[root@localhost soft]# cd -</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# pwd</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# cd -</span><br><span class="line">/opt/soft</span><br><span class="line">[root@localhost soft]#</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="例5：把上个命令的参数作为cd参数使用。"><a href="#例5：把上个命令的参数作为cd参数使用。" class="headerlink" title="例5：把上个命令的参数作为cd参数使用。"></a>例5：把上个命令的参数作为cd参数使用。</h4><p>cd !$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost soft]# cd !$</span><br><span class="line">cd -</span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]# cd !$</span><br><span class="line">cd -</span><br><span class="line">/opt/soft</span><br><span class="line">[root@localhost soft]#</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ls命令]]></title>
      <url>/1900/01/01/Linux/ls/</url>
      <content type="html"><![CDATA[<p>&ensp;&ensp;ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印当前目录的清单，如果你是指定其他目录，那么就会显示指定目录里的文件及文件夹清单。通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限（包括目录、文件夹、文件权限），查看目录信息等等。</p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>ls 【选项】【目录名】</p>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>&ensp;&ensp;列出目标目录中所有的子目录和文件。<br><a id="more"></a></p>
<h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul>
<li>-a , -all 列出，目录下的所有文件，包括以 <strong>.</strong> 开头的隐含文件</li>
<li>-A , 同-a，但不列出“.”（表示当前目录）和“..”（表示当前目录的父目录）</li>
<li>-c 配合 -lt: 根据ctime排序及显示ctime（文件状态最后更改时间）配合 -l: 显示ctime但根据名称排序否则: 根据ctime排序</li>
<li>-C 每栏由上至下列出项目</li>
<li>–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</li>
<li>-d, –directory 将目录象文件一样显示，而不是显示其下的文件。</li>
<li>-D, –dired 产生适合 Emacs 的 dired 模式使用的结果</li>
<li>-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</li>
<li>-g 类似 -l,但不列出所有者</li>
<li>-G, –no-group 不列出任何有关组的信息</li>
<li>-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)</li>
<li>–si 类似 -h,但文件大小取 1000 的次方而不是 1024</li>
<li>-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地</li>
<li>–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</li>
<li>-i, –inode 印出每个文件的 inode 号</li>
<li>-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目</li>
<li>-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。</li>
<li>-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</li>
<li>-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息</li>
<li>-m 所有项目以逗号分隔，并填满整行行宽</li>
<li>-o 类似 -l,显示文件的除组信息外的详细信息。 </li>
<li>-r, –reverse 依相反次序排列</li>
<li>-R, –recursive 同时列出所有子目录层</li>
<li>-s, –size 以块大小为单位列出所有文件的大小</li>
<li>-S 根据文件大小排序</li>
<li>–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：<br>extension -X status -c<br>none -U time -t<br>size -S atime -u<br>time -t access -u<br>version -v use -u</li>
<li>-t 以文件修改时间排序</li>
<li>-u 配合 -lt:显示访问时间而且依访问时间排序<br>配合 -l:显示访问时间但根据名称排序<br>否则：根据访问时间排序</li>
<li>-U 不进行排序;依文件系统原有的次序列出项目</li>
<li>-v 根据版本进行排序</li>
<li>-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值</li>
<li>-x 逐行列出项目而不是逐栏列出</li>
<li>-X 根据扩展名排序</li>
<li>-1 每行只列出一个文件</li>
<li>–help 显示此帮助信息并离开</li>
<li>–version 显示版本信息并离开</li>
</ul>
<h3 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h3><hr>
<h4 id="例一：列出-home-peidachang文件夹下的所有文件和目录的详细资料"><a href="#例一：列出-home-peidachang文件夹下的所有文件和目录的详细资料" class="headerlink" title="例一：列出/home/peidachang文件夹下的所有文件和目录的详细资料"></a>例一：列出/home/peidachang文件夹下的所有文件和目录的详细资料</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -l -R /home/peidachang<br>&ensp;&ensp;在使用 ls 命令时要注意命令的格式：在命令提示符后，首先是命令的关键字，接下来是命令参数，在命令参数之前要有一短横线“-”，所有的命令参数都有特定的作用，自己可以根据需要选用一个或者多个参数，在命令参数的后面是命令的操作对象。在以上这条命令“ ls -l -R /home/peidachang”中，“ls” 是命令关键字，“-l -R”是参数，“ /home/peidachang”是命令的操作对象。在这条命令中，使用到了两个参数，分别为“l”和“R”，当然，你也可以把他们放在一起使用，如下所示：<br>&ensp;&ensp;<strong>命令：</strong> ls -lR /home/peidachang<br>&ensp;&ensp;这种形式和上面的命令形式执行的结果是完全一样的。另外，如果命令的操作对象位于当前目录中，可以直接对操作对象进行操作;如果不在当前目录则需要给出操作对象的完整路径，例如上面的例子中，我的当前文件夹是peidachang文件夹，我想对home文件夹下的peidachang文件进行操作，我可以直接输入 ls -lR peidachang，也可以用 ls -lR /home/peidachang。 </p>
<hr>
<h4 id="例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令："><a href="#例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：" class="headerlink" title="例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令："></a>例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -l t*<br>&ensp;&ensp;可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。</p>
<hr>
<h4 id="例三：只列出文件下的子目录"><a href="#例三：只列出文件下的子目录" class="headerlink" title="例三：只列出文件下的子目录"></a>例三：只列出文件下的子目录</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -F /opt/soft |grep /$<br>&ensp;&ensp;列出 /opt/soft 文件下面的子目录<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]# ls -F /opt/soft |grep /$<br>&ensp;&ensp;&ensp;&ensp;jdk1.6.0_16/<br>&ensp;&ensp;&ensp;&ensp;subversion-1.6.1/<br>&ensp;&ensp;&ensp;&ensp;tomcat6.0.32/</p>
<p>&ensp;&ensp;<strong>命令：</strong> ls -l /opt/soft | grep “^d”<br>&ensp;&ensp;列出 /opt/soft 文件下面的子目录详细情况<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]#  ls -l /opt/soft | grep “^d”<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 16 1016 1016      4096 10-11 03:25 subversion-1.6.1<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x  9 root root      4096 2011-11-01 tomcat6.0.32</p>
<hr>
<h4 id="例四：列出目前工作目录下所有名称是s-开头的档案，愈新的排愈后面，可以使用如下命令："><a href="#例四：列出目前工作目录下所有名称是s-开头的档案，愈新的排愈后面，可以使用如下命令：" class="headerlink" title="例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令："></a>例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令：</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -ltr s<em><br>&ensp;&ensp;可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]# ls -ltr s</em><br>&ensp;&ensp;&ensp;&ensp;src:<br>&ensp;&ensp;&ensp;&ensp;总计 0<br>&ensp;&ensp;&ensp;&ensp;script:<br>&ensp;&ensp;&ensp;&ensp;总计 0<br>&ensp;&ensp;&ensp;&ensp;soft:<br>&ensp;&ensp;&ensp;&ensp;总计 350644<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x  9 root root      4096 2011-11-01 tomcat6.0.32<br>&ensp;&ensp;&ensp;&ensp;-rwxr-xr-x  1 root root  81871260 09-17 18:15 jdk-6u16-linux-x64.bin<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16<br>&ensp;&ensp;&ensp;&ensp;drwxr-xr-x 10 root root      4096 09-17 18:17 jdk1.6.0_16<br>&ensp;&ensp;&ensp;&ensp;-rw-r–r–  1 root root   5457684 09-21 00:23 tomcat6.0.32.tar.gz</p>
<hr>
<h4 id="例五：列出目前工作目录下所有档案及目录-目录于名称后加”-“-可执行档于名称后加”-”"><a href="#例五：列出目前工作目录下所有档案及目录-目录于名称后加”-“-可执行档于名称后加”-”" class="headerlink" title="例五：列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加”*”"></a>例五：列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加”*”</h4><p>&ensp;&ensp;<strong>命令：</strong> ls -AF<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;ls -l <em> |grep “^-“|wc -l —文件个数<br>&ensp;&ensp;&ensp;&ensp;ls -l </em> |grep “^d”|wc -l    —目录个数</p>
<hr>
<h4 id="例七-在ls中列出文件的绝对路径"><a href="#例七-在ls中列出文件的绝对路径" class="headerlink" title="例七: 在ls中列出文件的绝对路径"></a>例七: 在ls中列出文件的绝对路径</h4><p>&ensp;&ensp;<strong>命令：</strong> ls | sed “s:^:<code>pwd</code>/:”<br>&ensp;&ensp;<strong>输出：</strong><br>&ensp;&ensp;&ensp;&ensp;[root@localhost opt]# ls | sed “s:^:<code>pwd</code>/:”<br>&ensp;&ensp;&ensp;&ensp;/opt/log<br>&ensp;&ensp;&ensp;&ensp;/opt/script<br>&ensp;&ensp;&ensp;&ensp;/opt/soft<br>&ensp;&ensp;&ensp;&ensp;/opt/src<br>&ensp;&ensp;&ensp;&ensp;/opt/svndata<br>&ensp;&ensp;&ensp;&ensp;/opt/web</p>
<hr>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p><strong>显示彩色目录列表</strong><br>    打开/etc/bashrc, 加入如下一行:<br>    alias ls=”ls –color”<br>    下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下:</p>
<pre><code>1. 蓝色--&gt;目录
2. 绿色--&gt;可执行文件
3. 红色--&gt;压缩文件
4. 浅蓝色--&gt;链接文件
5. 灰色--&gt;其他文件
</code></pre>]]></content>
      
        
    </entry>
    
  
  
</search>
